{"version":3,"sources":["node_modules/browser-pack/_prelude.js","companyregistry-client.js","app/angularcontrollers.js","app/angulardirectives.js","app/angularservices.js","app/app.js","app/components/beneficiary/BeneficiaryCreateViewDirective.js","app/components/beneficiary/BeneficiaryDeleteViewDirective.js","app/components/beneficiary/BeneficiaryDetailViewDirective.js","app/components/beneficiary/BeneficiaryListFragmentViewDirective.js","app/components/beneficiary/BeneficiaryListViewDirective.js","app/components/beneficiary/BeneficiarySearchViewDirective.js","app/components/beneficiary/BeneficiaryService.js","app/components/beneficiary/BeneficiaryUpdateViewDirective.js","app/components/beneficiary/BeneficiaryViewController.js","app/components/beneficiary/BeneficiaryViewDirective.js","app/components/common/MainViewController.js","app/components/common/MainViewDirective.js","app/components/common/States.js","app/components/common/UtilService.js","app/components/company/CompanyCreateViewDirective.js","app/components/company/CompanyDeleteViewDirective.js","app/components/company/CompanyListFragmentViewDirective.js","app/components/company/CompanyListViewDirective.js","app/components/company/CompanySearchViewDirective.js","app/components/company/CompanyService.js","app/components/company/CompanyUpdateViewDirective.js","app/components/company/CompanyViewController.js","app/components/company/CompanyViewDirective.js","app/components/nav/SideNavViewController.js","app/components/nav/SideNavViewDirective.js","app/components/nls/i18n-en.js","app/config.js","app/constants.js","node_modules/angular-animate/angular-animate.js","node_modules/angular-animate/index.js","node_modules/angular-block-ui/dist/angular-block-ui.js","node_modules/angular-block-ui/dist/angular-block-ui.min.css","node_modules/angular-sanitize/angular-sanitize.js","node_modules/angular-sanitize/index.js","node_modules/angular-translate/dist/angular-translate.js","node_modules/angular-ui-router/release/angular-ui-router.js","node_modules/browserify-css/browser.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","global","ng","window","MainViewController","SideNavViewController","BeneficiaryViewController","CompanyViewController","config","moduleName","configBlock","namespace","controllersModule","controller","this","self","./components/beneficiary/BeneficiaryViewController","./components/common/MainViewController","./components/company/CompanyViewController","./components/nav/SideNavViewController","./config",2,"MainViewDirective","SideNavViewDirective","BeneficiaryViewDirective","BeneficiaryCreateViewDirective","BeneficiaryUpdateViewDirective","BeneficiaryDeleteViewDirective","BeneficiaryListViewDirective","BeneficiaryListFragmentViewDirective","BeneficiaryDetailViewDirective","BeneficiarySearchViewDirective","CompanyViewDirective","CompanyCreateViewDirective","CompanyUpdateViewDirective","CompanyDeleteViewDirective","CompanyListViewDirective","CompanyListFragmentViewDirective","CompanySearchViewDirective","directivesModule","directive","./components/beneficiary/BeneficiaryCreateViewDirective","./components/beneficiary/BeneficiaryDeleteViewDirective","./components/beneficiary/BeneficiaryDetailViewDirective","./components/beneficiary/BeneficiaryListFragmentViewDirective","./components/beneficiary/BeneficiaryListViewDirective","./components/beneficiary/BeneficiarySearchViewDirective","./components/beneficiary/BeneficiaryUpdateViewDirective","./components/beneficiary/BeneficiaryViewDirective","./components/common/MainViewDirective","./components/company/CompanyCreateViewDirective","./components/company/CompanyDeleteViewDirective","./components/company/CompanyListFragmentViewDirective","./components/company/CompanyListViewDirective","./components/company/CompanySearchViewDirective","./components/company/CompanyUpdateViewDirective","./components/company/CompanyViewDirective","./components/nav/SideNavViewDirective",3,"BeneficiaryService","CompanyService","UtilService","servicesModule","factory","service","./components/beneficiary/BeneficiaryService","./components/common/UtilService","./components/company/CompanyService",4,"constants","services","controllers","directives","animateModule","translateModule","sanitizeModule","blockUIModule","uiRouterModule","name","settings","states","blockUI","inform","hrefSanitize","constant","runBlock","run","./angularcontrollers","./angulardirectives","./angularservices","./constants","angular-animate","angular-block-ui","angular-block-ui/dist/angular-block-ui.min.css","angular-sanitize","angular-translate","angular-ui-router",5,"templateUrl","restrict","scope","beneficiary","controllerAs",6,7,"$parse","$compile","$rootScope","$timeout","link","el","attrs","$on","ev","data","beneficiaries","id","beneficiaryId","inputEls","angular","element","find","j","attr","$inject",8,"delref",9,10,11,"$http","serviceInstance","selectedBeneficiaryId","popOnDelete","getBeneficiary","url","callback","method","dataType","then","results","error","errorData","status","message","createBeneficiary","updateBeneficiary","deleteBeneficiary",12,13,"$scope","$window","$document","$log","$state","$modal","beneficiaryService","utilService","CONSTANTS","useExistingBeneficiary","minimumValidBeneficiary","beneficiarySearched","beneficiaryFound","searchRequestSumbitted","addRequestSubmitted","addRequestAttempted","updateRequestSubmitted","updateRequestAttempted","deleteRequestSubmitted","deleteSuccessful","serviceUrl","path","initBeneficiary","firstName","lastName","current","resetBeneficiary","addBeneficiary","$event","stopPropagation","isFormValid","warn","add","ttl","type","instances","get","beneficiaryContextPath","result","info","go","reload","errorMessage","cancelAddBeneficiary","cancelOrCloseBeneficiaryUpdate","cancelOrCloseBeneficiaryDelete","$dismiss","fetchBeneficiary","splice","idSearch","isBlank","baseUrl","push","searchBeneficiary","isValidId","registerPopoverShow","mutateBeneficiaryOptions","$index","registerPopoverPrep","discardMessage","registerPopoverHide","popover","trigger","clear",14,15,16,17,"stateConfig","main","views","template","mainItem@start","company","initial","list","search","update","delete","onEnter","open","backdrop","keyboard","windowClass",18,"formId","isValid","formEl","document","getElementById","console","log","className","indexOf","elements","value","isUndefined","parseInt",19,20,21,"companies",22,23,24,"selectedCompanyId","getCompany","createCompany","updateCompany","deleteCompany",25,26,"$q","companyService","companyFound","initCompany","address","city","country","email","phoneNumber","verifyMinimumValidBeneficiary","resetCompany","addCompany","companyContextPath","cancelAddCompany","cancelOrCloseCompanyUpdate","cancelOrCloseCompanyDelete","fetchCompany","searchCompany","companySearchBlock","start","findBeneficiary","disableBeneficiary","stop","mutateCompanyOptions","removeBeneficiary","$emit",27,28,29,30,"translationsEN","BENEFICIARY","ID","FIRST_NAME","LAST_NAME",31,"$logProvider","$translateProvider","debugEnabled","i18n_en","useSanitizeValueStrategy","translations","useStaticFilesLoader","files","prefix","suffix","preferredLanguage","fallbackLanguage","$stateProvider","$urlRouterProvider","otherwise","state","copy","blockUIConfig","delay","autoBlock","autoInjectBodyBlock","informProvider","defaults","html","modal","$modalStack","top","getTop","dismiss","key","$compileProvider","aHrefSanitizationWhitelist","./components/common/States","./components/nls/i18n-en",32,33,"undefined","assertArg","arg","reason","ngMinErr","mergeClasses","b","isArray","join","packageStyles","options","styles","to","from","pendClasses","classes","fix","isPrefix","isString","split","forEach","klass","removeFromArray","arr","val","index","stripCommentsFromElement","jqLite","nodeType","ELEMENT_NODE","extractElementNode","elm","$$addClass","$$jqLite","addClass","$$removeClass","removeClass","applyAnimationClassesFactory","prepareAnimationOptions","$$prepared","domOperation","noop","$$domOperationFired","applyAnimationStyles","applyAnimationFromStyles","applyAnimationToStyles","css","mergeAnimationOptions","target","newOptions","toAdd","toRemove","resolveElementClasses","preparationClasses","concatWithSpace","realDomOperation","extend","existing","splitClassesToLookup","obj","ADD_CLASS","REMOVE_CLASS","flags","prop","allow","getDomNode","applyGeneratedPreparationClasses","event","EVENT_CLASS_PREFIX","ADD_CLASS_SUFFIX","REMOVE_CLASS_SUFFIX","clearGeneratedClasses","activeClasses","blockTransitions","node","duration","applyInlineStyle","TRANSITION_DELAY_PROP","blockKeyframeAnimations","applyBlock","ANIMATION_PROP","ANIMATION_PLAYSTATE_KEY","styleTuple","style","getCssKeyframeDurationStyle","ANIMATION_DURATION_PROP","getCssDelayStyle","isKeyframeAnimation","ANIMATION_DELAY_PROP","computeCssStyles","properties","Object","create","detectedStyles","getComputedStyle","formalStyleName","actualStyleName","c","charAt","parseMaxTime","str","maxValue","values","substring","parseFloat","Math","max","truthyTimingValue","getCssTransitionDurationStyle","applyOnlyDuration","TRANSITION_PROP","DURATION_KEY","createLocalCacheLookup","cache","flush","count","entry","total","put","registerRestorableStyles","backup","isDefined","getPropertyValue","TRANSITIONEND_EVENT","ANIMATIONEND_EVENT","isObject","isFunction","isElement","ACTIVE_CLASS_SUFFIX","NG_ANIMATE_CLASSNAME","NG_ANIMATE_CHILDREN_DATA","CSS_PREFIX","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","PROPERTY_KEY","DELAY_KEY","TIMING_KEY","ANIMATION_ITERATION_COUNT_KEY","SAFE_FAST_FORWARD_DURATION_VALUE","TRANSITION_DURATION_PROP","$$rAFSchedulerFactory","$$rAF","scheduler","tasks","queue","concat","nextTick","items","shift","cancelFn","waitUntilQuiet","fn","$$AnimateChildrenDirective","ngAnimateChildren","$observe","ANIMATE_TIMER_KEY","ONE_SECOND","ELAPSED_TIME_MAX_DECIMAL_PLACES","CLOSING_TIME_BUFFER","DETECT_CSS_PROPERTIES","transitionDuration","transitionDelay","transitionProperty","animationDuration","animationDelay","animationIterationCount","DETECT_STAGGER_CSS_PROPERTIES","$AnimateCssProvider","$animateProvider","gcsLookup","gcsStaggerLookup","$get","$$AnimateRunner","$$forceReflow","$sniffer","$$rAFScheduler","$animate","gcsHashFn","extraClasses","KEY","parentNode","parentID","parentCounter","getAttribute","computeCachedCssStyles","cacheKey","timings","computeCachedCssStaggerStyles","stagger","staggerClassName","rafWaitQueue","pageWidth","computeTimings","aD","tD","maxDelay","maxDuration","applyAnimationClasses","endFn","close","rejected","animationClosed","animationCompleted","animationPaused","$$skipPreparationClasses","temporaryStyles","keys","restoreStyles","setProperty","removeProperty","onDone","runner","complete","applyBlocking","blockTransition","blockKeyframeAnimation","closeAndReturnNoopAnimator","end","cancel","$$willAnimate","triggerAnimationStart","recalculateTimingStyles","fullClassName","relativeDelay","hasTransitions","hasAnimations","applyAnimationDelay","delayStyle","maxDelayTime","maxDurationTime","easing","easeProp","easeVal","events","startTime","Date","now","timerTime","endTime","animationsData","setupFallbackTimer","currentTimerData","expectedEndTime","timer","onAnimationExpired","on","onAnimationProgress","cleanupStyles","removeData","originalEvent","timeStamp","$manualTimeStamp","elapsedTime","toFixed","playPause","playAnimation","maxStagger","itemIndex","floor","runnerHost","resume","pause","enabled","animations","transitions","isStructural","structural","structuralClassName","addRemoveClassName","applyClassesEarly","trim","hasToStyles","containsKeyframeAnimation","keyframeStyle","staggerVal","transitionStyle","durationStyle","staggerIndex","isFirst","skipBlocking","hasTransitionAll","applyTransitionDuration","applyAnimationDuration","applyTransitionDelay","$$AnimateCssDriverProvider","$$animationProvider","isDocumentFragment","drivers","NG_ANIMATE_SHIM_CLASS_NAME","NG_ANIMATE_ANCHOR_CLASS_NAME","NG_OUT_ANCHOR_CLASS_NAME","NG_IN_ANCHOR_CLASS_NAME","$animateCss","$rootElement","filterCssClasses","replace","getUniqueValues","filter","prepareAnchoredAnimation","outAnchor","inAnchor","calculateAnchorStyles","anchor","coords","getBoundingClientRect","bodyNode","scrollTop","scrollLeft","prepareOutAnimation","animator","clone","getClassVal","prepareInAnimation","endingClasses","startingClasses","remove","cloneNode","rootBodyElement","append","animatorIn","animatorOut","startingAnimator","currentAnimation","done","prepareFromToAnchorAnimation","anchors","fromAnimation","prepareRegularAnimation","toAnimation","anchorAnimations","outElement","inElement","animationRunners","animation","all","animationDetails","body","rootNode","contains","$$AnimateJsProvider","$injector","lookupAnimations","matches","flagMap","animationFactory","$$registeredAnimations","applyOptions","executeAnimationFn","args","classesToAdd","classesToRemove","apply","groupEventedAnimations","fnName","operations","ani","endProgressCb","resolved","onAnimationComplete","cancelled","packageAnimations","runners","animateFn","reject","arguments","before","after","afterFn","beforeFn","toUpperCase","substr","onComplete","success","endAnimations","closeActiveAnimations","chain","$$AnimateJsDriverProvider","$$animateJs","prepareAnimation","endFnFactory","NG_ANIMATE_ATTR_NAME","NG_ANIMATE_PIN_DATA","$$AnimateQueueProvider","isAllowed","ruleType","previousAnimation","rules","some","hasAnimationClasses","and","PRE_DIGEST_STATE","RUNNING_STATE","skip","newAnimation","nO","cO","$$HashMap","$$animation","$templateRequest","postDigestTaskFactory","postDigestCalled","$$postDigest","normalizeAnimationOptions","findCallbacks","targetNode","entries","callbackRegistry","queueAnimation","notifyProgress","phase","runInNextPostDigestOrNow","callbacks","progress","parent","isAnimatableClassName","skipAnimations","animationsEnabled","disabledElementsLookup","existingAnimation","activeAnimationsLookup","hasExistingAnimation","areAnimationsAllowed","closeChildAnimations","skipAnimationFlag","cancelAnimationFlag","joinAnimationFlag","isValidAnimation","clearElementAnimationState","counter","markElementAnimationState","animationCancelled","parentElement","realRunner","setHost","children","querySelectorAll","child","removeAttribute","isMatchingElement","nodeOrElmA","nodeOrElmB","animateChildren","bodyElement","bodyElementDetected","nodeName","rootElementDetected","parentAnimationDetected","parentHost","details","allowAnimation","setAttribute","oldValue","newValue","deregisterWatch","$watch","totalPendingRequests","isEmpty","classNameFilter","test","container","off","filterFromRegistry","matchContainer","matchCallback","containerNode","isMatch","pin","bool","argCount","hasElement","recordExists","$$AnimateAsyncRunFactory","waitForTick","waitQueue","passed","$$AnimateRunnerFactory","$$animateAsyncRun","AnimateRunner","host","_doneCallbacks","_runInAnimationFrame","_state","INITIAL_STATE","DONE_PENDING_STATE","DONE_COMPLETE_STATE","next","response","onProgress","prototype","getPromise","promise","resolve","resolveHandler","rejectHandler","catch","handler","finally","_resolve","$$AnimationProvider","setRunner","RUNNER_STORAGE_KEY","removeRunner","getRunner","NG_ANIMATE_REF_ATTR","sortAnimations","processNode","processed","elementNode","domNode","lookup","parentEntry","tree","flatten","remainingLevelEntries","nextLevelEntries","row","childEntry","animationQueue","getAnchorNodes","SELECTOR","hasAttribute","groupAnimations","preparedAnimations","refLookup","enterOrMove","anchorNodes","direction","animationID","usedIndicesLookup","anchorGroups","indexKey","toString","lookupKey","group","beforeStart","cssClassesIntersection","out","in","aa","invokeFirstDriver","driverName","has","driver","tempClasses","updateAnimationRunners","newRunner","handleDestroyedElement","groupedAnimations","toBeSortedAnimations","animationEntry","startAnimationFn","closeFn","targetElement","operation","animationRunner","provider",34,"./angular-animate",35,"moduleLoaded","ex","blockNavigation","mainBlockUI","registerLocationChange","$_blockLocationChange","blockCount","preventDefault","blockBrowserNavigation","blkUI","$provide","$httpProvider","decorator","$delegate","exception","cause","resetOnException","reset","interceptors","$templateCache","decorateLocation","hook","overrides","blockUiContainerLinkFn","compile","$element","blockUIUtils","$attrs","srvInstance","inheritedData","blockUiCompileFn","blockUiPreLinkFn","pre","hasClass","cssClass","$_blockUiMessageClass","instanceId","blockUi","$id","parentInstance","_parent","release","addRef","$_blockUiState","toggleClass","pattern","blockUiPattern","regExp","buildRegExp","requestFilter","injectBlockUI","stopBlockUI","$_noBlock","$_blocks","rejection","request","locate","requestError","responseError","BlockUI","startPromise","blocking","doneCallbacks","_id","_refs","$ae","activeElement","isElementInBlockScope","_restoreFocus","blur","_cancelStartTimeout","regexp","_pattern","executeCallbacks","$body","focus","cb","mainBlock","_destroy","isNaN","instance","idOrInstance","forEachFnHook","$","utils","match","RegExp","forEachFn","blockScope","findElement","predicateFn","traverse","ret","$elements",36,"createStyle","href","browserify-css",37,"$SanitizeProvider","$$sanitizeUri","buf","htmlParser","htmlSanitizeWriter","uri","isImage","sanitizeText","chars","writer","makeMap","lowercaseKeys","lowercase","parseStartTag","tag","tagName","rest","unary","blockElements","stack","last","inlineElements","parseEndTag","optionalEndTagElements","voidElements","ATTR_REGEXP","doubleQuotedValue","singleQuotedValue","unquotedValue","decodeEntities","pos","text","specialElements","COMMENT_REGEXP","CDATA_REGEXP","lastIndexOf","comment","DOCTYPE_REGEXP","BEGING_END_TAGE_REGEXP","END_TAG_REGEXP","BEGIN_TAG_REGEXP","START_TAG_REGEXP","$sanitizeMinErr","hiddenPre","innerHTML","textContent","encodeEntities","SURROGATE_PAIR_REGEXP","hi","charCodeAt","low","NON_ALPHANUMERIC_REGEXP","uriValidator","ignore","bind","validElements","lkey","validAttrs","uriAttrs","$$minErr","optionalEndTagBlockElements","optionalEndTagInlineElements","svgElements","htmlAttrs","svgAttrs","createElement","$sanitize","LINKY_URL_REGEXP","MAILTO_REGEXP","addText","addLink","raw",38,"./angular-sanitize",39,"root","define","amd","runTranslate","$translate","storageKey","storage","fallbackFromIncorrectStorageValue","preferred","use","displayName","$translateSanitizationProvider","strategies","currentStrategy","hasConfiguredStrategy","hasShownNoStrategyConfiguredWarning","sanitize","mode","htmlSanitizeValue","escape","htmlEscapeValue","sanitizeParameters","mapInterpolationParameters","escapeParameters","escaped","addStrategy","strategyName","strategyFunction","removeStrategy","useStrategy","strategy","cachedStrategyMap","applyStrategies","selectedStrategies","selectedStrategy","showNoStrategyConfiguredWarning","iteratee","propertyValue","propertyKey","isNumber","$STORAGE_KEY","$windowProvider","pascalprechtTranslateOverrider","$preferredLanguage","$languageKeyAliases","$fallbackLanguage","$fallbackWasString","$uses","$nextLang","$storageFactory","$storagePrefix","$missingTranslationHandlerFactory","$interpolationFactory","$loaderFactory","$loaderOptions","$notFoundIndicatorLeft","$notFoundIndicatorRight","loaderCache","$translationTable","$availableLanguageKeys","$storageKey","$interpolatorFactories","$cloakClassName","$postCompilingEnabled","$forceAsyncReloadEnabled","$nestedObjectDelimeter","$isReady","directivePriority","statefulFilter","uniformLanguageTagResolver","languageTagResolver","default","java","temp","parts","toLowerCase","bcp47","version","getFirstBrowserLanguage","getLocale","language","nav","navigator","browserLanguagePropertyKeys","languages","locale","array","searchElement","len","negotiateLocale","avail","alias","langKeyAlias","hasWildcardKey","hasExactKey","hasOwnProperty","slice","langKey","translationTable","flatObject","cloakClassName","nestedObjectDelimeter","delimiter","prevKey","keyWithPath","keyWithShortPath","addInterpolation","useMessageFormatInterpolation","useInterpolation","setupPreferredLanguage","translationNotFoundIndicator","indicator","translationNotFoundIndicatorLeft","translationNotFoundIndicatorRight","fallbackStack","useUrlLoader","useLoader","loaderFactory","useLocalStorage","useStorage","useCookieStorage","storageFactory","storagePrefix","useMissingTranslationHandlerLog","useMissingTranslationHandler","usePostCompiling","forceAsyncReload","uniformLanguageTag","standard","determinePreferredLanguage","registerAvailableLanguageKeys","languageKeys","aliases","useLoaderCache","priority","Storage","fallbackIndex","startFallbackIteration","defaultInterpolator","pendingLoader","interpolatorHashMap","langPromises","translationId","interpolateParams","interpolationId","defaultTranslationText","forceLanguage","uses","translateAll","translationIds","promises","translate","deferred","defer","regardless","promiseToWaitFor","promiseResolved","determineTranslation","applyNotFoundIndicators","useLanguage","setLocale","eachInterpolator","interpolator","loadAsync","loaderOptions","onLoaderSuccess","table","onLoaderError","eachInterpolationFactory","interpolatorFactory","getInterpolationIdentifier","getTranslationTable","onResolve","getFallbackTranslation","Interpolator","translation","interpolate","getFallbackTranslationInstant","translateByHandler","resultString","resolveForFallbackLanguage","fallbackLanguageIndex","resolveForFallbackLanguageInstant","fallbackTranslation","fallbackTranslationInstant","missingTranslationHandlerTranslation","_translationId","determineTranslationInstant","clearNextLangAndPromise","useFallbackLanguage","langKeyPosition","proposedLanguage","aliasedKey","isPostCompilingEnabled","isForceAsyncReloadEnabled","refresh","oneTranslationsLoaded","tables","loadingKeys","allTranslationsLoaded","tableData","instant","possibleLangKeys","d","possibleLangKey","versionInfo","isReady","$onReadyDeferred","onReady","globalOnReadyListener","globalOnChangeListener","equals","processAsyncResult","fallbackLanguageId","$translateDefaultInterpolation","$interpolate","$translateSanitization","$locale","$translateInterpolator","$identifier","string","interpolationParams","interpolatedText","translateDirective","tElement","tAttr","translateValuesExist","translateValues","translateInterpolation","translateValueExist","outerHTML","interpolateRegExp","startSymbol","endSymbol","watcherRegExp","iElement","iAttr","preText","postText","translateNamespace","getTranslateNamespace","initInterpolationParams","$parent","attributeName","observeElementTranslation","_unwatchOld","iElementText","interpolateMatches","watcherMatches","updateTranslations","observeAttributeTranslation","translateAttr","firstAttributeChangedEvent","defaultText","observeValueAttribute","attrName","updateTranslation","translateLanguage","applyTranslation","successful","empty","globallyEnabled","locallyDefined","translateCompile","locallyEnabled","contents","$attr","translateDefault","unbind","translateCloakDirective","applyCloak","removeCloak","translateCloak","translateNamespaceDirective","iAttrs","translateLanguageDirective","newTranslateLanguage","translateFilterFactory","translateFilter","interpolation","$stateful","$translationCache","$cacheFactory",40,"inherit","extra","merge","dst","ancestors","first","second","objectKeys","object","Array","Number","ceil","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","params","equalForKeys","k","filterByKeys","filtered","pick","omit","collection","map","$Resolve","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","when","$$promises","$$values","study","invocables","visit","visited","cycle","plan","annotate","param","pop","isResolve","invocableKeys","locals","wait","merged","$$inheritedValues","resolution","fail","$$failure","invoke","invocable","onfailure","invocation","proceed","waitParams","dep","ii","$TemplateFactory","fromConfig","fromString","fromUrl","templateProvider","fromProvider","headers","Accept","UrlMatcher","parentMatcher","addParameter","location","paramNames","$$UMFP","Param","quoteRegExp","squash","optional","surroundPattern","matchDetails","m","isSearch","segment","cfg","caseInsensitive","placeholder","searchPlaceholder","compiled","segments","$$new","ParamSet","source","p","exec","isOptional","lastIndex","sourceSearch","sourcePath","strict","$$paramNames","Type","$UrlMatcherFactory","valToString","valFromString","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","$types","injector","def","defaultSquashPolicy","enqueue","defaultTypes","encode","decode","is","int","date","getFullYear","getMonth","getDate","capture","valueOf","toISOString","json","toJson","fromJson","any","identity","$$getDefaultValue","strictMode","isMatcher","definition","definitionFn","unwrapShorthand","isShorthand","$$fn","getType","urlType","getArrayMode","arrayDefaults","arrayParamNomenclature","getSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","item","defaultValue","$value","hasReplaceVal","$replace","replacement","$normalize","$asArray","dynamic","$$parent","$$keys","reverse","paramset","paramValues","$$equals","paramValues1","paramValues2","equal","left","right","$$validates","rawVal","normalized","encoded","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","what","handleIfMatch","$match","$location","$browser","appendBasePath","isHtml5","absolute","baseHref","evt","check","rule","handled","defaultPrevented","lastPushedUrl","listen","listener","interceptDeferred","sync","read","urlMatcher","format","$$avoidResync","validates","html5Mode","history","hashPrefix","slash","port","protocol","redirect","handlerIsString","matcher","regex","sticky","deferIntercept","$StateProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","pathLength","queueState","parentName","flushQueuedChildren","queued","registerState","stateBuilder","$delegates","abstractKey","$stateParams","navigable","transitionTo","isGlob","doesStateMatchGlob","glob","globSegments","unshift","MAX_VALUE","func","$view","$resolve","$urlRouter","handleRedirect","$broadcast","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","transition","TransitionSuperseded","toParams","resolveState","paramsAreFiltered","resolveViews","viewsPromises","view","injectables","$template","load","globals","notify","controllerProvider","injectLocals","$$controller","$$state","$$controllerAs","TransitionPrevented","relative","fromParams","fromPath","toState","hash","redirectResult","toPath","keep","toLocals","reloadState","ownParams","shouldSkipReload","entering","exiting","onExit","includes","lossy","context","nonSearchParamsEqual","fromAndToState","notSearchParam","nonQueryParamKeys","nonQueryParams","nonQueryParamSet","reloadOnSearch","compositeName","","abstract","$ViewProvider","$templateFactory","async","$ViewScrollProvider","useAnchorScroll","$anchorScroll","scrollIntoView","$ViewDirective","$uiViewScroll","getService","getRenderer","animEnabled","ngMajorVer","ngMinorVer","$animator","statics","enter","leave","noanimation","minor","animate","terminal","transclude","tAttrs","$transclude","cleanupLastView","cleanOld","_previousEl","_currentScope","$destroy","previousEl","currentScope","_willBeDestroyed","currentEl","renderer","updateView","firstTime","newScope","getUiViewName","previousLocals","latestLocals","$new","autoScrollExp","$eval","onloadExp","onload","autoscroll","$ViewDirectiveFill","$controller","uiView","parseStateRef","ref","parsed","preparsed","paramExpr","stateContext","stateData","getTypeInfo","isSvg","isForm","isAnchor","clickable","clickHook","button","which","ctrlKey","metaKey","shiftKey","ignorePreventDefaultCount","defaultOpts","$StateRefDirective","uiSrefActive","uiSref","active","uiSrefOpts","$$addStateInfo","$set","$StateRefDynamicDirective","runStateRefLink","uiState","uiStateParams","uiStateOpts","watch","$StateRefActiveDirective","addState","stateParams","activeClass","stateHash","createStateHash","anyMatch","exactMatch","activeEqClass","uiSrefActiveEq","newState","$IsStateFilter","isFilter","$IncludedByStateFilter","includesFilter","defaultConfig","searchParams","decodePathArray","reverseString","unquoteDashes","allReversed","paramName","parameters","nTotal","nPath","paramVal","encodeDashes","encodeURIComponent","isPathParam","isDefaultValue","nextSegment","isFinalPathParam","$subPattern","sub","ArrayType","bindTo","callbackName","arrayWrap","arrayUnwrap","falsey","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","$arrayMode","major",41,"createLink","attributes","head","getElementsByTagName","appendChild","cssText","sheet","styleSheet","createTextNode"],"mappings":"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","file":"companyregistry-client.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\r\nvar MainViewController = require('./components/common/MainViewController');\r\nvar SideNavViewController = require('./components/nav/SideNavViewController');\r\nvar BeneficiaryViewController = require('./components/beneficiary/BeneficiaryViewController');\r\nvar CompanyViewController = require('./components/company/CompanyViewController');\r\nvar config = require('./config');\r\n\r\nvar moduleName = config.configBlock.namespace + '.controllers';\r\nvar controllersModule = ng.module(moduleName, [])\r\n    .controller('MainViewController', MainViewController.controller)\r\n    .controller('SideNavViewController', SideNavViewController.controller)\r\n    .controller('BeneficiaryViewController', BeneficiaryViewController.controller)\r\n    .controller('CompanyViewController', CompanyViewController.controller);\r\n\r\nexports.controllersModule = controllersModule;\r\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./components/beneficiary/BeneficiaryViewController\":13,\"./components/common/MainViewController\":15,\"./components/company/CompanyViewController\":26,\"./components/nav/SideNavViewController\":28,\"./config\":31}],2:[function(require,module,exports){\n(function (global){\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar MainViewDirective = require('./components/common/MainViewDirective');\nvar SideNavViewDirective = require('./components/nav/SideNavViewDirective');\nvar BeneficiaryViewDirective = require('./components/beneficiary/BeneficiaryViewDirective');\nvar BeneficiaryCreateViewDirective = require('./components/beneficiary/BeneficiaryCreateViewDirective');\nvar BeneficiaryUpdateViewDirective = require('./components/beneficiary/BeneficiaryUpdateViewDirective');\nvar BeneficiaryDeleteViewDirective = require('./components/beneficiary/BeneficiaryDeleteViewDirective');\nvar BeneficiaryListViewDirective = require('./components/beneficiary/BeneficiaryListViewDirective');\nvar BeneficiaryListFragmentViewDirective = require('./components/beneficiary/BeneficiaryListFragmentViewDirective');\nvar BeneficiaryDetailViewDirective = require('./components/beneficiary/BeneficiaryDetailViewDirective');\nvar BeneficiarySearchViewDirective = require('./components/beneficiary/BeneficiarySearchViewDirective');\nvar CompanyViewDirective = require('./components/company/CompanyViewDirective');\nvar CompanyCreateViewDirective = require('./components/company/CompanyCreateViewDirective');\nvar CompanyUpdateViewDirective = require('./components/company/CompanyUpdateViewDirective');\nvar CompanyDeleteViewDirective = require('./components/company/CompanyDeleteViewDirective');\nvar CompanyListViewDirective = require('./components/company/CompanyListViewDirective');\nvar CompanyListFragmentViewDirective = require('./components/company/CompanyListFragmentViewDirective');\nvar CompanySearchViewDirective = require('./components/company/CompanySearchViewDirective');\nvar config = require('./config');\n\nvar moduleName = config.configBlock.namespace + '.directives';\n\nvar directivesModule = ng.module(moduleName, [])\n    .directive('mainView', MainViewDirective.directive)\n    .directive('sideNavView', SideNavViewDirective.directive)\n    .directive('beneficiaryView', BeneficiaryViewDirective.directive)\n    .directive('beneficiaryCreateView', BeneficiaryCreateViewDirective.directive)\n    .directive('beneficiaryUpdateView', BeneficiaryUpdateViewDirective.directive)\n    .directive('beneficiaryDeleteView', BeneficiaryDeleteViewDirective.directive)\n    .directive('beneficiaryDetailView', BeneficiaryDetailViewDirective.directive)\n    .directive('beneficiarySearchView', BeneficiarySearchViewDirective.directive)\n    .directive('beneficiaryListView', BeneficiaryListViewDirective.directive)\n    .directive('beneficiaryListDetailView', BeneficiaryListViewDirective.directive)\n    .directive('beneficiaryListFragmentView', BeneficiaryListFragmentViewDirective.directive)\n    .directive('companyView', CompanyViewDirective.directive)\n    .directive('companyCreateView', CompanyCreateViewDirective.directive)\n    .directive('companyUpdateView', CompanyUpdateViewDirective.directive)\n    .directive('companyDeleteView', CompanyDeleteViewDirective.directive)\n    .directive('companySearchView', CompanySearchViewDirective.directive)\n    .directive('companyListView', CompanyListViewDirective.directive)\n    .directive('companyListFragmentView', CompanyListFragmentViewDirective.directive)\n\nexports.directivesModule = directivesModule;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./components/beneficiary/BeneficiaryCreateViewDirective\":5,\"./components/beneficiary/BeneficiaryDeleteViewDirective\":6,\"./components/beneficiary/BeneficiaryDetailViewDirective\":7,\"./components/beneficiary/BeneficiaryListFragmentViewDirective\":8,\"./components/beneficiary/BeneficiaryListViewDirective\":9,\"./components/beneficiary/BeneficiarySearchViewDirective\":10,\"./components/beneficiary/BeneficiaryUpdateViewDirective\":12,\"./components/beneficiary/BeneficiaryViewDirective\":14,\"./components/common/MainViewDirective\":16,\"./components/company/CompanyCreateViewDirective\":19,\"./components/company/CompanyDeleteViewDirective\":20,\"./components/company/CompanyListFragmentViewDirective\":21,\"./components/company/CompanyListViewDirective\":22,\"./components/company/CompanySearchViewDirective\":23,\"./components/company/CompanyUpdateViewDirective\":25,\"./components/company/CompanyViewDirective\":27,\"./components/nav/SideNavViewDirective\":29,\"./config\":31}],3:[function(require,module,exports){\n(function (global){\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar BeneficiaryService = require('./components/beneficiary/BeneficiaryService');\nvar CompanyService = require('./components/company/CompanyService');\nvar UtilService = require('./components/common/UtilService');\nvar config = require('./config');\n\nvar moduleName = config.configBlock.namespace + '.services';\nvar servicesModule = ng.module(moduleName, [])\n    .factory('beneficiaryService', BeneficiaryService.service)\n    .factory('companyService', CompanyService.service)\n    .factory('utilService', UtilService.service);\n\nexports.servicesModule = servicesModule;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./components/beneficiary/BeneficiaryService\":11,\"./components/common/UtilService\":18,\"./components/company/CompanyService\":24,\"./config\":31}],4:[function(require,module,exports){\n(function (global){\n/** Main app **/\n\n'use strict';\n\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar config = require('./config');\nvar constants = require('./constants');\nvar services = require('./angularservices');\nvar controllers = require('./angularcontrollers');\nvar directives = require('./angulardirectives');\n\nvar animateModule = require('angular-animate');\nvar translateModule = require('angular-translate');\nvar sanitizeModule = require('angular-sanitize');\nvar blockUIModule = require('angular-block-ui');\nvar uiRouterModule = require('angular-ui-router');\n\nrequire('angular-block-ui/dist/angular-block-ui.min.css');\n\nvar moduleName = config.configBlock.namespace;\n\n// Declare app level module which depends on services, controllers and directives\nng.module(moduleName, [animateModule, translateModule, sanitizeModule, blockUIModule, uiRouterModule,\n    services.servicesModule.name, controllers.controllersModule.name, directives.directivesModule.name,\n    'inform', 'inform-exception'/*, 'inform-http-exception'*/\n]);\n\nng.module(moduleName)\n  .config(config.configBlock.settings)\n  .config(config.configBlock.states)\n  .config(config.configBlock.blockUI)\n  .config(config.configBlock.inform)\n  .config(config.configBlock.hrefSanitize);\n\nng.module(moduleName)\n  .constant('CONSTANTS', constants.constants);\n\nvar runBlock = function() {\n\n    // Add code that needs a run block to execute here.\n};\n\nng.module(moduleName)\n  .run(runBlock);\n  // .run(config.configBlock.modal);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./angularcontrollers\":1,\"./angulardirectives\":2,\"./angularservices\":3,\"./config\":31,\"./constants\":32,\"angular-animate\":34,\"angular-block-ui\":35,\"angular-block-ui/dist/angular-block-ui.min.css\":36,\"angular-sanitize\":38,\"angular-translate\":39,\"angular-ui-router\":40}],5:[function(require,module,exports){\n/**\r\n * Beneficiary Form Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryCreateView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],6:[function(require,module,exports){\n/**\r\n * Company Delete Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryDeleteView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],7:[function(require,module,exports){\n/**\r\n * Beneficiary Detail View Component Directive\r\n *\r\n * @param {$parse} Angular parser service\r\n * @param {$rootScope} Angular rootScope service\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function($parse, $compile, $rootScope, $timeout) {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryDetailView.html',\r\n        restrict: 'AE',\r\n        //replace: true,\r\n        //transclude: true,\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        link: function(scope, el, attrs) {\r\n            $rootScope.$on('disableBeneficiary', function(ev, data) {\r\n                for (var i = 0; i < data.beneficiaries.length; i++) {\r\n                    if (data.beneficiaries[i].id === data.beneficiaryId) {\r\n                        var inputEls = angular.element(el.find('input[type=text]'));\r\n                        for (var j = 0; j < inputEls.length; j++) {\r\n                            angular.element(inputEls[j]).attr('disabled', '');\r\n                            $timeout(function() {\r\n                                $compile(inputEls[j])(scope);\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                //$compile(el)(scope);\r\n            });\r\n        }\r\n    };\r\n};\r\ndirective.$inject = [\"$parse\", \"$compile\", \"$rootScope\", \"$timeout\"];\r\n\r\nexports.directive = directive;\r\n\n},{}],8:[function(require,module,exports){\n/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryListFragmentView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiaries: '=',\r\n            delref: '='\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],9:[function(require,module,exports){\n/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryListView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],10:[function(require,module,exports){\n/**\r\n * Company Search Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiarySearchView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],11:[function(require,module,exports){\n/**\r\n * This service helps to perform http requests (GET, POST, PUT, DELETE) for beneficiary tasks\r\n *\r\n * @param {$http} The AngularJS http service\r\n * @param {$timeout} The AngularJS timeout service\r\n *\r\n * @ngInject\r\n */\r\nvar service = function($http, $timeout) {\r\n    'use strict';\r\n\r\n    var serviceInstance = {};\r\n    serviceInstance.selectedBeneficiaryId = null;\r\n    serviceInstance.popOnDelete = null;\r\n    serviceInstance.beneficiary = null;\r\n    serviceInstance.beneficiaries = [];\r\n\r\n    serviceInstance.getBeneficiary = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'GET',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.createBeneficiary = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            data: data,\r\n            method: 'POST',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n    serviceInstance.updateBeneficiary = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'PUT',\r\n            data: data,\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.deleteBeneficiary = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'DELETE',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$http\", \"$timeout\"];\r\n\r\nexports.service = service;\r\n\n},{}],12:[function(require,module,exports){\n/**\r\n * Beneficiary Form Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryUpdateView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],13:[function(require,module,exports){\n/**\r\n * Beneficiary View controller\r\n *\r\n * This controller is responsible for handing beneficiary form module related logic\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {$modal} Angular modal service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {utilService} Utility service\r\n * @param {blockUI} Block UI service\r\n * @param {inform} Inform provider service\r\n * @param {CONSTANTS} Project constants values\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function($rootScope, $scope, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, utilService, blockUI, inform, CONSTANTS) {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n    $scope.useExistingBeneficiary = false;\r\n    $scope.minimumValidBeneficiary = false;\r\n    $scope.beneficiaryId = null;\r\n    $scope.beneficiarySearched = false;\r\n    $scope.beneficiaryFound = false;\r\n    $scope.searchRequestSumbitted = false;\r\n    $scope.addRequestSubmitted = false;\r\n    $scope.addRequestAttempted = false;\r\n    $scope.updateRequestSubmitted = false;\r\n    $scope.updateRequestAttempted = false;\r\n    $scope.deleteRequestSubmitted = false;\r\n    $scope.deleteSuccessful = false;\r\n    $scope.serviceUrl = CONSTANTS.url.path;\r\n\r\n    $scope.initBeneficiary = {\r\n        \"firstName\": null,\r\n        \"lastName\": null\r\n    };\r\n\r\n    $scope.beneficiaries = beneficiaryService.beneficiaries.length > 0 ? beneficiaryService.beneficiaries : [];\r\n    $scope.beneficiary = beneficiaryService.beneficiary &&\r\n                         ($state.current.name === 'start.beneficiary.update' || $state.current.name === 'start.beneficiary.list.delete' || $state.current.name === 'start.beneficiary.search.delete') ?\r\n                         beneficiaryService.beneficiary : $scope.initBeneficiary;\r\n\r\n    $scope.resetBeneficiary = function() {\r\n        $timeout(function() {\r\n            $scope.beneficiary = $scope.initBeneficiary;\r\n            $scope.beneficiaries = [];\r\n        });\r\n    };\r\n\r\n    $scope.addBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.addRequestSubmitted = false;\r\n        beneficiaryService.beneficiary = $scope.beneficiary;\r\n        if (!utilService.isFormValid('beneficiaryDetailsForm')) {\r\n            $scope.addRequestAttempted = true;\r\n            $log.warn('form invalid');\r\n            inform.add('Invalid form. First name and Last name are required to create beneficiary', {\r\n                ttl: 3500,\r\n                type: 'danger'\r\n            });\r\n            // $scope.registerPopoverShow('#addBeneficiary');\r\n            return;\r\n        }\r\n\r\n        var beneficiaryCreateBlock = blockUI.instances.get('beneficiaryCreateBlock');\r\n        // beneficiaryCreateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        $scope.addRequestSubmitted = true;\r\n        beneficiaryService.createBeneficiary(url, $scope.beneficiary, function(result) {\r\n            $timeout(function() {\r\n                $log.info(result);\r\n                if (result && result.data) {\r\n                    if (result.data.id > 0) {\r\n                        inform.add('beneficiary created successfully.', {\r\n                            ttl: 2500\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.beneficiary', {}, {reload:true});\r\n                        }, 2500);\r\n                    } else {\r\n                        inform.add('Request completed, however beneficiary couldn\\'t be created.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating beneficiary.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.addRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // beneficiaryCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelAddBeneficiary = function() {\r\n        $state.go('start.beneficiary');\r\n    };\r\n\r\n    $scope.updateBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.updateRequestSubmitted = false;\r\n        beneficiaryService.beneficiary = $scope.beneficiary;\r\n        if (!utilService.isFormValid('beneficiaryDetailsForm')) {\r\n            $scope.updateRequestAttempted = true;\r\n            $log.warn('ccform invalid');\r\n            inform.add('Invalid form. First name and Last name are required to create beneficiary', {\r\n                ttl: 3500,\r\n                type: 'danger'\r\n            });\r\n            return;\r\n        }\r\n\r\n        // var beneficiaryUpdateBlock = blockUI.instances.get('beneficiaryUpdateBlock');\r\n        // beneficiaryUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        $scope.updateRequestSubmitted = true;\r\n        beneficiaryService.updateBeneficiary(url, $scope.beneficiary, function(result) {\r\n            $timeout(function() {\r\n                if (result && result.data) {\r\n                    if (result.data.status === true) {\r\n                        inform.add('beneficiary updated successfully.', {\r\n                            ttl: 4000\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.beneficiary.list', {}, {reload: true});\r\n                        }, 4500);\r\n                    } else {\r\n                        inform.add('Request completed successfully, but no update performed on beneficiary.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'beneficiary couldn\\'t be updated.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.updateRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // beneficiaryUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseBeneficiaryUpdate = function() {\r\n        $state.go('start.beneficiary.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.deleteBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.beneficiary = beneficiaryService.beneficiary;\r\n        // var beneficiaryUpdateBlock = blockUI.instances.get('beneficiaryUpdateBlock');\r\n        // beneficiaryUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + $scope.beneficiary.id;\r\n        beneficiaryService.deleteBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.deleteRequestSubmitted = true;\r\n                if (result && result.data && result.data.status === true) {\r\n                    $scope.deleteSuccessful = true;\r\n                } else {\r\n                  $log.info(result);\r\n                }\r\n                // beneficiaryUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseBeneficiaryDelete = function() {\r\n        $scope.$dismiss();\r\n        $state.go('start.beneficiary.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.fetchBeneficiary = function(id) {\r\n        $scope.beneficiaries.splice(0, $scope.beneficiaries.length);\r\n\r\n        var idSearch = !utilService.isBlank(id);\r\n        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        var url = idSearch ? baseUrl + '/' + id : baseUrl;\r\n        //var beneficiaryListBlock = blockUI.instances.get('beneficiaryListBlock');\r\n        //beneficiaryListBlock.start();\r\n        beneficiaryService.getBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.searchRequestSumbitted = true;\r\n                if (result && result.data) {\r\n                    if (idSearch) {\r\n                        $scope.beneficiaries.push(result.data);\r\n                    } else {\r\n                        $scope.beneficiaries = result.data;\r\n                    }\r\n                    beneficiaryService.beneficiaries = $scope.beneficiaries;\r\n                    $scope.beneficiaryFound = true;\r\n                }\r\n                //beneficiaryListBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.searchBeneficiary = function(id, $event) {\r\n        $event.stopPropagation();\r\n        $timeout(function() {\r\n            if (!utilService.isValidId(id)) {\r\n                $scope.registerPopoverShow('#searchExistingBeneficiaryId');\r\n                return;\r\n            }\r\n            $scope.fetchBeneficiary(id);\r\n        });\r\n    };\r\n\r\n    $scope.mutateBeneficiaryOptions = function(beneficiary, $index, $event) {\r\n        $event.stopPropagation();\r\n        beneficiaryService.selectedBeneficiaryId = '#beneficiary' + $index;\r\n        beneficiaryService.beneficiary = beneficiary;\r\n        $scope.registerPopoverPrep(beneficiaryService.selectedBeneficiaryId);\r\n        $scope.registerPopoverShow(beneficiaryService.selectedBeneficiaryId);\r\n    };\r\n\r\n    /* initialize popover */\r\n\r\n    $scope.discardMessage = function($event) {\r\n        $event ? $event.stopPropagation() : '';\r\n        beneficiaryService.popOnDelete = \"delete\";\r\n        $scope.registerPopoverHide('[id*=popover]');\r\n    };\r\n\r\n    beneficiaryService.popOnDelete = \"delete\";\r\n\r\n    $scope.registerPopoverPrep = function(id) {\r\n        angular.element($document.find(id)).popover({\r\n            trigger: 'manual'\r\n        });\r\n    };\r\n\r\n    $scope.registerPopoverShow = function(id) {\r\n        if (beneficiaryService.popOnDelete !== \"popover\") {\r\n            beneficiaryService.popOnDelete = \"popover\";\r\n            angular.element($document.find(id)).popover('show');\r\n        }\r\n    };\r\n\r\n    $scope.registerPopoverHide = function(id) {\r\n        var el = angular.element($document.find(id));\r\n        el ? el.popover('hide') : '';\r\n    };\r\n\r\n    $scope.registerPopoverPrep('#removeBeneficiary');\r\n    $scope.registerPopoverPrep('#addBeneficiary');\r\n    $scope.registerPopoverPrep('#updateBeneficiary');\r\n    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');\r\n    $scope.registerPopoverHide('[id*=popover]');\r\n\r\n    // clear all informs\r\n    inform.clear();\r\n};\r\ncontroller.$inject = [\"$rootScope\", \"$scope\", \"$timeout\", \"$window\", \"$document\", \"$log\", \"$state\", \"$modal\", \"beneficiaryService\", \"utilService\", \"blockUI\", \"inform\", \"CONSTANTS\"];\r\n\r\nexports.controller = controller;\r\n\n},{}],14:[function(require,module,exports){\n/**\r\n * Main Beneficiary Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],15:[function(require,module,exports){\n/**\r\n * Main View controller\r\n *\r\n * This controller is responsible for handing request from main view\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function() {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n};\r\n\r\nexports.controller = controller;\r\n\n},{}],16:[function(require,module,exports){\n/**\r\n * Main Directive\r\n *\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/common/MainView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'MainViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],17:[function(require,module,exports){\nvar stateConfig = {\r\n    /**\r\n     * Default to <company-create-view />\r\n     */\r\n    main: {\r\n        url: '/',\r\n        views: {\r\n            'main': {\r\n                template: '<main-view></main-view>'\r\n            },\r\n            'mainItem@start': {\r\n                template: '<company-create-view></company-create-view>'\r\n            }\r\n        }\r\n    },\r\n    company: {\r\n        initial: {\r\n            url: 'company',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-view></company-view>'\r\n                }\r\n            }\r\n        },\r\n        list: {\r\n            url: '/list',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-list-view></company-list-view>'\r\n                }\r\n            }\r\n        },\r\n        search: {\r\n            url: '/search',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-search-view></company-search-view>'\r\n                }\r\n            }\r\n        },\r\n        update: {\r\n            url: '/update',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-update-view></company-update-view>'\r\n                }\r\n            }\r\n        },\r\n        delete: {\r\n            // would be used under start.company.list state, hence url resolves to: #/company/list/delete\r\n            url: '/delete',\r\n            /**\r\n             * On state enter event listener\r\n             * @param  {$modal} Modal service\r\n             * @ngInject\r\n             */\r\n            onEnter: [\"$modal\", function($modal) {\r\n                $modal.open({\r\n                    template: '<company-delete-view></company-delete-view>',\r\n                    backdrop: 'static',\r\n                    keyboard: false,\r\n                    windowClass: 'modal',\r\n                    controller: 'CompanyViewController'\r\n                });\r\n            }]\r\n        }\r\n    },\r\n    beneficiary: {\r\n        initial: {\r\n            url: 'beneficiary',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-view></beneficiary-view>'\r\n                }\r\n            }\r\n        },\r\n        list: {\r\n            url: '/list',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-list-view></beneficiary-list-view>'\r\n                }\r\n            }\r\n        },\r\n        search: {\r\n            url: '/search',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-search-view></beneficiary-seach-view>'\r\n                }\r\n            }\r\n        },\r\n        update: {\r\n            url: '/update',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-update-view></beneficiary-update-view>'\r\n                }\r\n            }\r\n        },\r\n        delete: {\r\n            /** would be used under start.beneficiary.list or start.beneficiary.search state,\r\n             *  hence url resolves to: #/beneficiary/list/delete or  #/beneficiary/search/delete\r\n             */\r\n            url: '/delete',\r\n            /**\r\n             * On state enter event listener\r\n             * @param  {$modal} Modal service\r\n             * @ngInject\r\n             */\r\n            onEnter: [\"$modal\", function($modal) {\r\n                $modal.open({\r\n                    template: '<beneficiary-delete-view></beneficiary-delete-view>',\r\n                    backdrop: 'static',\r\n                    keyboard: false,\r\n                    windowClass: 'modal',\r\n                    controller: 'BeneficiaryViewController'\r\n                });\r\n            }]\r\n        }\r\n    }\r\n};\r\n\r\nexports.stateConfig = stateConfig;\r\n\n},{}],18:[function(require,module,exports){\n/**\r\n * This service provide custom word lookup for case normalization if one is not provided by the service client\r\n *\r\n * @param {$window} The angular window service\r\n * @ngInject\r\n */\r\nvar service = function($window) {\r\n    'use strict';\r\n    var serviceInstance = {};\r\n\r\n    serviceInstance.isFormValid = function(formId) {\r\n        var isValid = true;\r\n        var formEl = $window.document.getElementById(formId);\r\n        console.log(formEl);\r\n        if (!formEl || (formEl && formEl.className && formEl.className.indexOf('ng-invalid') > -1)) return false;\r\n        // otherwise, perform sanity check\r\n        var elements = $window.document.getElementById(formId).elements;\r\n        for (var i = 0, element = elements[i++]; i < elements.length; i++) {\r\n            if ((element.type === 'text' || element.type === 'checkbox' || element.type === 'radio' || element.type === 'date' || element.type === 'datetime-local' || element.type === 'email' || element.type === 'month' || element.type === 'number' || element.type === 'time' || element.type === 'url' || element.type === 'week' || element.type === 'textarea' || element.type === 'select') && (element.className.indexOf('ng-invalid') > -1)) {\r\n                isValid = false;\r\n                return isValid;\r\n            }\r\n        }\r\n\r\n        return isValid;\r\n    };\r\n\r\n    serviceInstance.isBlank = function(value) {\r\n        return angular.isUndefined(value) || value === null || value.length === 0;\r\n    };\r\n\r\n    serviceInstance.isValidId = function(id) {\r\n        return parseInt(id) >= 1;\r\n    }\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$window\"];\r\n\r\nexports.service = service;\r\n\n},{}],19:[function(require,module,exports){\n/**\r\n * Company Create Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyCreateView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],20:[function(require,module,exports){\n/**\r\n * Company Delete Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyDeleteView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],21:[function(require,module,exports){\n/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function() {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyListFragmentView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            companies: '=',\r\n            delref: '='\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],22:[function(require,module,exports){\n/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyListView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],23:[function(require,module,exports){\n/**\r\n * Company Search Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanySearchView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],24:[function(require,module,exports){\n/**\r\n * This service helps to perform http requests (GET, POST, PUT, DELETE) for company tasks\r\n *\r\n * @param {$http} The AngularJS http service\r\n * @param {$timeout} The AngularJS timeout service\r\n *\r\n * @ngInject\r\n */\r\nvar service = function($http, $timeout) {\r\n    'use strict';\r\n\r\n    var serviceInstance = {};\r\n    serviceInstance.selectedCompanyId = null;\r\n    serviceInstance.popOnDelete = null;\r\n    serviceInstance.company = null;\r\n    serviceInstance.companies = [];\r\n\r\n    serviceInstance.getCompany = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'GET',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.createCompany = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            data: data,\r\n            method: 'POST',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n    serviceInstance.updateCompany = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'PUT',\r\n            data: data,\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.deleteCompany = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'DELETE',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$http\", \"$timeout\"];\r\n\r\nexports.service = service;\r\n\n},{}],25:[function(require,module,exports){\n/**\r\n * Company Update Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyUpdateView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],26:[function(require,module,exports){\n/**\r\n * Company View controller\r\n *\r\n * This controller is responsible for handing company form module related logic\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$q} Angular promise service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {$modal} Angular modal service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n * @param {utilService} Utility service\r\n * @param {blockUI} Block UI service\r\n * @param {inform} Inform provider service\r\n * @param {CONSTANTS} Project constants values\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function($rootScope, $scope, $q, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, companyService, utilService, blockUI, inform, CONSTANTS) {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n    $scope.useExistingBeneficiary = false;\r\n    $scope.minimumValidBeneficiary = false;\r\n    $scope.beneficiaryId = null;\r\n    $scope.beneficiarySearched = false;\r\n    $scope.beneficiaryFound = false;\r\n    $scope.companyFound = false;\r\n    $scope.searchRequestSumbitted = false;\r\n    $scope.addRequestSubmitted = false;\r\n    $scope.updateRequestSubmitted = false;\r\n    $scope.deleteRequestSubmitted = false;\r\n    $scope.deleteSuccessful = false;\r\n    $scope.serviceUrl = CONSTANTS.url.path;\r\n\r\n    $scope.initCompany = {\r\n        \"name\": null,\r\n        \"address\": null,\r\n        \"city\": null,\r\n        \"country\": null,\r\n        \"email\": null,\r\n        \"phoneNumber\": null,\r\n        \"beneficiaries\": [{\r\n            \"id\": -1,\r\n            \"firstName\": null,\r\n            \"lastName\": null\r\n        }]\r\n    };\r\n\r\n    $scope.companies = companyService.companies.length > 0 ? companyService.companies : [];\r\n    $scope.company = companyService.company &&\r\n                    ($state.current.name === 'start.company.update' || $state.current.name === 'start.company.list.delete' || $state.current.name === 'start.company.search.delete') ?\r\n                    companyService.company : $scope.initCompany;\r\n\r\n    $scope.verifyMinimumValidBeneficiary = function() {\r\n        for (var i = 0; i < $scope.company.beneficiaries.length; i++) {\r\n            $scope.minimumValidBeneficiary = $scope.company.beneficiaries[i].id !== -1 ||\r\n                                            (!utilService.isBlank($scope.company.beneficiaries[i].firstName) && !utilService.isBlank($scope.company.beneficiaries[i].lastName));\r\n            if ($scope.minimumValidBeneficiary) {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n\r\n    $scope.resetCompany = function() {\r\n        $timeout(function() {\r\n            $scope.company = $scope.initCompany;\r\n            $scope.companies = [];\r\n        });\r\n    };\r\n\r\n    $scope.addCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.addRequestSubmitted = false;\r\n        companyService.company = $scope.company;\r\n        if (utilService.isFormValid('companyDetailsForm')) {\r\n            $scope.verifyMinimumValidBeneficiary();\r\n            if (!$scope.minimumValidBeneficiary) {\r\n                $scope.registerPopoverShow('#addCompany');\r\n                return;\r\n            }\r\n            $log.info('valid');\r\n        } else {\r\n            $log.warn('form invalid');\r\n            return;\r\n        }\r\n\r\n        var companyCreateBlock = blockUI.instances.get('companyCreateBlock');\r\n        // companyCreateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        $scope.addRequestSubmitted = true;\r\n        companyService.createCompany(url, $scope.company, function(result) {\r\n            $timeout(function() {\r\n                if (result && result.data) {\r\n                    if (result.data.id > 0) {\r\n                        inform.add('Company created successfully.', {\r\n                            ttl: 2500\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.company', {}, {reload:true});\r\n                        }, 2500);\r\n                    } else {\r\n                        inform.add('Request completed, however company couldn\\'t be created.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating company.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.addRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // companyCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelAddCompany = function() {\r\n        $state.go('start.company');\r\n    };\r\n\r\n    $scope.updateCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.updateRequestSubmitted = false;\r\n        companyService.company = $scope.company;\r\n        if (utilService.isFormValid('companyUpdateForm')) {\r\n            $scope.verifyMinimumValidBeneficiary();\r\n            if (!$scope.minimumValidBeneficiary) {\r\n                $scope.registerPopoverShow('#updateCompany');\r\n                return;\r\n            }\r\n        } else {\r\n            $log.warn('form invalid');\r\n            return;\r\n        }\r\n\r\n        // var companyUpdateBlock = blockUI.instances.get('companyUpdateBlock');\r\n        // companyUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        $scope.updateRequestSubmitted = true;\r\n        companyService.updateCompany(url, $scope.company, function(result) {\r\n            $timeout(function() {\r\n                if (result && result.data) {\r\n                    if (result.data.status === true) {\r\n                        inform.add('Company updated successfully.', {\r\n                            ttl: 4000\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.company.list', {}, {reload: true});\r\n                        }, 4500);\r\n                    } else {\r\n                        inform.add('Request completed successfully, but no update performed on company.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Company couldn\\'t be updated.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.updateRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // companyUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseCompanyUpdate = function() {\r\n        $state.go('start.company.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.deleteCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.company = companyService.company;\r\n        // var companyUpdateBlock = blockUI.instances.get('companyUpdateBlock');\r\n        // companyUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath + '/' + $scope.company.id;\r\n        companyService.deleteCompany(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.deleteRequestSubmitted = true;\r\n                if (result && result.data && result.data.status === true) {\r\n                    $scope.deleteSuccessful = true;\r\n                }\r\n                // companyUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseCompanyDelete = function() {\r\n        $scope.$dismiss();\r\n        $state.go('start.company.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.fetchCompany = function(id) {\r\n        $scope.companies.splice(0, $scope.companies.length);\r\n\r\n        var idSearch = !utilService.isBlank(id);\r\n        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        var url = idSearch ? baseUrl + '/' + id : baseUrl;\r\n        //var companyListBlock = blockUI.instances.get('companyListBlock');\r\n        //companyListBlock.start();\r\n        companyService.getCompany(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.searchRequestSumbitted = true;\r\n                if (result && result.data) {\r\n                    if (idSearch) {\r\n                        $scope.companies.push(result.data);\r\n                    } else {\r\n                        $scope.companies = result.data;\r\n                    }\r\n                    companyService.companies = $scope.companies;\r\n                    $scope.companyFound = true;\r\n                }\r\n                //companyListBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.searchCompany = function(id, $event) {\r\n        $event.stopPropagation();\r\n        $timeout(function() {\r\n            if (!utilService.isValidId(id)) {\r\n                $scope.registerPopoverShow('#searchExistingCompanyId');\r\n                return;\r\n            }\r\n            $scope.fetchCompany(id);\r\n        });\r\n    };\r\n\r\n    $scope.searchBeneficiary = function(id, $event) {\r\n        $event.stopPropagation();\r\n\r\n        if (!utilService.isValidId(id)) {\r\n            $scope.registerPopoverShow('#searchExistingBeneficiaryId');\r\n            return;\r\n        }\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + id;\r\n\r\n        var companySearchBlock = blockUI.instances.get('companySearchBlock');\r\n        companySearchBlock.start();\r\n        beneficiaryService.findBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.beneficiarySearched = true;\r\n                if (result && result.data) {\r\n                    $scope.verifyMinimumValidBeneficiary();\r\n                    // remove all empty forms\r\n                    if (!$scope.minimumValidBeneficiary) {\r\n                        $scope.company.beneficiaries.splice(0, $scope.company.beneficiaries.length);\r\n                    }\r\n                    $scope.company.beneficiaries.push(result.data);\r\n                    $scope.disableBeneficiary(result.data.id);\r\n                    $scope.minimumValidBeneficiary = true;\r\n                    $scope.beneficiaryFound = true;\r\n                    $scope.beneficiaryId = null;\r\n                }\r\n                companySearchBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.mutateCompanyOptions = function(company, $index, $event) {\r\n        $event.stopPropagation();\r\n        companyService.selectedCompanyId = '#company' + $index;\r\n        companyService.company = company;\r\n        $scope.registerPopoverPrep(companyService.selectedCompanyId);\r\n        $scope.registerPopoverShow(companyService.selectedCompanyId);\r\n    };\r\n\r\n    $scope.addBeneficiary = function() {\r\n        $scope.company.beneficiaries.push({\r\n            \"firstName\": \"\",\r\n            \"lastName\": \"\"\r\n        });\r\n    };\r\n\r\n    $scope.removeBeneficiary = function($event, beneficiary) {\r\n        $event.stopPropagation();\r\n        if ($scope.company.beneficiaries.indexOf(beneficiary) != -1) {\r\n            $timeout(function() {\r\n                if ($scope.company.beneficiaries.length === 1) {\r\n                    $scope.registerPopoverShow('#removeBeneficiary');\r\n                    return;\r\n                }\r\n                $scope.company.beneficiaries.splice($scope.company.beneficiaries.indexOf(beneficiary), 1);\r\n            });\r\n        }\r\n    };\r\n\r\n    $scope.disableBeneficiary = function(beneficiaryId) {\r\n        $rootScope.$emit('disableBeneficiary', {\r\n            beneficiaries: $scope.company.beneficiaries,\r\n            beneficiaryId: beneficiaryId\r\n        });\r\n    }\r\n\r\n    /* initialize popover */\r\n\r\n    $scope.discardMessage = function($event) {\r\n        $event ? $event.stopPropagation() : '';\r\n        companyService.popOnDelete = \"delete\";\r\n        $scope.registerPopoverHide('[id*=popover]');\r\n    };\r\n\r\n    companyService.popOnDelete = \"delete\";\r\n\r\n    $scope.registerPopoverPrep = function(id) {\r\n        angular.element($document.find(id)).popover({\r\n            trigger: 'manual'\r\n        });\r\n    };\r\n\r\n    $scope.registerPopoverShow = function(id) {\r\n        if (companyService.popOnDelete !== \"popover\") {\r\n            companyService.popOnDelete = \"popover\";\r\n            angular.element($document.find(id)).popover('show');\r\n        }\r\n    };\r\n\r\n    $scope.registerPopoverHide = function(id) {\r\n        var el = angular.element($document.find(id));\r\n        el ? el.popover('hide') : '';\r\n    };\r\n\r\n    $scope.registerPopoverPrep('#removeBeneficiary');\r\n    $scope.registerPopoverPrep('#addCompany');\r\n    $scope.registerPopoverPrep('#updateCompany');\r\n    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');\r\n    $scope.registerPopoverPrep('#searchExistingCompanyId');\r\n    $scope.registerPopoverHide('[id*=popover]');\r\n\r\n    // clear all informs\r\n    inform.clear();\r\n};\r\ncontroller.$inject = [\"$rootScope\", \"$scope\", \"$q\", \"$timeout\", \"$window\", \"$document\", \"$log\", \"$state\", \"$modal\", \"beneficiaryService\", \"companyService\", \"utilService\", \"blockUI\", \"inform\", \"CONSTANTS\"];\r\n\r\nexports.controller = controller;\r\n\n},{}],27:[function(require,module,exports){\n/**\r\n * Main Company Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyView.html',\r\n        restrict: 'AE',\r\n        scope: false\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],28:[function(require,module,exports){\n/**\r\n * Side Nav View controller\r\n *\r\n * This controller is responsible for handing request from side nav\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function() {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n};\r\n\r\nexports.controller = controller;\r\n\n},{}],29:[function(require,module,exports){\n/**\r\n * Side Nav Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/nav/SideNavView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'SideNavViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],30:[function(require,module,exports){\nvar translationsEN = {\n    \"BENEFICIARY\": {\n        \"ID\": \"Id\",\n        \"FIRST_NAME\": \"First name\",\n        \"LAST_NAME\": \"Last name\"\n    }\n};\n\nexports.translationsEN = translationsEN;\n\n},{}],31:[function(require,module,exports){\n'use strict';\r\n\r\nvar states = require('./components/common/States');\r\nvar configBlock = {\r\n    /**\r\n     * @param {$logProvider} The log provider service\r\n     * @param {$translateProvider} The angular translate service\r\n     * @ngInject\r\n     */\r\n    settings: [\"$logProvider\", \"$translateProvider\", function($logProvider, $translateProvider) {\r\n        $logProvider.debugEnabled(true); // Turns global logging with $log.debug on\r\n\r\n        var i18n_en = require('./components/nls/i18n-en');\r\n        $translateProvider.useSanitizeValueStrategy('sanitizeParameters');\r\n        $translateProvider.translations('en', i18n_en.translationsEN).useStaticFilesLoader({\r\n                files: [{\r\n                    prefix: './components/nls/i18n-',\r\n                    suffix: '.json'\r\n                }]\r\n            })\r\n            .preferredLanguage('en')\r\n            .fallbackLanguage('en');\r\n    }],\r\n    /**\r\n     * @param {$stateProvider} $stateProvider The UI router stateProvider service\r\n     * @param {$urlRouterProvider} The UI router urlRouterProvider service\r\n     * @param {$modalStateProvider} The custom modal state provider service\r\n     * @ngInject\r\n     */\r\n    states: [\"$stateProvider\", \"$urlRouterProvider\", function($stateProvider, $urlRouterProvider) {\r\n        $urlRouterProvider.otherwise('/');\r\n        $stateProvider\r\n            .state('start', states.stateConfig.main)\r\n            .state('start.company', states.stateConfig.company.initial)\r\n            .state('start.company.list', states.stateConfig.company.list)\r\n            .state('start.company.list.delete',  angular.copy(states.stateConfig.company.delete))\r\n            .state('start.company.search', states.stateConfig.company.search)\r\n            .state('start.company.search.delete', angular.copy(states.stateConfig.company.delete))\r\n            .state('start.company.update', states.stateConfig.company.update)\r\n            .state('start.beneficiary', states.stateConfig.beneficiary.initial)\r\n            .state('start.beneficiary.list', states.stateConfig.beneficiary.list)\r\n            .state('start.beneficiary.list.delete', angular.copy(states.stateConfig.beneficiary.delete))\r\n            .state('start.beneficiary.search', states.stateConfig.beneficiary.search)\r\n            .state('start.beneficiary.search.delete', angular.copy(states.stateConfig.beneficiary.delete))\r\n            .state('start.beneficiary.update', states.stateConfig.beneficiary.update)\r\n    }],\r\n\r\n    /**\r\n     * @param  {blockUIConfig} The block UI config service\r\n     * @ngInject\r\n     */\r\n    blockUI: [\"blockUIConfig\", function(blockUIConfig) {\r\n        blockUIConfig.delay = 100;\r\n        blockUIConfig.autoBlock = false;\r\n        blockUIConfig.autoInjectBodyBlock = false;\r\n        blockUIConfig.template = '<div><img src=\"dist/images/ajax-loader.gif\" /> Processing...</h1>';\r\n    }],\r\n\r\n    /**\r\n     * @param  {informProvider} The inform provider service\r\n     * @ngInject\r\n     */\r\n    inform: [\"informProvider\", function(informProvider) {\r\n        informProvider.defaults({\r\n            /**\r\n             * The time to live for the message in milliseconds.\r\n             * Default value is 5000. Specify <0 to make the message sticky.\r\n             */\r\n            ttl: -1,\r\n\r\n            /**\r\n             * The type of message to enable styling.\r\n             * Values can be 'default', 'primary', 'success', 'info', 'warning', 'danger' or any other custom required type.\r\n             * Default value is 'info'. If 'default' is specified as value, then 'info' is used\r\n             */\r\n            type: 'success',\r\n            /**\r\n             * Allow html formatting\r\n             * Default value is false\r\n             */\r\n            html: true\r\n        });\r\n    }],\r\n\r\n    /**\r\n     * Modal block\r\n     * @param  {$rootScope}  Angular root scope service\r\n     * @param  {$modalStack} Angular UI modal stack\r\n     * @ngInject\r\n     */\r\n    modal: [\"$rootScope\", \"$modalStack\", function($rootScope, $modalStack) {\r\n        $rootScope.$on('$stateChangeStart', function() {\r\n            var top = $modalStack.getTop();\r\n            if (top) {\r\n                $modalStack.dismiss(top.key);\r\n            }\r\n        });\r\n    }],\r\n\r\n    /**\r\n     * Href sanitization whitelist\r\n     * @param  {$compileProvide} Angular compile provider service\r\n     * @ngInject\r\n     */\r\n    hrefSanitize: [\"$compileProvider\", function($compileProvider) {\r\n        $compileProvider.aHrefSanitizationWhitelist(/^\\s*(https?|ftp|mailto|file|chrome-extension|blob:chrome-extension):/);\r\n    }],\r\n\r\n    namespace: 'com.companyregistry'\r\n};\r\n\r\nexports.configBlock = configBlock;\r\n\n},{\"./components/common/States\":17,\"./components/nls/i18n-en\":30}],32:[function(require,module,exports){\n'use strict';\r\n\r\nexports.constants = {\r\n    url: {\r\n\t\t\t\t// path: 'http://localhost:8080/companyregistry',\r\n\t\t\t\tpath: 'https://companyregistry.herokuapp.com',\r\n        companyContextPath: 'companies',\r\n        beneficiaryContextPath: 'beneficiaries'\r\n    }\r\n};\r\n\n},{}],33:[function(require,module,exports){\n/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* jshint ignore:start */\nvar noop        = angular.noop;\nvar extend      = angular.extend;\nvar jqLite      = angular.element;\nvar forEach     = angular.forEach;\nvar isArray     = angular.isArray;\nvar isString    = angular.isString;\nvar isObject    = angular.isObject;\nvar isUndefined = angular.isUndefined;\nvar isDefined   = angular.isDefined;\nvar isFunction  = angular.isFunction;\nvar isElement   = angular.isElement;\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar isPromiseLike = function(p) {\n  return p && p.then ? true : false;\n};\n\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return [];\n        break;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n        break;\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  }\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationOptions(element, target, newOptions) {\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof angular.element) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncancelled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\nvar $$AnimateChildrenDirective = [function() {\n  return function(scope, element, attrs) {\n    var val = attrs.ngAnimateChildren;\n    if (angular.isString(val) && val.length === 0) { //empty attribute\n      element.data(NG_ANIMATE_CHILDREN_DATA, true);\n    } else {\n      attrs.$observe('ngAnimateChildren', function(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      });\n    }\n  };\n}];\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and stlyes may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n * * `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occuring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a colapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for zegative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$animate',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $animate) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = \"$$ngAnimateParentKey\";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an interal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var cancelLastRAFRequest;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, options) {\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$animate.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle = parseFloat(options.delay);\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            value ? node.style.setProperty(prop, value)\n                  : node.style.removeProperty(prop);\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        var startTime, events = [];\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidently cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intential stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          element.on(events.join(' '), onAnimationProgress);\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n\n        function onAnimationProgress(event) {\n          event.stopPropagation();\n          var ev = event.originalEvent || event;\n          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();\n\n          /* Firefox (or possibly just Gecko) likes to not round values up\n           * when a ms measurement is used for the animation */\n          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n          /* $manualTimeStamp is a mocked timeStamp value which is set\n           * within browserTrigger(). This is only here so that tests can\n           * mock animations properly. Real events fallback to event.timeStamp,\n           * or, if they don't, then a timeStamp is automatically created for them.\n           * We're checking to see if the timeStamp surpasses the expected delay,\n           * but we're using elapsedTime instead of the timeStamp on the 2nd\n           * pre-condition since animations sometimes close off early */\n          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n            // we set this flag to ensure that if the transition is paused then, when resumed,\n            // the animation will automatically close itself since transitions cannot be paused.\n            animationCompleted = true;\n            close();\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragement case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coods object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      return {\n        start: function() {\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          var animationClosed = false;\n          var runner = new $$AnimateRunner({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            animationClosed = true;\n            applyOptions();\n            applyAnimationStyles(element, options);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(options, and) {\n    options = options || {};\n    var a = (options.addClass || '').length > 0;\n    var b = (options.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    var nO = newAnimation.options;\n    var cO = currentAnimation.options;\n\n    // if the exact same CSS class is added/removed then it's safe to cancel it\n    return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = {};\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationOptions(element, options) {\n      return mergeAnimationOptions(element, options, {});\n    }\n\n    function findCallbacks(element, event) {\n      var targetNode = getDomNode(element);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (entry.node.contains(targetNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    return {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n      },\n\n      off: function(event, container, callback) {\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n\n        function filterFromRegistry(list, matchContainer, matchCallback) {\n          var containerNode = extractElementNode(matchContainer);\n          return list.filter(function(entry) {\n            var isMatch = entry.node === containerNode &&\n                            (!matchCallback || entry.callback === matchCallback);\n            return !isMatch;\n          });\n        }\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n            var recordExists = disabledElementsLookup.get(node);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !recordExists;\n            } else {\n              // (element, bool) - Element setter\n              bool = !!bool;\n              if (!bool) {\n                disabledElementsLookup.put(node, true);\n              } else if (recordExists) {\n                disabledElementsLookup.remove(node);\n              }\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    function queueAnimation(element, event, options) {\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        close();\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationOptions(element, existingAnimation.options, options);\n            return existingAnimation.runner;\n          }\n        }\n\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationOptions(element, options);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationOptions(element, options);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation.options);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails.options));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n            });\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        switch (state) {\n          case RUNNING_STATE:\n            animationDetails.runner.end();\n            /* falls through */\n          case PRE_DIGEST_STATE:\n            if (animationDetails) {\n              activeAnimationsLookup.remove(child);\n            }\n            break;\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n\n      var parentHost = element.data(NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      while (parentElement && parentElement.length) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        var parentNode = parentElement[0];\n        if (parentNode.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentNode) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n          if (!rootElementDetected) {\n            parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);\n            if (parentHost) {\n              parentElement = parentHost;\n            }\n          }\n        }\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be apart of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        parentElement = parentElement.parent();\n      }\n\n      var allowAnimation = !parentAnimationDetected || animateChildren;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$AnimateAsyncRunFactory = ['$$rAF', function($$rAF) {\n  var waitQueue = [];\n\n  function waitForTick(fn) {\n    waitQueue.push(fn);\n    if (waitQueue.length > 1) return;\n    $$rAF(function() {\n      for (var i = 0; i < waitQueue.length; i++) {\n        waitQueue[i]();\n      }\n      waitQueue = [];\n    });\n  }\n\n  return function() {\n    var passed = false;\n    waitForTick(function() {\n      passed = true;\n    });\n    return function(callback) {\n      passed ? callback() : waitForTick(callback);\n    };\n  };\n}];\n\nvar $$AnimateRunnerFactory = ['$q', '$sniffer', '$$animateAsyncRun',\n                      function($q,   $sniffer,   $$animateAsyncRun) {\n\n  var INITIAL_STATE = 0;\n  var DONE_PENDING_STATE = 1;\n  var DONE_COMPLETE_STATE = 2;\n\n  AnimateRunner.chain = function(chain, callback) {\n    var index = 0;\n\n    next();\n    function next() {\n      if (index === chain.length) {\n        callback(true);\n        return;\n      }\n\n      chain[index](function(response) {\n        if (response === false) {\n          callback(false);\n          return;\n        }\n        index++;\n        next();\n      });\n    }\n  };\n\n  AnimateRunner.all = function(runners, callback) {\n    var count = 0;\n    var status = true;\n    forEach(runners, function(runner) {\n      runner.done(onProgress);\n    });\n\n    function onProgress(response) {\n      status = status && response;\n      if (++count === runners.length) {\n        callback(status);\n      }\n    }\n  };\n\n  function AnimateRunner(host) {\n    this.setHost(host);\n\n    this._doneCallbacks = [];\n    this._runInAnimationFrame = $$animateAsyncRun();\n    this._state = 0;\n  }\n\n  AnimateRunner.prototype = {\n    setHost: function(host) {\n      this.host = host || {};\n    },\n\n    done: function(fn) {\n      if (this._state === DONE_COMPLETE_STATE) {\n        fn();\n      } else {\n        this._doneCallbacks.push(fn);\n      }\n    },\n\n    progress: noop,\n\n    getPromise: function() {\n      if (!this.promise) {\n        var self = this;\n        this.promise = $q(function(resolve, reject) {\n          self.done(function(status) {\n            status === false ? reject() : resolve();\n          });\n        });\n      }\n      return this.promise;\n    },\n\n    then: function(resolveHandler, rejectHandler) {\n      return this.getPromise().then(resolveHandler, rejectHandler);\n    },\n\n    'catch': function(handler) {\n      return this.getPromise()['catch'](handler);\n    },\n\n    'finally': function(handler) {\n      return this.getPromise()['finally'](handler);\n    },\n\n    pause: function() {\n      if (this.host.pause) {\n        this.host.pause();\n      }\n    },\n\n    resume: function() {\n      if (this.host.resume) {\n        this.host.resume();\n      }\n    },\n\n    end: function() {\n      if (this.host.end) {\n        this.host.end();\n      }\n      this._resolve(true);\n    },\n\n    cancel: function() {\n      if (this.host.cancel) {\n        this.host.cancel();\n      }\n      this._resolve(false);\n    },\n\n    complete: function(response) {\n      var self = this;\n      if (self._state === INITIAL_STATE) {\n        self._state = DONE_PENDING_STATE;\n        self._runInAnimationFrame(function() {\n          self._resolve(response);\n        });\n      }\n    },\n\n    _resolve: function(response) {\n      if (this._state !== DONE_COMPLETE_STATE) {\n        forEach(this._doneCallbacks, function(fn) {\n          fn(response);\n        });\n        this._doneCallbacks.length = 0;\n        this._state = DONE_COMPLETE_STATE;\n      }\n    }\n  };\n\n  return AnimateRunner;\n}];\n\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effictively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check\n\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          getRunner(element).setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/* global angularAnimateModule: true,\n\n   $$AnimateAsyncRunFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateRunnerFactory,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,\n*/\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=true\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the ainmation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       }).start();\n*        runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       }).start();\n *\n *       runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n *\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix\n * will be evaluated for animation when any DOM changes occur in the application.\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [])\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .factory('$$AnimateRunner', $$AnimateRunnerFactory)\n  .factory('$$animateAsyncRun', $$AnimateAsyncRunFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n\n},{}],34:[function(require,module,exports){\nrequire('./angular-animate');\nmodule.exports = 'ngAnimate';\n\n},{\"./angular-animate\":33}],35:[function(require,module,exports){\n/*!\n   angular-block-ui v0.2.0\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\n   License: MIT\n*/\n(function(angular) {\n\nvar blkUI = angular.module('blockUI', []);\n\nblkUI.config([\"$provide\", \"$httpProvider\", function ($provide, $httpProvider) {\n\n  $provide.decorator('$exceptionHandler', ['$delegate', '$injector',\n    function ($delegate, $injector) {\n      var blockUI, blockUIConfig;\n\n      return function (exception, cause) {\n\n        blockUIConfig = blockUIConfig || $injector.get('blockUIConfig');\n\n        if (blockUIConfig.resetOnException) {\n          try {\n            blockUI = blockUI || $injector.get('blockUI');\n            blockUI.instances.reset();\n          } catch (ex) {\n            console.log('$exceptionHandler', exception);\n          }\n        }\n\n        $delegate(exception, cause);\n      };\n    }\n  ]);\n\n  $httpProvider.interceptors.push('blockUIHttpInterceptor');\n}]);\n\nblkUI.run([\"$document\", \"blockUIConfig\", \"$templateCache\", function ($document, blockUIConfig, $templateCache) {\n  if (blockUIConfig.autoInjectBodyBlock) {\n    $document.find('body').attr('block-ui', 'main');\n  }\n\n  if (blockUIConfig.template) {\n\n    // Swap the builtin template with the custom template.\n    // Create a magic cache key and place the template in the cache.\n\n    blockUIConfig.templateUrl = '$$block-ui-template$$';\n    $templateCache.put(blockUIConfig.templateUrl, blockUIConfig.template);\n  }\n}]);\n\nfunction moduleLoaded(name) {\n  try {\n    angular.module(name);\n  } catch(ex) {\n    return false;\n  }\n  return true;\n}\nblkUI.config([\"$provide\", function ($provide) {\n  $provide.decorator('$location', decorateLocation);\n}]);\n\nvar decorateLocation = [\n  '$delegate', 'blockUI', 'blockUIConfig',\n  function ($delegate, blockUI, blockUIConfig) {\n\n    if (blockUIConfig.blockBrowserNavigation) {\n\n      blockUI.$_blockLocationChange = true;\n\n      var overrides = ['url', 'path', 'search', 'hash', 'state'];\n\n      function hook(f) {\n        var s = $delegate[f];\n        $delegate[f] = function () {\n\n          //        console.log(f, Date.now(), arguments);\n\n          var result = s.apply($delegate, arguments);\n\n          // The call was a setter if the $location service is returned.\n\n          if (result === $delegate) {\n\n            // Mark the mainblock ui to allow the location change.\n\n            blockUI.$_blockLocationChange = false;\n          }\n\n          return result;\n        };\n      }\n\n      angular.forEach(overrides, hook);\n\n    }\n\n    return $delegate;\n}];\n\n// Called from block-ui-directive for the 'main' instance.\n\nfunction blockNavigation($scope, mainBlockUI, blockUIConfig) {\n\n  if (blockUIConfig.blockBrowserNavigation) {\n\n    function registerLocationChange() {\n\n      $scope.$on('$locationChangeStart', function (event) {\n\n        //        console.log('$locationChangeStart', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);\n\n        if (mainBlockUI.$_blockLocationChange && mainBlockUI.state().blockCount > 0) {\n          event.preventDefault();\n        }\n      });\n\n      $scope.$on('$locationChangeSuccess', function () {\n        mainBlockUI.$_blockLocationChange = blockUIConfig.blockBrowserNavigation;\n\n        //        console.log('$locationChangeSuccess', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);\n      });\n    }\n\n    if (moduleLoaded('ngRoute')) {\n\n      // After the initial content has been loaded we'll spy on any location\n      // changes and discard them when needed.\n\n      var fn = $scope.$on('$viewContentLoaded', function () {\n\n        // Unhook the view loaded and hook a function that will prevent\n        // location changes while the block is active.\n\n        fn();\n        registerLocationChange();\n\n      });\n\n    } else {\n      registerLocationChange();\n    }\n\n  }\n}\nblkUI.directive('blockUiContainer', [\"blockUIConfig\", \"blockUiContainerLinkFn\", function (blockUIConfig, blockUiContainerLinkFn) {\n  return {\n    scope: true,\n    restrict: 'A',\n    templateUrl: blockUIConfig.templateUrl,\n    compile: function($element) {\n      return blockUiContainerLinkFn;\n    }\n  };\n}]).factory('blockUiContainerLinkFn', [\"blockUI\", \"blockUIUtils\", function (blockUI, blockUIUtils) {\n\n  return function ($scope, $element, $attrs) {\n\n    var srvInstance = $element.inheritedData('block-ui');\n\n    if (!srvInstance) {\n      throw new Error('No parent block-ui service instance located.');\n    }\n\n    // Expose the state on the scope\n\n    $scope.state = srvInstance.state();\n\n//    $scope.$watch('state.blocking', function(value) {\n//      $element.toggleClass('block-ui-visible', !!value);\n//    });\n//\n//    $scope.$watch('state.blockCount > 0', function(value) {\n//      $element.toggleClass('block-ui-active', !!value);\n//    });\n  };\n}]);\nblkUI.directive('blockUi', [\"blockUiCompileFn\", function (blockUiCompileFn) {\n\n  return {\n    scope: true,\n    restrict: 'A',\n    compile: blockUiCompileFn\n  };\n\n}]).factory('blockUiCompileFn', [\"blockUiPreLinkFn\", function (blockUiPreLinkFn) {\n\n  return function ($element, $attrs) {\n\n    // Class should be added here to prevent an animation delay error.\n\n    $element.append('<div block-ui-container class=\"block-ui-container\"></div>');\n\n    return {\n      pre: blockUiPreLinkFn\n    };\n\n  };\n\n}]).factory('blockUiPreLinkFn', [\"blockUI\", \"blockUIUtils\", \"blockUIConfig\", function (blockUI, blockUIUtils, blockUIConfig) {\n\n  return function ($scope, $element, $attrs) {\n\n    // If the element does not have the class \"block-ui\" set, we set the\n    // default css classes from the config.\n\n    if (!$element.hasClass('block-ui')) {\n      $element.addClass(blockUIConfig.cssClass);\n    }\n\n    // Expose the blockUiMessageClass attribute value on the scope\n\n    $attrs.$observe('blockUiMessageClass', function (value) {\n      $scope.$_blockUiMessageClass = value;\n    });\n\n    // Create the blockUI instance\n    // Prefix underscore to prevent integers:\n    // https://github.com/McNull/angular-block-ui/pull/8\n\n    var instanceId = $attrs.blockUi || '_' + $scope.$id;\n    var srvInstance = blockUI.instances.get(instanceId);\n\n    // If this is the main (topmost) block element we'll also need to block any\n    // location changes while the block is active.\n\n    if (instanceId === 'main') {\n      blockNavigation($scope, srvInstance, blockUIConfig);\n    } else {\n      // Locate the parent blockUI instance\n      var parentInstance = $element.inheritedData('block-ui');\n\n      if (parentInstance) {\n        // TODO: assert if parent is already set to something else\n        srvInstance._parent = parentInstance;\n      }\n    }\n\n    // Ensure the instance is released when the scope is destroyed\n\n    $scope.$on('$destroy', function () {\n      srvInstance.release();\n    });\n\n    // Increase the reference count\n\n    srvInstance.addRef();\n\n    // Expose the state on the scope\n\n    $scope.$_blockUiState = srvInstance.state();\n\n    $scope.$watch('$_blockUiState.blocking', function (value) {\n      // Set the aria-busy attribute if needed\n      $element.attr('aria-busy', !!value);\n      $element.toggleClass('block-ui-visible', !!value);\n    });\n\n    $scope.$watch('$_blockUiState.blockCount > 0', function (value) {\n      $element.toggleClass('block-ui-active', !!value);\n    });\n\n    // If a pattern is provided assign it to the state\n\n    var pattern = $attrs.blockUiPattern;\n\n    if (pattern) {\n      var regExp = blockUIUtils.buildRegExp(pattern);\n      srvInstance.pattern(regExp);\n    }\n\n    // Store a reference to the service instance on the element\n\n    $element.data('block-ui', srvInstance);\n\n  };\n\n}]);\n//.factory('blockUiPostLinkFn', function(blockUIUtils) {\n//\n//  return function($scope, $element, $attrs) {\n//\n//    var $message;\n//\n//    $attrs.$observe('blockUiMessageClass', function(value) {\n//\n//      $message = $message || blockUIUtils.findElement($element, function($e) {\n//        return $e.hasClass('block-ui-message');\n//      });\n//\n//      $message.addClass(value);\n//\n//    });\n//  };\n//\n//});\nblkUI.constant('blockUIConfig', {\n    templateUrl: 'angular-block-ui/angular-block-ui.ng.html',\n    delay: 250,\n    message: \"Loading ...\",\n    autoBlock: true,\n    resetOnException: true,\n    requestFilter: angular.noop,\n    autoInjectBodyBlock: true,\n    cssClass: 'block-ui block-ui-anim-fade',\n    blockBrowserNavigation: false\n});\n\n\nblkUI.factory('blockUIHttpInterceptor', [\"$q\", \"$injector\", \"blockUIConfig\", \"$templateCache\", function($q, $injector, blockUIConfig, $templateCache) {\n\n  var blockUI;\n\n  function injectBlockUI() {\n    blockUI = blockUI || $injector.get('blockUI');\n  }\n\n  function stopBlockUI(config) {\n    if (blockUIConfig.autoBlock && (config && !config.$_noBlock && config.$_blocks)) {\n      injectBlockUI();\n      config.$_blocks.stop();\n    }\n  }\n\n  function error(rejection) {\n\n    try {\n      stopBlockUI(rejection.config);\n    } catch(ex) {\n      console.log('httpRequestError', ex);\n    }\n\n    return $q.reject(rejection);\n  }\n\n  return {\n    request: function(config) {\n\n      // Only block when autoBlock is enabled ...\n      // ... and the request doesn't match a cached template.\n\n      if (blockUIConfig.autoBlock &&\n        !(config.method == 'GET' && $templateCache.get(config.url))) {\n\n        // Don't block excluded requests\n\n        var result = blockUIConfig.requestFilter(config);\n\n        if (result === false) {\n          // Tag the config so we don't unblock this request\n          config.$_noBlock = true;\n        } else {\n\n          injectBlockUI();\n\n          config.$_blocks = blockUI.instances.locate(config);\n          config.$_blocks.start(result);\n        }\n      }\n\n      return config;\n    },\n\n    requestError: error,\n\n    response: function(response) {\n\n      // If the connection to the website goes down the response interceptor gets and error with \"cannot read property config of null\".\n      // https://github.com/McNull/angular-block-ui/issues/53\n\n      if(response) {\n        stopBlockUI(response.config);\n      }\n\n      return response;\n    },\n\n    responseError: error\n  };\n\n}]);\n\nblkUI.factory('blockUI', [\"blockUIConfig\", \"$timeout\", \"blockUIUtils\", \"$document\", function(blockUIConfig, $timeout, blockUIUtils, $document) {\n\n  var $body = $document.find('body');\n\n  function BlockUI(id) {\n\n    var self = this;\n\n    var state = {\n      id: id,\n      blockCount: 0,\n      message: blockUIConfig.message,\n      blocking: false\n    }, startPromise, doneCallbacks = [];\n\n    this._id = id;\n\n    this._refs = 0;\n\n    this.start = function(message) {\n\n      if(state.blockCount > 0) {\n        message = message || state.message || blockUIConfig.message;\n      } else {\n        message = message || blockUIConfig.message;\n      }\n\n      state.message = message;\n\n      state.blockCount++;\n\n      // Check if the focused element is part of the block scope\n\n      var $ae = angular.element($document[0].activeElement);\n\n      if($ae.length && blockUIUtils.isElementInBlockScope($ae, self)) {\n\n        // Let the active element lose focus and store a reference \n        // to restore focus when we're done (reset)\n\n        self._restoreFocus = $ae[0];\n\n        // https://github.com/McNull/angular-block-ui/issues/13\n        // http://stackoverflow.com/questions/22698058/apply-already-in-progress-error-when-using-typeahead-plugin-found-to-be-relate\n        // Queue the blur after any ng-blur expression.\n\n        $timeout(function() {\n          // Ensure we still need to blur\n          if(self._restoreFocus) {\n            self._restoreFocus.blur();\n          }\n        });\n      }\n\n      if (!startPromise) {\n        startPromise = $timeout(function() {\n          startPromise = null;\n          state.blocking = true;\n        }, blockUIConfig.delay);\n      }\n    };\n\n    this._cancelStartTimeout = function() {\n      if (startPromise) {\n        $timeout.cancel(startPromise);\n        startPromise = null;\n      }\n    };\n\n    this.stop = function() {\n      state.blockCount = Math.max(0, --state.blockCount);\n\n      if (state.blockCount === 0) {\n        self.reset(true);\n      }\n    };\n\n    this.message = function(value) {\n      state.message = value;\n    };\n\n    this.pattern = function(regexp) {\n      if (regexp !== undefined) {\n        self._pattern = regexp;\n      }\n\n      return self._pattern;\n    };\n\n    this.reset = function(executeCallbacks) {\n      \n      self._cancelStartTimeout();\n      state.blockCount = 0;\n      state.blocking = false;\n\n      // Restore the focus to the element that was active\n      // before the block start, but not if the user has \n      // focused something else while the block was active.\n\n      if(self._restoreFocus && \n         (!$document[0].activeElement || $document[0].activeElement === $body[0])) {\n        self._restoreFocus.focus();\n        self._restoreFocus = null;\n      }\n      \n      try {\n        if (executeCallbacks) {\n          angular.forEach(doneCallbacks, function(cb) {\n            cb();\n          });\n        }\n      } finally {\n        doneCallbacks.length = 0;\n      }\n    };\n\n    this.done = function(fn) {\n      doneCallbacks.push(fn);\n    };\n\n    this.state = function() {\n      return state;\n    };\n\n    this.addRef = function() {\n      self._refs += 1;\n    };\n\n    this.release = function() {\n      if(--self._refs <= 0) {\n        mainBlock.instances._destroy(self);\n      }\n    };\n  }\n\n  var instances = [];\n\n  instances.get = function(id) {\n\n    if(!isNaN(id)) {\n      throw new Error('BlockUI id cannot be a number');\n    }\n\n    var instance = instances[id];\n\n    if(!instance) {\n      // TODO: ensure no array instance trashing [xxx] -- current workaround: '_' + $scope.$id\n      instance = instances[id] = new BlockUI(id);\n      instances.push(instance);\n    }\n\n    return instance;\n  };\n\n  instances._destroy = function(idOrInstance) {\n    if (angular.isString(idOrInstance)) {\n      idOrInstance = instances[idOrInstance];\n    }\n\n    if (idOrInstance) {\n      idOrInstance.reset();\n\n      var i = blockUIUtils.indexOf(instances, idOrInstance);\n      instances.splice(i, 1);\n\n      delete instances[idOrInstance.state().id];\n    }\n  };\n  \n  instances.locate = function(request) {\n\n    var result = [];\n\n    // Add function wrappers that will be executed on every item\n    // in the array.\n    \n    blockUIUtils.forEachFnHook(result, 'start');\n    blockUIUtils.forEachFnHook(result, 'stop');\n\n    var i = instances.length;\n\n    while(i--) {\n      var instance = instances[i];\n      var pattern = instance._pattern;\n\n      if(pattern && pattern.test(request.url)) {\n        result.push(instance);\n      }\n    }\n\n    if(result.length === 0) {\n      result.push(mainBlock);\n    }\n\n    return result;\n  };\n\n  // Propagate the reset to all instances\n\n  blockUIUtils.forEachFnHook(instances, 'reset');\n\n  var mainBlock = instances.get('main');\n\n  mainBlock.addRef();\n  mainBlock.instances = instances;\n\n  return mainBlock;\n}]);\n\n\nblkUI.factory('blockUIUtils', function() {\n\n  var $ = angular.element;\n\n  var utils = {\n    buildRegExp: function(pattern) {\n      var match = pattern.match(/^\\/(.*)\\/([gim]*)$/), regExp;\n\n      if(match) {\n        regExp = new RegExp(match[1], match[2]);\n      } else {\n        throw Error('Incorrect regular expression format: ' + pattern);\n      }\n\n      return regExp;\n    },\n    forEachFn: function(arr, fnName, args) {\n      var i = arr.length;\n      while(i--) {\n        var t = arr[i];\n        t[fnName].apply(t, args);\n      }\n    },\n    forEachFnHook: function(arr, fnName) {\n      arr[fnName] = function() {\n        utils.forEachFn(this, fnName, arguments);\n      }\n    },\n    isElementInBlockScope: function($element, blockScope) {\n      var c = $element.inheritedData('block-ui');\n\n      while(c) {\n        if(c === blockScope) {\n          return true;\n        }\n\n        c = c._parent;\n      }\n\n      return false;\n    },\n    findElement: function ($element, predicateFn, traverse) {\n      var ret = null;\n\n      if (predicateFn($element)) {\n        ret = $element;\n      } else {\n\n        var $elements;\n\n        if (traverse) {\n          $elements = $element.parent();\n        } else {\n          $elements = $element.children();\n        }\n\n        var i = $elements.length;\n        while (!ret && i--) {\n          ret = utils.findElement($($elements[i]), predicateFn, traverse);\n        }\n      }\n\n      return ret;\n    },\n    indexOf: function(arr, obj, start) {\n//      if(Array.prototype.indexOf) {\n//        return arr.indexOf(obj, start);\n//      }\n\n      for (var i = (start || 0), j = arr.length; i < j; i++) {\n        if (arr[i] === obj) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  };\n\n  return utils;\n\n});\n// Automatically generated.\n// This file is already embedded in your main javascript output, there's no need to include this file\n// manually in the index.html. This file is only here for your debugging pleasures.\nangular.module('blockUI').run(['$templateCache', function($templateCache){\n  $templateCache.put('angular-block-ui/angular-block-ui.ng.html', '<div class=\\\"block-ui-overlay\\\"></div><div class=\\\"block-ui-message-container\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\"><div class=\\\"block-ui-message\\\" ng-class=\\\"$_blockUiMessageClass\\\">{{ state.message }}</div></div>');\n}]);\n})(angular);\nif (typeof module !== \"undefined\") module.exports = \"blockUI\";\n\n\n},{}],36:[function(require,module,exports){\nvar css = \"/*!\\n   angular-block-ui v0.2.0\\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\\n   License: MIT\\n*/\\n.block-ui {\\n  position: relative;\\n}\\nbody.block-ui {\\n  position: static;\\n}\\n.block-ui-main>.block-ui-container,\\nbody.block-ui>.block-ui-container {\\n  position: fixed;\\n}\\n.block-ui-container {\\n  position: absolute;\\n  z-index: 10000;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n  height: 0;\\n  overflow: hidden;\\n  opacity: 0;\\n  filter: alpha(opacity=00);\\n}\\n.block-ui-active>.block-ui-container {\\n  height: 100%;\\n  cursor: wait;\\n}\\n.block-ui-active .block-ui-active>.block-ui-container {\\n  height: 0;\\n}\\n.block-ui-visible>.block-ui-container {\\n  opacity: 1;\\n  filter: alpha(opacity=100);\\n}\\n.block-ui-overlay {\\n  width: 100%;\\n  height: 100%;\\n  opacity: .5;\\n  filter: alpha(opacity=50);\\n  background-color: #fff;\\n}\\n.block-ui-message-container {\\n  position: absolute;\\n  top: 35%;\\n  left: 0;\\n  right: 0;\\n  height: 0;\\n  text-align: center;\\n  z-index: 10001;\\n}\\n.block-ui-message {\\n  display: inline-block;\\n  text-align: left;\\n  background-color: #333;\\n  color: #f5f5f5;\\n  padding: 20px;\\n  border-radius: 4px;\\n  font-size: 20px;\\n  font-weight: 700;\\n  filter: alpha(opacity=100);\\n}\\n.block-ui-anim-fade>.block-ui-container {\\n  -webkit-transition: height 0s linear 200ms,opacity 200ms ease 0s;\\n  transition: height 0s linear 200ms,opacity 200ms ease 0s;\\n}\\n.block-ui-anim-fade.block-ui-active>.block-ui-container {\\n  -webkit-transition-delay: 0s;\\n  transition-delay: 0s;\\n}\\n\"; (require(\"browserify-css\").createStyle(css, { \"href\": \"node_modules\\\\angular-block-ui\\\\dist\\\\angular-block-ui.min.css\"})); module.exports = css;\n},{\"browserify-css\":41}],37:[function(require,module,exports){\n/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $sanitizeMinErr = angular.$$minErr('$sanitize');\n\n/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n\n/*\n * HTML Parser By Misko Hevery (misko@hevery.com)\n * based on:  HTML Parser By John Resig (ejohn.org)\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n *\n * // Use like so:\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n */\n\n\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string, however, since our parser is more strict than a typical browser\n *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a\n *   browser, won't make it through the sanitizer. The input may also contain SVG markup.\n *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and\n *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getInnerHtml()).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\nfunction $SanitizeProvider() {\n  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n    return function(html) {\n      var buf = [];\n      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n        return !/^unsafe/.test($$sanitizeUri(uri, isImage));\n      }));\n      return buf.join('');\n    };\n  }];\n}\n\nfunction sanitizeText(chars) {\n  var buf = [];\n  var writer = htmlSanitizeWriter(buf, angular.noop);\n  writer.chars(chars);\n  return buf.join('');\n}\n\n\n// Regular Expressions for parsing tags and attributes\nvar START_TAG_REGEXP =\n       /^<((?:[a-zA-Z])[\\w:-]*)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)\\s*(>?)/,\n  END_TAG_REGEXP = /^<\\/\\s*([\\w:-]+)[^>]*>/,\n  ATTR_REGEXP = /([\\w:-]+)(?:\\s*=\\s*(?:(?:\"((?:[^\"])*)\")|(?:'((?:[^'])*)')|([^>\\s]+)))?/g,\n  BEGIN_TAG_REGEXP = /^</,\n  BEGING_END_TAGE_REGEXP = /^<\\//,\n  COMMENT_REGEXP = /<!--(.*?)-->/g,\n  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,\n  CDATA_REGEXP = /<!\\[CDATA\\[(.*?)]]>/g,\n  SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n  // Match everything outside of normal chars and \" (quote character)\n  NON_ALPHANUMERIC_REGEXP = /([^\\#-~| |!])/g;\n\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\nvar voidElements = makeMap(\"area,br,col,hr,img,wbr\");\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\nvar optionalEndTagBlockElements = makeMap(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),\n    optionalEndTagInlineElements = makeMap(\"rp,rt\"),\n    optionalEndTagElements = angular.extend({},\n                                            optionalEndTagInlineElements,\n                                            optionalEndTagBlockElements);\n\n// Safe Block Elements - HTML5\nvar blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap(\"address,article,\" +\n        \"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,\" +\n        \"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul\"));\n\n// Inline Elements - HTML5\nvar inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap(\"a,abbr,acronym,b,\" +\n        \"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,\" +\n        \"samp,small,span,strike,strong,sub,sup,time,tt,u,var\"));\n\n// SVG Elements\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n// They can potentially allow for arbitrary javascript to be executed. See #11290\nvar svgElements = makeMap(\"circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,\" +\n        \"hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,\" +\n        \"radialGradient,rect,stop,svg,switch,text,title,tspan,use\");\n\n// Special Elements (can contain anything)\nvar specialElements = makeMap(\"script,style\");\n\nvar validElements = angular.extend({},\n                                   voidElements,\n                                   blockElements,\n                                   inlineElements,\n                                   optionalEndTagElements,\n                                   svgElements);\n\n//Attributes that have href and hence need to be sanitized\nvar uriAttrs = makeMap(\"background,cite,href,longdesc,src,usemap,xlink:href\");\n\nvar htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n    'valign,value,vspace,width');\n\n// SVG attributes (without \"id\" and \"name\" attributes)\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\nvar svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +\n    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\nvar validAttrs = angular.extend({},\n                                uriAttrs,\n                                svgAttrs,\n                                htmlAttrs);\n\nfunction makeMap(str, lowercaseKeys) {\n  var obj = {}, items = str.split(','), i;\n  for (i = 0; i < items.length; i++) {\n    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;\n  }\n  return obj;\n}\n\n\n/**\n * @example\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n * @param {string} html string\n * @param {object} handler\n */\nfunction htmlParser(html, handler) {\n  if (typeof html !== 'string') {\n    if (html === null || typeof html === 'undefined') {\n      html = '';\n    } else {\n      html = '' + html;\n    }\n  }\n  var index, chars, match, stack = [], last = html, text;\n  stack.last = function() { return stack[stack.length - 1]; };\n\n  while (html) {\n    text = '';\n    chars = true;\n\n    // Make sure we're not in a script or style element\n    if (!stack.last() || !specialElements[stack.last()]) {\n\n      // Comment\n      if (html.indexOf(\"<!--\") === 0) {\n        // comments containing -- are not allowed unless they terminate the comment\n        index = html.indexOf(\"--\", 4);\n\n        if (index >= 0 && html.lastIndexOf(\"-->\", index) === index) {\n          if (handler.comment) handler.comment(html.substring(4, index));\n          html = html.substring(index + 3);\n          chars = false;\n        }\n      // DOCTYPE\n      } else if (DOCTYPE_REGEXP.test(html)) {\n        match = html.match(DOCTYPE_REGEXP);\n\n        if (match) {\n          html = html.replace(match[0], '');\n          chars = false;\n        }\n      // end tag\n      } else if (BEGING_END_TAGE_REGEXP.test(html)) {\n        match = html.match(END_TAG_REGEXP);\n\n        if (match) {\n          html = html.substring(match[0].length);\n          match[0].replace(END_TAG_REGEXP, parseEndTag);\n          chars = false;\n        }\n\n      // start tag\n      } else if (BEGIN_TAG_REGEXP.test(html)) {\n        match = html.match(START_TAG_REGEXP);\n\n        if (match) {\n          // We only have a valid start-tag if there is a '>'.\n          if (match[4]) {\n            html = html.substring(match[0].length);\n            match[0].replace(START_TAG_REGEXP, parseStartTag);\n          }\n          chars = false;\n        } else {\n          // no ending tag found --- this piece should be encoded as an entity.\n          text += '<';\n          html = html.substring(1);\n        }\n      }\n\n      if (chars) {\n        index = html.indexOf(\"<\");\n\n        text += index < 0 ? html : html.substring(0, index);\n        html = index < 0 ? \"\" : html.substring(index);\n\n        if (handler.chars) handler.chars(decodeEntities(text));\n      }\n\n    } else {\n      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\\W\\w].\n      html = html.replace(new RegExp(\"([\\\\W\\\\w]*)<\\\\s*\\\\/\\\\s*\" + stack.last() + \"[^>]*>\", 'i'),\n        function(all, text) {\n          text = text.replace(COMMENT_REGEXP, \"$1\").replace(CDATA_REGEXP, \"$1\");\n\n          if (handler.chars) handler.chars(decodeEntities(text));\n\n          return \"\";\n      });\n\n      parseEndTag(\"\", stack.last());\n    }\n\n    if (html == last) {\n      throw $sanitizeMinErr('badparse', \"The sanitizer was unable to parse the following block \" +\n                                        \"of html: {0}\", html);\n    }\n    last = html;\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function parseStartTag(tag, tagName, rest, unary) {\n    tagName = angular.lowercase(tagName);\n    if (blockElements[tagName]) {\n      while (stack.last() && inlineElements[stack.last()]) {\n        parseEndTag(\"\", stack.last());\n      }\n    }\n\n    if (optionalEndTagElements[tagName] && stack.last() == tagName) {\n      parseEndTag(\"\", tagName);\n    }\n\n    unary = voidElements[tagName] || !!unary;\n\n    if (!unary) {\n      stack.push(tagName);\n    }\n\n    var attrs = {};\n\n    rest.replace(ATTR_REGEXP,\n      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {\n        var value = doubleQuotedValue\n          || singleQuotedValue\n          || unquotedValue\n          || '';\n\n        attrs[name] = decodeEntities(value);\n    });\n    if (handler.start) handler.start(tagName, attrs, unary);\n  }\n\n  function parseEndTag(tag, tagName) {\n    var pos = 0, i;\n    tagName = angular.lowercase(tagName);\n    if (tagName) {\n      // Find the closest opened tag of the same type\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos] == tagName) break;\n      }\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (i = stack.length - 1; i >= pos; i--)\n        if (handler.end) handler.end(stack[i]);\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n    }\n  }\n}\n\nvar hiddenPre=document.createElement(\"pre\");\n/**\n * decodes all entities into regular string\n * @param value\n * @returns {string} A string with decoded entities.\n */\nfunction decodeEntities(value) {\n  if (!value) { return ''; }\n\n  hiddenPre.innerHTML = value.replace(/</g,\"&lt;\");\n  // innerText depends on styling as it doesn't display hidden elements.\n  // Therefore, it's better to use textContent not to cause unnecessary reflows.\n  return hiddenPre.textContent;\n}\n\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n * @returns {string} escaped text\n */\nfunction encodeEntities(value) {\n  return value.\n    replace(/&/g, '&amp;').\n    replace(SURROGATE_PAIR_REGEXP, function(value) {\n      var hi = value.charCodeAt(0);\n      var low = value.charCodeAt(1);\n      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n    }).\n    replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n      return '&#' + value.charCodeAt(0) + ';';\n    }).\n    replace(/</g, '&lt;').\n    replace(/>/g, '&gt;');\n}\n\n/**\n * create an HTML/XML writer which writes to buffer\n * @param {Array} buf use buf.jain('') to get out sanitized html string\n * @returns {object} in the form of {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * }\n */\nfunction htmlSanitizeWriter(buf, uriValidator) {\n  var ignore = false;\n  var out = angular.bind(buf, buf.push);\n  return {\n    start: function(tag, attrs, unary) {\n      tag = angular.lowercase(tag);\n      if (!ignore && specialElements[tag]) {\n        ignore = tag;\n      }\n      if (!ignore && validElements[tag] === true) {\n        out('<');\n        out(tag);\n        angular.forEach(attrs, function(value, key) {\n          var lkey=angular.lowercase(key);\n          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n          if (validAttrs[lkey] === true &&\n            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n            out(' ');\n            out(key);\n            out('=\"');\n            out(encodeEntities(value));\n            out('\"');\n          }\n        });\n        out(unary ? '/>' : '>');\n      }\n    },\n    end: function(tag) {\n        tag = angular.lowercase(tag);\n        if (!ignore && validElements[tag] === true) {\n          out('</');\n          out(tag);\n          out('>');\n        }\n        if (tag == ignore) {\n          ignore = false;\n        }\n      },\n    chars: function(chars) {\n        if (!ignore) {\n          out(encodeEntities(chars));\n        }\n      }\n  };\n}\n\n\n// define ngSanitize module and register $sanitize service\nangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n/* global sanitizeText: false */\n\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.\n * @returns {string} Html-linkified text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n       <script>\n         angular.module('linkyExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', function($scope) {\n             $scope.snippet =\n               'Pretty text with some links:\\n'+\n               'http://angularjs.org/,\\n'+\n               'mailto:us@somewhere.org,\\n'+\n               'another@somewhere.org,\\n'+\n               'and one more: ftp://127.0.0.1/.';\n             $scope.snippetWithTarget = 'http://angularjs.org/';\n           }]);\n       </script>\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Filter</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithTarget | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n     </file>\n   </example>\n */\nangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n  var LINKY_URL_REGEXP =\n        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n      MAILTO_REGEXP = /^mailto:/i;\n\n  return function(text, target) {\n    if (!text) return text;\n    var match;\n    var raw = text;\n    var html = [];\n    var url;\n    var i;\n    while ((match = raw.match(LINKY_URL_REGEXP))) {\n      // We can not end in these as they are sometimes found at the end of the sentence\n      url = match[0];\n      // if we did not match ftp/http/www/mailto then assume mailto\n      if (!match[2] && !match[4]) {\n        url = (match[3] ? 'http://' : 'mailto:') + url;\n      }\n      i = match.index;\n      addText(raw.substr(0, i));\n      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n      raw = raw.substring(i + match[0].length);\n    }\n    addText(raw);\n    return $sanitize(html.join(''));\n\n    function addText(text) {\n      if (!text) {\n        return;\n      }\n      html.push(sanitizeText(text));\n    }\n\n    function addLink(url, text) {\n      html.push('<a ');\n      if (angular.isDefined(target)) {\n        html.push('target=\"',\n                  target,\n                  '\" ');\n      }\n      html.push('href=\"',\n                url.replace(/\"/g, '&quot;'),\n                '\">');\n      addText(text);\n      html.push('</a>');\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n\n},{}],38:[function(require,module,exports){\nrequire('./angular-sanitize');\nmodule.exports = 'ngSanitize';\n\n},{\"./angular-sanitize\":37}],39:[function(require,module,exports){\n/*!\n * angular-translate - v2.10.0 - 2016-02-28\n * \n * Copyright (c) 2016 The angular-translate team, Pascal Precht; Licensed MIT\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define([], function () {\n      return (factory());\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    factory();\n  }\n}(this, function () {\n\n/**\n * @ngdoc overview\n * @name pascalprecht.translate\n *\n * @description\n * The main module which holds everything together.\n */\nangular.module('pascalprecht.translate', ['ng'])\n  .run(runTranslate);\n\nfunction runTranslate($translate) {\n\n  'use strict';\n\n  var key = $translate.storageKey(),\n    storage = $translate.storage();\n\n  var fallbackFromIncorrectStorageValue = function () {\n    var preferred = $translate.preferredLanguage();\n    if (angular.isString(preferred)) {\n      $translate.use(preferred);\n      // $translate.use() will also remember the language.\n      // So, we don't need to call storage.put() here.\n    } else {\n      storage.put(key, $translate.use());\n    }\n  };\n\n  fallbackFromIncorrectStorageValue.displayName = 'fallbackFromIncorrectStorageValue';\n\n  if (storage) {\n    if (!storage.get(key)) {\n      fallbackFromIncorrectStorageValue();\n    } else {\n      $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);\n    }\n  } else if (angular.isString($translate.preferredLanguage())) {\n    $translate.use($translate.preferredLanguage());\n  }\n}\nrunTranslate.$inject = ['$translate'];\n\nrunTranslate.displayName = 'runTranslate';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateSanitizationProvider\n *\n * @description\n *\n * Configurations for $translateSanitization\n */\nangular.module('pascalprecht.translate').provider('$translateSanitization', $translateSanitizationProvider);\n\nfunction $translateSanitizationProvider () {\n\n  'use strict';\n\n  var $sanitize,\n      currentStrategy = null, // TODO change to either 'sanitize', 'escape' or ['sanitize', 'escapeParameters'] in 3.0.\n      hasConfiguredStrategy = false,\n      hasShownNoStrategyConfiguredWarning = false,\n      strategies;\n\n  /**\n   * Definition of a sanitization strategy function\n   * @callback StrategyFunction\n   * @param {string|object} value - value to be sanitized (either a string or an interpolated value map)\n   * @param {string} mode - either 'text' for a string (translation) or 'params' for the interpolated params\n   * @return {string|object}\n   */\n\n  /**\n   * @ngdoc property\n   * @name strategies\n   * @propertyOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Following strategies are built-in:\n   * <dl>\n   *   <dt>sanitize</dt>\n   *   <dd>Sanitizes HTML in the translation text using $sanitize</dd>\n   *   <dt>escape</dt>\n   *   <dd>Escapes HTML in the translation</dd>\n   *   <dt>sanitizeParameters</dt>\n   *   <dd>Sanitizes HTML in the values of the interpolation parameters using $sanitize</dd>\n   *   <dt>escapeParameters</dt>\n   *   <dd>Escapes HTML in the values of the interpolation parameters</dd>\n   *   <dt>escaped</dt>\n   *   <dd>Support legacy strategy name 'escaped' for backwards compatibility (will be removed in 3.0)</dd>\n   * </dl>\n   *\n   */\n\n  strategies = {\n    sanitize: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlSanitizeValue(value);\n      }\n      return value;\n    },\n    escape: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlEscapeValue(value);\n      }\n      return value;\n    },\n    sanitizeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlSanitizeValue);\n      }\n      return value;\n    },\n    escapeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlEscapeValue);\n      }\n      return value;\n    }\n  };\n  // Support legacy strategy name 'escaped' for backwards compatibility.\n  // TODO should be removed in 3.0\n  strategies.escaped = strategies.escapeParameters;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#addStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Adds a sanitization strategy to the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @param {StrategyFunction} strategyFunction - strategy function\n   * @returns {object} this\n   */\n  this.addStrategy = function (strategyName, strategyFunction) {\n    strategies[strategyName] = strategyFunction;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#removeStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Removes a sanitization strategy from the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @returns {object} this\n   */\n  this.removeStrategy = function (strategyName) {\n    delete strategies[strategyName];\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#useStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n   *\n   * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n   * @returns {object} this\n   */\n  this.useStrategy = function (strategy) {\n    hasConfiguredStrategy = true;\n    currentStrategy = strategy;\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translateSanitization\n   * @requires $injector\n   * @requires $log\n   *\n   * @description\n   * Sanitizes interpolation parameters and translated texts.\n   *\n   */\n  this.$get = ['$injector', '$log', function ($injector, $log) {\n\n    var cachedStrategyMap = {};\n\n    var applyStrategies = function (value, mode, selectedStrategies) {\n      angular.forEach(selectedStrategies, function (selectedStrategy) {\n        if (angular.isFunction(selectedStrategy)) {\n          value = selectedStrategy(value, mode);\n        } else if (angular.isFunction(strategies[selectedStrategy])) {\n          value = strategies[selectedStrategy](value, mode);\n        } else if (angular.isString(strategies[selectedStrategy])) {\n          if (!cachedStrategyMap[strategies[selectedStrategy]]) {\n            try {\n              cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);\n            } catch (e) {\n              cachedStrategyMap[strategies[selectedStrategy]] = function() {};\n              throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n            }\n          }\n          value = cachedStrategyMap[strategies[selectedStrategy]](value, mode);\n        } else {\n          throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n        }\n      });\n      return value;\n    };\n\n    // TODO: should be removed in 3.0\n    var showNoStrategyConfiguredWarning = function () {\n      if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {\n        $log.warn('pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.');\n        hasShownNoStrategyConfiguredWarning = true;\n      }\n    };\n\n    if ($injector.has('$sanitize')) {\n      $sanitize = $injector.get('$sanitize');\n    }\n\n    return {\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#useStrategy\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n       *\n       * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n       */\n      useStrategy: (function (self) {\n        return function (strategy) {\n          self.useStrategy(strategy);\n        };\n      })(this),\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#sanitize\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Sanitizes a value.\n       *\n       * @param {string|object} value The value which should be sanitized.\n       * @param {string} mode The current sanitization mode, either 'params' or 'text'.\n       * @param {string|StrategyFunction|array} [strategy] Optional custom strategy which should be used instead of the currently selected strategy.\n       * @returns {string|object} sanitized value\n       */\n      sanitize: function (value, mode, strategy) {\n        if (!currentStrategy) {\n          showNoStrategyConfiguredWarning();\n        }\n\n        if (arguments.length < 3) {\n          strategy = currentStrategy;\n        }\n\n        if (!strategy) {\n          return value;\n        }\n\n        var selectedStrategies = angular.isArray(strategy) ? strategy : [strategy];\n        return applyStrategies(value, mode, selectedStrategies);\n      }\n    };\n  }];\n\n  var htmlEscapeValue = function (value) {\n    var element = angular.element('<div></div>');\n    element.text(value); // not chainable, see #1044\n    return element.html();\n  };\n\n  var htmlSanitizeValue = function (value) {\n    if (!$sanitize) {\n      throw new Error('pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as \\'escape\\'.');\n    }\n    return $sanitize(value);\n  };\n\n  var mapInterpolationParameters = function (value, iteratee, stack) {\n    if (angular.isObject(value)) {\n      var result = angular.isArray(value) ? [] : {};\n\n      if (!stack) {\n        stack = [];\n      } else {\n        if (stack.indexOf(value) > -1) {\n          throw new Error('pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object');\n        }\n      }\n\n      stack.push(value);\n      angular.forEach(value, function (propertyValue, propertyKey) {\n        result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack);\n      });\n      stack.splice(-1, 1); // remove last\n\n      return result;\n    } else if (angular.isNumber(value)) {\n      return value;\n    } else {\n      return iteratee(value);\n    }\n  };\n}\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateProvider\n * @description\n *\n * $translateProvider allows developers to register translation-tables, asynchronous loaders\n * and similar to configure translation behavior directly inside of a module.\n *\n */\nangular.module('pascalprecht.translate')\n.constant('pascalprechtTranslateOverrider', {})\n.provider('$translate', $translate);\n\nfunction $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {\n\n  'use strict';\n\n  var $translationTable = {},\n      $preferredLanguage,\n      $availableLanguageKeys = [],\n      $languageKeyAliases,\n      $fallbackLanguage,\n      $fallbackWasString,\n      $uses,\n      $nextLang,\n      $storageFactory,\n      $storageKey = $STORAGE_KEY,\n      $storagePrefix,\n      $missingTranslationHandlerFactory,\n      $interpolationFactory,\n      $interpolatorFactories = [],\n      $loaderFactory,\n      $cloakClassName = 'translate-cloak',\n      $loaderOptions,\n      $notFoundIndicatorLeft,\n      $notFoundIndicatorRight,\n      $postCompilingEnabled = false,\n      $forceAsyncReloadEnabled = false,\n      $nestedObjectDelimeter = '.',\n      $isReady = false,\n      loaderCache,\n      directivePriority = 0,\n      statefulFilter = true,\n      uniformLanguageTagResolver = 'default',\n      languageTagResolver = {\n        'default': function (tag) {\n          return (tag || '').split('-').join('_');\n        },\n        java: function (tag) {\n          var temp = (tag || '').split('-').join('_');\n          var parts = temp.split('_');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '_' + parts[1].toUpperCase()) : temp;\n        },\n        bcp47: function (tag) {\n          var temp = (tag || '').split('_').join('-');\n          var parts = temp.split('-');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '-' + parts[1].toUpperCase()) : temp;\n        }\n      };\n\n  var version = '2.10.0';\n\n  // tries to determine the browsers language\n  var getFirstBrowserLanguage = function () {\n\n    // internal purpose only\n    if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {\n      return pascalprechtTranslateOverrider.getLocale();\n    }\n\n    var nav = $windowProvider.$get().navigator,\n        browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],\n        i,\n        language;\n\n    // support for HTML 5.1 \"navigator.languages\"\n    if (angular.isArray(nav.languages)) {\n      for (i = 0; i < nav.languages.length; i++) {\n        language = nav.languages[i];\n        if (language && language.length) {\n          return language;\n        }\n      }\n    }\n\n    // support for other well known properties in browsers\n    for (i = 0; i < browserLanguagePropertyKeys.length; i++) {\n      language = nav[browserLanguagePropertyKeys[i]];\n      if (language && language.length) {\n        return language;\n      }\n    }\n\n    return null;\n  };\n  getFirstBrowserLanguage.displayName = 'angular-translate/service: getFirstBrowserLanguage';\n\n  // tries to determine the browsers locale\n  var getLocale = function () {\n    var locale = getFirstBrowserLanguage() || '';\n    if (languageTagResolver[uniformLanguageTagResolver]) {\n      locale = languageTagResolver[uniformLanguageTagResolver](locale);\n    }\n    return locale;\n  };\n  getLocale.displayName = 'angular-translate/service: getLocale';\n\n  /**\n   * @name indexOf\n   * @private\n   *\n   * @description\n   * indexOf polyfill. Kinda sorta.\n   *\n   * @param {array} array Array to search in.\n   * @param {string} searchElement Element to search for.\n   *\n   * @returns {int} Index of search element.\n   */\n  var indexOf = function(array, searchElement) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === searchElement) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  var negotiateLocale = function (preferred) {\n    if(!preferred) {\n      return;\n    }\n\n    var avail = [],\n        locale = angular.lowercase(preferred),\n        i = 0,\n        n = $availableLanguageKeys.length;\n\n    for (; i < n; i++) {\n      avail.push(angular.lowercase($availableLanguageKeys[i]));\n    }\n\n    // Check for an exact match in our list of available keys\n    if (indexOf(avail, locale) > -1) {\n      return preferred;\n    }\n\n    if ($languageKeyAliases) {\n      var alias;\n      for (var langKeyAlias in $languageKeyAliases) {\n        var hasWildcardKey = false;\n        var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) &&\n          angular.lowercase(langKeyAlias) === angular.lowercase(preferred);\n\n        if (langKeyAlias.slice(-1) === '*') {\n          hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length-1);\n        }\n        if (hasExactKey || hasWildcardKey) {\n          alias = $languageKeyAliases[langKeyAlias];\n          if (indexOf(avail, angular.lowercase(alias)) > -1) {\n            return alias;\n          }\n        }\n      }\n    }\n\n    // Check for a language code without region\n    var parts = preferred.split('_');\n\n    if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {\n      return parts[0];\n    }\n\n    // If everything fails, return undefined.\n    return;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translations\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a new translation table for specific language key.\n   *\n   * To register a translation table for specific language, pass a defined language\n   * key as first parameter.\n   *\n   * <pre>\n   *  // register translation table for language: 'de_DE'\n   *  $translateProvider.translations('de_DE', {\n   *    'GREETING': 'Hallo Welt!'\n   *  });\n   *\n   *  // register another one\n   *  $translateProvider.translations('en_US', {\n   *    'GREETING': 'Hello world!'\n   *  });\n   * </pre>\n   *\n   * When registering multiple translation tables for for the same language key,\n   * the actual translation table gets extended. This allows you to define module\n   * specific translation which only get added, once a specific module is loaded in\n   * your app.\n   *\n   * Invoking this method with no arguments returns the translation table which was\n   * registered with no language key. Invoking it with a language key returns the\n   * related translation table.\n   *\n   * @param {string} key A language key.\n   * @param {object} translationTable A plain old JavaScript object that represents a translation table.\n   *\n   */\n  var translations = function (langKey, translationTable) {\n\n    if (!langKey && !translationTable) {\n      return $translationTable;\n    }\n\n    if (langKey && !translationTable) {\n      if (angular.isString(langKey)) {\n        return $translationTable[langKey];\n      }\n    } else {\n      if (!angular.isObject($translationTable[langKey])) {\n        $translationTable[langKey] = {};\n      }\n      angular.extend($translationTable[langKey], flatObject(translationTable));\n    }\n    return this;\n  };\n\n  this.translations = translations;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#cloakClassName\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the class name for `translate-cloak` directive.\n   * Default class name is `translate-cloak`.\n   *\n   * @param {string} name translate-cloak class name\n   */\n  this.cloakClassName = function (name) {\n    if (!name) {\n      return $cloakClassName;\n    }\n    $cloakClassName = name;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#nestedObjectDelimeter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the delimiter for namespaced translations.\n   * Default delimiter is `.`.\n   *\n   * @param {string} delimiter namespace separator\n   */\n  this.nestedObjectDelimeter = function (delimiter) {\n    if (!delimiter) {\n      return $nestedObjectDelimeter;\n    }\n    $nestedObjectDelimeter = delimiter;\n    return this;\n  };\n\n  /**\n   * @name flatObject\n   * @private\n   *\n   * @description\n   * Flats an object. This function is used to flatten given translation data with\n   * namespaces, so they are later accessible via dot notation.\n   */\n  var flatObject = function (data, path, result, prevKey) {\n    var key, keyWithPath, keyWithShortPath, val;\n\n    if (!path) {\n      path = [];\n    }\n    if (!result) {\n      result = {};\n    }\n    for (key in data) {\n      if (!Object.prototype.hasOwnProperty.call(data, key)) {\n        continue;\n      }\n      val = data[key];\n      if (angular.isObject(val)) {\n        flatObject(val, path.concat(key), result, key);\n      } else {\n        keyWithPath = path.length ? ('' + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key) : key;\n        if(path.length && key === prevKey){\n          // Create shortcut path (foo.bar == foo.bar.bar)\n          keyWithShortPath = '' + path.join($nestedObjectDelimeter);\n          // Link it to original path\n          result[keyWithShortPath] = '@:' + keyWithPath;\n        }\n        result[keyWithPath] = val;\n      }\n    }\n    return result;\n  };\n  flatObject.displayName = 'flatObject';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#addInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Adds interpolation services to angular-translate, so it can manage them.\n   *\n   * @param {object} factory Interpolation service factory\n   */\n  this.addInterpolation = function (factory) {\n    $interpolatorFactories.push(factory);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMessageFormatInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use interpolation functionality of messageformat.js.\n   * This is useful when having high level pluralization and gender selection.\n   */\n  this.useMessageFormatInterpolation = function () {\n    return this.useInterpolation('$translateMessageFormatInterpolation');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which interpolation style to use as default, application-wide.\n   * Simply pass a factory/service name. The interpolation service has to implement\n   * the correct interface.\n   *\n   * @param {string} factory Interpolation service name.\n   */\n  this.useInterpolation = function (factory) {\n    $interpolationFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useSanitizeStrategy\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Simply sets a sanitation strategy type.\n   *\n   * @param {string} value Strategy type.\n   */\n  this.useSanitizeValueStrategy = function (value) {\n    $translateSanitizationProvider.useStrategy(value);\n    return this;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#preferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use for translation\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **prefer**.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.preferredLanguage = function(langKey) {\n    if (langKey) {\n      setupPreferredLanguage(langKey);\n      return this;\n    }\n    return $preferredLanguage;\n  };\n  var setupPreferredLanguage = function (langKey) {\n    if (langKey) {\n      $preferredLanguage = langKey;\n    }\n    return $preferredLanguage;\n  };\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicator\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found. E.g. when\n   * setting the indicator as 'X' and one tries to translate a translation id\n   * called `NOT_FOUND`, this will result in `X NOT_FOUND X`.\n   *\n   * Internally this methods sets a left indicator and a right indicator using\n   * `$translateProvider.translationNotFoundIndicatorLeft()` and\n   * `$translateProvider.translationNotFoundIndicatorRight()`.\n   *\n   * **Note**: These methods automatically add a whitespace between the indicators\n   * and the translation id.\n   *\n   * @param {string} indicator An indicator, could be any string.\n   */\n  this.translationNotFoundIndicator = function (indicator) {\n    this.translationNotFoundIndicatorLeft(indicator);\n    this.translationNotFoundIndicatorRight(indicator);\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found left to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorLeft = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorLeft;\n    }\n    $notFoundIndicatorLeft = indicator;\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found right to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorRight = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorRight;\n    }\n    $notFoundIndicatorRight = indicator;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#fallbackLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use when missing translations\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **fallback**.\n   *\n   * @param {string||array} langKey A language key.\n   *\n   */\n  this.fallbackLanguage = function (langKey) {\n    fallbackStack(langKey);\n    return this;\n  };\n\n  var fallbackStack = function (langKey) {\n    if (langKey) {\n      if (angular.isString(langKey)) {\n        $fallbackWasString = true;\n        $fallbackLanguage = [ langKey ];\n      } else if (angular.isArray(langKey)) {\n        $fallbackWasString = false;\n        $fallbackLanguage = langKey;\n      }\n      if (angular.isString($preferredLanguage)  && indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n        $fallbackLanguage.push($preferredLanguage);\n      }\n\n      return this;\n    } else {\n      if ($fallbackWasString) {\n        return $fallbackLanguage[0];\n      } else {\n        return $fallbackLanguage;\n      }\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#use\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Set which translation table to use for translation by given language key. When\n   * trying to 'use' a language which isn't provided, it'll throw an error.\n   *\n   * You actually don't have to use this method since `$translateProvider#preferredLanguage`\n   * does the job too.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.use = function (langKey) {\n    if (langKey) {\n      if (!$translationTable[langKey] && (!$loaderFactory)) {\n        // only throw an error, when not loading translation data asynchronously\n        throw new Error('$translateProvider couldn\\'t find translationTable for langKey: \\'' + langKey + '\\'');\n      }\n      $uses = langKey;\n      return this;\n    }\n    return $uses;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storageKey\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which key must represent the choosed language by a user in the storage.\n   *\n   * @param {string} key A key for the storage.\n   */\n  var storageKey = function(key) {\n    if (!key) {\n      if ($storagePrefix) {\n        return $storagePrefix + $storageKey;\n      }\n      return $storageKey;\n    }\n    $storageKey = key;\n    return this;\n  };\n\n  this.storageKey = storageKey;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useUrlLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateUrlLoader` extension service as loader.\n   *\n   * @param {string} url Url\n   * @param {Object=} options Optional configuration object\n   */\n  this.useUrlLoader = function (url, options) {\n    return this.useLoader('$translateUrlLoader', angular.extend({ url: url }, options));\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStaticFilesLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateStaticFilesLoader` extension service as loader.\n   *\n   * @param {Object=} options Optional configuration object\n   */\n  this.useStaticFilesLoader = function (options) {\n    return this.useLoader('$translateStaticFilesLoader', options);\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use any other service as loader.\n   *\n   * @param {string} loaderFactory Factory name to use\n   * @param {Object=} options Optional configuration object\n   */\n  this.useLoader = function (loaderFactory, options) {\n    $loaderFactory = loaderFactory;\n    $loaderOptions = options || {};\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLocalStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateLocalStorage` service as storage layer.\n   *\n   */\n  this.useLocalStorage = function () {\n    return this.useStorage('$translateLocalStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useCookieStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateCookieStorage` service as storage layer.\n   */\n  this.useCookieStorage = function () {\n    return this.useStorage('$translateCookieStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use custom service as storage layer.\n   */\n  this.useStorage = function (storageFactory) {\n    $storageFactory = storageFactory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storagePrefix\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets prefix for storage key.\n   *\n   * @param {string} prefix Storage key prefix\n   */\n  this.storagePrefix = function (prefix) {\n    if (!prefix) {\n      return prefix;\n    }\n    $storagePrefix = prefix;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandlerLog\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use built-in log handler when trying to translate\n   * a translation Id which doesn't exist.\n   *\n   * This is actually a shortcut method for `useMissingTranslationHandler()`.\n   *\n   */\n  this.useMissingTranslationHandlerLog = function () {\n    return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandler\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Expects a factory name which later gets instantiated with `$injector`.\n   * This method can be used to tell angular-translate to use a custom\n   * missingTranslationHandler. Just build a factory which returns a function\n   * and expects a translation id as argument.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.useMissingTranslationHandler('customHandler');\n   *  });\n   *\n   *  app.factory('customHandler', function (dep1, dep2) {\n   *    return function (translationId) {\n   *      // something with translationId and dep1 and dep2\n   *    };\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.useMissingTranslationHandler = function (factory) {\n    $missingTranslationHandlerFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#usePostCompiling\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If post compiling is enabled, all translated values will be processed\n   * again with AngularJS' $compile.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.usePostCompiling(true);\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.usePostCompiling = function (value) {\n    $postCompilingEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#forceAsyncReload\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If force async reload is enabled, async loader will always be called\n   * even if $translationTable already contains the language key, adding\n   * possible new entries to the $translationTable.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.forceAsyncReload(true);\n   *  });\n   * </pre>\n   *\n   * @param {boolean} value - valid values are true or false\n   */\n  this.forceAsyncReload = function (value) {\n    $forceAsyncReloadEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#uniformLanguageTag\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which language tag should be used as a result when determining\n   * the current browser language.\n   *\n   * This setting must be set before invoking {@link pascalprecht.translate.$translateProvider#methods_determinePreferredLanguage determinePreferredLanguage()}.\n   *\n   * <pre>\n   * $translateProvider\n   *   .uniformLanguageTag('bcp47')\n   *   .determinePreferredLanguage()\n   * </pre>\n   *\n   * The resolver currently supports:\n   * * default\n   *     (traditionally: hyphens will be converted into underscores, i.e. en-US => en_US)\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_us\n   * * java\n   *     like default, but the second part will be always in uppercase\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_US\n   * * BCP 47 (RFC 4646 & 4647)\n   *     en-US => en-US\n   *     en_US => en-US\n   *     en-us => en-US\n   *\n   * See also:\n   * * http://en.wikipedia.org/wiki/IETF_language_tag\n   * * http://www.w3.org/International/core/langtags/\n   * * http://tools.ietf.org/html/bcp47\n   *\n   * @param {string|object} options - options (or standard)\n   * @param {string} options.standard - valid values are 'default', 'bcp47', 'java'\n   */\n  this.uniformLanguageTag = function (options) {\n\n    if (!options) {\n      options = {};\n    } else if (angular.isString(options)) {\n      options = {\n        standard: options\n      };\n    }\n\n    uniformLanguageTagResolver = options.standard;\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#determinePreferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to try to determine on its own which language key\n   * to set as preferred language. When `fn` is given, angular-translate uses it\n   * to determine a language key, otherwise it uses the built-in `getLocale()`\n   * method.\n   *\n   * The `getLocale()` returns a language key in the format `[lang]_[country]` or\n   * `[lang]` depending on what the browser provides.\n   *\n   * Use this method at your own risk, since not all browsers return a valid\n   * locale (see {@link pascalprecht.translate.$translateProvider#methods_uniformLanguageTag uniformLanguageTag()}).\n   *\n   * @param {Function=} fn Function to determine a browser's locale\n   */\n  this.determinePreferredLanguage = function (fn) {\n\n    var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();\n\n    if (!$availableLanguageKeys.length) {\n      $preferredLanguage = locale;\n    } else {\n      $preferredLanguage = negotiateLocale(locale) || locale;\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#registerAvailableLanguageKeys\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a set of language keys the app will work with. Use this method in\n   * combination with\n   * {@link pascalprecht.translate.$translateProvider#determinePreferredLanguage determinePreferredLanguage}.\n   * When available languages keys are registered, angular-translate\n   * tries to find the best fitting language key depending on the browsers locale,\n   * considering your language key convention.\n   *\n   * @param {object} languageKeys Array of language keys the your app will use\n   * @param {object=} aliases Alias map.\n   */\n  this.registerAvailableLanguageKeys = function (languageKeys, aliases) {\n    if (languageKeys) {\n      $availableLanguageKeys = languageKeys;\n      if (aliases) {\n        $languageKeyAliases = aliases;\n      }\n      return this;\n    }\n    return $availableLanguageKeys;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoaderCache\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a cache for internal $http based loaders.\n   * {@link pascalprecht.translate.$translationCache $translationCache}.\n   * When false the cache will be disabled (default). When true or undefined\n   * the cache will be a default (see $cacheFactory). When an object it will\n   * be treat as a cache object itself: the usage is $http({cache: cache})\n   *\n   * @param {object} cache boolean, string or cache-object\n   */\n  this.useLoaderCache = function (cache) {\n    if (cache === false) {\n      // disable cache\n      loaderCache = undefined;\n    } else if (cache === true) {\n      // enable cache using AJS defaults\n      loaderCache = true;\n    } else if (typeof(cache) === 'undefined') {\n      // enable cache using default\n      loaderCache = '$translationCache';\n    } else if (cache) {\n      // enable cache using given one (see $cacheFactory)\n      loaderCache = cache;\n    }\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#directivePriority\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets the default priority of the translate directive. The standard value is `0`.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {number} priority for the translate-directive\n   */\n  this.directivePriority = function (priority) {\n    if (priority === undefined) {\n      // getter\n      return directivePriority;\n    } else {\n      // setter with chaining\n      directivePriority = priority;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#statefulFilter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Since AngularJS 1.3, filters which are not stateless (depending at the scope)\n   * have to explicit define this behavior.\n   * Sets whether the translate filter should be stateful or stateless. The standard value is `true`\n   * meaning being stateful.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {boolean} state - defines the state of the filter\n   */\n  this.statefulFilter = function (state) {\n    if (state === undefined) {\n      // getter\n      return statefulFilter;\n    } else {\n      // setter with chaining\n      statefulFilter = state;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translate\n   * @requires $interpolate\n   * @requires $log\n   * @requires $rootScope\n   * @requires $q\n   *\n   * @description\n   * The `$translate` service is the actual core of angular-translate. It expects a translation id\n   * and optional interpolate parameters to translate contents.\n   *\n   * <pre>\n   *  $translate('HEADLINE_TEXT').then(function (translation) {\n   *    $scope.translatedText = translation;\n   *  });\n   * </pre>\n   *\n   * @param {string|array} translationId A token which represents a translation id\n   *                                     This can be optionally an array of translation ids which\n   *                                     results that the function returns an object where each key\n   *                                     is the translation id and the value the translation.\n   * @param {object=} interpolateParams An object hash for dynamic values\n   * @param {string} interpolationId The id of the interpolation to use\n   * @param {string} forceLanguage A language to be used instead of the current language\n   * @returns {object} promise\n   */\n  this.$get = [\n    '$log',\n    '$injector',\n    '$rootScope',\n    '$q',\n    function ($log, $injector, $rootScope, $q) {\n\n      var Storage,\n          defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),\n          pendingLoader = false,\n          interpolatorHashMap = {},\n          langPromises = {},\n          fallbackIndex,\n          startFallbackIteration;\n\n      var $translate = function (translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage) {\n\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          // Inspired by Q.allSettled by Kris Kowal\n          // https://github.com/kriskowal/q/blob/b0fa72980717dc202ffc3cbf03b936e10ebbb9d7/q.js#L1553-1563\n          // This transforms all promises regardless resolved or rejected\n          var translateAll = function (translationIds) {\n            var results = {}; // storing the actual results\n            var promises = []; // promises to wait for\n            // Wraps the promise a) being always resolved and b) storing the link id->value\n            var translate = function (translationId) {\n              var deferred = $q.defer();\n              var regardless = function (value) {\n                results[translationId] = value;\n                deferred.resolve([translationId, value]);\n              };\n              // we don't care whether the promise was resolved or rejected; just store the values\n              $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage).then(regardless, regardless);\n              return deferred.promise;\n            };\n            for (var i = 0, c = translationIds.length; i < c; i++) {\n              promises.push(translate(translationIds[i]));\n            }\n            // wait for all (including storing to results)\n            return $q.all(promises).then(function () {\n              // return the results\n              return results;\n            });\n          };\n          return translateAll(translationId);\n        }\n\n        var deferred = $q.defer();\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var promiseToWaitFor = (function () {\n          var promise = $preferredLanguage ?\n            langPromises[$preferredLanguage] :\n            langPromises[uses];\n\n          fallbackIndex = 0;\n\n          if ($storageFactory && !promise) {\n            // looks like there's no pending promise for $preferredLanguage or\n            // $uses. Maybe there's one pending for a language that comes from\n            // storage.\n            var langKey = Storage.get($storageKey);\n            promise = langPromises[langKey];\n\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n                var index = indexOf($fallbackLanguage, langKey);\n                // maybe the language from storage is also defined as fallback language\n                // we increase the fallback language index to not search in that language\n                // as fallback, since it's probably the first used language\n                // in that case the index starts after the first element\n                fallbackIndex = (index === 0) ? 1 : 0;\n\n                // but we can make sure to ALWAYS fallback to preferred language at least\n                if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n                  $fallbackLanguage.push($preferredLanguage);\n                }\n            }\n          }\n          return promise;\n        }());\n\n        if (!promiseToWaitFor) {\n          // no promise to wait for? okay. Then there's no loader registered\n          // nor is a one pending for language that comes from storage.\n          // We can just translate.\n          determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n        } else {\n          var promiseResolved = function () {\n            // $uses may have changed while waiting\n            if (!forceLanguage) {\n              uses = $uses;\n            }\n            determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n          };\n          promiseResolved.displayName = 'promiseResolved';\n\n          promiseToWaitFor['finally'](promiseResolved);\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name applyNotFoundIndicators\n       * @private\n       *\n       * @description\n       * Applies not fount indicators to given translation id, if needed.\n       * This function gets only executed, if a translation id doesn't exist,\n       * which is why a translation id is expected as argument.\n       *\n       * @param {string} translationId Translation id.\n       * @returns {string} Same as given translation id but applied with not found\n       * indicators.\n       */\n      var applyNotFoundIndicators = function (translationId) {\n        // applying notFoundIndicators\n        if ($notFoundIndicatorLeft) {\n          translationId = [$notFoundIndicatorLeft, translationId].join(' ');\n        }\n        if ($notFoundIndicatorRight) {\n          translationId = [translationId, $notFoundIndicatorRight].join(' ');\n        }\n        return translationId;\n      };\n\n      /**\n       * @name useLanguage\n       * @private\n       *\n       * @description\n       * Makes actual use of a language by setting a given language key as used\n       * language and informs registered interpolators to also use the given\n       * key as locale.\n       *\n       * @param {key} Locale key.\n       */\n      var useLanguage = function (key) {\n        $uses = key;\n\n        // make sure to store new language key before triggering success event\n        if ($storageFactory) {\n          Storage.put($translate.storageKey(), $uses);\n        }\n\n        $rootScope.$emit('$translateChangeSuccess', {language: key});\n\n        // inform default interpolator\n        defaultInterpolator.setLocale($uses);\n\n        var eachInterpolator = function (interpolator, id) {\n          interpolatorHashMap[id].setLocale($uses);\n        };\n        eachInterpolator.displayName = 'eachInterpolatorLocaleSetter';\n\n        // inform all others too!\n        angular.forEach(interpolatorHashMap, eachInterpolator);\n        $rootScope.$emit('$translateChangeEnd', {language: key});\n      };\n\n      /**\n       * @name loadAsync\n       * @private\n       *\n       * @description\n       * Kicks of registered async loader using `$injector` and applies existing\n       * loader options. When resolved, it updates translation tables accordingly\n       * or rejects with given language key.\n       *\n       * @param {string} key Language key.\n       * @return {Promise} A promise.\n       */\n      var loadAsync = function (key) {\n        if (!key) {\n          throw 'No language key specified for loading.';\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateLoadingStart', {language: key});\n        pendingLoader = true;\n\n        var cache = loaderCache;\n        if (typeof(cache) === 'string') {\n          // getting on-demand instance of loader\n          cache = $injector.get(cache);\n        }\n\n        var loaderOptions = angular.extend({}, $loaderOptions, {\n          key: key,\n          $http: angular.extend({}, {\n            cache: cache\n          }, $loaderOptions.$http)\n        });\n\n        var onLoaderSuccess = function (data) {\n          var translationTable = {};\n          $rootScope.$emit('$translateLoadingSuccess', {language: key});\n\n          if (angular.isArray(data)) {\n            angular.forEach(data, function (table) {\n              angular.extend(translationTable, flatObject(table));\n            });\n          } else {\n            angular.extend(translationTable, flatObject(data));\n          }\n          pendingLoader = false;\n          deferred.resolve({\n            key: key,\n            table: translationTable\n          });\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderSuccess.displayName = 'onLoaderSuccess';\n\n        var onLoaderError = function (key) {\n          $rootScope.$emit('$translateLoadingError', {language: key});\n          deferred.reject(key);\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderError.displayName = 'onLoaderError';\n\n        $injector.get($loaderFactory)(loaderOptions)\n          .then(onLoaderSuccess, onLoaderError);\n\n        return deferred.promise;\n      };\n\n      if ($storageFactory) {\n        Storage = $injector.get($storageFactory);\n\n        if (!Storage.get || !Storage.put) {\n          throw new Error('Couldn\\'t use storage \\'' + $storageFactory + '\\', missing get() or put() method!');\n        }\n      }\n\n      // if we have additional interpolations that were added via\n      // $translateProvider.addInterpolation(), we have to map'em\n      if ($interpolatorFactories.length) {\n        var eachInterpolationFactory = function (interpolatorFactory) {\n          var interpolator = $injector.get(interpolatorFactory);\n          // setting initial locale for each interpolation service\n          interpolator.setLocale($preferredLanguage || $uses);\n          // make'em recognizable through id\n          interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;\n        };\n        eachInterpolationFactory.displayName = 'interpolationFactoryAdder';\n\n        angular.forEach($interpolatorFactories, eachInterpolationFactory);\n      }\n\n      /**\n       * @name getTranslationTable\n       * @private\n       *\n       * @description\n       * Returns a promise that resolves to the translation table\n       * or is rejected if an error occurred.\n       *\n       * @param langKey\n       * @returns {Q.promise}\n       */\n      var getTranslationTable = function (langKey) {\n        var deferred = $q.defer();\n        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {\n          deferred.resolve($translationTable[langKey]);\n        } else if (langPromises[langKey]) {\n          var onResolve = function (data) {\n            translations(data.key, data.table);\n            deferred.resolve(data.table);\n          };\n          onResolve.displayName = 'translationTableResolver';\n          langPromises[langKey].then(onResolve, deferred.reject);\n        } else {\n          deferred.reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslation\n       * @private\n       *\n       * @description\n       * Returns a promise that will resolve to the translation\n       * or be rejected if no translation was found for the language.\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise}\n       */\n      var getFallbackTranslation = function (langKey, translationId, interpolateParams, Interpolator) {\n        var deferred = $q.defer();\n\n        var onResolve = function (translationTable) {\n          if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n            Interpolator.setLocale(langKey);\n            var translation = translationTable[translationId];\n            if (translation.substr(0, 2) === '@:') {\n              getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator)\n                .then(deferred.resolve, deferred.reject);\n            } else {\n              deferred.resolve(Interpolator.interpolate(translationTable[translationId], interpolateParams));\n            }\n            Interpolator.setLocale($uses);\n          } else {\n            deferred.reject();\n          }\n        };\n        onResolve.displayName = 'fallbackTranslationResolver';\n\n        getTranslationTable(langKey).then(onResolve, deferred.reject);\n\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslationInstant\n       * @private\n       *\n       * @description\n       * Returns a translation\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var getFallbackTranslationInstant = function (langKey, translationId, interpolateParams, Interpolator) {\n        var result, translationTable = $translationTable[langKey];\n\n        if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n          Interpolator.setLocale(langKey);\n          result = Interpolator.interpolate(translationTable[translationId], interpolateParams);\n          if (result.substr(0, 2) === '@:') {\n            return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);\n          }\n          Interpolator.setLocale($uses);\n        }\n\n        return result;\n      };\n\n\n      /**\n       * @name translateByHandler\n       * @private\n       *\n       * Translate by missing translation handler.\n       *\n       * @param translationId\n       * @returns translation created by $missingTranslationHandler or translationId is $missingTranslationHandler is\n       * absent\n       */\n      var translateByHandler = function (translationId, interpolateParams) {\n        // If we have a handler factory - we might also call it here to determine if it provides\n        // a default text for a translationid that can't be found anywhere in our tables\n        if ($missingTranslationHandlerFactory) {\n          var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams);\n          if (resultString !== undefined) {\n            return resultString;\n          } else {\n            return translationId;\n          }\n        } else {\n          return translationId;\n        }\n      };\n\n      /**\n       * @name resolveForFallbackLanguage\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise that will resolve to the translation.\n       */\n      var resolveForFallbackLanguage = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        var deferred = $q.defer();\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(\n            deferred.resolve,\n            function () {\n              // Look in the next fallback language for a translation.\n              // It delays the resolving by passing another promise to resolve.\n              resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve);\n            }\n          );\n        } else {\n          // No translation found in any fallback language\n          // if a default translation text is set in the directive, then return this as a result\n          if (defaultTranslationText) {\n            deferred.resolve(defaultTranslationText);\n          } else {\n            // if no default translation is set and an error handler is defined, send it to the handler\n            // and then return the result\n            deferred.resolve(translateByHandler(translationId, interpolateParams));\n          }\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name resolveForFallbackLanguageInstant\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var resolveForFallbackLanguageInstant = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {\n        var result;\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);\n          if (!result) {\n            result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);\n          }\n        }\n        return result;\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise, that resolves to the translation.\n       */\n      var fallbackTranslation = function (translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguage((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText);\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {String} translation\n       */\n      var fallbackTranslationInstant = function (translationId, interpolateParams, Interpolator) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguageInstant((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator);\n      };\n\n      var determineTranslation = function (translationId, interpolateParams, interpolationId, defaultTranslationText, uses) {\n\n        var deferred = $q.defer();\n\n        var table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n\n            $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses)\n              .then(deferred.resolve, deferred.reject);\n          } else {\n            deferred.resolve(Interpolator.interpolate(translation, interpolateParams));\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText)\n                .then(function (translation) {\n                  deferred.resolve(translation);\n                }, function (_translationId) {\n                  deferred.reject(applyNotFoundIndicators(_translationId));\n                });\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n              } else {\n                deferred.resolve(missingTranslationHandlerTranslation);\n              }\n          } else {\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n            } else {\n              deferred.reject(applyNotFoundIndicators(translationId));\n            }\n          }\n        }\n        return deferred.promise;\n      };\n\n      var determineTranslationInstant = function (translationId, interpolateParams, interpolationId, uses) {\n\n        var result, table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = defaultInterpolator;\n\n        // if the interpolation id exists use custom interpolator\n        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {\n          Interpolator = interpolatorHashMap[interpolationId];\n        }\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n            result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses);\n          } else {\n            result = Interpolator.interpolate(translation, interpolateParams);\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackIndex = 0;\n            result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            result = missingTranslationHandlerTranslation;\n          } else {\n            result = applyNotFoundIndicators(translationId);\n          }\n        }\n\n        return result;\n      };\n\n      var clearNextLangAndPromise = function(key) {\n        if ($nextLang === key) {\n          $nextLang = undefined;\n        }\n        langPromises[key] = undefined;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#preferredLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the preferred language.\n       *\n       * @param {string} langKey language String or Array to be used as preferredLanguage (changing at runtime)\n       *\n       * @return {string} preferred language key\n       */\n      $translate.preferredLanguage = function (langKey) {\n        if(langKey) {\n          setupPreferredLanguage(langKey);\n        }\n        return $preferredLanguage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#cloakClassName\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured class name for `translate-cloak` directive.\n       *\n       * @return {string} cloakClassName\n       */\n      $translate.cloakClassName = function () {\n        return $cloakClassName;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#nestedObjectDelimeter\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured delimiter for nested namespaces.\n       *\n       * @return {string} nestedObjectDelimeter\n       */\n      $translate.nestedObjectDelimeter = function () {\n        return $nestedObjectDelimeter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#fallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the fallback languages or sets a new fallback stack.\n       *\n       * @param {string=} langKey language String or Array of fallback languages to be used (to change stack at runtime)\n       *\n       * @return {string||array} fallback language key\n       */\n      $translate.fallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          fallbackStack(langKey);\n\n          // as we might have an async loader initiated and a new translation language might have been defined\n          // we need to add the promise to the stack also. So - iterate.\n          if ($loaderFactory) {\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n              for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n                if (!langPromises[$fallbackLanguage[i]]) {\n                  langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);\n                }\n              }\n            }\n          }\n          $translate.use($translate.use());\n        }\n        if ($fallbackWasString) {\n          return $fallbackLanguage[0];\n        } else {\n          return $fallbackLanguage;\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#useFallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Sets the first key of the fallback language stack to be used for translation.\n       * Therefore all languages in the fallback array BEFORE this key will be skipped!\n       *\n       * @param {string=} langKey Contains the langKey the iteration shall start with. Set to false if you want to\n       * get back to the whole stack\n       */\n      $translate.useFallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          if (!langKey) {\n            startFallbackIteration = 0;\n          } else {\n            var langKeyPosition = indexOf($fallbackLanguage, langKey);\n            if (langKeyPosition > -1) {\n              startFallbackIteration = langKeyPosition;\n            }\n          }\n\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#proposedLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key of language that is currently loaded asynchronously.\n       *\n       * @return {string} language key\n       */\n      $translate.proposedLanguage = function () {\n        return $nextLang;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns registered storage.\n       *\n       * @return {object} Storage\n       */\n      $translate.storage = function () {\n        return Storage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#negotiateLocale\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a language key based on available languages and language aliases. If a\n       * language key cannot be resolved, returns undefined.\n       *\n       * If no or a falsy key is given, returns undefined.\n       *\n       * @param {string} [key] Language key\n       * @return {string|undefined} Language key or undefined if no language key is found.\n       */\n      $translate.negotiateLocale = negotiateLocale;\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#use\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Tells angular-translate which language to use by given language key. This method is\n       * used to change language at runtime. It also takes care of storing the language\n       * key in a configured store to let your app remember the choosed language.\n       *\n       * When trying to 'use' a language which isn't available it tries to load it\n       * asynchronously with registered loaders.\n       *\n       * Returns promise object with loaded language file data or string of the currently used language.\n       *\n       * If no or a falsy key is given it returns the currently used language key.\n       * The returned string will be ```undefined``` if setting up $translate hasn't finished.\n       * @example\n       * $translate.use(\"en_US\").then(function(data){\n       *   $scope.text = $translate(\"HELLO\");\n       * });\n       *\n       * @param {string} [key] Language key\n       * @return {object|string} Promise with loaded language data or the language key if a falsy param was given.\n       */\n      $translate.use = function (key) {\n        if (!key) {\n          return $uses;\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateChangeStart', {language: key});\n\n        // Try to get the aliased language key\n        var aliasedKey = negotiateLocale(key);\n        if (aliasedKey) {\n          key = aliasedKey;\n        }\n\n        // if there isn't a translation table for the language we've requested,\n        // we load it asynchronously\n        $nextLang = key;\n        if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {\n          langPromises[key] = loadAsync(key).then(function (translation) {\n            translations(translation.key, translation.table);\n            deferred.resolve(translation.key);\n            if ($nextLang === key) {\n              useLanguage(translation.key);\n            }\n            return translation;\n          }, function (key) {\n            $rootScope.$emit('$translateChangeError', {language: key});\n            deferred.reject(key);\n            $rootScope.$emit('$translateChangeEnd', {language: key});\n            return $q.reject(key);\n          });\n          langPromises[key]['finally'](function () {\n            clearNextLangAndPromise(key);\n          });\n        } else if (langPromises[key]) {\n          // we are already loading this asynchronously\n          // resolve our new deferred when the old langPromise is resolved\n          langPromises[key].then(function (translation) {\n            if ($nextLang === translation.key) {\n              useLanguage(translation.key);\n            }\n            deferred.resolve(translation.key);\n            return translation;\n          }, function (key) {\n            // find first available fallback language if that request has failed\n            if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0) {\n              return $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);\n            } else {\n              return deferred.reject(key);\n            }\n          });\n        } else {\n          deferred.resolve(key);\n          useLanguage(key);\n        }\n\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storageKey\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the key for the storage.\n       *\n       * @return {string} storage key\n       */\n      $translate.storageKey = function () {\n        return storageKey();\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isPostCompilingEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether post compiling is enabled or not\n       *\n       * @return {bool} storage key\n       */\n      $translate.isPostCompilingEnabled = function () {\n        return $postCompilingEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isForceAsyncReloadEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether force async reload is enabled or not\n       *\n       * @return {boolean} forceAsyncReload value\n       */\n      $translate.isForceAsyncReloadEnabled = function () {\n        return $forceAsyncReloadEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#refresh\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Refreshes a translation table pointed by the given langKey. If langKey is not specified,\n       * the module will drop all existent translation tables and load new version of those which\n       * are currently in use.\n       *\n       * Refresh means that the module will drop target translation table and try to load it again.\n       *\n       * In case there are no loaders registered the refresh() method will throw an Error.\n       *\n       * If the module is able to refresh translation tables refresh() method will broadcast\n       * $translateRefreshStart and $translateRefreshEnd events.\n       *\n       * @example\n       * // this will drop all currently existent translation tables and reload those which are\n       * // currently in use\n       * $translate.refresh();\n       * // this will refresh a translation table for the en_US language\n       * $translate.refresh('en_US');\n       *\n       * @param {string} langKey A language key of the table, which has to be refreshed\n       *\n       * @return {promise} Promise, which will be resolved in case a translation tables refreshing\n       * process is finished successfully, and reject if not.\n       */\n      $translate.refresh = function (langKey) {\n        if (!$loaderFactory) {\n          throw new Error('Couldn\\'t refresh translation table, no loader registered!');\n        }\n\n        var deferred = $q.defer();\n\n        function resolve() {\n          deferred.resolve();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        function reject() {\n          deferred.reject();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        $rootScope.$emit('$translateRefreshStart', {language: langKey});\n\n        if (!langKey) {\n          // if there's no language key specified we refresh ALL THE THINGS!\n          var tables = [], loadingKeys = {};\n\n          // reload registered fallback languages\n          if ($fallbackLanguage && $fallbackLanguage.length) {\n            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n              tables.push(loadAsync($fallbackLanguage[i]));\n              loadingKeys[$fallbackLanguage[i]] = true;\n            }\n          }\n\n          // reload currently used language\n          if ($uses && !loadingKeys[$uses]) {\n            tables.push(loadAsync($uses));\n          }\n\n          var allTranslationsLoaded = function (tableData) {\n            $translationTable = {};\n            angular.forEach(tableData, function (data) {\n              translations(data.key, data.table);\n            });\n            if ($uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          allTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          $q.all(tables).then(allTranslationsLoaded, reject);\n\n        } else if ($translationTable[langKey]) {\n\n          var oneTranslationsLoaded = function (data) {\n            translations(data.key, data.table);\n            if (langKey === $uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          oneTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          loadAsync(langKey).then(oneTranslationsLoaded, reject);\n\n        } else {\n          reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#instant\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a translation instantly from the internal state of loaded translation. All rules\n       * regarding the current language, the preferred language of even fallback languages will be\n       * used except any promise handling. If a language was not found, an asynchronous loading\n       * will be invoked in the background.\n       *\n       * @param {string|array} translationId A token which represents a translation id\n       *                                     This can be optionally an array of translation ids which\n       *                                     results that the function's promise returns an object where\n       *                                     each key is the translation id and the value the translation.\n       * @param {object} interpolateParams Params\n       * @param {string} interpolationId The id of the interpolation to use\n       * @param {string} forceLanguage A language to be used instead of the current language\n       *\n       * @return {string|object} translation\n       */\n      $translate.instant = function (translationId, interpolateParams, interpolationId, forceLanguage) {\n\n        // we don't want to re-negotiate $uses\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Detect undefined and null values to shorten the execution and prevent exceptions\n        if (translationId === null || angular.isUndefined(translationId)) {\n          return translationId;\n        }\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          var results = {};\n          for (var i = 0, c = translationId.length; i < c; i++) {\n            results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage);\n          }\n          return results;\n        }\n\n        // We discarded unacceptable values. So we just need to verify if translationId is empty String\n        if (angular.isString(translationId) && translationId.length < 1) {\n          return translationId;\n        }\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var result, possibleLangKeys = [];\n        if ($preferredLanguage) {\n          possibleLangKeys.push($preferredLanguage);\n        }\n        if (uses) {\n          possibleLangKeys.push(uses);\n        }\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);\n        }\n        for (var j = 0, d = possibleLangKeys.length; j < d; j++) {\n          var possibleLangKey = possibleLangKeys[j];\n          if ($translationTable[possibleLangKey]) {\n            if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {\n              result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses);\n            }\n          }\n          if (typeof result !== 'undefined') {\n            break;\n          }\n        }\n\n        if (!result && result !== '') {\n          if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {\n            result = applyNotFoundIndicators(translationId);\n          } else {\n            // Return translation of default interpolator if not found anything.\n            result = defaultInterpolator.interpolate(translationId, interpolateParams);\n            if ($missingTranslationHandlerFactory && !pendingLoader) {\n              result = translateByHandler(translationId, interpolateParams);\n            }\n          }\n        }\n\n        return result;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#versionInfo\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the current version information for the angular-translate library\n       *\n       * @return {string} angular-translate version\n       */\n      $translate.versionInfo = function () {\n        return version;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#loaderCache\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the defined loaderCache.\n       *\n       * @return {boolean|string|object} current value of loaderCache\n       */\n      $translate.loaderCache = function () {\n        return loaderCache;\n      };\n\n      // internal purpose only\n      $translate.directivePriority = function () {\n        return directivePriority;\n      };\n\n      // internal purpose only\n      $translate.statefulFilter = function () {\n        return statefulFilter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_onReady onReady()}.\n       *\n       * @return {boolean} current value of ready\n       */\n      $translate.isReady = function () {\n        return $isReady;\n      };\n\n      var $onReadyDeferred = $q.defer();\n      $onReadyDeferred.promise.then(function () {\n        $isReady = true;\n      });\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#onReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_isReady isReady()}.\n       *\n       * @param {Function=} fn Function to invoke when service is ready\n       * @return {object} Promise resolved when service is ready\n       */\n      $translate.onReady = function (fn) {\n        var deferred = $q.defer();\n        if (angular.isFunction(fn)) {\n          deferred.promise.then(fn);\n        }\n        if ($isReady) {\n          deferred.resolve();\n        } else {\n          $onReadyDeferred.promise.then(deferred.resolve);\n        }\n        return deferred.promise;\n      };\n\n      // Whenever $translateReady is being fired, this will ensure the state of $isReady\n      var globalOnReadyListener = $rootScope.$on('$translateReady', function () {\n        $onReadyDeferred.resolve();\n        globalOnReadyListener(); // one time only\n        globalOnReadyListener = null;\n      });\n      var globalOnChangeListener = $rootScope.$on('$translateChangeEnd', function () {\n        $onReadyDeferred.resolve();\n        globalOnChangeListener(); // one time only\n        globalOnChangeListener = null;\n      });\n\n      if ($loaderFactory) {\n\n        // If at least one async loader is defined and there are no\n        // (default) translations available we should try to load them.\n        if (angular.equals($translationTable, {})) {\n          if ($translate.use()) {\n            $translate.use($translate.use());\n          }\n        }\n\n        // Also, if there are any fallback language registered, we start\n        // loading them asynchronously as soon as we can.\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          var processAsyncResult = function (translation) {\n            translations(translation.key, translation.table);\n            $rootScope.$emit('$translateChangeEnd', { language: translation.key });\n            return translation;\n          };\n          for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n            var fallbackLanguageId = $fallbackLanguage[i];\n            if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {\n              langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);\n            }\n          }\n        }\n      } else {\n        $rootScope.$emit('$translateReady', { language: $translate.use() });\n      }\n\n      return $translate;\n    }\n  ];\n}\n$translate.$inject = ['$STORAGE_KEY', '$windowProvider', '$translateSanitizationProvider', 'pascalprechtTranslateOverrider'];\n\n$translate.displayName = 'displayName';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateDefaultInterpolation\n * @requires $interpolate\n *\n * @description\n * Uses angular's `$interpolate` services to interpolate strings against some values.\n *\n * Be aware to configure a proper sanitization strategy.\n *\n * See also:\n * * {@link pascalprecht.translate.$translateSanitization}\n *\n * @return {object} $translateDefaultInterpolation Interpolator service\n */\nangular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', $translateDefaultInterpolation);\n\nfunction $translateDefaultInterpolation ($interpolate, $translateSanitization) {\n\n  'use strict';\n\n  var $translateInterpolator = {},\n      $locale,\n      $identifier = 'default';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#setLocale\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Sets current locale (this is currently not use in this interpolation).\n   *\n   * @param {string} locale Language key or locale.\n   */\n  $translateInterpolator.setLocale = function (locale) {\n    $locale = locale;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#getInterpolationIdentifier\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Returns an identifier for this interpolation service.\n   *\n   * @returns {string} $identifier\n   */\n  $translateInterpolator.getInterpolationIdentifier = function () {\n    return $identifier;\n  };\n\n  /**\n   * @deprecated will be removed in 3.0\n   * @see {@link pascalprecht.translate.$translateSanitization}\n   */\n  $translateInterpolator.useSanitizeValueStrategy = function (value) {\n    $translateSanitization.useStrategy(value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#interpolate\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Interpolates given string agains given interpolate params using angulars\n   * `$interpolate` service.\n   *\n   * @returns {string} interpolated string.\n   */\n  $translateInterpolator.interpolate = function (string, interpolationParams) {\n    interpolationParams = interpolationParams || {};\n    interpolationParams = $translateSanitization.sanitize(interpolationParams, 'params');\n\n    var interpolatedText = $interpolate(string)(interpolationParams);\n    interpolatedText = $translateSanitization.sanitize(interpolatedText, 'text');\n\n    return interpolatedText;\n  };\n\n  return $translateInterpolator;\n}\n$translateDefaultInterpolation.$inject = ['$interpolate', '$translateSanitization'];\n\n$translateDefaultInterpolation.displayName = '$translateDefaultInterpolation';\n\nangular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translate\n * @requires $compile\n * @requires $filter\n * @requires $interpolate\n * @restrict AE\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate Translation id which could be either string or interpolated string.\n * @param {string=} translate-values Values to pass into translation id. Can be passed as object literal string or interpolated object.\n * @param {string=} translate-attr-ATTR translate Translation id and put it into ATTR attribute.\n * @param {string=} translate-default will be used unless translation was successful\n * @param {boolean=} translate-compile (default true if present) defines locally activation of {@link pascalprecht.translate.$translateProvider#methods_usePostCompiling}\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre translate=\"TRANSLATION_ID\"></pre>\n        <pre translate>TRANSLATION_ID</pre>\n        <pre translate translate-attr-title=\"TRANSLATION_ID\"></pre>\n        <pre translate=\"{{translationId}}\"></pre>\n        <pre translate>{{translationId}}</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{value: 5}\"></pre>\n        <pre translate translate-values=\"{value: 5}\">WITH_VALUES</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n        <pre translate translate-values=\"{{values}}\">WITH_VALUES</pre>\n        <pre translate translate-attr-title=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        }).preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n    <file name=\"scenario.js\">\n      it('should translate', function () {\n        inject(function ($rootScope, $compile) {\n          $rootScope.translationId = 'TRANSLATION_ID';\n\n          element = $compile('<p translate=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate=\"{{translationId}}\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>TRANSLATION_ID</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>{{translationId}}</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate translate-attr-title=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.attr('title')).toBe('Hello there!');\n        });\n      });\n    </file>\n   </example>\n */\n.directive('translate', translateDirective);\nfunction translateDirective($translate, $q, $interpolate, $compile, $parse, $rootScope) {\n\n  'use strict';\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  return {\n    restrict: 'AE',\n    scope: true,\n    priority: $translate.directivePriority(),\n    compile: function (tElement, tAttr) {\n\n      var translateValuesExist = (tAttr.translateValues) ?\n        tAttr.translateValues : undefined;\n\n      var translateInterpolation = (tAttr.translateInterpolation) ?\n        tAttr.translateInterpolation : undefined;\n\n      var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);\n\n      var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',\n          watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';\n\n      return function linkFn(scope, iElement, iAttr) {\n\n        scope.interpolateParams = {};\n        scope.preText = '';\n        scope.postText = '';\n        scope.translateNamespace = getTranslateNamespace(scope);\n        var translationIds = {};\n\n        var initInterpolationParams = function (interpolateParams, iAttr, tAttr) {\n          // initial setup\n          if (iAttr.translateValues) {\n            angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));\n          }\n          // initially fetch all attributes if existing and fill the params\n          if (translateValueExist) {\n            for (var attr in tAttr) {\n              if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n                var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);\n                interpolateParams[attributeName] = tAttr[attr];\n              }\n            }\n          }\n        };\n\n        // Ensures any change of the attribute \"translate\" containing the id will\n        // be re-stored to the scope's \"translationId\".\n        // If the attribute has no content, the element's text value (white spaces trimmed off) will be used.\n        var observeElementTranslation = function (translationId) {\n\n          // Remove any old watcher\n          if (angular.isFunction(observeElementTranslation._unwatchOld)) {\n            observeElementTranslation._unwatchOld();\n            observeElementTranslation._unwatchOld = undefined;\n          }\n\n          if (angular.equals(translationId , '') || !angular.isDefined(translationId)) {\n            var iElementText = trim.apply(iElement.text());\n\n            // Resolve translation id by inner html if required\n            var interpolateMatches = iElementText.match(interpolateRegExp);\n            // Interpolate translation id if required\n            if (angular.isArray(interpolateMatches)) {\n              scope.preText = interpolateMatches[1];\n              scope.postText = interpolateMatches[3];\n              translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);\n              var watcherMatches = iElementText.match(watcherRegExp);\n              if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {\n                observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function (newValue) {\n                  translationIds.translate = newValue;\n                  updateTranslations();\n                });\n              }\n            } else {\n              // do not assigne the translation id if it is empty.\n              translationIds.translate = !iElementText ? undefined : iElementText;\n            }\n          } else {\n            translationIds.translate = translationId;\n          }\n          updateTranslations();\n        };\n\n        var observeAttributeTranslation = function (translateAttr) {\n          iAttr.$observe(translateAttr, function (translationId) {\n            translationIds[translateAttr] = translationId;\n            updateTranslations();\n          });\n        };\n\n        // initial setup with values\n        initInterpolationParams(scope.interpolateParams, iAttr, tAttr);\n\n        var firstAttributeChangedEvent = true;\n        iAttr.$observe('translate', function (translationId) {\n          if (typeof translationId === 'undefined') {\n            // case of element \"<translate>xyz</translate>\"\n            observeElementTranslation('');\n          } else {\n            // case of regular attribute\n            if (translationId !== '' || !firstAttributeChangedEvent) {\n              translationIds.translate = translationId;\n              updateTranslations();\n            }\n          }\n          firstAttributeChangedEvent = false;\n        });\n\n        for (var translateAttr in iAttr) {\n          if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr') {\n            observeAttributeTranslation(translateAttr);\n          }\n        }\n\n        iAttr.$observe('translateDefault', function (value) {\n          scope.defaultText = value;\n          updateTranslations();\n        });\n\n        if (translateValuesExist) {\n          iAttr.$observe('translateValues', function (interpolateParams) {\n            if (interpolateParams) {\n              scope.$parent.$watch(function () {\n                angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));\n              });\n            }\n          });\n        }\n\n        if (translateValueExist) {\n          var observeValueAttribute = function (attrName) {\n            iAttr.$observe(attrName, function (value) {\n              var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);\n              scope.interpolateParams[attributeName] = value;\n            });\n          };\n          for (var attr in iAttr) {\n            if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n              observeValueAttribute(attr);\n            }\n          }\n        }\n\n        // Master update function\n        var updateTranslations = function () {\n          for (var key in translationIds) {\n\n            if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {\n              updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);\n            }\n          }\n        };\n\n        // Put translation processing function outside loop\n        var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {\n          if (translationId) {\n            // if translation id starts with '.' and translateNamespace given, prepend namespace\n            if (translateNamespace && translationId.charAt(0) === '.') {\n              translationId = translateNamespace + translationId;\n            }\n\n            $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage)\n              .then(function (translation) {\n                applyTranslation(translation, scope, true, translateAttr);\n              }, function (translationId) {\n                applyTranslation(translationId, scope, false, translateAttr);\n              });\n          } else {\n            // as an empty string cannot be translated, we can solve this using successful=false\n            applyTranslation(translationId, scope, false, translateAttr);\n          }\n        };\n\n        var applyTranslation = function (value, scope, successful, translateAttr) {\n          if (translateAttr === 'translate') {\n            // default translate into innerHTML\n            if (!successful && typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n            iElement.empty().append(scope.preText + value + scope.postText);\n            var globallyEnabled = $translate.isPostCompilingEnabled();\n            var locallyDefined = typeof tAttr.translateCompile !== 'undefined';\n            var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';\n            if ((globallyEnabled && !locallyDefined) || locallyEnabled) {\n              $compile(iElement.contents())(scope);\n            }\n          } else {\n            // translate attribute\n            if (!successful && typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n            var attributeName = iAttr.$attr[translateAttr];\n            if (attributeName.substr(0, 5) === 'data-') {\n              // ensure html5 data prefix is stripped\n              attributeName = attributeName.substr(5);\n            }\n            attributeName = attributeName.substr(15);\n            iElement.attr(attributeName, value);\n          }\n        };\n\n        if (translateValuesExist || translateValueExist || iAttr.translateDefault) {\n          scope.$watch('interpolateParams', updateTranslations, true);\n        }\n        scope.$watch('translateLanguage', updateTranslations);\n\n        // Ensures the text will be refreshed after the current language was changed\n        // w/ $translate.use(...)\n        var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);\n\n        // ensure translation will be looked up at least one\n        if (iElement.text().length) {\n          if (iAttr.translate) {\n            observeElementTranslation(iAttr.translate);\n          } else {\n            observeElementTranslation('');\n          }\n        } else if (iAttr.translate) {\n          // ensure attribute will be not skipped\n          observeElementTranslation(iAttr.translate);\n        }\n        updateTranslations();\n        scope.$on('$destroy', unbind);\n      };\n    }\n  };\n}\ntranslateDirective.$inject = ['$translate', '$q', '$interpolate', '$compile', '$parse', '$rootScope'];\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateDirective.displayName = 'translateDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateCloak\n * @requires $rootScope\n * @requires $translate\n * @restrict A\n *\n * $description\n * Adds a `translate-cloak` class name to the given element where this directive\n * is applied initially and removes it, once a loader has finished loading.\n *\n * This directive can be used to prevent initial flickering when loading translation\n * data asynchronously.\n *\n * The class name is defined in\n * {@link pascalprecht.translate.$translateProvider#cloakClassName $translate.cloakClassName()}.\n *\n * @param {string=} translate-cloak If a translationId is provided, it will be used for showing\n *                                  or hiding the cloak. Basically it relies on the translation\n *                                  resolve.\n */\n.directive('translateCloak', translateCloakDirective);\n\nfunction translateCloakDirective($translate, $rootScope) {\n\n  'use strict';\n\n  return {\n    compile: function (tElement) {\n      var applyCloak = function () {\n        tElement.addClass($translate.cloakClassName());\n      },\n      removeCloak = function () {\n        tElement.removeClass($translate.cloakClassName());\n      };\n      $translate.onReady(function () {\n        removeCloak();\n      });\n      applyCloak();\n\n      return function linkFn(scope, iElement, iAttr) {\n        if (iAttr.translateCloak && iAttr.translateCloak.length) {\n          // Register a watcher for the defined translation allowing a fine tuned cloak\n          iAttr.$observe('translateCloak', function (translationId) {\n            $translate(translationId).then(removeCloak, applyCloak);\n          });\n          // Register for change events as this is being another indicicator revalidating the cloak)\n          $rootScope.$on('$translateChangeSuccess', function () {\n            $translate(iAttr.translateCloak).then(removeCloak, applyCloak);\n          });\n        }\n      };\n    }\n  };\n}\ntranslateCloakDirective.$inject = ['$translate', '$rootScope'];\n\ntranslateCloakDirective.displayName = 'translateCloakDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateNamespace\n * @restrict A\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate namespace name which could be either string or interpolated string.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div translate-namespace=\"CONTENT\">\n\n        <div>\n            <h1 translate>.HEADERS.TITLE</h1>\n            <h1 translate>.HEADERS.WELCOME</h1>\n        </div>\n\n        <div translate-namespace=\".HEADERS\">\n            <h1 translate>.TITLE</h1>\n            <h1 translate>.WELCOME</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'CONTENT': {\n            'HEADERS': {\n                TITLE: 'Title'\n            }\n          },\n          'CONTENT.HEADERS.WELCOME': 'Welcome'\n        }).preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateNamespace', translateNamespaceDirective);\n\nfunction translateNamespaceDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return {\n        pre: function (scope, iElement, iAttrs) {\n          scope.translateNamespace = getTranslateNamespace(scope);\n\n          if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === '.') {\n            scope.translateNamespace += iAttrs.translateNamespace;\n          } else {\n            scope.translateNamespace = iAttrs.translateNamespace;\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateNamespaceDirective.displayName = 'translateNamespaceDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateLanguage\n * @restrict A\n *\n * @description\n * Forces the language to the directives in the underlying scope.\n *\n * @param {string=} translate language that will be negotiated.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div>\n\n        <div>\n            <h1 translate>HELLO</h1>\n        </div>\n\n        <div translate-language=\"de\">\n            <h1 translate>HELLO</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider\n          .translations('en',{\n            'HELLO': 'Hello world!'\n          })\n          .translations('de',{\n            'HELLO': 'Hallo Welt!'\n          })\n          .translations(.preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateLanguage', translateLanguageDirective);\n\nfunction translateLanguageDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return function linkFn(scope, iElement, iAttrs) {\n        iAttrs.$observe('translateLanguage', function (newTranslateLanguage) {\n          scope.translateLanguage = newTranslateLanguage;\n        });\n      };\n    }\n  };\n}\n\ntranslateLanguageDirective.displayName = 'translateLanguageDirective';\n\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc filter\n * @name pascalprecht.translate.filter:translate\n * @requires $parse\n * @requires pascalprecht.translate.$translate\n * @function\n *\n * @description\n * Uses `$translate` service to translate contents. Accepts interpolate parameters\n * to pass dynamized values though translation.\n *\n * @param {string} translationId A translation id to be translated.\n * @param {*=} interpolateParams Optional object literal (as hash or string) to pass values into translation.\n *\n * @returns {string} Translated text.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre>{{ 'TRANSLATION_ID' | translate }}</pre>\n        <pre>{{ translationId | translate }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:'{value: 5}' }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:values }}</pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en', {\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        });\n        $translateProvider.preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n   </example>\n */\n.filter('translate', translateFilterFactory);\n\nfunction translateFilterFactory($parse, $translate) {\n\n  'use strict';\n\n  var translateFilter = function (translationId, interpolateParams, interpolation, forceLanguage) {\n\n    if (!angular.isObject(interpolateParams)) {\n      interpolateParams = $parse(interpolateParams)(this);\n    }\n\n    return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);\n  };\n\n  if ($translate.statefulFilter()) {\n    translateFilter.$stateful = true;\n  }\n\n  return translateFilter;\n}\ntranslateFilterFactory.$inject = ['$parse', '$translate'];\n\ntranslateFilterFactory.displayName = 'translateFilterFactory';\n\nangular.module('pascalprecht.translate')\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translationCache\n * @requires $cacheFactory\n *\n * @description\n * The first time a translation table is used, it is loaded in the translation cache for quick retrieval. You\n * can load translation tables directly into the cache by consuming the\n * `$translationCache` service directly.\n *\n * @return {object} $cacheFactory object.\n */\n  .factory('$translationCache', $translationCache);\n\nfunction $translationCache($cacheFactory) {\n\n  'use strict';\n\n  return $cacheFactory('translations');\n}\n$translationCache.$inject = ['$cacheFactory'];\n\n$translationCache.displayName = '$translationCache';\nreturn 'pascalprecht.translate';\n\n}));\n\n},{}],40:[function(require,module,exports){\n/**\n * State-based routing for AngularJS\n * @version v0.2.18\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    toJson = angular.toJson;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i] || !parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:\n        result = result.replace(/\\/$/, '');\n        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  var param, paramVal;\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    param = this.params[paramName];\n    paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n    param = this.params[paramName];\n    paramVal = searchParams[paramName];\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validates\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      var isFinalPathParam = i + 1 === nPath;\n\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n\n      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      if (encoded.length === 0) continue;\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        if (isArray(val) && val.length === 0) return val;\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  // Use tildes to pre-encode slashes.\n  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n  // and bidirectional encoding/decoding fails.\n  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    \"string\": {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    \"int\": {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    \"bool\": {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    \"date\": {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    \"json\": {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    \"any\": { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\n      if (angular.isString(config.type))\n        return $types[config.type];\n      if (config.type instanceof Type)\n        return config.type;\n      return new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {function} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|function} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. \n   * \n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|function} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n\n        isHtml5 = isHtml5 && $sniffer.history;\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. Only parameters specified in the state definition can be overridden, new \n     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n     *    have changed.  It will reload the resolves and views of the current state and parent states.\n     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n     *    the transition reloads the resolves and views for that matched state, and all its children states.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n      \n      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n      if (hash) toParams['#'] = hash;\n      \n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n          if ($state.transition == null) $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .factory('$stateParams', function () { return {}; })\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\nvar ngMajorVer = angular.version.major;\nvar ngMinorVer = angular.version.minor;\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations\n * will be applied to the ui-view)\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = {\n      enter: function (element, target, cb) { target.after(element); cb(); },\n      leave: function (element, cb) { element.remove(); cb(); }\n    };\n\n    if (!!attrs.noanimation) return statics;\n\n    function animEnabled(element) {\n      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);\n      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();\n      return (!!$animator);\n    }\n\n    // ng 1.2+\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          if (!animEnabled(element)) {\n            statics.enter(element, target, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function(element, cb) {\n          if (!animEnabled(element)) {\n            statics.leave(element, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        }\n      };\n    }\n\n    // ng 1.1.5\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics;\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          var _previousEl = previousEl;\n          var _currentScope = currentScope;\n\n          if (_currentScope) {\n            _currentScope._willBeDestroyed = true;\n          }\n\n          function cleanOld() {\n            if (_previousEl) {\n              _previousEl.remove();\n            }\n\n            if (_currentScope) {\n              _currentScope.$destroy();\n            }\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              cleanOld();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n          } else {\n            cleanOld();\n            previousEl = null;\n          }\n\n          currentEl = null;\n          currentScope = null;\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          currentScope.$emit('$viewContentLoaded', name);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var inherited = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\nfunction clickHook(el, $state, $timeout, type, current) {\n  return function(e) {\n    var button = e.which || e.button, target = current();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function() {\n        $state.go(target.state, target.params, target.options);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\n      e.preventDefault = function() {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\nfunction defaultOpts(el, $state) {\n  return { relative: stateContext(el) || $state.$current, inherit: true };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n * URL, the directive will automatically generate & update the `href` attribute via\n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n * the link will trigger a state transition with optional parameters.\n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative\n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the\n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n *\n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n      var def    = { state: ref.state, href: null, params: null };\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n\n      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\n      var update = function(val) {\n        if (val) def.params = angular.copy(val);\n        def.href = $state.href(ref.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(ref.state, def.params);\n        if (def.href !== null) attrs.$set(type.attr, def.href);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n        def.params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-state\n *\n * @requires ui.router.state.uiSref\n *\n * @restrict A\n *\n * @description\n * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n * params and override options.\n *\n * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}\n * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDynamicDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n      var def    = { state: null, params: null, options: null, href: null };\n\n      function runStateRefLink (group) {\n        def.state = group[0]; def.params = group[1]; def.options = group[2];\n        def.href = $state.href(def.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(def.state, def.params);\n        if (def.href) attrs.$set(type.attr, def.href);\n      }\n\n      scope.$watch(watch, runStateRefLink, true);\n      runStateRefLink(scope.$eval(watch));\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * It is also possible to pass ui-sref-active an expression that evaluates\n * to an object hash, whose keys represent active class names and whose\n * values represent the respective state names/globs.\n * ui-sref-active will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * @Example\n * Given the following template, with \"admin\" being an abstract state:\n * <pre>\n * <div ui-sref-active=\"{'active': 'admin.*'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * </pre>\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied\n * to both the <div> and <a> elements. It is important to note that the state\n * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n      try {\n        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n      } catch (e) {\n        // Do nothing. uiSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n      if (isObject(uiSrefActive)) {\n        forEach(uiSrefActive, function(stateOrName, activeClass) {\n          if (isString(stateOrName)) {\n            var ref = parseStateRef(stateOrName, $state.current.name);\n            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n          }\n        });\n      }\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ui-sref-active, so we\n        // shadow the one that comes from ui-sref\n        if (isObject(uiSrefActive) && states.length > 0) {\n          return;\n        }\n        addState(newState, newParams, uiSrefActive);\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      function addState(stateName, stateParams, activeClass) {\n        var state = $state.get(stateName, stateContext($element));\n        var stateHash = createStateHash(stateName, stateParams);\n\n        states.push({\n          state: state || { name: stateName },\n          params: stateParams,\n          hash: stateHash\n        });\n\n        activeClasses[stateHash] = activeClass;\n      }\n\n      /**\n       * @param {string} state\n       * @param {Object|string} [params]\n       * @return {string}\n       */\n      function createStateHash(state, params) {\n        if (!isString(state)) {\n          throw new Error('state should be a string');\n        }\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        params = $scope.$eval(params);\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        return state;\n      }\n\n      // Update route state\n      function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }\n\n      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n      function removeClass(el, className) { el.removeClass(className); }\n      function anyMatch(state, params) { return $state.includes(state.name, params); }\n      function exactMatch(state, params) { return $state.is(state.name, params); }\n\n      update();\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n  .directive('uiState', $StateRefDynamicDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state, params) {\n    return $state.is(state, params);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state, params, options) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n},{}],41:[function(require,module,exports){\n'use strict';\n// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.\n\nmodule.exports = {\n    // Create a <link> tag with optional data attributes\n    createLink: function(href, attributes) {\n        var head = document.head || document.getElementsByTagName('head')[0];\n        var link = document.createElement('link');\n\n        link.href = href;\n        link.rel = 'stylesheet';\n\n        for (var key in attributes) {\n            if ( ! attributes.hasOwnProperty(key)) {\n                continue;\n            }\n            var value = attributes[key];\n            link.setAttribute('data-' + key, value);\n        }\n\n        head.appendChild(link);\n    },\n    // Create a <style> tag with optional data attributes\n    createStyle: function(cssText, attributes) {\n        var head = document.head || document.getElementsByTagName('head')[0],\n            style = document.createElement('style');\n\n        style.type = 'text/css';\n\n        for (var key in attributes) {\n            if ( ! attributes.hasOwnProperty(key)) {\n                continue;\n            }\n            var value = attributes[key];\n            style.setAttribute('data-' + key, value);\n        }\n        \n        if (style.sheet) { // for jsdom and IE9+\n            style.innerHTML = cssText;\n            style.sheet.cssText = cssText;\n            head.appendChild(style);\n        } else if (style.styleSheet) { // for IE8 and below\n            head.appendChild(style);\n            style.styleSheet.cssText = cssText;\n        } else { // for Chrome, Firefox, and Safari\n            style.appendChild(document.createTextNode(cssText));\n            head.appendChild(style);\n        }\n    }\n};\n\n},{}]},{},[4])\n\n","var ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\r\nvar MainViewController = require('./components/common/MainViewController');\r\nvar SideNavViewController = require('./components/nav/SideNavViewController');\r\nvar BeneficiaryViewController = require('./components/beneficiary/BeneficiaryViewController');\r\nvar CompanyViewController = require('./components/company/CompanyViewController');\r\nvar config = require('./config');\r\n\r\nvar moduleName = config.configBlock.namespace + '.controllers';\r\nvar controllersModule = ng.module(moduleName, [])\r\n    .controller('MainViewController', MainViewController.controller)\r\n    .controller('SideNavViewController', SideNavViewController.controller)\r\n    .controller('BeneficiaryViewController', BeneficiaryViewController.controller)\r\n    .controller('CompanyViewController', CompanyViewController.controller);\r\n\r\nexports.controllersModule = controllersModule;\r\n","var ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar MainViewDirective = require('./components/common/MainViewDirective');\nvar SideNavViewDirective = require('./components/nav/SideNavViewDirective');\nvar BeneficiaryViewDirective = require('./components/beneficiary/BeneficiaryViewDirective');\nvar BeneficiaryCreateViewDirective = require('./components/beneficiary/BeneficiaryCreateViewDirective');\nvar BeneficiaryUpdateViewDirective = require('./components/beneficiary/BeneficiaryUpdateViewDirective');\nvar BeneficiaryDeleteViewDirective = require('./components/beneficiary/BeneficiaryDeleteViewDirective');\nvar BeneficiaryListViewDirective = require('./components/beneficiary/BeneficiaryListViewDirective');\nvar BeneficiaryListFragmentViewDirective = require('./components/beneficiary/BeneficiaryListFragmentViewDirective');\nvar BeneficiaryDetailViewDirective = require('./components/beneficiary/BeneficiaryDetailViewDirective');\nvar BeneficiarySearchViewDirective = require('./components/beneficiary/BeneficiarySearchViewDirective');\nvar CompanyViewDirective = require('./components/company/CompanyViewDirective');\nvar CompanyCreateViewDirective = require('./components/company/CompanyCreateViewDirective');\nvar CompanyUpdateViewDirective = require('./components/company/CompanyUpdateViewDirective');\nvar CompanyDeleteViewDirective = require('./components/company/CompanyDeleteViewDirective');\nvar CompanyListViewDirective = require('./components/company/CompanyListViewDirective');\nvar CompanyListFragmentViewDirective = require('./components/company/CompanyListFragmentViewDirective');\nvar CompanySearchViewDirective = require('./components/company/CompanySearchViewDirective');\nvar config = require('./config');\n\nvar moduleName = config.configBlock.namespace + '.directives';\n\nvar directivesModule = ng.module(moduleName, [])\n    .directive('mainView', MainViewDirective.directive)\n    .directive('sideNavView', SideNavViewDirective.directive)\n    .directive('beneficiaryView', BeneficiaryViewDirective.directive)\n    .directive('beneficiaryCreateView', BeneficiaryCreateViewDirective.directive)\n    .directive('beneficiaryUpdateView', BeneficiaryUpdateViewDirective.directive)\n    .directive('beneficiaryDeleteView', BeneficiaryDeleteViewDirective.directive)\n    .directive('beneficiaryDetailView', BeneficiaryDetailViewDirective.directive)\n    .directive('beneficiarySearchView', BeneficiarySearchViewDirective.directive)\n    .directive('beneficiaryListView', BeneficiaryListViewDirective.directive)\n    .directive('beneficiaryListDetailView', BeneficiaryListViewDirective.directive)\n    .directive('beneficiaryListFragmentView', BeneficiaryListFragmentViewDirective.directive)\n    .directive('companyView', CompanyViewDirective.directive)\n    .directive('companyCreateView', CompanyCreateViewDirective.directive)\n    .directive('companyUpdateView', CompanyUpdateViewDirective.directive)\n    .directive('companyDeleteView', CompanyDeleteViewDirective.directive)\n    .directive('companySearchView', CompanySearchViewDirective.directive)\n    .directive('companyListView', CompanyListViewDirective.directive)\n    .directive('companyListFragmentView', CompanyListFragmentViewDirective.directive)\n\nexports.directivesModule = directivesModule;\n","var ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar BeneficiaryService = require('./components/beneficiary/BeneficiaryService');\nvar CompanyService = require('./components/company/CompanyService');\nvar UtilService = require('./components/common/UtilService');\nvar config = require('./config');\n\nvar moduleName = config.configBlock.namespace + '.services';\nvar servicesModule = ng.module(moduleName, [])\n    .factory('beneficiaryService', BeneficiaryService.service)\n    .factory('companyService', CompanyService.service)\n    .factory('utilService', UtilService.service);\n\nexports.servicesModule = servicesModule;\n","/** Main app **/\n\n'use strict';\n\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar config = require('./config');\nvar constants = require('./constants');\nvar services = require('./angularservices');\nvar controllers = require('./angularcontrollers');\nvar directives = require('./angulardirectives');\n\nvar animateModule = require('angular-animate');\nvar translateModule = require('angular-translate');\nvar sanitizeModule = require('angular-sanitize');\nvar blockUIModule = require('angular-block-ui');\nvar uiRouterModule = require('angular-ui-router');\n\nrequire('angular-block-ui/dist/angular-block-ui.min.css');\n\nvar moduleName = config.configBlock.namespace;\n\n// Declare app level module which depends on services, controllers and directives\nng.module(moduleName, [animateModule, translateModule, sanitizeModule, blockUIModule, uiRouterModule,\n    services.servicesModule.name, controllers.controllersModule.name, directives.directivesModule.name,\n    'inform', 'inform-exception'/*, 'inform-http-exception'*/\n]);\n\nng.module(moduleName)\n  .config(config.configBlock.settings)\n  .config(config.configBlock.states)\n  .config(config.configBlock.blockUI)\n  .config(config.configBlock.inform)\n  .config(config.configBlock.hrefSanitize);\n\nng.module(moduleName)\n  .constant('CONSTANTS', constants.constants);\n\nvar runBlock = function() {\n\n    // Add code that needs a run block to execute here.\n};\n\nng.module(moduleName)\n  .run(runBlock);\n  // .run(config.configBlock.modal);\n","/**\r\n * Beneficiary Form Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryCreateView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Delete Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryDeleteView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Beneficiary Detail View Component Directive\r\n *\r\n * @param {$parse} Angular parser service\r\n * @param {$rootScope} Angular rootScope service\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function($parse, $compile, $rootScope, $timeout) {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryDetailView.html',\r\n        restrict: 'AE',\r\n        //replace: true,\r\n        //transclude: true,\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        link: function(scope, el, attrs) {\r\n            $rootScope.$on('disableBeneficiary', function(ev, data) {\r\n                for (var i = 0; i < data.beneficiaries.length; i++) {\r\n                    if (data.beneficiaries[i].id === data.beneficiaryId) {\r\n                        var inputEls = angular.element(el.find('input[type=text]'));\r\n                        for (var j = 0; j < inputEls.length; j++) {\r\n                            angular.element(inputEls[j]).attr('disabled', '');\r\n                            $timeout(function() {\r\n                                $compile(inputEls[j])(scope);\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                //$compile(el)(scope);\r\n            });\r\n        }\r\n    };\r\n};\r\ndirective.$inject = [\"$parse\", \"$compile\", \"$rootScope\", \"$timeout\"];\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryListFragmentView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiaries: '=',\r\n            delref: '='\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryListView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Search Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiarySearchView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * This service helps to perform http requests (GET, POST, PUT, DELETE) for beneficiary tasks\r\n *\r\n * @param {$http} The AngularJS http service\r\n * @param {$timeout} The AngularJS timeout service\r\n *\r\n * @ngInject\r\n */\r\nvar service = function($http, $timeout) {\r\n    'use strict';\r\n\r\n    var serviceInstance = {};\r\n    serviceInstance.selectedBeneficiaryId = null;\r\n    serviceInstance.popOnDelete = null;\r\n    serviceInstance.beneficiary = null;\r\n    serviceInstance.beneficiaries = [];\r\n\r\n    serviceInstance.getBeneficiary = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'GET',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.createBeneficiary = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            data: data,\r\n            method: 'POST',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n    serviceInstance.updateBeneficiary = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'PUT',\r\n            data: data,\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.deleteBeneficiary = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'DELETE',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$http\", \"$timeout\"];\r\n\r\nexports.service = service;\r\n","/**\r\n * Beneficiary Form Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryUpdateView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Beneficiary View controller\r\n *\r\n * This controller is responsible for handing beneficiary form module related logic\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {$modal} Angular modal service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {utilService} Utility service\r\n * @param {blockUI} Block UI service\r\n * @param {inform} Inform provider service\r\n * @param {CONSTANTS} Project constants values\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function($rootScope, $scope, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, utilService, blockUI, inform, CONSTANTS) {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n    $scope.useExistingBeneficiary = false;\r\n    $scope.minimumValidBeneficiary = false;\r\n    $scope.beneficiaryId = null;\r\n    $scope.beneficiarySearched = false;\r\n    $scope.beneficiaryFound = false;\r\n    $scope.searchRequestSumbitted = false;\r\n    $scope.addRequestSubmitted = false;\r\n    $scope.addRequestAttempted = false;\r\n    $scope.updateRequestSubmitted = false;\r\n    $scope.updateRequestAttempted = false;\r\n    $scope.deleteRequestSubmitted = false;\r\n    $scope.deleteSuccessful = false;\r\n    $scope.serviceUrl = CONSTANTS.url.path;\r\n\r\n    $scope.initBeneficiary = {\r\n        \"firstName\": null,\r\n        \"lastName\": null\r\n    };\r\n\r\n    $scope.beneficiaries = beneficiaryService.beneficiaries.length > 0 ? beneficiaryService.beneficiaries : [];\r\n    $scope.beneficiary = beneficiaryService.beneficiary &&\r\n                         ($state.current.name === 'start.beneficiary.update' || $state.current.name === 'start.beneficiary.list.delete' || $state.current.name === 'start.beneficiary.search.delete') ?\r\n                         beneficiaryService.beneficiary : $scope.initBeneficiary;\r\n\r\n    $scope.resetBeneficiary = function() {\r\n        $timeout(function() {\r\n            $scope.beneficiary = $scope.initBeneficiary;\r\n            $scope.beneficiaries = [];\r\n        });\r\n    };\r\n\r\n    $scope.addBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.addRequestSubmitted = false;\r\n        beneficiaryService.beneficiary = $scope.beneficiary;\r\n        if (!utilService.isFormValid('beneficiaryDetailsForm')) {\r\n            $scope.addRequestAttempted = true;\r\n            $log.warn('form invalid');\r\n            inform.add('Invalid form. First name and Last name are required to create beneficiary', {\r\n                ttl: 3500,\r\n                type: 'danger'\r\n            });\r\n            // $scope.registerPopoverShow('#addBeneficiary');\r\n            return;\r\n        }\r\n\r\n        var beneficiaryCreateBlock = blockUI.instances.get('beneficiaryCreateBlock');\r\n        // beneficiaryCreateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        $scope.addRequestSubmitted = true;\r\n        beneficiaryService.createBeneficiary(url, $scope.beneficiary, function(result) {\r\n            $timeout(function() {\r\n                $log.info(result);\r\n                if (result && result.data) {\r\n                    if (result.data.id > 0) {\r\n                        inform.add('beneficiary created successfully.', {\r\n                            ttl: 2500\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.beneficiary', {}, {reload:true});\r\n                        }, 2500);\r\n                    } else {\r\n                        inform.add('Request completed, however beneficiary couldn\\'t be created.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating beneficiary.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.addRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // beneficiaryCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelAddBeneficiary = function() {\r\n        $state.go('start.beneficiary');\r\n    };\r\n\r\n    $scope.updateBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.updateRequestSubmitted = false;\r\n        beneficiaryService.beneficiary = $scope.beneficiary;\r\n        if (!utilService.isFormValid('beneficiaryDetailsForm')) {\r\n            $scope.updateRequestAttempted = true;\r\n            $log.warn('ccform invalid');\r\n            inform.add('Invalid form. First name and Last name are required to create beneficiary', {\r\n                ttl: 3500,\r\n                type: 'danger'\r\n            });\r\n            return;\r\n        }\r\n\r\n        // var beneficiaryUpdateBlock = blockUI.instances.get('beneficiaryUpdateBlock');\r\n        // beneficiaryUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        $scope.updateRequestSubmitted = true;\r\n        beneficiaryService.updateBeneficiary(url, $scope.beneficiary, function(result) {\r\n            $timeout(function() {\r\n                if (result && result.data) {\r\n                    if (result.data.status === true) {\r\n                        inform.add('beneficiary updated successfully.', {\r\n                            ttl: 4000\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.beneficiary.list', {}, {reload: true});\r\n                        }, 4500);\r\n                    } else {\r\n                        inform.add('Request completed successfully, but no update performed on beneficiary.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'beneficiary couldn\\'t be updated.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.updateRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // beneficiaryUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseBeneficiaryUpdate = function() {\r\n        $state.go('start.beneficiary.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.deleteBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.beneficiary = beneficiaryService.beneficiary;\r\n        // var beneficiaryUpdateBlock = blockUI.instances.get('beneficiaryUpdateBlock');\r\n        // beneficiaryUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + $scope.beneficiary.id;\r\n        beneficiaryService.deleteBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.deleteRequestSubmitted = true;\r\n                if (result && result.data && result.data.status === true) {\r\n                    $scope.deleteSuccessful = true;\r\n                } else {\r\n                  $log.info(result);\r\n                }\r\n                // beneficiaryUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseBeneficiaryDelete = function() {\r\n        $scope.$dismiss();\r\n        $state.go('start.beneficiary.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.fetchBeneficiary = function(id) {\r\n        $scope.beneficiaries.splice(0, $scope.beneficiaries.length);\r\n\r\n        var idSearch = !utilService.isBlank(id);\r\n        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        var url = idSearch ? baseUrl + '/' + id : baseUrl;\r\n        //var beneficiaryListBlock = blockUI.instances.get('beneficiaryListBlock');\r\n        //beneficiaryListBlock.start();\r\n        beneficiaryService.getBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.searchRequestSumbitted = true;\r\n                if (result && result.data) {\r\n                    if (idSearch) {\r\n                        $scope.beneficiaries.push(result.data);\r\n                    } else {\r\n                        $scope.beneficiaries = result.data;\r\n                    }\r\n                    beneficiaryService.beneficiaries = $scope.beneficiaries;\r\n                    $scope.beneficiaryFound = true;\r\n                }\r\n                //beneficiaryListBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.searchBeneficiary = function(id, $event) {\r\n        $event.stopPropagation();\r\n        $timeout(function() {\r\n            if (!utilService.isValidId(id)) {\r\n                $scope.registerPopoverShow('#searchExistingBeneficiaryId');\r\n                return;\r\n            }\r\n            $scope.fetchBeneficiary(id);\r\n        });\r\n    };\r\n\r\n    $scope.mutateBeneficiaryOptions = function(beneficiary, $index, $event) {\r\n        $event.stopPropagation();\r\n        beneficiaryService.selectedBeneficiaryId = '#beneficiary' + $index;\r\n        beneficiaryService.beneficiary = beneficiary;\r\n        $scope.registerPopoverPrep(beneficiaryService.selectedBeneficiaryId);\r\n        $scope.registerPopoverShow(beneficiaryService.selectedBeneficiaryId);\r\n    };\r\n\r\n    /* initialize popover */\r\n\r\n    $scope.discardMessage = function($event) {\r\n        $event ? $event.stopPropagation() : '';\r\n        beneficiaryService.popOnDelete = \"delete\";\r\n        $scope.registerPopoverHide('[id*=popover]');\r\n    };\r\n\r\n    beneficiaryService.popOnDelete = \"delete\";\r\n\r\n    $scope.registerPopoverPrep = function(id) {\r\n        angular.element($document.find(id)).popover({\r\n            trigger: 'manual'\r\n        });\r\n    };\r\n\r\n    $scope.registerPopoverShow = function(id) {\r\n        if (beneficiaryService.popOnDelete !== \"popover\") {\r\n            beneficiaryService.popOnDelete = \"popover\";\r\n            angular.element($document.find(id)).popover('show');\r\n        }\r\n    };\r\n\r\n    $scope.registerPopoverHide = function(id) {\r\n        var el = angular.element($document.find(id));\r\n        el ? el.popover('hide') : '';\r\n    };\r\n\r\n    $scope.registerPopoverPrep('#removeBeneficiary');\r\n    $scope.registerPopoverPrep('#addBeneficiary');\r\n    $scope.registerPopoverPrep('#updateBeneficiary');\r\n    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');\r\n    $scope.registerPopoverHide('[id*=popover]');\r\n\r\n    // clear all informs\r\n    inform.clear();\r\n};\r\ncontroller.$inject = [\"$rootScope\", \"$scope\", \"$timeout\", \"$window\", \"$document\", \"$log\", \"$state\", \"$modal\", \"beneficiaryService\", \"utilService\", \"blockUI\", \"inform\", \"CONSTANTS\"];\r\n\r\nexports.controller = controller;\r\n","/**\r\n * Main Beneficiary Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Main View controller\r\n *\r\n * This controller is responsible for handing request from main view\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function() {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n};\r\n\r\nexports.controller = controller;\r\n","/**\r\n * Main Directive\r\n *\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/common/MainView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'MainViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","var stateConfig = {\r\n    /**\r\n     * Default to <company-create-view />\r\n     */\r\n    main: {\r\n        url: '/',\r\n        views: {\r\n            'main': {\r\n                template: '<main-view></main-view>'\r\n            },\r\n            'mainItem@start': {\r\n                template: '<company-create-view></company-create-view>'\r\n            }\r\n        }\r\n    },\r\n    company: {\r\n        initial: {\r\n            url: 'company',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-view></company-view>'\r\n                }\r\n            }\r\n        },\r\n        list: {\r\n            url: '/list',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-list-view></company-list-view>'\r\n                }\r\n            }\r\n        },\r\n        search: {\r\n            url: '/search',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-search-view></company-search-view>'\r\n                }\r\n            }\r\n        },\r\n        update: {\r\n            url: '/update',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-update-view></company-update-view>'\r\n                }\r\n            }\r\n        },\r\n        delete: {\r\n            // would be used under start.company.list state, hence url resolves to: #/company/list/delete\r\n            url: '/delete',\r\n            /**\r\n             * On state enter event listener\r\n             * @param  {$modal} Modal service\r\n             * @ngInject\r\n             */\r\n            onEnter: [\"$modal\", function($modal) {\r\n                $modal.open({\r\n                    template: '<company-delete-view></company-delete-view>',\r\n                    backdrop: 'static',\r\n                    keyboard: false,\r\n                    windowClass: 'modal',\r\n                    controller: 'CompanyViewController'\r\n                });\r\n            }]\r\n        }\r\n    },\r\n    beneficiary: {\r\n        initial: {\r\n            url: 'beneficiary',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-view></beneficiary-view>'\r\n                }\r\n            }\r\n        },\r\n        list: {\r\n            url: '/list',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-list-view></beneficiary-list-view>'\r\n                }\r\n            }\r\n        },\r\n        search: {\r\n            url: '/search',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-search-view></beneficiary-seach-view>'\r\n                }\r\n            }\r\n        },\r\n        update: {\r\n            url: '/update',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-update-view></beneficiary-update-view>'\r\n                }\r\n            }\r\n        },\r\n        delete: {\r\n            /** would be used under start.beneficiary.list or start.beneficiary.search state,\r\n             *  hence url resolves to: #/beneficiary/list/delete or  #/beneficiary/search/delete\r\n             */\r\n            url: '/delete',\r\n            /**\r\n             * On state enter event listener\r\n             * @param  {$modal} Modal service\r\n             * @ngInject\r\n             */\r\n            onEnter: [\"$modal\", function($modal) {\r\n                $modal.open({\r\n                    template: '<beneficiary-delete-view></beneficiary-delete-view>',\r\n                    backdrop: 'static',\r\n                    keyboard: false,\r\n                    windowClass: 'modal',\r\n                    controller: 'BeneficiaryViewController'\r\n                });\r\n            }]\r\n        }\r\n    }\r\n};\r\n\r\nexports.stateConfig = stateConfig;\r\n","/**\r\n * This service provide custom word lookup for case normalization if one is not provided by the service client\r\n *\r\n * @param {$window} The angular window service\r\n * @ngInject\r\n */\r\nvar service = function($window) {\r\n    'use strict';\r\n    var serviceInstance = {};\r\n\r\n    serviceInstance.isFormValid = function(formId) {\r\n        var isValid = true;\r\n        var formEl = $window.document.getElementById(formId);\r\n        console.log(formEl);\r\n        if (!formEl || (formEl && formEl.className && formEl.className.indexOf('ng-invalid') > -1)) return false;\r\n        // otherwise, perform sanity check\r\n        var elements = $window.document.getElementById(formId).elements;\r\n        for (var i = 0, element = elements[i++]; i < elements.length; i++) {\r\n            if ((element.type === 'text' || element.type === 'checkbox' || element.type === 'radio' || element.type === 'date' || element.type === 'datetime-local' || element.type === 'email' || element.type === 'month' || element.type === 'number' || element.type === 'time' || element.type === 'url' || element.type === 'week' || element.type === 'textarea' || element.type === 'select') && (element.className.indexOf('ng-invalid') > -1)) {\r\n                isValid = false;\r\n                return isValid;\r\n            }\r\n        }\r\n\r\n        return isValid;\r\n    };\r\n\r\n    serviceInstance.isBlank = function(value) {\r\n        return angular.isUndefined(value) || value === null || value.length === 0;\r\n    };\r\n\r\n    serviceInstance.isValidId = function(id) {\r\n        return parseInt(id) >= 1;\r\n    }\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$window\"];\r\n\r\nexports.service = service;\r\n","/**\r\n * Company Create Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyCreateView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Delete Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyDeleteView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function() {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyListFragmentView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            companies: '=',\r\n            delref: '='\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyListView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Search Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanySearchView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * This service helps to perform http requests (GET, POST, PUT, DELETE) for company tasks\r\n *\r\n * @param {$http} The AngularJS http service\r\n * @param {$timeout} The AngularJS timeout service\r\n *\r\n * @ngInject\r\n */\r\nvar service = function($http, $timeout) {\r\n    'use strict';\r\n\r\n    var serviceInstance = {};\r\n    serviceInstance.selectedCompanyId = null;\r\n    serviceInstance.popOnDelete = null;\r\n    serviceInstance.company = null;\r\n    serviceInstance.companies = [];\r\n\r\n    serviceInstance.getCompany = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'GET',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.createCompany = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            data: data,\r\n            method: 'POST',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n    serviceInstance.updateCompany = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'PUT',\r\n            data: data,\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.deleteCompany = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'DELETE',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$http\", \"$timeout\"];\r\n\r\nexports.service = service;\r\n","/**\r\n * Company Update Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyUpdateView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company View controller\r\n *\r\n * This controller is responsible for handing company form module related logic\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$q} Angular promise service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {$modal} Angular modal service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n * @param {utilService} Utility service\r\n * @param {blockUI} Block UI service\r\n * @param {inform} Inform provider service\r\n * @param {CONSTANTS} Project constants values\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function($rootScope, $scope, $q, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, companyService, utilService, blockUI, inform, CONSTANTS) {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n    $scope.useExistingBeneficiary = false;\r\n    $scope.minimumValidBeneficiary = false;\r\n    $scope.beneficiaryId = null;\r\n    $scope.beneficiarySearched = false;\r\n    $scope.beneficiaryFound = false;\r\n    $scope.companyFound = false;\r\n    $scope.searchRequestSumbitted = false;\r\n    $scope.addRequestSubmitted = false;\r\n    $scope.updateRequestSubmitted = false;\r\n    $scope.deleteRequestSubmitted = false;\r\n    $scope.deleteSuccessful = false;\r\n    $scope.serviceUrl = CONSTANTS.url.path;\r\n\r\n    $scope.initCompany = {\r\n        \"name\": null,\r\n        \"address\": null,\r\n        \"city\": null,\r\n        \"country\": null,\r\n        \"email\": null,\r\n        \"phoneNumber\": null,\r\n        \"beneficiaries\": [{\r\n            \"id\": -1,\r\n            \"firstName\": null,\r\n            \"lastName\": null\r\n        }]\r\n    };\r\n\r\n    $scope.companies = companyService.companies.length > 0 ? companyService.companies : [];\r\n    $scope.company = companyService.company &&\r\n                    ($state.current.name === 'start.company.update' || $state.current.name === 'start.company.list.delete' || $state.current.name === 'start.company.search.delete') ?\r\n                    companyService.company : $scope.initCompany;\r\n\r\n    $scope.verifyMinimumValidBeneficiary = function() {\r\n        for (var i = 0; i < $scope.company.beneficiaries.length; i++) {\r\n            $scope.minimumValidBeneficiary = $scope.company.beneficiaries[i].id !== -1 ||\r\n                                            (!utilService.isBlank($scope.company.beneficiaries[i].firstName) && !utilService.isBlank($scope.company.beneficiaries[i].lastName));\r\n            if ($scope.minimumValidBeneficiary) {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n\r\n    $scope.resetCompany = function() {\r\n        $timeout(function() {\r\n            $scope.company = $scope.initCompany;\r\n            $scope.companies = [];\r\n        });\r\n    };\r\n\r\n    $scope.addCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.addRequestSubmitted = false;\r\n        companyService.company = $scope.company;\r\n        if (utilService.isFormValid('companyDetailsForm')) {\r\n            $scope.verifyMinimumValidBeneficiary();\r\n            if (!$scope.minimumValidBeneficiary) {\r\n                $scope.registerPopoverShow('#addCompany');\r\n                return;\r\n            }\r\n            $log.info('valid');\r\n        } else {\r\n            $log.warn('form invalid');\r\n            return;\r\n        }\r\n\r\n        var companyCreateBlock = blockUI.instances.get('companyCreateBlock');\r\n        // companyCreateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        $scope.addRequestSubmitted = true;\r\n        companyService.createCompany(url, $scope.company, function(result) {\r\n            $timeout(function() {\r\n                if (result && result.data) {\r\n                    if (result.data.id > 0) {\r\n                        inform.add('Company created successfully.', {\r\n                            ttl: 2500\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.company', {}, {reload:true});\r\n                        }, 2500);\r\n                    } else {\r\n                        inform.add('Request completed, however company couldn\\'t be created.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating company.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.addRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // companyCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelAddCompany = function() {\r\n        $state.go('start.company');\r\n    };\r\n\r\n    $scope.updateCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.updateRequestSubmitted = false;\r\n        companyService.company = $scope.company;\r\n        if (utilService.isFormValid('companyUpdateForm')) {\r\n            $scope.verifyMinimumValidBeneficiary();\r\n            if (!$scope.minimumValidBeneficiary) {\r\n                $scope.registerPopoverShow('#updateCompany');\r\n                return;\r\n            }\r\n        } else {\r\n            $log.warn('form invalid');\r\n            return;\r\n        }\r\n\r\n        // var companyUpdateBlock = blockUI.instances.get('companyUpdateBlock');\r\n        // companyUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        $scope.updateRequestSubmitted = true;\r\n        companyService.updateCompany(url, $scope.company, function(result) {\r\n            $timeout(function() {\r\n                if (result && result.data) {\r\n                    if (result.data.status === true) {\r\n                        inform.add('Company updated successfully.', {\r\n                            ttl: 4000\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.company.list', {}, {reload: true});\r\n                        }, 4500);\r\n                    } else {\r\n                        inform.add('Request completed successfully, but no update performed on company.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Company couldn\\'t be updated.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.updateRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // companyUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseCompanyUpdate = function() {\r\n        $state.go('start.company.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.deleteCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.company = companyService.company;\r\n        // var companyUpdateBlock = blockUI.instances.get('companyUpdateBlock');\r\n        // companyUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath + '/' + $scope.company.id;\r\n        companyService.deleteCompany(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.deleteRequestSubmitted = true;\r\n                if (result && result.data && result.data.status === true) {\r\n                    $scope.deleteSuccessful = true;\r\n                }\r\n                // companyUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseCompanyDelete = function() {\r\n        $scope.$dismiss();\r\n        $state.go('start.company.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.fetchCompany = function(id) {\r\n        $scope.companies.splice(0, $scope.companies.length);\r\n\r\n        var idSearch = !utilService.isBlank(id);\r\n        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        var url = idSearch ? baseUrl + '/' + id : baseUrl;\r\n        //var companyListBlock = blockUI.instances.get('companyListBlock');\r\n        //companyListBlock.start();\r\n        companyService.getCompany(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.searchRequestSumbitted = true;\r\n                if (result && result.data) {\r\n                    if (idSearch) {\r\n                        $scope.companies.push(result.data);\r\n                    } else {\r\n                        $scope.companies = result.data;\r\n                    }\r\n                    companyService.companies = $scope.companies;\r\n                    $scope.companyFound = true;\r\n                }\r\n                //companyListBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.searchCompany = function(id, $event) {\r\n        $event.stopPropagation();\r\n        $timeout(function() {\r\n            if (!utilService.isValidId(id)) {\r\n                $scope.registerPopoverShow('#searchExistingCompanyId');\r\n                return;\r\n            }\r\n            $scope.fetchCompany(id);\r\n        });\r\n    };\r\n\r\n    $scope.searchBeneficiary = function(id, $event) {\r\n        $event.stopPropagation();\r\n\r\n        if (!utilService.isValidId(id)) {\r\n            $scope.registerPopoverShow('#searchExistingBeneficiaryId');\r\n            return;\r\n        }\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + id;\r\n\r\n        var companySearchBlock = blockUI.instances.get('companySearchBlock');\r\n        companySearchBlock.start();\r\n        beneficiaryService.findBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.beneficiarySearched = true;\r\n                if (result && result.data) {\r\n                    $scope.verifyMinimumValidBeneficiary();\r\n                    // remove all empty forms\r\n                    if (!$scope.minimumValidBeneficiary) {\r\n                        $scope.company.beneficiaries.splice(0, $scope.company.beneficiaries.length);\r\n                    }\r\n                    $scope.company.beneficiaries.push(result.data);\r\n                    $scope.disableBeneficiary(result.data.id);\r\n                    $scope.minimumValidBeneficiary = true;\r\n                    $scope.beneficiaryFound = true;\r\n                    $scope.beneficiaryId = null;\r\n                }\r\n                companySearchBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.mutateCompanyOptions = function(company, $index, $event) {\r\n        $event.stopPropagation();\r\n        companyService.selectedCompanyId = '#company' + $index;\r\n        companyService.company = company;\r\n        $scope.registerPopoverPrep(companyService.selectedCompanyId);\r\n        $scope.registerPopoverShow(companyService.selectedCompanyId);\r\n    };\r\n\r\n    $scope.addBeneficiary = function() {\r\n        $scope.company.beneficiaries.push({\r\n            \"firstName\": \"\",\r\n            \"lastName\": \"\"\r\n        });\r\n    };\r\n\r\n    $scope.removeBeneficiary = function($event, beneficiary) {\r\n        $event.stopPropagation();\r\n        if ($scope.company.beneficiaries.indexOf(beneficiary) != -1) {\r\n            $timeout(function() {\r\n                if ($scope.company.beneficiaries.length === 1) {\r\n                    $scope.registerPopoverShow('#removeBeneficiary');\r\n                    return;\r\n                }\r\n                $scope.company.beneficiaries.splice($scope.company.beneficiaries.indexOf(beneficiary), 1);\r\n            });\r\n        }\r\n    };\r\n\r\n    $scope.disableBeneficiary = function(beneficiaryId) {\r\n        $rootScope.$emit('disableBeneficiary', {\r\n            beneficiaries: $scope.company.beneficiaries,\r\n            beneficiaryId: beneficiaryId\r\n        });\r\n    }\r\n\r\n    /* initialize popover */\r\n\r\n    $scope.discardMessage = function($event) {\r\n        $event ? $event.stopPropagation() : '';\r\n        companyService.popOnDelete = \"delete\";\r\n        $scope.registerPopoverHide('[id*=popover]');\r\n    };\r\n\r\n    companyService.popOnDelete = \"delete\";\r\n\r\n    $scope.registerPopoverPrep = function(id) {\r\n        angular.element($document.find(id)).popover({\r\n            trigger: 'manual'\r\n        });\r\n    };\r\n\r\n    $scope.registerPopoverShow = function(id) {\r\n        if (companyService.popOnDelete !== \"popover\") {\r\n            companyService.popOnDelete = \"popover\";\r\n            angular.element($document.find(id)).popover('show');\r\n        }\r\n    };\r\n\r\n    $scope.registerPopoverHide = function(id) {\r\n        var el = angular.element($document.find(id));\r\n        el ? el.popover('hide') : '';\r\n    };\r\n\r\n    $scope.registerPopoverPrep('#removeBeneficiary');\r\n    $scope.registerPopoverPrep('#addCompany');\r\n    $scope.registerPopoverPrep('#updateCompany');\r\n    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');\r\n    $scope.registerPopoverPrep('#searchExistingCompanyId');\r\n    $scope.registerPopoverHide('[id*=popover]');\r\n\r\n    // clear all informs\r\n    inform.clear();\r\n};\r\ncontroller.$inject = [\"$rootScope\", \"$scope\", \"$q\", \"$timeout\", \"$window\", \"$document\", \"$log\", \"$state\", \"$modal\", \"beneficiaryService\", \"companyService\", \"utilService\", \"blockUI\", \"inform\", \"CONSTANTS\"];\r\n\r\nexports.controller = controller;\r\n","/**\r\n * Main Company Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyView.html',\r\n        restrict: 'AE',\r\n        scope: false\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Side Nav View controller\r\n *\r\n * This controller is responsible for handing request from side nav\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function() {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n};\r\n\r\nexports.controller = controller;\r\n","/**\r\n * Side Nav Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/nav/SideNavView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'SideNavViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","var translationsEN = {\n    \"BENEFICIARY\": {\n        \"ID\": \"Id\",\n        \"FIRST_NAME\": \"First name\",\n        \"LAST_NAME\": \"Last name\"\n    }\n};\n\nexports.translationsEN = translationsEN;\n","'use strict';\r\n\r\nvar states = require('./components/common/States');\r\nvar configBlock = {\r\n    /**\r\n     * @param {$logProvider} The log provider service\r\n     * @param {$translateProvider} The angular translate service\r\n     * @ngInject\r\n     */\r\n    settings: [\"$logProvider\", \"$translateProvider\", function($logProvider, $translateProvider) {\r\n        $logProvider.debugEnabled(true); // Turns global logging with $log.debug on\r\n\r\n        var i18n_en = require('./components/nls/i18n-en');\r\n        $translateProvider.useSanitizeValueStrategy('sanitizeParameters');\r\n        $translateProvider.translations('en', i18n_en.translationsEN).useStaticFilesLoader({\r\n                files: [{\r\n                    prefix: './components/nls/i18n-',\r\n                    suffix: '.json'\r\n                }]\r\n            })\r\n            .preferredLanguage('en')\r\n            .fallbackLanguage('en');\r\n    }],\r\n    /**\r\n     * @param {$stateProvider} $stateProvider The UI router stateProvider service\r\n     * @param {$urlRouterProvider} The UI router urlRouterProvider service\r\n     * @param {$modalStateProvider} The custom modal state provider service\r\n     * @ngInject\r\n     */\r\n    states: [\"$stateProvider\", \"$urlRouterProvider\", function($stateProvider, $urlRouterProvider) {\r\n        $urlRouterProvider.otherwise('/');\r\n        $stateProvider\r\n            .state('start', states.stateConfig.main)\r\n            .state('start.company', states.stateConfig.company.initial)\r\n            .state('start.company.list', states.stateConfig.company.list)\r\n            .state('start.company.list.delete',  angular.copy(states.stateConfig.company.delete))\r\n            .state('start.company.search', states.stateConfig.company.search)\r\n            .state('start.company.search.delete', angular.copy(states.stateConfig.company.delete))\r\n            .state('start.company.update', states.stateConfig.company.update)\r\n            .state('start.beneficiary', states.stateConfig.beneficiary.initial)\r\n            .state('start.beneficiary.list', states.stateConfig.beneficiary.list)\r\n            .state('start.beneficiary.list.delete', angular.copy(states.stateConfig.beneficiary.delete))\r\n            .state('start.beneficiary.search', states.stateConfig.beneficiary.search)\r\n            .state('start.beneficiary.search.delete', angular.copy(states.stateConfig.beneficiary.delete))\r\n            .state('start.beneficiary.update', states.stateConfig.beneficiary.update)\r\n    }],\r\n\r\n    /**\r\n     * @param  {blockUIConfig} The block UI config service\r\n     * @ngInject\r\n     */\r\n    blockUI: [\"blockUIConfig\", function(blockUIConfig) {\r\n        blockUIConfig.delay = 100;\r\n        blockUIConfig.autoBlock = false;\r\n        blockUIConfig.autoInjectBodyBlock = false;\r\n        blockUIConfig.template = '<div><img src=\"dist/images/ajax-loader.gif\" /> Processing...</h1>';\r\n    }],\r\n\r\n    /**\r\n     * @param  {informProvider} The inform provider service\r\n     * @ngInject\r\n     */\r\n    inform: [\"informProvider\", function(informProvider) {\r\n        informProvider.defaults({\r\n            /**\r\n             * The time to live for the message in milliseconds.\r\n             * Default value is 5000. Specify <0 to make the message sticky.\r\n             */\r\n            ttl: -1,\r\n\r\n            /**\r\n             * The type of message to enable styling.\r\n             * Values can be 'default', 'primary', 'success', 'info', 'warning', 'danger' or any other custom required type.\r\n             * Default value is 'info'. If 'default' is specified as value, then 'info' is used\r\n             */\r\n            type: 'success',\r\n            /**\r\n             * Allow html formatting\r\n             * Default value is false\r\n             */\r\n            html: true\r\n        });\r\n    }],\r\n\r\n    /**\r\n     * Modal block\r\n     * @param  {$rootScope}  Angular root scope service\r\n     * @param  {$modalStack} Angular UI modal stack\r\n     * @ngInject\r\n     */\r\n    modal: [\"$rootScope\", \"$modalStack\", function($rootScope, $modalStack) {\r\n        $rootScope.$on('$stateChangeStart', function() {\r\n            var top = $modalStack.getTop();\r\n            if (top) {\r\n                $modalStack.dismiss(top.key);\r\n            }\r\n        });\r\n    }],\r\n\r\n    /**\r\n     * Href sanitization whitelist\r\n     * @param  {$compileProvide} Angular compile provider service\r\n     * @ngInject\r\n     */\r\n    hrefSanitize: [\"$compileProvider\", function($compileProvider) {\r\n        $compileProvider.aHrefSanitizationWhitelist(/^\\s*(https?|ftp|mailto|file|chrome-extension|blob:chrome-extension):/);\r\n    }],\r\n\r\n    namespace: 'com.companyregistry'\r\n};\r\n\r\nexports.configBlock = configBlock;\r\n","'use strict';\r\n\r\nexports.constants = {\r\n    url: {\r\n\t\t\t\t// path: 'http://localhost:8080/companyregistry',\r\n\t\t\t\tpath: 'https://companyregistry.herokuapp.com',\r\n        companyContextPath: 'companies',\r\n        beneficiaryContextPath: 'beneficiaries'\r\n    }\r\n};\r\n","/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* jshint ignore:start */\nvar noop        = angular.noop;\nvar extend      = angular.extend;\nvar jqLite      = angular.element;\nvar forEach     = angular.forEach;\nvar isArray     = angular.isArray;\nvar isString    = angular.isString;\nvar isObject    = angular.isObject;\nvar isUndefined = angular.isUndefined;\nvar isDefined   = angular.isDefined;\nvar isFunction  = angular.isFunction;\nvar isElement   = angular.isElement;\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar isPromiseLike = function(p) {\n  return p && p.then ? true : false;\n};\n\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return [];\n        break;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n        break;\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  }\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationOptions(element, target, newOptions) {\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof angular.element) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncancelled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\nvar $$AnimateChildrenDirective = [function() {\n  return function(scope, element, attrs) {\n    var val = attrs.ngAnimateChildren;\n    if (angular.isString(val) && val.length === 0) { //empty attribute\n      element.data(NG_ANIMATE_CHILDREN_DATA, true);\n    } else {\n      attrs.$observe('ngAnimateChildren', function(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      });\n    }\n  };\n}];\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and stlyes may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n * * `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occuring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a colapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for zegative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$animate',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $animate) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = \"$$ngAnimateParentKey\";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an interal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var cancelLastRAFRequest;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, options) {\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$animate.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle = parseFloat(options.delay);\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            value ? node.style.setProperty(prop, value)\n                  : node.style.removeProperty(prop);\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        var startTime, events = [];\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidently cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intential stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          element.on(events.join(' '), onAnimationProgress);\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n\n        function onAnimationProgress(event) {\n          event.stopPropagation();\n          var ev = event.originalEvent || event;\n          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();\n\n          /* Firefox (or possibly just Gecko) likes to not round values up\n           * when a ms measurement is used for the animation */\n          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n          /* $manualTimeStamp is a mocked timeStamp value which is set\n           * within browserTrigger(). This is only here so that tests can\n           * mock animations properly. Real events fallback to event.timeStamp,\n           * or, if they don't, then a timeStamp is automatically created for them.\n           * We're checking to see if the timeStamp surpasses the expected delay,\n           * but we're using elapsedTime instead of the timeStamp on the 2nd\n           * pre-condition since animations sometimes close off early */\n          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n            // we set this flag to ensure that if the transition is paused then, when resumed,\n            // the animation will automatically close itself since transitions cannot be paused.\n            animationCompleted = true;\n            close();\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragement case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coods object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      return {\n        start: function() {\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          var animationClosed = false;\n          var runner = new $$AnimateRunner({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            animationClosed = true;\n            applyOptions();\n            applyAnimationStyles(element, options);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(options, and) {\n    options = options || {};\n    var a = (options.addClass || '').length > 0;\n    var b = (options.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    var nO = newAnimation.options;\n    var cO = currentAnimation.options;\n\n    // if the exact same CSS class is added/removed then it's safe to cancel it\n    return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = {};\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationOptions(element, options) {\n      return mergeAnimationOptions(element, options, {});\n    }\n\n    function findCallbacks(element, event) {\n      var targetNode = getDomNode(element);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (entry.node.contains(targetNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    return {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n      },\n\n      off: function(event, container, callback) {\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n\n        function filterFromRegistry(list, matchContainer, matchCallback) {\n          var containerNode = extractElementNode(matchContainer);\n          return list.filter(function(entry) {\n            var isMatch = entry.node === containerNode &&\n                            (!matchCallback || entry.callback === matchCallback);\n            return !isMatch;\n          });\n        }\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n            var recordExists = disabledElementsLookup.get(node);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !recordExists;\n            } else {\n              // (element, bool) - Element setter\n              bool = !!bool;\n              if (!bool) {\n                disabledElementsLookup.put(node, true);\n              } else if (recordExists) {\n                disabledElementsLookup.remove(node);\n              }\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    function queueAnimation(element, event, options) {\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        close();\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationOptions(element, existingAnimation.options, options);\n            return existingAnimation.runner;\n          }\n        }\n\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationOptions(element, options);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationOptions(element, options);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation.options);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails.options));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n            });\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        switch (state) {\n          case RUNNING_STATE:\n            animationDetails.runner.end();\n            /* falls through */\n          case PRE_DIGEST_STATE:\n            if (animationDetails) {\n              activeAnimationsLookup.remove(child);\n            }\n            break;\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n\n      var parentHost = element.data(NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      while (parentElement && parentElement.length) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        var parentNode = parentElement[0];\n        if (parentNode.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentNode) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n          if (!rootElementDetected) {\n            parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);\n            if (parentHost) {\n              parentElement = parentHost;\n            }\n          }\n        }\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be apart of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        parentElement = parentElement.parent();\n      }\n\n      var allowAnimation = !parentAnimationDetected || animateChildren;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$AnimateAsyncRunFactory = ['$$rAF', function($$rAF) {\n  var waitQueue = [];\n\n  function waitForTick(fn) {\n    waitQueue.push(fn);\n    if (waitQueue.length > 1) return;\n    $$rAF(function() {\n      for (var i = 0; i < waitQueue.length; i++) {\n        waitQueue[i]();\n      }\n      waitQueue = [];\n    });\n  }\n\n  return function() {\n    var passed = false;\n    waitForTick(function() {\n      passed = true;\n    });\n    return function(callback) {\n      passed ? callback() : waitForTick(callback);\n    };\n  };\n}];\n\nvar $$AnimateRunnerFactory = ['$q', '$sniffer', '$$animateAsyncRun',\n                      function($q,   $sniffer,   $$animateAsyncRun) {\n\n  var INITIAL_STATE = 0;\n  var DONE_PENDING_STATE = 1;\n  var DONE_COMPLETE_STATE = 2;\n\n  AnimateRunner.chain = function(chain, callback) {\n    var index = 0;\n\n    next();\n    function next() {\n      if (index === chain.length) {\n        callback(true);\n        return;\n      }\n\n      chain[index](function(response) {\n        if (response === false) {\n          callback(false);\n          return;\n        }\n        index++;\n        next();\n      });\n    }\n  };\n\n  AnimateRunner.all = function(runners, callback) {\n    var count = 0;\n    var status = true;\n    forEach(runners, function(runner) {\n      runner.done(onProgress);\n    });\n\n    function onProgress(response) {\n      status = status && response;\n      if (++count === runners.length) {\n        callback(status);\n      }\n    }\n  };\n\n  function AnimateRunner(host) {\n    this.setHost(host);\n\n    this._doneCallbacks = [];\n    this._runInAnimationFrame = $$animateAsyncRun();\n    this._state = 0;\n  }\n\n  AnimateRunner.prototype = {\n    setHost: function(host) {\n      this.host = host || {};\n    },\n\n    done: function(fn) {\n      if (this._state === DONE_COMPLETE_STATE) {\n        fn();\n      } else {\n        this._doneCallbacks.push(fn);\n      }\n    },\n\n    progress: noop,\n\n    getPromise: function() {\n      if (!this.promise) {\n        var self = this;\n        this.promise = $q(function(resolve, reject) {\n          self.done(function(status) {\n            status === false ? reject() : resolve();\n          });\n        });\n      }\n      return this.promise;\n    },\n\n    then: function(resolveHandler, rejectHandler) {\n      return this.getPromise().then(resolveHandler, rejectHandler);\n    },\n\n    'catch': function(handler) {\n      return this.getPromise()['catch'](handler);\n    },\n\n    'finally': function(handler) {\n      return this.getPromise()['finally'](handler);\n    },\n\n    pause: function() {\n      if (this.host.pause) {\n        this.host.pause();\n      }\n    },\n\n    resume: function() {\n      if (this.host.resume) {\n        this.host.resume();\n      }\n    },\n\n    end: function() {\n      if (this.host.end) {\n        this.host.end();\n      }\n      this._resolve(true);\n    },\n\n    cancel: function() {\n      if (this.host.cancel) {\n        this.host.cancel();\n      }\n      this._resolve(false);\n    },\n\n    complete: function(response) {\n      var self = this;\n      if (self._state === INITIAL_STATE) {\n        self._state = DONE_PENDING_STATE;\n        self._runInAnimationFrame(function() {\n          self._resolve(response);\n        });\n      }\n    },\n\n    _resolve: function(response) {\n      if (this._state !== DONE_COMPLETE_STATE) {\n        forEach(this._doneCallbacks, function(fn) {\n          fn(response);\n        });\n        this._doneCallbacks.length = 0;\n        this._state = DONE_COMPLETE_STATE;\n      }\n    }\n  };\n\n  return AnimateRunner;\n}];\n\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effictively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check\n\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          getRunner(element).setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/* global angularAnimateModule: true,\n\n   $$AnimateAsyncRunFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateRunnerFactory,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,\n*/\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=true\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the ainmation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       }).start();\n*        runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       }).start();\n *\n *       runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n *\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix\n * will be evaluated for animation when any DOM changes occur in the application.\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [])\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .factory('$$AnimateRunner', $$AnimateRunnerFactory)\n  .factory('$$animateAsyncRun', $$AnimateAsyncRunFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n","require('./angular-animate');\nmodule.exports = 'ngAnimate';\n","/*!\n   angular-block-ui v0.2.0\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\n   License: MIT\n*/\n(function(angular) {\n\nvar blkUI = angular.module('blockUI', []);\n\nblkUI.config([\"$provide\", \"$httpProvider\", function ($provide, $httpProvider) {\n\n  $provide.decorator('$exceptionHandler', ['$delegate', '$injector',\n    function ($delegate, $injector) {\n      var blockUI, blockUIConfig;\n\n      return function (exception, cause) {\n\n        blockUIConfig = blockUIConfig || $injector.get('blockUIConfig');\n\n        if (blockUIConfig.resetOnException) {\n          try {\n            blockUI = blockUI || $injector.get('blockUI');\n            blockUI.instances.reset();\n          } catch (ex) {\n            console.log('$exceptionHandler', exception);\n          }\n        }\n\n        $delegate(exception, cause);\n      };\n    }\n  ]);\n\n  $httpProvider.interceptors.push('blockUIHttpInterceptor');\n}]);\n\nblkUI.run([\"$document\", \"blockUIConfig\", \"$templateCache\", function ($document, blockUIConfig, $templateCache) {\n  if (blockUIConfig.autoInjectBodyBlock) {\n    $document.find('body').attr('block-ui', 'main');\n  }\n\n  if (blockUIConfig.template) {\n\n    // Swap the builtin template with the custom template.\n    // Create a magic cache key and place the template in the cache.\n\n    blockUIConfig.templateUrl = '$$block-ui-template$$';\n    $templateCache.put(blockUIConfig.templateUrl, blockUIConfig.template);\n  }\n}]);\n\nfunction moduleLoaded(name) {\n  try {\n    angular.module(name);\n  } catch(ex) {\n    return false;\n  }\n  return true;\n}\nblkUI.config([\"$provide\", function ($provide) {\n  $provide.decorator('$location', decorateLocation);\n}]);\n\nvar decorateLocation = [\n  '$delegate', 'blockUI', 'blockUIConfig',\n  function ($delegate, blockUI, blockUIConfig) {\n\n    if (blockUIConfig.blockBrowserNavigation) {\n\n      blockUI.$_blockLocationChange = true;\n\n      var overrides = ['url', 'path', 'search', 'hash', 'state'];\n\n      function hook(f) {\n        var s = $delegate[f];\n        $delegate[f] = function () {\n\n          //        console.log(f, Date.now(), arguments);\n\n          var result = s.apply($delegate, arguments);\n\n          // The call was a setter if the $location service is returned.\n\n          if (result === $delegate) {\n\n            // Mark the mainblock ui to allow the location change.\n\n            blockUI.$_blockLocationChange = false;\n          }\n\n          return result;\n        };\n      }\n\n      angular.forEach(overrides, hook);\n\n    }\n\n    return $delegate;\n}];\n\n// Called from block-ui-directive for the 'main' instance.\n\nfunction blockNavigation($scope, mainBlockUI, blockUIConfig) {\n\n  if (blockUIConfig.blockBrowserNavigation) {\n\n    function registerLocationChange() {\n\n      $scope.$on('$locationChangeStart', function (event) {\n\n        //        console.log('$locationChangeStart', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);\n\n        if (mainBlockUI.$_blockLocationChange && mainBlockUI.state().blockCount > 0) {\n          event.preventDefault();\n        }\n      });\n\n      $scope.$on('$locationChangeSuccess', function () {\n        mainBlockUI.$_blockLocationChange = blockUIConfig.blockBrowserNavigation;\n\n        //        console.log('$locationChangeSuccess', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);\n      });\n    }\n\n    if (moduleLoaded('ngRoute')) {\n\n      // After the initial content has been loaded we'll spy on any location\n      // changes and discard them when needed.\n\n      var fn = $scope.$on('$viewContentLoaded', function () {\n\n        // Unhook the view loaded and hook a function that will prevent\n        // location changes while the block is active.\n\n        fn();\n        registerLocationChange();\n\n      });\n\n    } else {\n      registerLocationChange();\n    }\n\n  }\n}\nblkUI.directive('blockUiContainer', [\"blockUIConfig\", \"blockUiContainerLinkFn\", function (blockUIConfig, blockUiContainerLinkFn) {\n  return {\n    scope: true,\n    restrict: 'A',\n    templateUrl: blockUIConfig.templateUrl,\n    compile: function($element) {\n      return blockUiContainerLinkFn;\n    }\n  };\n}]).factory('blockUiContainerLinkFn', [\"blockUI\", \"blockUIUtils\", function (blockUI, blockUIUtils) {\n\n  return function ($scope, $element, $attrs) {\n\n    var srvInstance = $element.inheritedData('block-ui');\n\n    if (!srvInstance) {\n      throw new Error('No parent block-ui service instance located.');\n    }\n\n    // Expose the state on the scope\n\n    $scope.state = srvInstance.state();\n\n//    $scope.$watch('state.blocking', function(value) {\n//      $element.toggleClass('block-ui-visible', !!value);\n//    });\n//\n//    $scope.$watch('state.blockCount > 0', function(value) {\n//      $element.toggleClass('block-ui-active', !!value);\n//    });\n  };\n}]);\nblkUI.directive('blockUi', [\"blockUiCompileFn\", function (blockUiCompileFn) {\n\n  return {\n    scope: true,\n    restrict: 'A',\n    compile: blockUiCompileFn\n  };\n\n}]).factory('blockUiCompileFn', [\"blockUiPreLinkFn\", function (blockUiPreLinkFn) {\n\n  return function ($element, $attrs) {\n\n    // Class should be added here to prevent an animation delay error.\n\n    $element.append('<div block-ui-container class=\"block-ui-container\"></div>');\n\n    return {\n      pre: blockUiPreLinkFn\n    };\n\n  };\n\n}]).factory('blockUiPreLinkFn', [\"blockUI\", \"blockUIUtils\", \"blockUIConfig\", function (blockUI, blockUIUtils, blockUIConfig) {\n\n  return function ($scope, $element, $attrs) {\n\n    // If the element does not have the class \"block-ui\" set, we set the\n    // default css classes from the config.\n\n    if (!$element.hasClass('block-ui')) {\n      $element.addClass(blockUIConfig.cssClass);\n    }\n\n    // Expose the blockUiMessageClass attribute value on the scope\n\n    $attrs.$observe('blockUiMessageClass', function (value) {\n      $scope.$_blockUiMessageClass = value;\n    });\n\n    // Create the blockUI instance\n    // Prefix underscore to prevent integers:\n    // https://github.com/McNull/angular-block-ui/pull/8\n\n    var instanceId = $attrs.blockUi || '_' + $scope.$id;\n    var srvInstance = blockUI.instances.get(instanceId);\n\n    // If this is the main (topmost) block element we'll also need to block any\n    // location changes while the block is active.\n\n    if (instanceId === 'main') {\n      blockNavigation($scope, srvInstance, blockUIConfig);\n    } else {\n      // Locate the parent blockUI instance\n      var parentInstance = $element.inheritedData('block-ui');\n\n      if (parentInstance) {\n        // TODO: assert if parent is already set to something else\n        srvInstance._parent = parentInstance;\n      }\n    }\n\n    // Ensure the instance is released when the scope is destroyed\n\n    $scope.$on('$destroy', function () {\n      srvInstance.release();\n    });\n\n    // Increase the reference count\n\n    srvInstance.addRef();\n\n    // Expose the state on the scope\n\n    $scope.$_blockUiState = srvInstance.state();\n\n    $scope.$watch('$_blockUiState.blocking', function (value) {\n      // Set the aria-busy attribute if needed\n      $element.attr('aria-busy', !!value);\n      $element.toggleClass('block-ui-visible', !!value);\n    });\n\n    $scope.$watch('$_blockUiState.blockCount > 0', function (value) {\n      $element.toggleClass('block-ui-active', !!value);\n    });\n\n    // If a pattern is provided assign it to the state\n\n    var pattern = $attrs.blockUiPattern;\n\n    if (pattern) {\n      var regExp = blockUIUtils.buildRegExp(pattern);\n      srvInstance.pattern(regExp);\n    }\n\n    // Store a reference to the service instance on the element\n\n    $element.data('block-ui', srvInstance);\n\n  };\n\n}]);\n//.factory('blockUiPostLinkFn', function(blockUIUtils) {\n//\n//  return function($scope, $element, $attrs) {\n//\n//    var $message;\n//\n//    $attrs.$observe('blockUiMessageClass', function(value) {\n//\n//      $message = $message || blockUIUtils.findElement($element, function($e) {\n//        return $e.hasClass('block-ui-message');\n//      });\n//\n//      $message.addClass(value);\n//\n//    });\n//  };\n//\n//});\nblkUI.constant('blockUIConfig', {\n    templateUrl: 'angular-block-ui/angular-block-ui.ng.html',\n    delay: 250,\n    message: \"Loading ...\",\n    autoBlock: true,\n    resetOnException: true,\n    requestFilter: angular.noop,\n    autoInjectBodyBlock: true,\n    cssClass: 'block-ui block-ui-anim-fade',\n    blockBrowserNavigation: false\n});\n\n\nblkUI.factory('blockUIHttpInterceptor', [\"$q\", \"$injector\", \"blockUIConfig\", \"$templateCache\", function($q, $injector, blockUIConfig, $templateCache) {\n\n  var blockUI;\n\n  function injectBlockUI() {\n    blockUI = blockUI || $injector.get('blockUI');\n  }\n\n  function stopBlockUI(config) {\n    if (blockUIConfig.autoBlock && (config && !config.$_noBlock && config.$_blocks)) {\n      injectBlockUI();\n      config.$_blocks.stop();\n    }\n  }\n\n  function error(rejection) {\n\n    try {\n      stopBlockUI(rejection.config);\n    } catch(ex) {\n      console.log('httpRequestError', ex);\n    }\n\n    return $q.reject(rejection);\n  }\n\n  return {\n    request: function(config) {\n\n      // Only block when autoBlock is enabled ...\n      // ... and the request doesn't match a cached template.\n\n      if (blockUIConfig.autoBlock &&\n        !(config.method == 'GET' && $templateCache.get(config.url))) {\n\n        // Don't block excluded requests\n\n        var result = blockUIConfig.requestFilter(config);\n\n        if (result === false) {\n          // Tag the config so we don't unblock this request\n          config.$_noBlock = true;\n        } else {\n\n          injectBlockUI();\n\n          config.$_blocks = blockUI.instances.locate(config);\n          config.$_blocks.start(result);\n        }\n      }\n\n      return config;\n    },\n\n    requestError: error,\n\n    response: function(response) {\n\n      // If the connection to the website goes down the response interceptor gets and error with \"cannot read property config of null\".\n      // https://github.com/McNull/angular-block-ui/issues/53\n\n      if(response) {\n        stopBlockUI(response.config);\n      }\n\n      return response;\n    },\n\n    responseError: error\n  };\n\n}]);\n\nblkUI.factory('blockUI', [\"blockUIConfig\", \"$timeout\", \"blockUIUtils\", \"$document\", function(blockUIConfig, $timeout, blockUIUtils, $document) {\n\n  var $body = $document.find('body');\n\n  function BlockUI(id) {\n\n    var self = this;\n\n    var state = {\n      id: id,\n      blockCount: 0,\n      message: blockUIConfig.message,\n      blocking: false\n    }, startPromise, doneCallbacks = [];\n\n    this._id = id;\n\n    this._refs = 0;\n\n    this.start = function(message) {\n\n      if(state.blockCount > 0) {\n        message = message || state.message || blockUIConfig.message;\n      } else {\n        message = message || blockUIConfig.message;\n      }\n\n      state.message = message;\n\n      state.blockCount++;\n\n      // Check if the focused element is part of the block scope\n\n      var $ae = angular.element($document[0].activeElement);\n\n      if($ae.length && blockUIUtils.isElementInBlockScope($ae, self)) {\n\n        // Let the active element lose focus and store a reference \n        // to restore focus when we're done (reset)\n\n        self._restoreFocus = $ae[0];\n\n        // https://github.com/McNull/angular-block-ui/issues/13\n        // http://stackoverflow.com/questions/22698058/apply-already-in-progress-error-when-using-typeahead-plugin-found-to-be-relate\n        // Queue the blur after any ng-blur expression.\n\n        $timeout(function() {\n          // Ensure we still need to blur\n          if(self._restoreFocus) {\n            self._restoreFocus.blur();\n          }\n        });\n      }\n\n      if (!startPromise) {\n        startPromise = $timeout(function() {\n          startPromise = null;\n          state.blocking = true;\n        }, blockUIConfig.delay);\n      }\n    };\n\n    this._cancelStartTimeout = function() {\n      if (startPromise) {\n        $timeout.cancel(startPromise);\n        startPromise = null;\n      }\n    };\n\n    this.stop = function() {\n      state.blockCount = Math.max(0, --state.blockCount);\n\n      if (state.blockCount === 0) {\n        self.reset(true);\n      }\n    };\n\n    this.message = function(value) {\n      state.message = value;\n    };\n\n    this.pattern = function(regexp) {\n      if (regexp !== undefined) {\n        self._pattern = regexp;\n      }\n\n      return self._pattern;\n    };\n\n    this.reset = function(executeCallbacks) {\n      \n      self._cancelStartTimeout();\n      state.blockCount = 0;\n      state.blocking = false;\n\n      // Restore the focus to the element that was active\n      // before the block start, but not if the user has \n      // focused something else while the block was active.\n\n      if(self._restoreFocus && \n         (!$document[0].activeElement || $document[0].activeElement === $body[0])) {\n        self._restoreFocus.focus();\n        self._restoreFocus = null;\n      }\n      \n      try {\n        if (executeCallbacks) {\n          angular.forEach(doneCallbacks, function(cb) {\n            cb();\n          });\n        }\n      } finally {\n        doneCallbacks.length = 0;\n      }\n    };\n\n    this.done = function(fn) {\n      doneCallbacks.push(fn);\n    };\n\n    this.state = function() {\n      return state;\n    };\n\n    this.addRef = function() {\n      self._refs += 1;\n    };\n\n    this.release = function() {\n      if(--self._refs <= 0) {\n        mainBlock.instances._destroy(self);\n      }\n    };\n  }\n\n  var instances = [];\n\n  instances.get = function(id) {\n\n    if(!isNaN(id)) {\n      throw new Error('BlockUI id cannot be a number');\n    }\n\n    var instance = instances[id];\n\n    if(!instance) {\n      // TODO: ensure no array instance trashing [xxx] -- current workaround: '_' + $scope.$id\n      instance = instances[id] = new BlockUI(id);\n      instances.push(instance);\n    }\n\n    return instance;\n  };\n\n  instances._destroy = function(idOrInstance) {\n    if (angular.isString(idOrInstance)) {\n      idOrInstance = instances[idOrInstance];\n    }\n\n    if (idOrInstance) {\n      idOrInstance.reset();\n\n      var i = blockUIUtils.indexOf(instances, idOrInstance);\n      instances.splice(i, 1);\n\n      delete instances[idOrInstance.state().id];\n    }\n  };\n  \n  instances.locate = function(request) {\n\n    var result = [];\n\n    // Add function wrappers that will be executed on every item\n    // in the array.\n    \n    blockUIUtils.forEachFnHook(result, 'start');\n    blockUIUtils.forEachFnHook(result, 'stop');\n\n    var i = instances.length;\n\n    while(i--) {\n      var instance = instances[i];\n      var pattern = instance._pattern;\n\n      if(pattern && pattern.test(request.url)) {\n        result.push(instance);\n      }\n    }\n\n    if(result.length === 0) {\n      result.push(mainBlock);\n    }\n\n    return result;\n  };\n\n  // Propagate the reset to all instances\n\n  blockUIUtils.forEachFnHook(instances, 'reset');\n\n  var mainBlock = instances.get('main');\n\n  mainBlock.addRef();\n  mainBlock.instances = instances;\n\n  return mainBlock;\n}]);\n\n\nblkUI.factory('blockUIUtils', function() {\n\n  var $ = angular.element;\n\n  var utils = {\n    buildRegExp: function(pattern) {\n      var match = pattern.match(/^\\/(.*)\\/([gim]*)$/), regExp;\n\n      if(match) {\n        regExp = new RegExp(match[1], match[2]);\n      } else {\n        throw Error('Incorrect regular expression format: ' + pattern);\n      }\n\n      return regExp;\n    },\n    forEachFn: function(arr, fnName, args) {\n      var i = arr.length;\n      while(i--) {\n        var t = arr[i];\n        t[fnName].apply(t, args);\n      }\n    },\n    forEachFnHook: function(arr, fnName) {\n      arr[fnName] = function() {\n        utils.forEachFn(this, fnName, arguments);\n      }\n    },\n    isElementInBlockScope: function($element, blockScope) {\n      var c = $element.inheritedData('block-ui');\n\n      while(c) {\n        if(c === blockScope) {\n          return true;\n        }\n\n        c = c._parent;\n      }\n\n      return false;\n    },\n    findElement: function ($element, predicateFn, traverse) {\n      var ret = null;\n\n      if (predicateFn($element)) {\n        ret = $element;\n      } else {\n\n        var $elements;\n\n        if (traverse) {\n          $elements = $element.parent();\n        } else {\n          $elements = $element.children();\n        }\n\n        var i = $elements.length;\n        while (!ret && i--) {\n          ret = utils.findElement($($elements[i]), predicateFn, traverse);\n        }\n      }\n\n      return ret;\n    },\n    indexOf: function(arr, obj, start) {\n//      if(Array.prototype.indexOf) {\n//        return arr.indexOf(obj, start);\n//      }\n\n      for (var i = (start || 0), j = arr.length; i < j; i++) {\n        if (arr[i] === obj) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  };\n\n  return utils;\n\n});\n// Automatically generated.\n// This file is already embedded in your main javascript output, there's no need to include this file\n// manually in the index.html. This file is only here for your debugging pleasures.\nangular.module('blockUI').run(['$templateCache', function($templateCache){\n  $templateCache.put('angular-block-ui/angular-block-ui.ng.html', '<div class=\\\"block-ui-overlay\\\"></div><div class=\\\"block-ui-message-container\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\"><div class=\\\"block-ui-message\\\" ng-class=\\\"$_blockUiMessageClass\\\">{{ state.message }}</div></div>');\n}]);\n})(angular);\nif (typeof module !== \"undefined\") module.exports = \"blockUI\";\n//# sourceMappingURL=angular-block-ui.js.map\n","var css = \"/*!\\n   angular-block-ui v0.2.0\\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\\n   License: MIT\\n*/\\n.block-ui {\\n  position: relative;\\n}\\nbody.block-ui {\\n  position: static;\\n}\\n.block-ui-main>.block-ui-container,\\nbody.block-ui>.block-ui-container {\\n  position: fixed;\\n}\\n.block-ui-container {\\n  position: absolute;\\n  z-index: 10000;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n  height: 0;\\n  overflow: hidden;\\n  opacity: 0;\\n  filter: alpha(opacity=00);\\n}\\n.block-ui-active>.block-ui-container {\\n  height: 100%;\\n  cursor: wait;\\n}\\n.block-ui-active .block-ui-active>.block-ui-container {\\n  height: 0;\\n}\\n.block-ui-visible>.block-ui-container {\\n  opacity: 1;\\n  filter: alpha(opacity=100);\\n}\\n.block-ui-overlay {\\n  width: 100%;\\n  height: 100%;\\n  opacity: .5;\\n  filter: alpha(opacity=50);\\n  background-color: #fff;\\n}\\n.block-ui-message-container {\\n  position: absolute;\\n  top: 35%;\\n  left: 0;\\n  right: 0;\\n  height: 0;\\n  text-align: center;\\n  z-index: 10001;\\n}\\n.block-ui-message {\\n  display: inline-block;\\n  text-align: left;\\n  background-color: #333;\\n  color: #f5f5f5;\\n  padding: 20px;\\n  border-radius: 4px;\\n  font-size: 20px;\\n  font-weight: 700;\\n  filter: alpha(opacity=100);\\n}\\n.block-ui-anim-fade>.block-ui-container {\\n  -webkit-transition: height 0s linear 200ms,opacity 200ms ease 0s;\\n  transition: height 0s linear 200ms,opacity 200ms ease 0s;\\n}\\n.block-ui-anim-fade.block-ui-active>.block-ui-container {\\n  -webkit-transition-delay: 0s;\\n  transition-delay: 0s;\\n}\\n\"; (require(\"browserify-css\").createStyle(css, { \"href\": \"node_modules\\\\angular-block-ui\\\\dist\\\\angular-block-ui.min.css\"})); module.exports = css;","/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $sanitizeMinErr = angular.$$minErr('$sanitize');\n\n/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n\n/*\n * HTML Parser By Misko Hevery (misko@hevery.com)\n * based on:  HTML Parser By John Resig (ejohn.org)\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n *\n * // Use like so:\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n */\n\n\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string, however, since our parser is more strict than a typical browser\n *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a\n *   browser, won't make it through the sanitizer. The input may also contain SVG markup.\n *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and\n *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getInnerHtml()).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\nfunction $SanitizeProvider() {\n  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n    return function(html) {\n      var buf = [];\n      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n        return !/^unsafe/.test($$sanitizeUri(uri, isImage));\n      }));\n      return buf.join('');\n    };\n  }];\n}\n\nfunction sanitizeText(chars) {\n  var buf = [];\n  var writer = htmlSanitizeWriter(buf, angular.noop);\n  writer.chars(chars);\n  return buf.join('');\n}\n\n\n// Regular Expressions for parsing tags and attributes\nvar START_TAG_REGEXP =\n       /^<((?:[a-zA-Z])[\\w:-]*)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)\\s*(>?)/,\n  END_TAG_REGEXP = /^<\\/\\s*([\\w:-]+)[^>]*>/,\n  ATTR_REGEXP = /([\\w:-]+)(?:\\s*=\\s*(?:(?:\"((?:[^\"])*)\")|(?:'((?:[^'])*)')|([^>\\s]+)))?/g,\n  BEGIN_TAG_REGEXP = /^</,\n  BEGING_END_TAGE_REGEXP = /^<\\//,\n  COMMENT_REGEXP = /<!--(.*?)-->/g,\n  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,\n  CDATA_REGEXP = /<!\\[CDATA\\[(.*?)]]>/g,\n  SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n  // Match everything outside of normal chars and \" (quote character)\n  NON_ALPHANUMERIC_REGEXP = /([^\\#-~| |!])/g;\n\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\nvar voidElements = makeMap(\"area,br,col,hr,img,wbr\");\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\nvar optionalEndTagBlockElements = makeMap(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),\n    optionalEndTagInlineElements = makeMap(\"rp,rt\"),\n    optionalEndTagElements = angular.extend({},\n                                            optionalEndTagInlineElements,\n                                            optionalEndTagBlockElements);\n\n// Safe Block Elements - HTML5\nvar blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap(\"address,article,\" +\n        \"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,\" +\n        \"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul\"));\n\n// Inline Elements - HTML5\nvar inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap(\"a,abbr,acronym,b,\" +\n        \"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,\" +\n        \"samp,small,span,strike,strong,sub,sup,time,tt,u,var\"));\n\n// SVG Elements\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n// They can potentially allow for arbitrary javascript to be executed. See #11290\nvar svgElements = makeMap(\"circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,\" +\n        \"hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,\" +\n        \"radialGradient,rect,stop,svg,switch,text,title,tspan,use\");\n\n// Special Elements (can contain anything)\nvar specialElements = makeMap(\"script,style\");\n\nvar validElements = angular.extend({},\n                                   voidElements,\n                                   blockElements,\n                                   inlineElements,\n                                   optionalEndTagElements,\n                                   svgElements);\n\n//Attributes that have href and hence need to be sanitized\nvar uriAttrs = makeMap(\"background,cite,href,longdesc,src,usemap,xlink:href\");\n\nvar htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n    'valign,value,vspace,width');\n\n// SVG attributes (without \"id\" and \"name\" attributes)\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\nvar svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +\n    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\nvar validAttrs = angular.extend({},\n                                uriAttrs,\n                                svgAttrs,\n                                htmlAttrs);\n\nfunction makeMap(str, lowercaseKeys) {\n  var obj = {}, items = str.split(','), i;\n  for (i = 0; i < items.length; i++) {\n    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;\n  }\n  return obj;\n}\n\n\n/**\n * @example\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n * @param {string} html string\n * @param {object} handler\n */\nfunction htmlParser(html, handler) {\n  if (typeof html !== 'string') {\n    if (html === null || typeof html === 'undefined') {\n      html = '';\n    } else {\n      html = '' + html;\n    }\n  }\n  var index, chars, match, stack = [], last = html, text;\n  stack.last = function() { return stack[stack.length - 1]; };\n\n  while (html) {\n    text = '';\n    chars = true;\n\n    // Make sure we're not in a script or style element\n    if (!stack.last() || !specialElements[stack.last()]) {\n\n      // Comment\n      if (html.indexOf(\"<!--\") === 0) {\n        // comments containing -- are not allowed unless they terminate the comment\n        index = html.indexOf(\"--\", 4);\n\n        if (index >= 0 && html.lastIndexOf(\"-->\", index) === index) {\n          if (handler.comment) handler.comment(html.substring(4, index));\n          html = html.substring(index + 3);\n          chars = false;\n        }\n      // DOCTYPE\n      } else if (DOCTYPE_REGEXP.test(html)) {\n        match = html.match(DOCTYPE_REGEXP);\n\n        if (match) {\n          html = html.replace(match[0], '');\n          chars = false;\n        }\n      // end tag\n      } else if (BEGING_END_TAGE_REGEXP.test(html)) {\n        match = html.match(END_TAG_REGEXP);\n\n        if (match) {\n          html = html.substring(match[0].length);\n          match[0].replace(END_TAG_REGEXP, parseEndTag);\n          chars = false;\n        }\n\n      // start tag\n      } else if (BEGIN_TAG_REGEXP.test(html)) {\n        match = html.match(START_TAG_REGEXP);\n\n        if (match) {\n          // We only have a valid start-tag if there is a '>'.\n          if (match[4]) {\n            html = html.substring(match[0].length);\n            match[0].replace(START_TAG_REGEXP, parseStartTag);\n          }\n          chars = false;\n        } else {\n          // no ending tag found --- this piece should be encoded as an entity.\n          text += '<';\n          html = html.substring(1);\n        }\n      }\n\n      if (chars) {\n        index = html.indexOf(\"<\");\n\n        text += index < 0 ? html : html.substring(0, index);\n        html = index < 0 ? \"\" : html.substring(index);\n\n        if (handler.chars) handler.chars(decodeEntities(text));\n      }\n\n    } else {\n      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\\W\\w].\n      html = html.replace(new RegExp(\"([\\\\W\\\\w]*)<\\\\s*\\\\/\\\\s*\" + stack.last() + \"[^>]*>\", 'i'),\n        function(all, text) {\n          text = text.replace(COMMENT_REGEXP, \"$1\").replace(CDATA_REGEXP, \"$1\");\n\n          if (handler.chars) handler.chars(decodeEntities(text));\n\n          return \"\";\n      });\n\n      parseEndTag(\"\", stack.last());\n    }\n\n    if (html == last) {\n      throw $sanitizeMinErr('badparse', \"The sanitizer was unable to parse the following block \" +\n                                        \"of html: {0}\", html);\n    }\n    last = html;\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function parseStartTag(tag, tagName, rest, unary) {\n    tagName = angular.lowercase(tagName);\n    if (blockElements[tagName]) {\n      while (stack.last() && inlineElements[stack.last()]) {\n        parseEndTag(\"\", stack.last());\n      }\n    }\n\n    if (optionalEndTagElements[tagName] && stack.last() == tagName) {\n      parseEndTag(\"\", tagName);\n    }\n\n    unary = voidElements[tagName] || !!unary;\n\n    if (!unary) {\n      stack.push(tagName);\n    }\n\n    var attrs = {};\n\n    rest.replace(ATTR_REGEXP,\n      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {\n        var value = doubleQuotedValue\n          || singleQuotedValue\n          || unquotedValue\n          || '';\n\n        attrs[name] = decodeEntities(value);\n    });\n    if (handler.start) handler.start(tagName, attrs, unary);\n  }\n\n  function parseEndTag(tag, tagName) {\n    var pos = 0, i;\n    tagName = angular.lowercase(tagName);\n    if (tagName) {\n      // Find the closest opened tag of the same type\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos] == tagName) break;\n      }\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (i = stack.length - 1; i >= pos; i--)\n        if (handler.end) handler.end(stack[i]);\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n    }\n  }\n}\n\nvar hiddenPre=document.createElement(\"pre\");\n/**\n * decodes all entities into regular string\n * @param value\n * @returns {string} A string with decoded entities.\n */\nfunction decodeEntities(value) {\n  if (!value) { return ''; }\n\n  hiddenPre.innerHTML = value.replace(/</g,\"&lt;\");\n  // innerText depends on styling as it doesn't display hidden elements.\n  // Therefore, it's better to use textContent not to cause unnecessary reflows.\n  return hiddenPre.textContent;\n}\n\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n * @returns {string} escaped text\n */\nfunction encodeEntities(value) {\n  return value.\n    replace(/&/g, '&amp;').\n    replace(SURROGATE_PAIR_REGEXP, function(value) {\n      var hi = value.charCodeAt(0);\n      var low = value.charCodeAt(1);\n      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n    }).\n    replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n      return '&#' + value.charCodeAt(0) + ';';\n    }).\n    replace(/</g, '&lt;').\n    replace(/>/g, '&gt;');\n}\n\n/**\n * create an HTML/XML writer which writes to buffer\n * @param {Array} buf use buf.jain('') to get out sanitized html string\n * @returns {object} in the form of {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * }\n */\nfunction htmlSanitizeWriter(buf, uriValidator) {\n  var ignore = false;\n  var out = angular.bind(buf, buf.push);\n  return {\n    start: function(tag, attrs, unary) {\n      tag = angular.lowercase(tag);\n      if (!ignore && specialElements[tag]) {\n        ignore = tag;\n      }\n      if (!ignore && validElements[tag] === true) {\n        out('<');\n        out(tag);\n        angular.forEach(attrs, function(value, key) {\n          var lkey=angular.lowercase(key);\n          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n          if (validAttrs[lkey] === true &&\n            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n            out(' ');\n            out(key);\n            out('=\"');\n            out(encodeEntities(value));\n            out('\"');\n          }\n        });\n        out(unary ? '/>' : '>');\n      }\n    },\n    end: function(tag) {\n        tag = angular.lowercase(tag);\n        if (!ignore && validElements[tag] === true) {\n          out('</');\n          out(tag);\n          out('>');\n        }\n        if (tag == ignore) {\n          ignore = false;\n        }\n      },\n    chars: function(chars) {\n        if (!ignore) {\n          out(encodeEntities(chars));\n        }\n      }\n  };\n}\n\n\n// define ngSanitize module and register $sanitize service\nangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n/* global sanitizeText: false */\n\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.\n * @returns {string} Html-linkified text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n       <script>\n         angular.module('linkyExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', function($scope) {\n             $scope.snippet =\n               'Pretty text with some links:\\n'+\n               'http://angularjs.org/,\\n'+\n               'mailto:us@somewhere.org,\\n'+\n               'another@somewhere.org,\\n'+\n               'and one more: ftp://127.0.0.1/.';\n             $scope.snippetWithTarget = 'http://angularjs.org/';\n           }]);\n       </script>\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Filter</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithTarget | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n     </file>\n   </example>\n */\nangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n  var LINKY_URL_REGEXP =\n        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n      MAILTO_REGEXP = /^mailto:/i;\n\n  return function(text, target) {\n    if (!text) return text;\n    var match;\n    var raw = text;\n    var html = [];\n    var url;\n    var i;\n    while ((match = raw.match(LINKY_URL_REGEXP))) {\n      // We can not end in these as they are sometimes found at the end of the sentence\n      url = match[0];\n      // if we did not match ftp/http/www/mailto then assume mailto\n      if (!match[2] && !match[4]) {\n        url = (match[3] ? 'http://' : 'mailto:') + url;\n      }\n      i = match.index;\n      addText(raw.substr(0, i));\n      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n      raw = raw.substring(i + match[0].length);\n    }\n    addText(raw);\n    return $sanitize(html.join(''));\n\n    function addText(text) {\n      if (!text) {\n        return;\n      }\n      html.push(sanitizeText(text));\n    }\n\n    function addLink(url, text) {\n      html.push('<a ');\n      if (angular.isDefined(target)) {\n        html.push('target=\"',\n                  target,\n                  '\" ');\n      }\n      html.push('href=\"',\n                url.replace(/\"/g, '&quot;'),\n                '\">');\n      addText(text);\n      html.push('</a>');\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n","require('./angular-sanitize');\nmodule.exports = 'ngSanitize';\n","/*!\n * angular-translate - v2.10.0 - 2016-02-28\n * \n * Copyright (c) 2016 The angular-translate team, Pascal Precht; Licensed MIT\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define([], function () {\n      return (factory());\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    factory();\n  }\n}(this, function () {\n\n/**\n * @ngdoc overview\n * @name pascalprecht.translate\n *\n * @description\n * The main module which holds everything together.\n */\nangular.module('pascalprecht.translate', ['ng'])\n  .run(runTranslate);\n\nfunction runTranslate($translate) {\n\n  'use strict';\n\n  var key = $translate.storageKey(),\n    storage = $translate.storage();\n\n  var fallbackFromIncorrectStorageValue = function () {\n    var preferred = $translate.preferredLanguage();\n    if (angular.isString(preferred)) {\n      $translate.use(preferred);\n      // $translate.use() will also remember the language.\n      // So, we don't need to call storage.put() here.\n    } else {\n      storage.put(key, $translate.use());\n    }\n  };\n\n  fallbackFromIncorrectStorageValue.displayName = 'fallbackFromIncorrectStorageValue';\n\n  if (storage) {\n    if (!storage.get(key)) {\n      fallbackFromIncorrectStorageValue();\n    } else {\n      $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);\n    }\n  } else if (angular.isString($translate.preferredLanguage())) {\n    $translate.use($translate.preferredLanguage());\n  }\n}\nrunTranslate.$inject = ['$translate'];\n\nrunTranslate.displayName = 'runTranslate';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateSanitizationProvider\n *\n * @description\n *\n * Configurations for $translateSanitization\n */\nangular.module('pascalprecht.translate').provider('$translateSanitization', $translateSanitizationProvider);\n\nfunction $translateSanitizationProvider () {\n\n  'use strict';\n\n  var $sanitize,\n      currentStrategy = null, // TODO change to either 'sanitize', 'escape' or ['sanitize', 'escapeParameters'] in 3.0.\n      hasConfiguredStrategy = false,\n      hasShownNoStrategyConfiguredWarning = false,\n      strategies;\n\n  /**\n   * Definition of a sanitization strategy function\n   * @callback StrategyFunction\n   * @param {string|object} value - value to be sanitized (either a string or an interpolated value map)\n   * @param {string} mode - either 'text' for a string (translation) or 'params' for the interpolated params\n   * @return {string|object}\n   */\n\n  /**\n   * @ngdoc property\n   * @name strategies\n   * @propertyOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Following strategies are built-in:\n   * <dl>\n   *   <dt>sanitize</dt>\n   *   <dd>Sanitizes HTML in the translation text using $sanitize</dd>\n   *   <dt>escape</dt>\n   *   <dd>Escapes HTML in the translation</dd>\n   *   <dt>sanitizeParameters</dt>\n   *   <dd>Sanitizes HTML in the values of the interpolation parameters using $sanitize</dd>\n   *   <dt>escapeParameters</dt>\n   *   <dd>Escapes HTML in the values of the interpolation parameters</dd>\n   *   <dt>escaped</dt>\n   *   <dd>Support legacy strategy name 'escaped' for backwards compatibility (will be removed in 3.0)</dd>\n   * </dl>\n   *\n   */\n\n  strategies = {\n    sanitize: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlSanitizeValue(value);\n      }\n      return value;\n    },\n    escape: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlEscapeValue(value);\n      }\n      return value;\n    },\n    sanitizeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlSanitizeValue);\n      }\n      return value;\n    },\n    escapeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlEscapeValue);\n      }\n      return value;\n    }\n  };\n  // Support legacy strategy name 'escaped' for backwards compatibility.\n  // TODO should be removed in 3.0\n  strategies.escaped = strategies.escapeParameters;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#addStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Adds a sanitization strategy to the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @param {StrategyFunction} strategyFunction - strategy function\n   * @returns {object} this\n   */\n  this.addStrategy = function (strategyName, strategyFunction) {\n    strategies[strategyName] = strategyFunction;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#removeStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Removes a sanitization strategy from the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @returns {object} this\n   */\n  this.removeStrategy = function (strategyName) {\n    delete strategies[strategyName];\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#useStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n   *\n   * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n   * @returns {object} this\n   */\n  this.useStrategy = function (strategy) {\n    hasConfiguredStrategy = true;\n    currentStrategy = strategy;\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translateSanitization\n   * @requires $injector\n   * @requires $log\n   *\n   * @description\n   * Sanitizes interpolation parameters and translated texts.\n   *\n   */\n  this.$get = ['$injector', '$log', function ($injector, $log) {\n\n    var cachedStrategyMap = {};\n\n    var applyStrategies = function (value, mode, selectedStrategies) {\n      angular.forEach(selectedStrategies, function (selectedStrategy) {\n        if (angular.isFunction(selectedStrategy)) {\n          value = selectedStrategy(value, mode);\n        } else if (angular.isFunction(strategies[selectedStrategy])) {\n          value = strategies[selectedStrategy](value, mode);\n        } else if (angular.isString(strategies[selectedStrategy])) {\n          if (!cachedStrategyMap[strategies[selectedStrategy]]) {\n            try {\n              cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);\n            } catch (e) {\n              cachedStrategyMap[strategies[selectedStrategy]] = function() {};\n              throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n            }\n          }\n          value = cachedStrategyMap[strategies[selectedStrategy]](value, mode);\n        } else {\n          throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n        }\n      });\n      return value;\n    };\n\n    // TODO: should be removed in 3.0\n    var showNoStrategyConfiguredWarning = function () {\n      if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {\n        $log.warn('pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.');\n        hasShownNoStrategyConfiguredWarning = true;\n      }\n    };\n\n    if ($injector.has('$sanitize')) {\n      $sanitize = $injector.get('$sanitize');\n    }\n\n    return {\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#useStrategy\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n       *\n       * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n       */\n      useStrategy: (function (self) {\n        return function (strategy) {\n          self.useStrategy(strategy);\n        };\n      })(this),\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#sanitize\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Sanitizes a value.\n       *\n       * @param {string|object} value The value which should be sanitized.\n       * @param {string} mode The current sanitization mode, either 'params' or 'text'.\n       * @param {string|StrategyFunction|array} [strategy] Optional custom strategy which should be used instead of the currently selected strategy.\n       * @returns {string|object} sanitized value\n       */\n      sanitize: function (value, mode, strategy) {\n        if (!currentStrategy) {\n          showNoStrategyConfiguredWarning();\n        }\n\n        if (arguments.length < 3) {\n          strategy = currentStrategy;\n        }\n\n        if (!strategy) {\n          return value;\n        }\n\n        var selectedStrategies = angular.isArray(strategy) ? strategy : [strategy];\n        return applyStrategies(value, mode, selectedStrategies);\n      }\n    };\n  }];\n\n  var htmlEscapeValue = function (value) {\n    var element = angular.element('<div></div>');\n    element.text(value); // not chainable, see #1044\n    return element.html();\n  };\n\n  var htmlSanitizeValue = function (value) {\n    if (!$sanitize) {\n      throw new Error('pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as \\'escape\\'.');\n    }\n    return $sanitize(value);\n  };\n\n  var mapInterpolationParameters = function (value, iteratee, stack) {\n    if (angular.isObject(value)) {\n      var result = angular.isArray(value) ? [] : {};\n\n      if (!stack) {\n        stack = [];\n      } else {\n        if (stack.indexOf(value) > -1) {\n          throw new Error('pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object');\n        }\n      }\n\n      stack.push(value);\n      angular.forEach(value, function (propertyValue, propertyKey) {\n        result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack);\n      });\n      stack.splice(-1, 1); // remove last\n\n      return result;\n    } else if (angular.isNumber(value)) {\n      return value;\n    } else {\n      return iteratee(value);\n    }\n  };\n}\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateProvider\n * @description\n *\n * $translateProvider allows developers to register translation-tables, asynchronous loaders\n * and similar to configure translation behavior directly inside of a module.\n *\n */\nangular.module('pascalprecht.translate')\n.constant('pascalprechtTranslateOverrider', {})\n.provider('$translate', $translate);\n\nfunction $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {\n\n  'use strict';\n\n  var $translationTable = {},\n      $preferredLanguage,\n      $availableLanguageKeys = [],\n      $languageKeyAliases,\n      $fallbackLanguage,\n      $fallbackWasString,\n      $uses,\n      $nextLang,\n      $storageFactory,\n      $storageKey = $STORAGE_KEY,\n      $storagePrefix,\n      $missingTranslationHandlerFactory,\n      $interpolationFactory,\n      $interpolatorFactories = [],\n      $loaderFactory,\n      $cloakClassName = 'translate-cloak',\n      $loaderOptions,\n      $notFoundIndicatorLeft,\n      $notFoundIndicatorRight,\n      $postCompilingEnabled = false,\n      $forceAsyncReloadEnabled = false,\n      $nestedObjectDelimeter = '.',\n      $isReady = false,\n      loaderCache,\n      directivePriority = 0,\n      statefulFilter = true,\n      uniformLanguageTagResolver = 'default',\n      languageTagResolver = {\n        'default': function (tag) {\n          return (tag || '').split('-').join('_');\n        },\n        java: function (tag) {\n          var temp = (tag || '').split('-').join('_');\n          var parts = temp.split('_');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '_' + parts[1].toUpperCase()) : temp;\n        },\n        bcp47: function (tag) {\n          var temp = (tag || '').split('_').join('-');\n          var parts = temp.split('-');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '-' + parts[1].toUpperCase()) : temp;\n        }\n      };\n\n  var version = '2.10.0';\n\n  // tries to determine the browsers language\n  var getFirstBrowserLanguage = function () {\n\n    // internal purpose only\n    if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {\n      return pascalprechtTranslateOverrider.getLocale();\n    }\n\n    var nav = $windowProvider.$get().navigator,\n        browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],\n        i,\n        language;\n\n    // support for HTML 5.1 \"navigator.languages\"\n    if (angular.isArray(nav.languages)) {\n      for (i = 0; i < nav.languages.length; i++) {\n        language = nav.languages[i];\n        if (language && language.length) {\n          return language;\n        }\n      }\n    }\n\n    // support for other well known properties in browsers\n    for (i = 0; i < browserLanguagePropertyKeys.length; i++) {\n      language = nav[browserLanguagePropertyKeys[i]];\n      if (language && language.length) {\n        return language;\n      }\n    }\n\n    return null;\n  };\n  getFirstBrowserLanguage.displayName = 'angular-translate/service: getFirstBrowserLanguage';\n\n  // tries to determine the browsers locale\n  var getLocale = function () {\n    var locale = getFirstBrowserLanguage() || '';\n    if (languageTagResolver[uniformLanguageTagResolver]) {\n      locale = languageTagResolver[uniformLanguageTagResolver](locale);\n    }\n    return locale;\n  };\n  getLocale.displayName = 'angular-translate/service: getLocale';\n\n  /**\n   * @name indexOf\n   * @private\n   *\n   * @description\n   * indexOf polyfill. Kinda sorta.\n   *\n   * @param {array} array Array to search in.\n   * @param {string} searchElement Element to search for.\n   *\n   * @returns {int} Index of search element.\n   */\n  var indexOf = function(array, searchElement) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === searchElement) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  var negotiateLocale = function (preferred) {\n    if(!preferred) {\n      return;\n    }\n\n    var avail = [],\n        locale = angular.lowercase(preferred),\n        i = 0,\n        n = $availableLanguageKeys.length;\n\n    for (; i < n; i++) {\n      avail.push(angular.lowercase($availableLanguageKeys[i]));\n    }\n\n    // Check for an exact match in our list of available keys\n    if (indexOf(avail, locale) > -1) {\n      return preferred;\n    }\n\n    if ($languageKeyAliases) {\n      var alias;\n      for (var langKeyAlias in $languageKeyAliases) {\n        var hasWildcardKey = false;\n        var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) &&\n          angular.lowercase(langKeyAlias) === angular.lowercase(preferred);\n\n        if (langKeyAlias.slice(-1) === '*') {\n          hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length-1);\n        }\n        if (hasExactKey || hasWildcardKey) {\n          alias = $languageKeyAliases[langKeyAlias];\n          if (indexOf(avail, angular.lowercase(alias)) > -1) {\n            return alias;\n          }\n        }\n      }\n    }\n\n    // Check for a language code without region\n    var parts = preferred.split('_');\n\n    if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {\n      return parts[0];\n    }\n\n    // If everything fails, return undefined.\n    return;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translations\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a new translation table for specific language key.\n   *\n   * To register a translation table for specific language, pass a defined language\n   * key as first parameter.\n   *\n   * <pre>\n   *  // register translation table for language: 'de_DE'\n   *  $translateProvider.translations('de_DE', {\n   *    'GREETING': 'Hallo Welt!'\n   *  });\n   *\n   *  // register another one\n   *  $translateProvider.translations('en_US', {\n   *    'GREETING': 'Hello world!'\n   *  });\n   * </pre>\n   *\n   * When registering multiple translation tables for for the same language key,\n   * the actual translation table gets extended. This allows you to define module\n   * specific translation which only get added, once a specific module is loaded in\n   * your app.\n   *\n   * Invoking this method with no arguments returns the translation table which was\n   * registered with no language key. Invoking it with a language key returns the\n   * related translation table.\n   *\n   * @param {string} key A language key.\n   * @param {object} translationTable A plain old JavaScript object that represents a translation table.\n   *\n   */\n  var translations = function (langKey, translationTable) {\n\n    if (!langKey && !translationTable) {\n      return $translationTable;\n    }\n\n    if (langKey && !translationTable) {\n      if (angular.isString(langKey)) {\n        return $translationTable[langKey];\n      }\n    } else {\n      if (!angular.isObject($translationTable[langKey])) {\n        $translationTable[langKey] = {};\n      }\n      angular.extend($translationTable[langKey], flatObject(translationTable));\n    }\n    return this;\n  };\n\n  this.translations = translations;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#cloakClassName\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the class name for `translate-cloak` directive.\n   * Default class name is `translate-cloak`.\n   *\n   * @param {string} name translate-cloak class name\n   */\n  this.cloakClassName = function (name) {\n    if (!name) {\n      return $cloakClassName;\n    }\n    $cloakClassName = name;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#nestedObjectDelimeter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the delimiter for namespaced translations.\n   * Default delimiter is `.`.\n   *\n   * @param {string} delimiter namespace separator\n   */\n  this.nestedObjectDelimeter = function (delimiter) {\n    if (!delimiter) {\n      return $nestedObjectDelimeter;\n    }\n    $nestedObjectDelimeter = delimiter;\n    return this;\n  };\n\n  /**\n   * @name flatObject\n   * @private\n   *\n   * @description\n   * Flats an object. This function is used to flatten given translation data with\n   * namespaces, so they are later accessible via dot notation.\n   */\n  var flatObject = function (data, path, result, prevKey) {\n    var key, keyWithPath, keyWithShortPath, val;\n\n    if (!path) {\n      path = [];\n    }\n    if (!result) {\n      result = {};\n    }\n    for (key in data) {\n      if (!Object.prototype.hasOwnProperty.call(data, key)) {\n        continue;\n      }\n      val = data[key];\n      if (angular.isObject(val)) {\n        flatObject(val, path.concat(key), result, key);\n      } else {\n        keyWithPath = path.length ? ('' + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key) : key;\n        if(path.length && key === prevKey){\n          // Create shortcut path (foo.bar == foo.bar.bar)\n          keyWithShortPath = '' + path.join($nestedObjectDelimeter);\n          // Link it to original path\n          result[keyWithShortPath] = '@:' + keyWithPath;\n        }\n        result[keyWithPath] = val;\n      }\n    }\n    return result;\n  };\n  flatObject.displayName = 'flatObject';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#addInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Adds interpolation services to angular-translate, so it can manage them.\n   *\n   * @param {object} factory Interpolation service factory\n   */\n  this.addInterpolation = function (factory) {\n    $interpolatorFactories.push(factory);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMessageFormatInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use interpolation functionality of messageformat.js.\n   * This is useful when having high level pluralization and gender selection.\n   */\n  this.useMessageFormatInterpolation = function () {\n    return this.useInterpolation('$translateMessageFormatInterpolation');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which interpolation style to use as default, application-wide.\n   * Simply pass a factory/service name. The interpolation service has to implement\n   * the correct interface.\n   *\n   * @param {string} factory Interpolation service name.\n   */\n  this.useInterpolation = function (factory) {\n    $interpolationFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useSanitizeStrategy\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Simply sets a sanitation strategy type.\n   *\n   * @param {string} value Strategy type.\n   */\n  this.useSanitizeValueStrategy = function (value) {\n    $translateSanitizationProvider.useStrategy(value);\n    return this;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#preferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use for translation\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **prefer**.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.preferredLanguage = function(langKey) {\n    if (langKey) {\n      setupPreferredLanguage(langKey);\n      return this;\n    }\n    return $preferredLanguage;\n  };\n  var setupPreferredLanguage = function (langKey) {\n    if (langKey) {\n      $preferredLanguage = langKey;\n    }\n    return $preferredLanguage;\n  };\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicator\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found. E.g. when\n   * setting the indicator as 'X' and one tries to translate a translation id\n   * called `NOT_FOUND`, this will result in `X NOT_FOUND X`.\n   *\n   * Internally this methods sets a left indicator and a right indicator using\n   * `$translateProvider.translationNotFoundIndicatorLeft()` and\n   * `$translateProvider.translationNotFoundIndicatorRight()`.\n   *\n   * **Note**: These methods automatically add a whitespace between the indicators\n   * and the translation id.\n   *\n   * @param {string} indicator An indicator, could be any string.\n   */\n  this.translationNotFoundIndicator = function (indicator) {\n    this.translationNotFoundIndicatorLeft(indicator);\n    this.translationNotFoundIndicatorRight(indicator);\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found left to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorLeft = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorLeft;\n    }\n    $notFoundIndicatorLeft = indicator;\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found right to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorRight = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorRight;\n    }\n    $notFoundIndicatorRight = indicator;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#fallbackLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use when missing translations\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **fallback**.\n   *\n   * @param {string||array} langKey A language key.\n   *\n   */\n  this.fallbackLanguage = function (langKey) {\n    fallbackStack(langKey);\n    return this;\n  };\n\n  var fallbackStack = function (langKey) {\n    if (langKey) {\n      if (angular.isString(langKey)) {\n        $fallbackWasString = true;\n        $fallbackLanguage = [ langKey ];\n      } else if (angular.isArray(langKey)) {\n        $fallbackWasString = false;\n        $fallbackLanguage = langKey;\n      }\n      if (angular.isString($preferredLanguage)  && indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n        $fallbackLanguage.push($preferredLanguage);\n      }\n\n      return this;\n    } else {\n      if ($fallbackWasString) {\n        return $fallbackLanguage[0];\n      } else {\n        return $fallbackLanguage;\n      }\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#use\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Set which translation table to use for translation by given language key. When\n   * trying to 'use' a language which isn't provided, it'll throw an error.\n   *\n   * You actually don't have to use this method since `$translateProvider#preferredLanguage`\n   * does the job too.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.use = function (langKey) {\n    if (langKey) {\n      if (!$translationTable[langKey] && (!$loaderFactory)) {\n        // only throw an error, when not loading translation data asynchronously\n        throw new Error('$translateProvider couldn\\'t find translationTable for langKey: \\'' + langKey + '\\'');\n      }\n      $uses = langKey;\n      return this;\n    }\n    return $uses;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storageKey\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which key must represent the choosed language by a user in the storage.\n   *\n   * @param {string} key A key for the storage.\n   */\n  var storageKey = function(key) {\n    if (!key) {\n      if ($storagePrefix) {\n        return $storagePrefix + $storageKey;\n      }\n      return $storageKey;\n    }\n    $storageKey = key;\n    return this;\n  };\n\n  this.storageKey = storageKey;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useUrlLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateUrlLoader` extension service as loader.\n   *\n   * @param {string} url Url\n   * @param {Object=} options Optional configuration object\n   */\n  this.useUrlLoader = function (url, options) {\n    return this.useLoader('$translateUrlLoader', angular.extend({ url: url }, options));\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStaticFilesLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateStaticFilesLoader` extension service as loader.\n   *\n   * @param {Object=} options Optional configuration object\n   */\n  this.useStaticFilesLoader = function (options) {\n    return this.useLoader('$translateStaticFilesLoader', options);\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use any other service as loader.\n   *\n   * @param {string} loaderFactory Factory name to use\n   * @param {Object=} options Optional configuration object\n   */\n  this.useLoader = function (loaderFactory, options) {\n    $loaderFactory = loaderFactory;\n    $loaderOptions = options || {};\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLocalStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateLocalStorage` service as storage layer.\n   *\n   */\n  this.useLocalStorage = function () {\n    return this.useStorage('$translateLocalStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useCookieStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateCookieStorage` service as storage layer.\n   */\n  this.useCookieStorage = function () {\n    return this.useStorage('$translateCookieStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use custom service as storage layer.\n   */\n  this.useStorage = function (storageFactory) {\n    $storageFactory = storageFactory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storagePrefix\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets prefix for storage key.\n   *\n   * @param {string} prefix Storage key prefix\n   */\n  this.storagePrefix = function (prefix) {\n    if (!prefix) {\n      return prefix;\n    }\n    $storagePrefix = prefix;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandlerLog\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use built-in log handler when trying to translate\n   * a translation Id which doesn't exist.\n   *\n   * This is actually a shortcut method for `useMissingTranslationHandler()`.\n   *\n   */\n  this.useMissingTranslationHandlerLog = function () {\n    return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandler\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Expects a factory name which later gets instantiated with `$injector`.\n   * This method can be used to tell angular-translate to use a custom\n   * missingTranslationHandler. Just build a factory which returns a function\n   * and expects a translation id as argument.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.useMissingTranslationHandler('customHandler');\n   *  });\n   *\n   *  app.factory('customHandler', function (dep1, dep2) {\n   *    return function (translationId) {\n   *      // something with translationId and dep1 and dep2\n   *    };\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.useMissingTranslationHandler = function (factory) {\n    $missingTranslationHandlerFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#usePostCompiling\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If post compiling is enabled, all translated values will be processed\n   * again with AngularJS' $compile.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.usePostCompiling(true);\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.usePostCompiling = function (value) {\n    $postCompilingEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#forceAsyncReload\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If force async reload is enabled, async loader will always be called\n   * even if $translationTable already contains the language key, adding\n   * possible new entries to the $translationTable.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.forceAsyncReload(true);\n   *  });\n   * </pre>\n   *\n   * @param {boolean} value - valid values are true or false\n   */\n  this.forceAsyncReload = function (value) {\n    $forceAsyncReloadEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#uniformLanguageTag\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which language tag should be used as a result when determining\n   * the current browser language.\n   *\n   * This setting must be set before invoking {@link pascalprecht.translate.$translateProvider#methods_determinePreferredLanguage determinePreferredLanguage()}.\n   *\n   * <pre>\n   * $translateProvider\n   *   .uniformLanguageTag('bcp47')\n   *   .determinePreferredLanguage()\n   * </pre>\n   *\n   * The resolver currently supports:\n   * * default\n   *     (traditionally: hyphens will be converted into underscores, i.e. en-US => en_US)\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_us\n   * * java\n   *     like default, but the second part will be always in uppercase\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_US\n   * * BCP 47 (RFC 4646 & 4647)\n   *     en-US => en-US\n   *     en_US => en-US\n   *     en-us => en-US\n   *\n   * See also:\n   * * http://en.wikipedia.org/wiki/IETF_language_tag\n   * * http://www.w3.org/International/core/langtags/\n   * * http://tools.ietf.org/html/bcp47\n   *\n   * @param {string|object} options - options (or standard)\n   * @param {string} options.standard - valid values are 'default', 'bcp47', 'java'\n   */\n  this.uniformLanguageTag = function (options) {\n\n    if (!options) {\n      options = {};\n    } else if (angular.isString(options)) {\n      options = {\n        standard: options\n      };\n    }\n\n    uniformLanguageTagResolver = options.standard;\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#determinePreferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to try to determine on its own which language key\n   * to set as preferred language. When `fn` is given, angular-translate uses it\n   * to determine a language key, otherwise it uses the built-in `getLocale()`\n   * method.\n   *\n   * The `getLocale()` returns a language key in the format `[lang]_[country]` or\n   * `[lang]` depending on what the browser provides.\n   *\n   * Use this method at your own risk, since not all browsers return a valid\n   * locale (see {@link pascalprecht.translate.$translateProvider#methods_uniformLanguageTag uniformLanguageTag()}).\n   *\n   * @param {Function=} fn Function to determine a browser's locale\n   */\n  this.determinePreferredLanguage = function (fn) {\n\n    var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();\n\n    if (!$availableLanguageKeys.length) {\n      $preferredLanguage = locale;\n    } else {\n      $preferredLanguage = negotiateLocale(locale) || locale;\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#registerAvailableLanguageKeys\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a set of language keys the app will work with. Use this method in\n   * combination with\n   * {@link pascalprecht.translate.$translateProvider#determinePreferredLanguage determinePreferredLanguage}.\n   * When available languages keys are registered, angular-translate\n   * tries to find the best fitting language key depending on the browsers locale,\n   * considering your language key convention.\n   *\n   * @param {object} languageKeys Array of language keys the your app will use\n   * @param {object=} aliases Alias map.\n   */\n  this.registerAvailableLanguageKeys = function (languageKeys, aliases) {\n    if (languageKeys) {\n      $availableLanguageKeys = languageKeys;\n      if (aliases) {\n        $languageKeyAliases = aliases;\n      }\n      return this;\n    }\n    return $availableLanguageKeys;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoaderCache\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a cache for internal $http based loaders.\n   * {@link pascalprecht.translate.$translationCache $translationCache}.\n   * When false the cache will be disabled (default). When true or undefined\n   * the cache will be a default (see $cacheFactory). When an object it will\n   * be treat as a cache object itself: the usage is $http({cache: cache})\n   *\n   * @param {object} cache boolean, string or cache-object\n   */\n  this.useLoaderCache = function (cache) {\n    if (cache === false) {\n      // disable cache\n      loaderCache = undefined;\n    } else if (cache === true) {\n      // enable cache using AJS defaults\n      loaderCache = true;\n    } else if (typeof(cache) === 'undefined') {\n      // enable cache using default\n      loaderCache = '$translationCache';\n    } else if (cache) {\n      // enable cache using given one (see $cacheFactory)\n      loaderCache = cache;\n    }\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#directivePriority\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets the default priority of the translate directive. The standard value is `0`.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {number} priority for the translate-directive\n   */\n  this.directivePriority = function (priority) {\n    if (priority === undefined) {\n      // getter\n      return directivePriority;\n    } else {\n      // setter with chaining\n      directivePriority = priority;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#statefulFilter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Since AngularJS 1.3, filters which are not stateless (depending at the scope)\n   * have to explicit define this behavior.\n   * Sets whether the translate filter should be stateful or stateless. The standard value is `true`\n   * meaning being stateful.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {boolean} state - defines the state of the filter\n   */\n  this.statefulFilter = function (state) {\n    if (state === undefined) {\n      // getter\n      return statefulFilter;\n    } else {\n      // setter with chaining\n      statefulFilter = state;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translate\n   * @requires $interpolate\n   * @requires $log\n   * @requires $rootScope\n   * @requires $q\n   *\n   * @description\n   * The `$translate` service is the actual core of angular-translate. It expects a translation id\n   * and optional interpolate parameters to translate contents.\n   *\n   * <pre>\n   *  $translate('HEADLINE_TEXT').then(function (translation) {\n   *    $scope.translatedText = translation;\n   *  });\n   * </pre>\n   *\n   * @param {string|array} translationId A token which represents a translation id\n   *                                     This can be optionally an array of translation ids which\n   *                                     results that the function returns an object where each key\n   *                                     is the translation id and the value the translation.\n   * @param {object=} interpolateParams An object hash for dynamic values\n   * @param {string} interpolationId The id of the interpolation to use\n   * @param {string} forceLanguage A language to be used instead of the current language\n   * @returns {object} promise\n   */\n  this.$get = [\n    '$log',\n    '$injector',\n    '$rootScope',\n    '$q',\n    function ($log, $injector, $rootScope, $q) {\n\n      var Storage,\n          defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),\n          pendingLoader = false,\n          interpolatorHashMap = {},\n          langPromises = {},\n          fallbackIndex,\n          startFallbackIteration;\n\n      var $translate = function (translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage) {\n\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          // Inspired by Q.allSettled by Kris Kowal\n          // https://github.com/kriskowal/q/blob/b0fa72980717dc202ffc3cbf03b936e10ebbb9d7/q.js#L1553-1563\n          // This transforms all promises regardless resolved or rejected\n          var translateAll = function (translationIds) {\n            var results = {}; // storing the actual results\n            var promises = []; // promises to wait for\n            // Wraps the promise a) being always resolved and b) storing the link id->value\n            var translate = function (translationId) {\n              var deferred = $q.defer();\n              var regardless = function (value) {\n                results[translationId] = value;\n                deferred.resolve([translationId, value]);\n              };\n              // we don't care whether the promise was resolved or rejected; just store the values\n              $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage).then(regardless, regardless);\n              return deferred.promise;\n            };\n            for (var i = 0, c = translationIds.length; i < c; i++) {\n              promises.push(translate(translationIds[i]));\n            }\n            // wait for all (including storing to results)\n            return $q.all(promises).then(function () {\n              // return the results\n              return results;\n            });\n          };\n          return translateAll(translationId);\n        }\n\n        var deferred = $q.defer();\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var promiseToWaitFor = (function () {\n          var promise = $preferredLanguage ?\n            langPromises[$preferredLanguage] :\n            langPromises[uses];\n\n          fallbackIndex = 0;\n\n          if ($storageFactory && !promise) {\n            // looks like there's no pending promise for $preferredLanguage or\n            // $uses. Maybe there's one pending for a language that comes from\n            // storage.\n            var langKey = Storage.get($storageKey);\n            promise = langPromises[langKey];\n\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n                var index = indexOf($fallbackLanguage, langKey);\n                // maybe the language from storage is also defined as fallback language\n                // we increase the fallback language index to not search in that language\n                // as fallback, since it's probably the first used language\n                // in that case the index starts after the first element\n                fallbackIndex = (index === 0) ? 1 : 0;\n\n                // but we can make sure to ALWAYS fallback to preferred language at least\n                if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n                  $fallbackLanguage.push($preferredLanguage);\n                }\n            }\n          }\n          return promise;\n        }());\n\n        if (!promiseToWaitFor) {\n          // no promise to wait for? okay. Then there's no loader registered\n          // nor is a one pending for language that comes from storage.\n          // We can just translate.\n          determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n        } else {\n          var promiseResolved = function () {\n            // $uses may have changed while waiting\n            if (!forceLanguage) {\n              uses = $uses;\n            }\n            determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n          };\n          promiseResolved.displayName = 'promiseResolved';\n\n          promiseToWaitFor['finally'](promiseResolved);\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name applyNotFoundIndicators\n       * @private\n       *\n       * @description\n       * Applies not fount indicators to given translation id, if needed.\n       * This function gets only executed, if a translation id doesn't exist,\n       * which is why a translation id is expected as argument.\n       *\n       * @param {string} translationId Translation id.\n       * @returns {string} Same as given translation id but applied with not found\n       * indicators.\n       */\n      var applyNotFoundIndicators = function (translationId) {\n        // applying notFoundIndicators\n        if ($notFoundIndicatorLeft) {\n          translationId = [$notFoundIndicatorLeft, translationId].join(' ');\n        }\n        if ($notFoundIndicatorRight) {\n          translationId = [translationId, $notFoundIndicatorRight].join(' ');\n        }\n        return translationId;\n      };\n\n      /**\n       * @name useLanguage\n       * @private\n       *\n       * @description\n       * Makes actual use of a language by setting a given language key as used\n       * language and informs registered interpolators to also use the given\n       * key as locale.\n       *\n       * @param {key} Locale key.\n       */\n      var useLanguage = function (key) {\n        $uses = key;\n\n        // make sure to store new language key before triggering success event\n        if ($storageFactory) {\n          Storage.put($translate.storageKey(), $uses);\n        }\n\n        $rootScope.$emit('$translateChangeSuccess', {language: key});\n\n        // inform default interpolator\n        defaultInterpolator.setLocale($uses);\n\n        var eachInterpolator = function (interpolator, id) {\n          interpolatorHashMap[id].setLocale($uses);\n        };\n        eachInterpolator.displayName = 'eachInterpolatorLocaleSetter';\n\n        // inform all others too!\n        angular.forEach(interpolatorHashMap, eachInterpolator);\n        $rootScope.$emit('$translateChangeEnd', {language: key});\n      };\n\n      /**\n       * @name loadAsync\n       * @private\n       *\n       * @description\n       * Kicks of registered async loader using `$injector` and applies existing\n       * loader options. When resolved, it updates translation tables accordingly\n       * or rejects with given language key.\n       *\n       * @param {string} key Language key.\n       * @return {Promise} A promise.\n       */\n      var loadAsync = function (key) {\n        if (!key) {\n          throw 'No language key specified for loading.';\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateLoadingStart', {language: key});\n        pendingLoader = true;\n\n        var cache = loaderCache;\n        if (typeof(cache) === 'string') {\n          // getting on-demand instance of loader\n          cache = $injector.get(cache);\n        }\n\n        var loaderOptions = angular.extend({}, $loaderOptions, {\n          key: key,\n          $http: angular.extend({}, {\n            cache: cache\n          }, $loaderOptions.$http)\n        });\n\n        var onLoaderSuccess = function (data) {\n          var translationTable = {};\n          $rootScope.$emit('$translateLoadingSuccess', {language: key});\n\n          if (angular.isArray(data)) {\n            angular.forEach(data, function (table) {\n              angular.extend(translationTable, flatObject(table));\n            });\n          } else {\n            angular.extend(translationTable, flatObject(data));\n          }\n          pendingLoader = false;\n          deferred.resolve({\n            key: key,\n            table: translationTable\n          });\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderSuccess.displayName = 'onLoaderSuccess';\n\n        var onLoaderError = function (key) {\n          $rootScope.$emit('$translateLoadingError', {language: key});\n          deferred.reject(key);\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderError.displayName = 'onLoaderError';\n\n        $injector.get($loaderFactory)(loaderOptions)\n          .then(onLoaderSuccess, onLoaderError);\n\n        return deferred.promise;\n      };\n\n      if ($storageFactory) {\n        Storage = $injector.get($storageFactory);\n\n        if (!Storage.get || !Storage.put) {\n          throw new Error('Couldn\\'t use storage \\'' + $storageFactory + '\\', missing get() or put() method!');\n        }\n      }\n\n      // if we have additional interpolations that were added via\n      // $translateProvider.addInterpolation(), we have to map'em\n      if ($interpolatorFactories.length) {\n        var eachInterpolationFactory = function (interpolatorFactory) {\n          var interpolator = $injector.get(interpolatorFactory);\n          // setting initial locale for each interpolation service\n          interpolator.setLocale($preferredLanguage || $uses);\n          // make'em recognizable through id\n          interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;\n        };\n        eachInterpolationFactory.displayName = 'interpolationFactoryAdder';\n\n        angular.forEach($interpolatorFactories, eachInterpolationFactory);\n      }\n\n      /**\n       * @name getTranslationTable\n       * @private\n       *\n       * @description\n       * Returns a promise that resolves to the translation table\n       * or is rejected if an error occurred.\n       *\n       * @param langKey\n       * @returns {Q.promise}\n       */\n      var getTranslationTable = function (langKey) {\n        var deferred = $q.defer();\n        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {\n          deferred.resolve($translationTable[langKey]);\n        } else if (langPromises[langKey]) {\n          var onResolve = function (data) {\n            translations(data.key, data.table);\n            deferred.resolve(data.table);\n          };\n          onResolve.displayName = 'translationTableResolver';\n          langPromises[langKey].then(onResolve, deferred.reject);\n        } else {\n          deferred.reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslation\n       * @private\n       *\n       * @description\n       * Returns a promise that will resolve to the translation\n       * or be rejected if no translation was found for the language.\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise}\n       */\n      var getFallbackTranslation = function (langKey, translationId, interpolateParams, Interpolator) {\n        var deferred = $q.defer();\n\n        var onResolve = function (translationTable) {\n          if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n            Interpolator.setLocale(langKey);\n            var translation = translationTable[translationId];\n            if (translation.substr(0, 2) === '@:') {\n              getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator)\n                .then(deferred.resolve, deferred.reject);\n            } else {\n              deferred.resolve(Interpolator.interpolate(translationTable[translationId], interpolateParams));\n            }\n            Interpolator.setLocale($uses);\n          } else {\n            deferred.reject();\n          }\n        };\n        onResolve.displayName = 'fallbackTranslationResolver';\n\n        getTranslationTable(langKey).then(onResolve, deferred.reject);\n\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslationInstant\n       * @private\n       *\n       * @description\n       * Returns a translation\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var getFallbackTranslationInstant = function (langKey, translationId, interpolateParams, Interpolator) {\n        var result, translationTable = $translationTable[langKey];\n\n        if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n          Interpolator.setLocale(langKey);\n          result = Interpolator.interpolate(translationTable[translationId], interpolateParams);\n          if (result.substr(0, 2) === '@:') {\n            return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);\n          }\n          Interpolator.setLocale($uses);\n        }\n\n        return result;\n      };\n\n\n      /**\n       * @name translateByHandler\n       * @private\n       *\n       * Translate by missing translation handler.\n       *\n       * @param translationId\n       * @returns translation created by $missingTranslationHandler or translationId is $missingTranslationHandler is\n       * absent\n       */\n      var translateByHandler = function (translationId, interpolateParams) {\n        // If we have a handler factory - we might also call it here to determine if it provides\n        // a default text for a translationid that can't be found anywhere in our tables\n        if ($missingTranslationHandlerFactory) {\n          var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams);\n          if (resultString !== undefined) {\n            return resultString;\n          } else {\n            return translationId;\n          }\n        } else {\n          return translationId;\n        }\n      };\n\n      /**\n       * @name resolveForFallbackLanguage\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise that will resolve to the translation.\n       */\n      var resolveForFallbackLanguage = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        var deferred = $q.defer();\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(\n            deferred.resolve,\n            function () {\n              // Look in the next fallback language for a translation.\n              // It delays the resolving by passing another promise to resolve.\n              resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve);\n            }\n          );\n        } else {\n          // No translation found in any fallback language\n          // if a default translation text is set in the directive, then return this as a result\n          if (defaultTranslationText) {\n            deferred.resolve(defaultTranslationText);\n          } else {\n            // if no default translation is set and an error handler is defined, send it to the handler\n            // and then return the result\n            deferred.resolve(translateByHandler(translationId, interpolateParams));\n          }\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name resolveForFallbackLanguageInstant\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var resolveForFallbackLanguageInstant = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {\n        var result;\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);\n          if (!result) {\n            result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);\n          }\n        }\n        return result;\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise, that resolves to the translation.\n       */\n      var fallbackTranslation = function (translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguage((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText);\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {String} translation\n       */\n      var fallbackTranslationInstant = function (translationId, interpolateParams, Interpolator) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguageInstant((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator);\n      };\n\n      var determineTranslation = function (translationId, interpolateParams, interpolationId, defaultTranslationText, uses) {\n\n        var deferred = $q.defer();\n\n        var table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n\n            $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses)\n              .then(deferred.resolve, deferred.reject);\n          } else {\n            deferred.resolve(Interpolator.interpolate(translation, interpolateParams));\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText)\n                .then(function (translation) {\n                  deferred.resolve(translation);\n                }, function (_translationId) {\n                  deferred.reject(applyNotFoundIndicators(_translationId));\n                });\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n              } else {\n                deferred.resolve(missingTranslationHandlerTranslation);\n              }\n          } else {\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n            } else {\n              deferred.reject(applyNotFoundIndicators(translationId));\n            }\n          }\n        }\n        return deferred.promise;\n      };\n\n      var determineTranslationInstant = function (translationId, interpolateParams, interpolationId, uses) {\n\n        var result, table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = defaultInterpolator;\n\n        // if the interpolation id exists use custom interpolator\n        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {\n          Interpolator = interpolatorHashMap[interpolationId];\n        }\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n            result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses);\n          } else {\n            result = Interpolator.interpolate(translation, interpolateParams);\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackIndex = 0;\n            result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            result = missingTranslationHandlerTranslation;\n          } else {\n            result = applyNotFoundIndicators(translationId);\n          }\n        }\n\n        return result;\n      };\n\n      var clearNextLangAndPromise = function(key) {\n        if ($nextLang === key) {\n          $nextLang = undefined;\n        }\n        langPromises[key] = undefined;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#preferredLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the preferred language.\n       *\n       * @param {string} langKey language String or Array to be used as preferredLanguage (changing at runtime)\n       *\n       * @return {string} preferred language key\n       */\n      $translate.preferredLanguage = function (langKey) {\n        if(langKey) {\n          setupPreferredLanguage(langKey);\n        }\n        return $preferredLanguage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#cloakClassName\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured class name for `translate-cloak` directive.\n       *\n       * @return {string} cloakClassName\n       */\n      $translate.cloakClassName = function () {\n        return $cloakClassName;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#nestedObjectDelimeter\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured delimiter for nested namespaces.\n       *\n       * @return {string} nestedObjectDelimeter\n       */\n      $translate.nestedObjectDelimeter = function () {\n        return $nestedObjectDelimeter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#fallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the fallback languages or sets a new fallback stack.\n       *\n       * @param {string=} langKey language String or Array of fallback languages to be used (to change stack at runtime)\n       *\n       * @return {string||array} fallback language key\n       */\n      $translate.fallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          fallbackStack(langKey);\n\n          // as we might have an async loader initiated and a new translation language might have been defined\n          // we need to add the promise to the stack also. So - iterate.\n          if ($loaderFactory) {\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n              for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n                if (!langPromises[$fallbackLanguage[i]]) {\n                  langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);\n                }\n              }\n            }\n          }\n          $translate.use($translate.use());\n        }\n        if ($fallbackWasString) {\n          return $fallbackLanguage[0];\n        } else {\n          return $fallbackLanguage;\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#useFallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Sets the first key of the fallback language stack to be used for translation.\n       * Therefore all languages in the fallback array BEFORE this key will be skipped!\n       *\n       * @param {string=} langKey Contains the langKey the iteration shall start with. Set to false if you want to\n       * get back to the whole stack\n       */\n      $translate.useFallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          if (!langKey) {\n            startFallbackIteration = 0;\n          } else {\n            var langKeyPosition = indexOf($fallbackLanguage, langKey);\n            if (langKeyPosition > -1) {\n              startFallbackIteration = langKeyPosition;\n            }\n          }\n\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#proposedLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key of language that is currently loaded asynchronously.\n       *\n       * @return {string} language key\n       */\n      $translate.proposedLanguage = function () {\n        return $nextLang;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns registered storage.\n       *\n       * @return {object} Storage\n       */\n      $translate.storage = function () {\n        return Storage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#negotiateLocale\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a language key based on available languages and language aliases. If a\n       * language key cannot be resolved, returns undefined.\n       *\n       * If no or a falsy key is given, returns undefined.\n       *\n       * @param {string} [key] Language key\n       * @return {string|undefined} Language key or undefined if no language key is found.\n       */\n      $translate.negotiateLocale = negotiateLocale;\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#use\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Tells angular-translate which language to use by given language key. This method is\n       * used to change language at runtime. It also takes care of storing the language\n       * key in a configured store to let your app remember the choosed language.\n       *\n       * When trying to 'use' a language which isn't available it tries to load it\n       * asynchronously with registered loaders.\n       *\n       * Returns promise object with loaded language file data or string of the currently used language.\n       *\n       * If no or a falsy key is given it returns the currently used language key.\n       * The returned string will be ```undefined``` if setting up $translate hasn't finished.\n       * @example\n       * $translate.use(\"en_US\").then(function(data){\n       *   $scope.text = $translate(\"HELLO\");\n       * });\n       *\n       * @param {string} [key] Language key\n       * @return {object|string} Promise with loaded language data or the language key if a falsy param was given.\n       */\n      $translate.use = function (key) {\n        if (!key) {\n          return $uses;\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateChangeStart', {language: key});\n\n        // Try to get the aliased language key\n        var aliasedKey = negotiateLocale(key);\n        if (aliasedKey) {\n          key = aliasedKey;\n        }\n\n        // if there isn't a translation table for the language we've requested,\n        // we load it asynchronously\n        $nextLang = key;\n        if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {\n          langPromises[key] = loadAsync(key).then(function (translation) {\n            translations(translation.key, translation.table);\n            deferred.resolve(translation.key);\n            if ($nextLang === key) {\n              useLanguage(translation.key);\n            }\n            return translation;\n          }, function (key) {\n            $rootScope.$emit('$translateChangeError', {language: key});\n            deferred.reject(key);\n            $rootScope.$emit('$translateChangeEnd', {language: key});\n            return $q.reject(key);\n          });\n          langPromises[key]['finally'](function () {\n            clearNextLangAndPromise(key);\n          });\n        } else if (langPromises[key]) {\n          // we are already loading this asynchronously\n          // resolve our new deferred when the old langPromise is resolved\n          langPromises[key].then(function (translation) {\n            if ($nextLang === translation.key) {\n              useLanguage(translation.key);\n            }\n            deferred.resolve(translation.key);\n            return translation;\n          }, function (key) {\n            // find first available fallback language if that request has failed\n            if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0) {\n              return $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);\n            } else {\n              return deferred.reject(key);\n            }\n          });\n        } else {\n          deferred.resolve(key);\n          useLanguage(key);\n        }\n\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storageKey\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the key for the storage.\n       *\n       * @return {string} storage key\n       */\n      $translate.storageKey = function () {\n        return storageKey();\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isPostCompilingEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether post compiling is enabled or not\n       *\n       * @return {bool} storage key\n       */\n      $translate.isPostCompilingEnabled = function () {\n        return $postCompilingEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isForceAsyncReloadEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether force async reload is enabled or not\n       *\n       * @return {boolean} forceAsyncReload value\n       */\n      $translate.isForceAsyncReloadEnabled = function () {\n        return $forceAsyncReloadEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#refresh\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Refreshes a translation table pointed by the given langKey. If langKey is not specified,\n       * the module will drop all existent translation tables and load new version of those which\n       * are currently in use.\n       *\n       * Refresh means that the module will drop target translation table and try to load it again.\n       *\n       * In case there are no loaders registered the refresh() method will throw an Error.\n       *\n       * If the module is able to refresh translation tables refresh() method will broadcast\n       * $translateRefreshStart and $translateRefreshEnd events.\n       *\n       * @example\n       * // this will drop all currently existent translation tables and reload those which are\n       * // currently in use\n       * $translate.refresh();\n       * // this will refresh a translation table for the en_US language\n       * $translate.refresh('en_US');\n       *\n       * @param {string} langKey A language key of the table, which has to be refreshed\n       *\n       * @return {promise} Promise, which will be resolved in case a translation tables refreshing\n       * process is finished successfully, and reject if not.\n       */\n      $translate.refresh = function (langKey) {\n        if (!$loaderFactory) {\n          throw new Error('Couldn\\'t refresh translation table, no loader registered!');\n        }\n\n        var deferred = $q.defer();\n\n        function resolve() {\n          deferred.resolve();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        function reject() {\n          deferred.reject();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        $rootScope.$emit('$translateRefreshStart', {language: langKey});\n\n        if (!langKey) {\n          // if there's no language key specified we refresh ALL THE THINGS!\n          var tables = [], loadingKeys = {};\n\n          // reload registered fallback languages\n          if ($fallbackLanguage && $fallbackLanguage.length) {\n            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n              tables.push(loadAsync($fallbackLanguage[i]));\n              loadingKeys[$fallbackLanguage[i]] = true;\n            }\n          }\n\n          // reload currently used language\n          if ($uses && !loadingKeys[$uses]) {\n            tables.push(loadAsync($uses));\n          }\n\n          var allTranslationsLoaded = function (tableData) {\n            $translationTable = {};\n            angular.forEach(tableData, function (data) {\n              translations(data.key, data.table);\n            });\n            if ($uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          allTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          $q.all(tables).then(allTranslationsLoaded, reject);\n\n        } else if ($translationTable[langKey]) {\n\n          var oneTranslationsLoaded = function (data) {\n            translations(data.key, data.table);\n            if (langKey === $uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          oneTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          loadAsync(langKey).then(oneTranslationsLoaded, reject);\n\n        } else {\n          reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#instant\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a translation instantly from the internal state of loaded translation. All rules\n       * regarding the current language, the preferred language of even fallback languages will be\n       * used except any promise handling. If a language was not found, an asynchronous loading\n       * will be invoked in the background.\n       *\n       * @param {string|array} translationId A token which represents a translation id\n       *                                     This can be optionally an array of translation ids which\n       *                                     results that the function's promise returns an object where\n       *                                     each key is the translation id and the value the translation.\n       * @param {object} interpolateParams Params\n       * @param {string} interpolationId The id of the interpolation to use\n       * @param {string} forceLanguage A language to be used instead of the current language\n       *\n       * @return {string|object} translation\n       */\n      $translate.instant = function (translationId, interpolateParams, interpolationId, forceLanguage) {\n\n        // we don't want to re-negotiate $uses\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Detect undefined and null values to shorten the execution and prevent exceptions\n        if (translationId === null || angular.isUndefined(translationId)) {\n          return translationId;\n        }\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          var results = {};\n          for (var i = 0, c = translationId.length; i < c; i++) {\n            results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage);\n          }\n          return results;\n        }\n\n        // We discarded unacceptable values. So we just need to verify if translationId is empty String\n        if (angular.isString(translationId) && translationId.length < 1) {\n          return translationId;\n        }\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var result, possibleLangKeys = [];\n        if ($preferredLanguage) {\n          possibleLangKeys.push($preferredLanguage);\n        }\n        if (uses) {\n          possibleLangKeys.push(uses);\n        }\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);\n        }\n        for (var j = 0, d = possibleLangKeys.length; j < d; j++) {\n          var possibleLangKey = possibleLangKeys[j];\n          if ($translationTable[possibleLangKey]) {\n            if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {\n              result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses);\n            }\n          }\n          if (typeof result !== 'undefined') {\n            break;\n          }\n        }\n\n        if (!result && result !== '') {\n          if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {\n            result = applyNotFoundIndicators(translationId);\n          } else {\n            // Return translation of default interpolator if not found anything.\n            result = defaultInterpolator.interpolate(translationId, interpolateParams);\n            if ($missingTranslationHandlerFactory && !pendingLoader) {\n              result = translateByHandler(translationId, interpolateParams);\n            }\n          }\n        }\n\n        return result;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#versionInfo\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the current version information for the angular-translate library\n       *\n       * @return {string} angular-translate version\n       */\n      $translate.versionInfo = function () {\n        return version;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#loaderCache\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the defined loaderCache.\n       *\n       * @return {boolean|string|object} current value of loaderCache\n       */\n      $translate.loaderCache = function () {\n        return loaderCache;\n      };\n\n      // internal purpose only\n      $translate.directivePriority = function () {\n        return directivePriority;\n      };\n\n      // internal purpose only\n      $translate.statefulFilter = function () {\n        return statefulFilter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_onReady onReady()}.\n       *\n       * @return {boolean} current value of ready\n       */\n      $translate.isReady = function () {\n        return $isReady;\n      };\n\n      var $onReadyDeferred = $q.defer();\n      $onReadyDeferred.promise.then(function () {\n        $isReady = true;\n      });\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#onReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_isReady isReady()}.\n       *\n       * @param {Function=} fn Function to invoke when service is ready\n       * @return {object} Promise resolved when service is ready\n       */\n      $translate.onReady = function (fn) {\n        var deferred = $q.defer();\n        if (angular.isFunction(fn)) {\n          deferred.promise.then(fn);\n        }\n        if ($isReady) {\n          deferred.resolve();\n        } else {\n          $onReadyDeferred.promise.then(deferred.resolve);\n        }\n        return deferred.promise;\n      };\n\n      // Whenever $translateReady is being fired, this will ensure the state of $isReady\n      var globalOnReadyListener = $rootScope.$on('$translateReady', function () {\n        $onReadyDeferred.resolve();\n        globalOnReadyListener(); // one time only\n        globalOnReadyListener = null;\n      });\n      var globalOnChangeListener = $rootScope.$on('$translateChangeEnd', function () {\n        $onReadyDeferred.resolve();\n        globalOnChangeListener(); // one time only\n        globalOnChangeListener = null;\n      });\n\n      if ($loaderFactory) {\n\n        // If at least one async loader is defined and there are no\n        // (default) translations available we should try to load them.\n        if (angular.equals($translationTable, {})) {\n          if ($translate.use()) {\n            $translate.use($translate.use());\n          }\n        }\n\n        // Also, if there are any fallback language registered, we start\n        // loading them asynchronously as soon as we can.\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          var processAsyncResult = function (translation) {\n            translations(translation.key, translation.table);\n            $rootScope.$emit('$translateChangeEnd', { language: translation.key });\n            return translation;\n          };\n          for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n            var fallbackLanguageId = $fallbackLanguage[i];\n            if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {\n              langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);\n            }\n          }\n        }\n      } else {\n        $rootScope.$emit('$translateReady', { language: $translate.use() });\n      }\n\n      return $translate;\n    }\n  ];\n}\n$translate.$inject = ['$STORAGE_KEY', '$windowProvider', '$translateSanitizationProvider', 'pascalprechtTranslateOverrider'];\n\n$translate.displayName = 'displayName';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateDefaultInterpolation\n * @requires $interpolate\n *\n * @description\n * Uses angular's `$interpolate` services to interpolate strings against some values.\n *\n * Be aware to configure a proper sanitization strategy.\n *\n * See also:\n * * {@link pascalprecht.translate.$translateSanitization}\n *\n * @return {object} $translateDefaultInterpolation Interpolator service\n */\nangular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', $translateDefaultInterpolation);\n\nfunction $translateDefaultInterpolation ($interpolate, $translateSanitization) {\n\n  'use strict';\n\n  var $translateInterpolator = {},\n      $locale,\n      $identifier = 'default';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#setLocale\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Sets current locale (this is currently not use in this interpolation).\n   *\n   * @param {string} locale Language key or locale.\n   */\n  $translateInterpolator.setLocale = function (locale) {\n    $locale = locale;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#getInterpolationIdentifier\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Returns an identifier for this interpolation service.\n   *\n   * @returns {string} $identifier\n   */\n  $translateInterpolator.getInterpolationIdentifier = function () {\n    return $identifier;\n  };\n\n  /**\n   * @deprecated will be removed in 3.0\n   * @see {@link pascalprecht.translate.$translateSanitization}\n   */\n  $translateInterpolator.useSanitizeValueStrategy = function (value) {\n    $translateSanitization.useStrategy(value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#interpolate\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Interpolates given string agains given interpolate params using angulars\n   * `$interpolate` service.\n   *\n   * @returns {string} interpolated string.\n   */\n  $translateInterpolator.interpolate = function (string, interpolationParams) {\n    interpolationParams = interpolationParams || {};\n    interpolationParams = $translateSanitization.sanitize(interpolationParams, 'params');\n\n    var interpolatedText = $interpolate(string)(interpolationParams);\n    interpolatedText = $translateSanitization.sanitize(interpolatedText, 'text');\n\n    return interpolatedText;\n  };\n\n  return $translateInterpolator;\n}\n$translateDefaultInterpolation.$inject = ['$interpolate', '$translateSanitization'];\n\n$translateDefaultInterpolation.displayName = '$translateDefaultInterpolation';\n\nangular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translate\n * @requires $compile\n * @requires $filter\n * @requires $interpolate\n * @restrict AE\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate Translation id which could be either string or interpolated string.\n * @param {string=} translate-values Values to pass into translation id. Can be passed as object literal string or interpolated object.\n * @param {string=} translate-attr-ATTR translate Translation id and put it into ATTR attribute.\n * @param {string=} translate-default will be used unless translation was successful\n * @param {boolean=} translate-compile (default true if present) defines locally activation of {@link pascalprecht.translate.$translateProvider#methods_usePostCompiling}\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre translate=\"TRANSLATION_ID\"></pre>\n        <pre translate>TRANSLATION_ID</pre>\n        <pre translate translate-attr-title=\"TRANSLATION_ID\"></pre>\n        <pre translate=\"{{translationId}}\"></pre>\n        <pre translate>{{translationId}}</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{value: 5}\"></pre>\n        <pre translate translate-values=\"{value: 5}\">WITH_VALUES</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n        <pre translate translate-values=\"{{values}}\">WITH_VALUES</pre>\n        <pre translate translate-attr-title=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        }).preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n    <file name=\"scenario.js\">\n      it('should translate', function () {\n        inject(function ($rootScope, $compile) {\n          $rootScope.translationId = 'TRANSLATION_ID';\n\n          element = $compile('<p translate=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate=\"{{translationId}}\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>TRANSLATION_ID</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>{{translationId}}</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate translate-attr-title=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.attr('title')).toBe('Hello there!');\n        });\n      });\n    </file>\n   </example>\n */\n.directive('translate', translateDirective);\nfunction translateDirective($translate, $q, $interpolate, $compile, $parse, $rootScope) {\n\n  'use strict';\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  return {\n    restrict: 'AE',\n    scope: true,\n    priority: $translate.directivePriority(),\n    compile: function (tElement, tAttr) {\n\n      var translateValuesExist = (tAttr.translateValues) ?\n        tAttr.translateValues : undefined;\n\n      var translateInterpolation = (tAttr.translateInterpolation) ?\n        tAttr.translateInterpolation : undefined;\n\n      var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);\n\n      var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',\n          watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';\n\n      return function linkFn(scope, iElement, iAttr) {\n\n        scope.interpolateParams = {};\n        scope.preText = '';\n        scope.postText = '';\n        scope.translateNamespace = getTranslateNamespace(scope);\n        var translationIds = {};\n\n        var initInterpolationParams = function (interpolateParams, iAttr, tAttr) {\n          // initial setup\n          if (iAttr.translateValues) {\n            angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));\n          }\n          // initially fetch all attributes if existing and fill the params\n          if (translateValueExist) {\n            for (var attr in tAttr) {\n              if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n                var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);\n                interpolateParams[attributeName] = tAttr[attr];\n              }\n            }\n          }\n        };\n\n        // Ensures any change of the attribute \"translate\" containing the id will\n        // be re-stored to the scope's \"translationId\".\n        // If the attribute has no content, the element's text value (white spaces trimmed off) will be used.\n        var observeElementTranslation = function (translationId) {\n\n          // Remove any old watcher\n          if (angular.isFunction(observeElementTranslation._unwatchOld)) {\n            observeElementTranslation._unwatchOld();\n            observeElementTranslation._unwatchOld = undefined;\n          }\n\n          if (angular.equals(translationId , '') || !angular.isDefined(translationId)) {\n            var iElementText = trim.apply(iElement.text());\n\n            // Resolve translation id by inner html if required\n            var interpolateMatches = iElementText.match(interpolateRegExp);\n            // Interpolate translation id if required\n            if (angular.isArray(interpolateMatches)) {\n              scope.preText = interpolateMatches[1];\n              scope.postText = interpolateMatches[3];\n              translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);\n              var watcherMatches = iElementText.match(watcherRegExp);\n              if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {\n                observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function (newValue) {\n                  translationIds.translate = newValue;\n                  updateTranslations();\n                });\n              }\n            } else {\n              // do not assigne the translation id if it is empty.\n              translationIds.translate = !iElementText ? undefined : iElementText;\n            }\n          } else {\n            translationIds.translate = translationId;\n          }\n          updateTranslations();\n        };\n\n        var observeAttributeTranslation = function (translateAttr) {\n          iAttr.$observe(translateAttr, function (translationId) {\n            translationIds[translateAttr] = translationId;\n            updateTranslations();\n          });\n        };\n\n        // initial setup with values\n        initInterpolationParams(scope.interpolateParams, iAttr, tAttr);\n\n        var firstAttributeChangedEvent = true;\n        iAttr.$observe('translate', function (translationId) {\n          if (typeof translationId === 'undefined') {\n            // case of element \"<translate>xyz</translate>\"\n            observeElementTranslation('');\n          } else {\n            // case of regular attribute\n            if (translationId !== '' || !firstAttributeChangedEvent) {\n              translationIds.translate = translationId;\n              updateTranslations();\n            }\n          }\n          firstAttributeChangedEvent = false;\n        });\n\n        for (var translateAttr in iAttr) {\n          if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr') {\n            observeAttributeTranslation(translateAttr);\n          }\n        }\n\n        iAttr.$observe('translateDefault', function (value) {\n          scope.defaultText = value;\n          updateTranslations();\n        });\n\n        if (translateValuesExist) {\n          iAttr.$observe('translateValues', function (interpolateParams) {\n            if (interpolateParams) {\n              scope.$parent.$watch(function () {\n                angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));\n              });\n            }\n          });\n        }\n\n        if (translateValueExist) {\n          var observeValueAttribute = function (attrName) {\n            iAttr.$observe(attrName, function (value) {\n              var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);\n              scope.interpolateParams[attributeName] = value;\n            });\n          };\n          for (var attr in iAttr) {\n            if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n              observeValueAttribute(attr);\n            }\n          }\n        }\n\n        // Master update function\n        var updateTranslations = function () {\n          for (var key in translationIds) {\n\n            if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {\n              updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);\n            }\n          }\n        };\n\n        // Put translation processing function outside loop\n        var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {\n          if (translationId) {\n            // if translation id starts with '.' and translateNamespace given, prepend namespace\n            if (translateNamespace && translationId.charAt(0) === '.') {\n              translationId = translateNamespace + translationId;\n            }\n\n            $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage)\n              .then(function (translation) {\n                applyTranslation(translation, scope, true, translateAttr);\n              }, function (translationId) {\n                applyTranslation(translationId, scope, false, translateAttr);\n              });\n          } else {\n            // as an empty string cannot be translated, we can solve this using successful=false\n            applyTranslation(translationId, scope, false, translateAttr);\n          }\n        };\n\n        var applyTranslation = function (value, scope, successful, translateAttr) {\n          if (translateAttr === 'translate') {\n            // default translate into innerHTML\n            if (!successful && typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n            iElement.empty().append(scope.preText + value + scope.postText);\n            var globallyEnabled = $translate.isPostCompilingEnabled();\n            var locallyDefined = typeof tAttr.translateCompile !== 'undefined';\n            var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';\n            if ((globallyEnabled && !locallyDefined) || locallyEnabled) {\n              $compile(iElement.contents())(scope);\n            }\n          } else {\n            // translate attribute\n            if (!successful && typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n            var attributeName = iAttr.$attr[translateAttr];\n            if (attributeName.substr(0, 5) === 'data-') {\n              // ensure html5 data prefix is stripped\n              attributeName = attributeName.substr(5);\n            }\n            attributeName = attributeName.substr(15);\n            iElement.attr(attributeName, value);\n          }\n        };\n\n        if (translateValuesExist || translateValueExist || iAttr.translateDefault) {\n          scope.$watch('interpolateParams', updateTranslations, true);\n        }\n        scope.$watch('translateLanguage', updateTranslations);\n\n        // Ensures the text will be refreshed after the current language was changed\n        // w/ $translate.use(...)\n        var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);\n\n        // ensure translation will be looked up at least one\n        if (iElement.text().length) {\n          if (iAttr.translate) {\n            observeElementTranslation(iAttr.translate);\n          } else {\n            observeElementTranslation('');\n          }\n        } else if (iAttr.translate) {\n          // ensure attribute will be not skipped\n          observeElementTranslation(iAttr.translate);\n        }\n        updateTranslations();\n        scope.$on('$destroy', unbind);\n      };\n    }\n  };\n}\ntranslateDirective.$inject = ['$translate', '$q', '$interpolate', '$compile', '$parse', '$rootScope'];\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateDirective.displayName = 'translateDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateCloak\n * @requires $rootScope\n * @requires $translate\n * @restrict A\n *\n * $description\n * Adds a `translate-cloak` class name to the given element where this directive\n * is applied initially and removes it, once a loader has finished loading.\n *\n * This directive can be used to prevent initial flickering when loading translation\n * data asynchronously.\n *\n * The class name is defined in\n * {@link pascalprecht.translate.$translateProvider#cloakClassName $translate.cloakClassName()}.\n *\n * @param {string=} translate-cloak If a translationId is provided, it will be used for showing\n *                                  or hiding the cloak. Basically it relies on the translation\n *                                  resolve.\n */\n.directive('translateCloak', translateCloakDirective);\n\nfunction translateCloakDirective($translate, $rootScope) {\n\n  'use strict';\n\n  return {\n    compile: function (tElement) {\n      var applyCloak = function () {\n        tElement.addClass($translate.cloakClassName());\n      },\n      removeCloak = function () {\n        tElement.removeClass($translate.cloakClassName());\n      };\n      $translate.onReady(function () {\n        removeCloak();\n      });\n      applyCloak();\n\n      return function linkFn(scope, iElement, iAttr) {\n        if (iAttr.translateCloak && iAttr.translateCloak.length) {\n          // Register a watcher for the defined translation allowing a fine tuned cloak\n          iAttr.$observe('translateCloak', function (translationId) {\n            $translate(translationId).then(removeCloak, applyCloak);\n          });\n          // Register for change events as this is being another indicicator revalidating the cloak)\n          $rootScope.$on('$translateChangeSuccess', function () {\n            $translate(iAttr.translateCloak).then(removeCloak, applyCloak);\n          });\n        }\n      };\n    }\n  };\n}\ntranslateCloakDirective.$inject = ['$translate', '$rootScope'];\n\ntranslateCloakDirective.displayName = 'translateCloakDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateNamespace\n * @restrict A\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate namespace name which could be either string or interpolated string.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div translate-namespace=\"CONTENT\">\n\n        <div>\n            <h1 translate>.HEADERS.TITLE</h1>\n            <h1 translate>.HEADERS.WELCOME</h1>\n        </div>\n\n        <div translate-namespace=\".HEADERS\">\n            <h1 translate>.TITLE</h1>\n            <h1 translate>.WELCOME</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'CONTENT': {\n            'HEADERS': {\n                TITLE: 'Title'\n            }\n          },\n          'CONTENT.HEADERS.WELCOME': 'Welcome'\n        }).preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateNamespace', translateNamespaceDirective);\n\nfunction translateNamespaceDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return {\n        pre: function (scope, iElement, iAttrs) {\n          scope.translateNamespace = getTranslateNamespace(scope);\n\n          if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === '.') {\n            scope.translateNamespace += iAttrs.translateNamespace;\n          } else {\n            scope.translateNamespace = iAttrs.translateNamespace;\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateNamespaceDirective.displayName = 'translateNamespaceDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateLanguage\n * @restrict A\n *\n * @description\n * Forces the language to the directives in the underlying scope.\n *\n * @param {string=} translate language that will be negotiated.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div>\n\n        <div>\n            <h1 translate>HELLO</h1>\n        </div>\n\n        <div translate-language=\"de\">\n            <h1 translate>HELLO</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider\n          .translations('en',{\n            'HELLO': 'Hello world!'\n          })\n          .translations('de',{\n            'HELLO': 'Hallo Welt!'\n          })\n          .translations(.preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateLanguage', translateLanguageDirective);\n\nfunction translateLanguageDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return function linkFn(scope, iElement, iAttrs) {\n        iAttrs.$observe('translateLanguage', function (newTranslateLanguage) {\n          scope.translateLanguage = newTranslateLanguage;\n        });\n      };\n    }\n  };\n}\n\ntranslateLanguageDirective.displayName = 'translateLanguageDirective';\n\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc filter\n * @name pascalprecht.translate.filter:translate\n * @requires $parse\n * @requires pascalprecht.translate.$translate\n * @function\n *\n * @description\n * Uses `$translate` service to translate contents. Accepts interpolate parameters\n * to pass dynamized values though translation.\n *\n * @param {string} translationId A translation id to be translated.\n * @param {*=} interpolateParams Optional object literal (as hash or string) to pass values into translation.\n *\n * @returns {string} Translated text.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre>{{ 'TRANSLATION_ID' | translate }}</pre>\n        <pre>{{ translationId | translate }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:'{value: 5}' }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:values }}</pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en', {\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        });\n        $translateProvider.preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n   </example>\n */\n.filter('translate', translateFilterFactory);\n\nfunction translateFilterFactory($parse, $translate) {\n\n  'use strict';\n\n  var translateFilter = function (translationId, interpolateParams, interpolation, forceLanguage) {\n\n    if (!angular.isObject(interpolateParams)) {\n      interpolateParams = $parse(interpolateParams)(this);\n    }\n\n    return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);\n  };\n\n  if ($translate.statefulFilter()) {\n    translateFilter.$stateful = true;\n  }\n\n  return translateFilter;\n}\ntranslateFilterFactory.$inject = ['$parse', '$translate'];\n\ntranslateFilterFactory.displayName = 'translateFilterFactory';\n\nangular.module('pascalprecht.translate')\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translationCache\n * @requires $cacheFactory\n *\n * @description\n * The first time a translation table is used, it is loaded in the translation cache for quick retrieval. You\n * can load translation tables directly into the cache by consuming the\n * `$translationCache` service directly.\n *\n * @return {object} $cacheFactory object.\n */\n  .factory('$translationCache', $translationCache);\n\nfunction $translationCache($cacheFactory) {\n\n  'use strict';\n\n  return $cacheFactory('translations');\n}\n$translationCache.$inject = ['$cacheFactory'];\n\n$translationCache.displayName = '$translationCache';\nreturn 'pascalprecht.translate';\n\n}));\n","/**\n * State-based routing for AngularJS\n * @version v0.2.18\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    toJson = angular.toJson;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i] || !parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:\n        result = result.replace(/\\/$/, '');\n        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  var param, paramVal;\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    param = this.params[paramName];\n    paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n    param = this.params[paramName];\n    paramVal = searchParams[paramName];\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validates\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      var isFinalPathParam = i + 1 === nPath;\n\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n\n      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      if (encoded.length === 0) continue;\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        if (isArray(val) && val.length === 0) return val;\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  // Use tildes to pre-encode slashes.\n  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n  // and bidirectional encoding/decoding fails.\n  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    \"string\": {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    \"int\": {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    \"bool\": {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    \"date\": {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    \"json\": {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    \"any\": { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\n      if (angular.isString(config.type))\n        return $types[config.type];\n      if (config.type instanceof Type)\n        return config.type;\n      return new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {function} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|function} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. \n   * \n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|function} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n\n        isHtml5 = isHtml5 && $sniffer.history;\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. Only parameters specified in the state definition can be overridden, new \n     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n     *    have changed.  It will reload the resolves and views of the current state and parent states.\n     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n     *    the transition reloads the resolves and views for that matched state, and all its children states.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n      \n      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n      if (hash) toParams['#'] = hash;\n      \n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n          if ($state.transition == null) $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .factory('$stateParams', function () { return {}; })\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\nvar ngMajorVer = angular.version.major;\nvar ngMinorVer = angular.version.minor;\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations\n * will be applied to the ui-view)\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = {\n      enter: function (element, target, cb) { target.after(element); cb(); },\n      leave: function (element, cb) { element.remove(); cb(); }\n    };\n\n    if (!!attrs.noanimation) return statics;\n\n    function animEnabled(element) {\n      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);\n      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();\n      return (!!$animator);\n    }\n\n    // ng 1.2+\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          if (!animEnabled(element)) {\n            statics.enter(element, target, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function(element, cb) {\n          if (!animEnabled(element)) {\n            statics.leave(element, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        }\n      };\n    }\n\n    // ng 1.1.5\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics;\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          var _previousEl = previousEl;\n          var _currentScope = currentScope;\n\n          if (_currentScope) {\n            _currentScope._willBeDestroyed = true;\n          }\n\n          function cleanOld() {\n            if (_previousEl) {\n              _previousEl.remove();\n            }\n\n            if (_currentScope) {\n              _currentScope.$destroy();\n            }\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              cleanOld();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n          } else {\n            cleanOld();\n            previousEl = null;\n          }\n\n          currentEl = null;\n          currentScope = null;\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          currentScope.$emit('$viewContentLoaded', name);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var inherited = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\nfunction clickHook(el, $state, $timeout, type, current) {\n  return function(e) {\n    var button = e.which || e.button, target = current();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function() {\n        $state.go(target.state, target.params, target.options);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\n      e.preventDefault = function() {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\nfunction defaultOpts(el, $state) {\n  return { relative: stateContext(el) || $state.$current, inherit: true };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n * URL, the directive will automatically generate & update the `href` attribute via\n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n * the link will trigger a state transition with optional parameters.\n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative\n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the\n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n *\n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n      var def    = { state: ref.state, href: null, params: null };\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n\n      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\n      var update = function(val) {\n        if (val) def.params = angular.copy(val);\n        def.href = $state.href(ref.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(ref.state, def.params);\n        if (def.href !== null) attrs.$set(type.attr, def.href);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n        def.params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-state\n *\n * @requires ui.router.state.uiSref\n *\n * @restrict A\n *\n * @description\n * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n * params and override options.\n *\n * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}\n * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDynamicDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n      var def    = { state: null, params: null, options: null, href: null };\n\n      function runStateRefLink (group) {\n        def.state = group[0]; def.params = group[1]; def.options = group[2];\n        def.href = $state.href(def.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(def.state, def.params);\n        if (def.href) attrs.$set(type.attr, def.href);\n      }\n\n      scope.$watch(watch, runStateRefLink, true);\n      runStateRefLink(scope.$eval(watch));\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * It is also possible to pass ui-sref-active an expression that evaluates\n * to an object hash, whose keys represent active class names and whose\n * values represent the respective state names/globs.\n * ui-sref-active will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * @Example\n * Given the following template, with \"admin\" being an abstract state:\n * <pre>\n * <div ui-sref-active=\"{'active': 'admin.*'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * </pre>\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied\n * to both the <div> and <a> elements. It is important to note that the state\n * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n      try {\n        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n      } catch (e) {\n        // Do nothing. uiSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n      if (isObject(uiSrefActive)) {\n        forEach(uiSrefActive, function(stateOrName, activeClass) {\n          if (isString(stateOrName)) {\n            var ref = parseStateRef(stateOrName, $state.current.name);\n            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n          }\n        });\n      }\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ui-sref-active, so we\n        // shadow the one that comes from ui-sref\n        if (isObject(uiSrefActive) && states.length > 0) {\n          return;\n        }\n        addState(newState, newParams, uiSrefActive);\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      function addState(stateName, stateParams, activeClass) {\n        var state = $state.get(stateName, stateContext($element));\n        var stateHash = createStateHash(stateName, stateParams);\n\n        states.push({\n          state: state || { name: stateName },\n          params: stateParams,\n          hash: stateHash\n        });\n\n        activeClasses[stateHash] = activeClass;\n      }\n\n      /**\n       * @param {string} state\n       * @param {Object|string} [params]\n       * @return {string}\n       */\n      function createStateHash(state, params) {\n        if (!isString(state)) {\n          throw new Error('state should be a string');\n        }\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        params = $scope.$eval(params);\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        return state;\n      }\n\n      // Update route state\n      function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }\n\n      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n      function removeClass(el, className) { el.removeClass(className); }\n      function anyMatch(state, params) { return $state.includes(state.name, params); }\n      function exactMatch(state, params) { return $state.is(state.name, params); }\n\n      update();\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n  .directive('uiState', $StateRefDynamicDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state, params) {\n    return $state.is(state, params);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state, params, options) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);","'use strict';\n// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.\n\nmodule.exports = {\n    // Create a <link> tag with optional data attributes\n    createLink: function(href, attributes) {\n        var head = document.head || document.getElementsByTagName('head')[0];\n        var link = document.createElement('link');\n\n        link.href = href;\n        link.rel = 'stylesheet';\n\n        for (var key in attributes) {\n            if ( ! attributes.hasOwnProperty(key)) {\n                continue;\n            }\n            var value = attributes[key];\n            link.setAttribute('data-' + key, value);\n        }\n\n        head.appendChild(link);\n    },\n    // Create a <style> tag with optional data attributes\n    createStyle: function(cssText, attributes) {\n        var head = document.head || document.getElementsByTagName('head')[0],\n            style = document.createElement('style');\n\n        style.type = 'text/css';\n\n        for (var key in attributes) {\n            if ( ! attributes.hasOwnProperty(key)) {\n                continue;\n            }\n            var value = attributes[key];\n            style.setAttribute('data-' + key, value);\n        }\n        \n        if (style.sheet) { // for jsdom and IE9+\n            style.innerHTML = cssText;\n            style.sheet.cssText = cssText;\n            head.appendChild(style);\n        } else if (style.styleSheet) { // for IE8 and below\n            head.appendChild(style);\n            style.styleSheet.cssText = cssText;\n        } else { // for Chrome, Firefox, and Safari\n            style.appendChild(document.createTextNode(cssText));\n            head.appendChild(style);\n        }\n    }\n};\n"],"sourceRoot":"/source/"}