{"version":3,"sources":["node_modules/browser-pack/_prelude.js","companyregistry-client.js","app/angularcontrollers.js","app/angulardirectives.js","app/angularservices.js","app/app.js","app/components/beneficiary/BeneficiaryCreateViewDirective.js","app/components/beneficiary/BeneficiaryDeleteViewDirective.js","app/components/beneficiary/BeneficiaryDetailViewDirective.js","app/components/beneficiary/BeneficiaryListFragmentViewDirective.js","app/components/beneficiary/BeneficiaryListViewDirective.js","app/components/beneficiary/BeneficiarySearchViewDirective.js","app/components/beneficiary/BeneficiaryService.js","app/components/beneficiary/BeneficiaryUpdateViewDirective.js","app/components/beneficiary/BeneficiaryViewController.js","app/components/beneficiary/BeneficiaryViewDirective.js","app/components/common/MainViewController.js","app/components/common/MainViewDirective.js","app/components/common/States.js","app/components/common/UtilService.js","app/components/company/CompanyCreateViewDirective.js","app/components/company/CompanyDeleteViewDirective.js","app/components/company/CompanyListFragmentViewDirective.js","app/components/company/CompanyListViewDirective.js","app/components/company/CompanySearchViewDirective.js","app/components/company/CompanyService.js","app/components/company/CompanyUpdateViewDirective.js","app/components/company/CompanyViewController.js","app/components/company/CompanyViewDirective.js","app/components/nav/SideNavViewController.js","app/components/nav/SideNavViewDirective.js","app/components/nls/i18n-en.js","app/config.js","app/constants.js","node_modules/angular-animate/angular-animate.js","node_modules/angular-animate/index.js","node_modules/angular-block-ui/dist/angular-block-ui.js","node_modules/angular-block-ui/dist/angular-block-ui.min.css","node_modules/angular-sanitize/angular-sanitize.js","node_modules/angular-sanitize/index.js","node_modules/angular-translate/dist/angular-translate.js","node_modules/angular-ui-router/release/angular-ui-router.js","node_modules/browserify-css/browser.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","global","ng","window","MainViewController","SideNavViewController","BeneficiaryViewController","CompanyViewController","config","moduleName","configBlock","namespace","controllersModule","controller","this","self","./components/beneficiary/BeneficiaryViewController","./components/common/MainViewController","./components/company/CompanyViewController","./components/nav/SideNavViewController","./config",2,"MainViewDirective","SideNavViewDirective","BeneficiaryViewDirective","BeneficiaryCreateViewDirective","BeneficiaryUpdateViewDirective","BeneficiaryDeleteViewDirective","BeneficiaryListViewDirective","BeneficiaryListFragmentViewDirective","BeneficiaryDetailViewDirective","BeneficiarySearchViewDirective","CompanyViewDirective","CompanyCreateViewDirective","CompanyUpdateViewDirective","CompanyDeleteViewDirective","CompanyListViewDirective","CompanyListFragmentViewDirective","CompanySearchViewDirective","directivesModule","directive","./components/beneficiary/BeneficiaryCreateViewDirective","./components/beneficiary/BeneficiaryDeleteViewDirective","./components/beneficiary/BeneficiaryDetailViewDirective","./components/beneficiary/BeneficiaryListFragmentViewDirective","./components/beneficiary/BeneficiaryListViewDirective","./components/beneficiary/BeneficiarySearchViewDirective","./components/beneficiary/BeneficiaryUpdateViewDirective","./components/beneficiary/BeneficiaryViewDirective","./components/common/MainViewDirective","./components/company/CompanyCreateViewDirective","./components/company/CompanyDeleteViewDirective","./components/company/CompanyListFragmentViewDirective","./components/company/CompanyListViewDirective","./components/company/CompanySearchViewDirective","./components/company/CompanyUpdateViewDirective","./components/company/CompanyViewDirective","./components/nav/SideNavViewDirective",3,"BeneficiaryService","CompanyService","UtilService","servicesModule","factory","service","./components/beneficiary/BeneficiaryService","./components/common/UtilService","./components/company/CompanyService",4,"constants","services","controllers","directives","animateModule","translateModule","sanitizeModule","blockUIModule","uiRouterModule","name","settings","states","blockUI","inform","hrefSanitize","constant","runBlock","run","./angularcontrollers","./angulardirectives","./angularservices","./constants","angular-animate","angular-block-ui","angular-block-ui/dist/angular-block-ui.min.css","angular-sanitize","angular-translate","angular-ui-router",5,"templateUrl","restrict","scope","beneficiary","controllerAs",6,7,"$parse","$compile","$rootScope","$timeout","link","el","attrs","$on","ev","data","beneficiaries","id","beneficiaryId","inputEls","angular","element","find","j","attr","$inject",8,"delref",9,10,11,"$http","serviceInstance","selectedBeneficiaryId","popOnDelete","getBeneficiary","url","callback","method","dataType","then","results","error","errorData","status","message","createBeneficiary","updateBeneficiary","deleteBeneficiary",12,13,"$scope","$window","$document","$log","$state","$modal","beneficiaryService","utilService","CONSTANTS","useExistingBeneficiary","minimumValidBeneficiary","beneficiarySearched","beneficiaryFound","searchRequestSumbitted","addRequestSubmitted","addRequestAttempted","updateRequestSubmitted","updateRequestAttempted","deleteRequestSubmitted","deleteSuccessful","serviceUrl","host","port","contextRoot","initBeneficiary","firstName","lastName","current","resetBeneficiary","addBeneficiary","$event","stopPropagation","isFormValid","warn","add","ttl","type","instances","get","beneficiaryContextPath","result","info","go","reload","errorMessage","cancelAddBeneficiary","cancelOrCloseBeneficiaryUpdate","cancelOrCloseBeneficiaryDelete","$dismiss","fetchBeneficiary","splice","idSearch","isBlank","baseUrl","push","searchBeneficiary","isValidId","registerPopoverShow","mutateBeneficiaryOptions","$index","registerPopoverPrep","discardMessage","registerPopoverHide","popover","trigger","clear",14,15,16,17,"stateConfig","main","views","template","mainItem@start","company","initial","list","search","update","delete","onEnter","open","backdrop","keyboard","windowClass",18,"formId","isValid","formEl","document","getElementById","console","log","className","indexOf","elements","value","isUndefined","parseInt",19,20,21,"companies",22,23,24,"selectedCompanyId","getCompany","createCompany","updateCompany","deleteCompany",25,26,"$q","companyService","companyFound","initCompany","address","city","country","email","phoneNumber","verifyMinimumValidBeneficiary","resetCompany","addCompany","companyContextPath","cancelAddCompany","cancelOrCloseCompanyUpdate","cancelOrCloseCompanyDelete","fetchCompany","searchCompany","companySearchBlock","start","findBeneficiary","disableBeneficiary","stop","mutateCompanyOptions","removeBeneficiary","$emit",27,28,29,30,"translationsEN","BENEFICIARY","ID","FIRST_NAME","LAST_NAME",31,"$logProvider","$translateProvider","debugEnabled","i18n_en","useSanitizeValueStrategy","translations","useStaticFilesLoader","files","prefix","suffix","preferredLanguage","fallbackLanguage","$stateProvider","$urlRouterProvider","otherwise","state","copy","blockUIConfig","delay","autoBlock","autoInjectBodyBlock","informProvider","defaults","html","modal","$modalStack","top","getTop","dismiss","key","$compileProvider","aHrefSanitizationWhitelist","./components/common/States","./components/nls/i18n-en",32,33,"undefined","assertArg","arg","reason","ngMinErr","mergeClasses","b","isArray","join","packageStyles","options","styles","to","from","pendClasses","classes","fix","isPrefix","isString","split","forEach","klass","removeFromArray","arr","val","index","stripCommentsFromElement","jqLite","nodeType","ELEMENT_NODE","extractElementNode","elm","$$addClass","$$jqLite","addClass","$$removeClass","removeClass","applyAnimationClassesFactory","prepareAnimationOptions","$$prepared","domOperation","noop","$$domOperationFired","applyAnimationStyles","applyAnimationFromStyles","applyAnimationToStyles","css","mergeAnimationOptions","target","newOptions","toAdd","toRemove","resolveElementClasses","preparationClasses","concatWithSpace","realDomOperation","extend","existing","splitClassesToLookup","obj","ADD_CLASS","REMOVE_CLASS","flags","prop","allow","getDomNode","applyGeneratedPreparationClasses","event","EVENT_CLASS_PREFIX","ADD_CLASS_SUFFIX","REMOVE_CLASS_SUFFIX","clearGeneratedClasses","activeClasses","blockTransitions","node","duration","applyInlineStyle","TRANSITION_DELAY_PROP","blockKeyframeAnimations","applyBlock","ANIMATION_PROP","ANIMATION_PLAYSTATE_KEY","styleTuple","style","getCssKeyframeDurationStyle","ANIMATION_DURATION_PROP","getCssDelayStyle","isKeyframeAnimation","ANIMATION_DELAY_PROP","computeCssStyles","properties","Object","create","detectedStyles","getComputedStyle","formalStyleName","actualStyleName","c","charAt","parseMaxTime","str","maxValue","values","substring","parseFloat","Math","max","truthyTimingValue","getCssTransitionDurationStyle","applyOnlyDuration","TRANSITION_PROP","DURATION_KEY","createLocalCacheLookup","cache","flush","count","entry","total","put","registerRestorableStyles","backup","isDefined","getPropertyValue","TRANSITIONEND_EVENT","ANIMATIONEND_EVENT","isObject","isFunction","isElement","ACTIVE_CLASS_SUFFIX","NG_ANIMATE_CLASSNAME","NG_ANIMATE_CHILDREN_DATA","CSS_PREFIX","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","PROPERTY_KEY","DELAY_KEY","TIMING_KEY","ANIMATION_ITERATION_COUNT_KEY","SAFE_FAST_FORWARD_DURATION_VALUE","TRANSITION_DURATION_PROP","$$rAFSchedulerFactory","$$rAF","scheduler","tasks","queue","concat","nextTick","items","shift","cancelFn","waitUntilQuiet","fn","$$AnimateChildrenDirective","ngAnimateChildren","$observe","ANIMATE_TIMER_KEY","ONE_SECOND","ELAPSED_TIME_MAX_DECIMAL_PLACES","CLOSING_TIME_BUFFER","DETECT_CSS_PROPERTIES","transitionDuration","transitionDelay","transitionProperty","animationDuration","animationDelay","animationIterationCount","DETECT_STAGGER_CSS_PROPERTIES","$AnimateCssProvider","$animateProvider","gcsLookup","gcsStaggerLookup","$get","$$AnimateRunner","$$forceReflow","$sniffer","$$rAFScheduler","$animate","gcsHashFn","extraClasses","KEY","parentNode","parentID","parentCounter","getAttribute","computeCachedCssStyles","cacheKey","timings","computeCachedCssStaggerStyles","stagger","staggerClassName","rafWaitQueue","pageWidth","computeTimings","aD","tD","maxDelay","maxDuration","applyAnimationClasses","endFn","close","rejected","animationClosed","animationCompleted","animationPaused","$$skipPreparationClasses","temporaryStyles","keys","restoreStyles","setProperty","removeProperty","onDone","runner","complete","applyBlocking","blockTransition","blockKeyframeAnimation","closeAndReturnNoopAnimator","end","cancel","$$willAnimate","triggerAnimationStart","recalculateTimingStyles","fullClassName","relativeDelay","hasTransitions","hasAnimations","applyAnimationDelay","delayStyle","maxDelayTime","maxDurationTime","easing","easeProp","easeVal","events","startTime","Date","now","timerTime","endTime","animationsData","setupFallbackTimer","currentTimerData","expectedEndTime","timer","onAnimationExpired","on","onAnimationProgress","cleanupStyles","removeData","originalEvent","timeStamp","$manualTimeStamp","elapsedTime","toFixed","playPause","playAnimation","maxStagger","itemIndex","floor","runnerHost","resume","pause","enabled","animations","transitions","isStructural","structural","structuralClassName","addRemoveClassName","applyClassesEarly","trim","hasToStyles","containsKeyframeAnimation","keyframeStyle","staggerVal","transitionStyle","durationStyle","staggerIndex","isFirst","skipBlocking","hasTransitionAll","applyTransitionDuration","applyAnimationDuration","applyTransitionDelay","$$AnimateCssDriverProvider","$$animationProvider","isDocumentFragment","drivers","NG_ANIMATE_SHIM_CLASS_NAME","NG_ANIMATE_ANCHOR_CLASS_NAME","NG_OUT_ANCHOR_CLASS_NAME","NG_IN_ANCHOR_CLASS_NAME","$animateCss","$rootElement","filterCssClasses","replace","getUniqueValues","filter","prepareAnchoredAnimation","outAnchor","inAnchor","calculateAnchorStyles","anchor","coords","getBoundingClientRect","bodyNode","scrollTop","scrollLeft","prepareOutAnimation","animator","clone","getClassVal","prepareInAnimation","endingClasses","startingClasses","remove","cloneNode","rootBodyElement","append","animatorIn","animatorOut","startingAnimator","currentAnimation","done","prepareFromToAnchorAnimation","anchors","fromAnimation","prepareRegularAnimation","toAnimation","anchorAnimations","outElement","inElement","animationRunners","animation","all","animationDetails","body","rootNode","contains","$$AnimateJsProvider","$injector","lookupAnimations","matches","flagMap","animationFactory","$$registeredAnimations","applyOptions","executeAnimationFn","args","classesToAdd","classesToRemove","apply","groupEventedAnimations","fnName","operations","ani","endProgressCb","resolved","onAnimationComplete","cancelled","packageAnimations","runners","animateFn","reject","arguments","before","after","afterFn","beforeFn","toUpperCase","substr","onComplete","success","endAnimations","closeActiveAnimations","chain","$$AnimateJsDriverProvider","$$animateJs","prepareAnimation","endFnFactory","NG_ANIMATE_ATTR_NAME","NG_ANIMATE_PIN_DATA","$$AnimateQueueProvider","isAllowed","ruleType","previousAnimation","rules","some","hasAnimationClasses","and","PRE_DIGEST_STATE","RUNNING_STATE","skip","newAnimation","nO","cO","$$HashMap","$$animation","$templateRequest","postDigestTaskFactory","postDigestCalled","$$postDigest","normalizeAnimationOptions","findCallbacks","targetNode","entries","callbackRegistry","queueAnimation","notifyProgress","phase","runInNextPostDigestOrNow","callbacks","progress","parent","isAnimatableClassName","skipAnimations","animationsEnabled","disabledElementsLookup","existingAnimation","activeAnimationsLookup","hasExistingAnimation","areAnimationsAllowed","closeChildAnimations","skipAnimationFlag","cancelAnimationFlag","joinAnimationFlag","isValidAnimation","clearElementAnimationState","counter","markElementAnimationState","animationCancelled","parentElement","realRunner","setHost","children","querySelectorAll","child","removeAttribute","isMatchingElement","nodeOrElmA","nodeOrElmB","animateChildren","bodyElement","bodyElementDetected","nodeName","rootElementDetected","parentAnimationDetected","parentHost","details","allowAnimation","setAttribute","oldValue","newValue","deregisterWatch","$watch","totalPendingRequests","isEmpty","classNameFilter","test","container","off","filterFromRegistry","matchContainer","matchCallback","containerNode","isMatch","pin","bool","argCount","hasElement","recordExists","$$AnimateAsyncRunFactory","waitForTick","waitQueue","passed","$$AnimateRunnerFactory","$$animateAsyncRun","AnimateRunner","_doneCallbacks","_runInAnimationFrame","_state","INITIAL_STATE","DONE_PENDING_STATE","DONE_COMPLETE_STATE","next","response","onProgress","prototype","getPromise","promise","resolve","resolveHandler","rejectHandler","catch","handler","finally","_resolve","$$AnimationProvider","setRunner","RUNNER_STORAGE_KEY","removeRunner","getRunner","NG_ANIMATE_REF_ATTR","sortAnimations","processNode","processed","elementNode","domNode","lookup","parentEntry","tree","flatten","remainingLevelEntries","nextLevelEntries","row","childEntry","animationQueue","getAnchorNodes","SELECTOR","hasAttribute","groupAnimations","preparedAnimations","refLookup","enterOrMove","anchorNodes","direction","animationID","usedIndicesLookup","anchorGroups","indexKey","toString","lookupKey","group","beforeStart","cssClassesIntersection","out","in","aa","invokeFirstDriver","driverName","has","driver","tempClasses","updateAnimationRunners","newRunner","handleDestroyedElement","groupedAnimations","toBeSortedAnimations","animationEntry","startAnimationFn","closeFn","targetElement","operation","animationRunner","provider",34,"./angular-animate",35,"moduleLoaded","ex","blockNavigation","mainBlockUI","registerLocationChange","$_blockLocationChange","blockCount","preventDefault","blockBrowserNavigation","blkUI","$provide","$httpProvider","decorator","$delegate","exception","cause","resetOnException","reset","interceptors","$templateCache","decorateLocation","hook","overrides","blockUiContainerLinkFn","compile","$element","blockUIUtils","$attrs","srvInstance","inheritedData","blockUiCompileFn","blockUiPreLinkFn","pre","hasClass","cssClass","$_blockUiMessageClass","instanceId","blockUi","$id","parentInstance","_parent","release","addRef","$_blockUiState","toggleClass","pattern","blockUiPattern","regExp","buildRegExp","requestFilter","injectBlockUI","stopBlockUI","$_noBlock","$_blocks","rejection","request","locate","requestError","responseError","BlockUI","startPromise","blocking","doneCallbacks","_id","_refs","$ae","activeElement","isElementInBlockScope","_restoreFocus","blur","_cancelStartTimeout","regexp","_pattern","executeCallbacks","$body","focus","cb","mainBlock","_destroy","isNaN","instance","idOrInstance","forEachFnHook","$","utils","match","RegExp","forEachFn","blockScope","findElement","predicateFn","traverse","ret","$elements",36,"createStyle","href","browserify-css",37,"$SanitizeProvider","$$sanitizeUri","buf","htmlParser","htmlSanitizeWriter","uri","isImage","sanitizeText","chars","writer","makeMap","lowercaseKeys","lowercase","parseStartTag","tag","tagName","rest","unary","blockElements","stack","last","inlineElements","parseEndTag","optionalEndTagElements","voidElements","ATTR_REGEXP","doubleQuotedValue","singleQuotedValue","unquotedValue","decodeEntities","pos","text","specialElements","COMMENT_REGEXP","CDATA_REGEXP","lastIndexOf","comment","DOCTYPE_REGEXP","BEGING_END_TAGE_REGEXP","END_TAG_REGEXP","BEGIN_TAG_REGEXP","START_TAG_REGEXP","$sanitizeMinErr","hiddenPre","innerHTML","textContent","encodeEntities","SURROGATE_PAIR_REGEXP","hi","charCodeAt","low","NON_ALPHANUMERIC_REGEXP","uriValidator","ignore","bind","validElements","lkey","validAttrs","uriAttrs","$$minErr","optionalEndTagBlockElements","optionalEndTagInlineElements","svgElements","htmlAttrs","svgAttrs","createElement","$sanitize","LINKY_URL_REGEXP","MAILTO_REGEXP","addText","addLink","raw",38,"./angular-sanitize",39,"root","define","amd","runTranslate","$translate","storageKey","storage","fallbackFromIncorrectStorageValue","preferred","use","displayName","$translateSanitizationProvider","strategies","currentStrategy","hasConfiguredStrategy","hasShownNoStrategyConfiguredWarning","sanitize","mode","htmlSanitizeValue","escape","htmlEscapeValue","sanitizeParameters","mapInterpolationParameters","escapeParameters","escaped","addStrategy","strategyName","strategyFunction","removeStrategy","useStrategy","strategy","cachedStrategyMap","applyStrategies","selectedStrategies","selectedStrategy","showNoStrategyConfiguredWarning","iteratee","propertyValue","propertyKey","isNumber","$STORAGE_KEY","$windowProvider","pascalprechtTranslateOverrider","$preferredLanguage","$languageKeyAliases","$fallbackLanguage","$fallbackWasString","$uses","$nextLang","$storageFactory","$storagePrefix","$missingTranslationHandlerFactory","$interpolationFactory","$loaderFactory","$loaderOptions","$notFoundIndicatorLeft","$notFoundIndicatorRight","loaderCache","$translationTable","$availableLanguageKeys","$storageKey","$interpolatorFactories","$cloakClassName","$postCompilingEnabled","$forceAsyncReloadEnabled","$nestedObjectDelimeter","$isReady","directivePriority","statefulFilter","uniformLanguageTagResolver","languageTagResolver","default","java","temp","parts","toLowerCase","bcp47","version","getFirstBrowserLanguage","getLocale","language","nav","navigator","browserLanguagePropertyKeys","languages","locale","array","searchElement","len","negotiateLocale","avail","alias","langKeyAlias","hasWildcardKey","hasExactKey","hasOwnProperty","slice","langKey","translationTable","flatObject","cloakClassName","nestedObjectDelimeter","delimiter","path","prevKey","keyWithPath","keyWithShortPath","addInterpolation","useMessageFormatInterpolation","useInterpolation","setupPreferredLanguage","translationNotFoundIndicator","indicator","translationNotFoundIndicatorLeft","translationNotFoundIndicatorRight","fallbackStack","useUrlLoader","useLoader","loaderFactory","useLocalStorage","useStorage","useCookieStorage","storageFactory","storagePrefix","useMissingTranslationHandlerLog","useMissingTranslationHandler","usePostCompiling","forceAsyncReload","uniformLanguageTag","standard","determinePreferredLanguage","registerAvailableLanguageKeys","languageKeys","aliases","useLoaderCache","priority","Storage","fallbackIndex","startFallbackIteration","defaultInterpolator","pendingLoader","interpolatorHashMap","langPromises","translationId","interpolateParams","interpolationId","defaultTranslationText","forceLanguage","uses","translateAll","translationIds","promises","translate","deferred","defer","regardless","promiseToWaitFor","promiseResolved","determineTranslation","applyNotFoundIndicators","useLanguage","setLocale","eachInterpolator","interpolator","loadAsync","loaderOptions","onLoaderSuccess","table","onLoaderError","eachInterpolationFactory","interpolatorFactory","getInterpolationIdentifier","getTranslationTable","onResolve","getFallbackTranslation","Interpolator","translation","interpolate","getFallbackTranslationInstant","translateByHandler","resultString","resolveForFallbackLanguage","fallbackLanguageIndex","resolveForFallbackLanguageInstant","fallbackTranslation","fallbackTranslationInstant","missingTranslationHandlerTranslation","_translationId","determineTranslationInstant","clearNextLangAndPromise","useFallbackLanguage","langKeyPosition","proposedLanguage","aliasedKey","isPostCompilingEnabled","isForceAsyncReloadEnabled","refresh","oneTranslationsLoaded","tables","loadingKeys","allTranslationsLoaded","tableData","instant","possibleLangKeys","d","possibleLangKey","versionInfo","isReady","$onReadyDeferred","onReady","globalOnReadyListener","globalOnChangeListener","equals","processAsyncResult","fallbackLanguageId","$translateDefaultInterpolation","$interpolate","$translateSanitization","$locale","$translateInterpolator","$identifier","string","interpolationParams","interpolatedText","translateDirective","tElement","tAttr","translateValuesExist","translateValues","translateInterpolation","translateValueExist","outerHTML","interpolateRegExp","startSymbol","endSymbol","watcherRegExp","iElement","iAttr","preText","postText","translateNamespace","getTranslateNamespace","initInterpolationParams","$parent","attributeName","observeElementTranslation","_unwatchOld","iElementText","interpolateMatches","watcherMatches","updateTranslations","observeAttributeTranslation","translateAttr","firstAttributeChangedEvent","defaultText","observeValueAttribute","attrName","updateTranslation","translateLanguage","applyTranslation","successful","empty","globallyEnabled","locallyDefined","translateCompile","locallyEnabled","contents","$attr","translateDefault","unbind","translateCloakDirective","applyCloak","removeCloak","translateCloak","translateNamespaceDirective","iAttrs","translateLanguageDirective","newTranslateLanguage","translateFilterFactory","translateFilter","interpolation","$stateful","$translationCache","$cacheFactory",40,"inherit","extra","merge","dst","ancestors","first","second","objectKeys","object","Array","Number","ceil","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","params","equalForKeys","k","filterByKeys","filtered","pick","omit","collection","map","$Resolve","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","when","$$promises","$$values","study","invocables","visit","visited","cycle","plan","annotate","param","pop","isResolve","invocableKeys","locals","wait","merged","$$inheritedValues","resolution","fail","$$failure","invoke","invocable","onfailure","invocation","proceed","waitParams","dep","ii","$TemplateFactory","fromConfig","fromString","fromUrl","templateProvider","fromProvider","headers","Accept","UrlMatcher","parentMatcher","addParameter","location","paramNames","$$UMFP","Param","quoteRegExp","squash","optional","surroundPattern","matchDetails","m","isSearch","segment","cfg","caseInsensitive","placeholder","searchPlaceholder","compiled","segments","$$new","ParamSet","source","p","exec","isOptional","lastIndex","sourceSearch","sourcePath","strict","$$paramNames","Type","$UrlMatcherFactory","valToString","valFromString","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","$types","injector","def","defaultSquashPolicy","enqueue","defaultTypes","encode","decode","is","int","date","getFullYear","getMonth","getDate","capture","valueOf","toISOString","json","toJson","fromJson","any","identity","$$getDefaultValue","strictMode","isMatcher","definition","definitionFn","unwrapShorthand","isShorthand","$$fn","getType","urlType","getArrayMode","arrayDefaults","arrayParamNomenclature","getSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","item","defaultValue","$value","hasReplaceVal","$replace","replacement","$normalize","$asArray","dynamic","$$parent","$$keys","reverse","paramset","paramValues","$$equals","paramValues1","paramValues2","equal","left","right","$$validates","rawVal","normalized","encoded","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","what","handleIfMatch","$match","$location","$browser","appendBasePath","isHtml5","absolute","baseHref","evt","check","rule","handled","defaultPrevented","lastPushedUrl","listen","listener","interceptDeferred","sync","read","urlMatcher","format","$$avoidResync","validates","html5Mode","history","hashPrefix","slash","protocol","redirect","handlerIsString","matcher","regex","sticky","deferIntercept","$StateProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","pathLength","queueState","parentName","flushQueuedChildren","queued","registerState","stateBuilder","$delegates","abstractKey","$stateParams","navigable","transitionTo","isGlob","doesStateMatchGlob","glob","globSegments","unshift","MAX_VALUE","func","$view","$resolve","$urlRouter","handleRedirect","$broadcast","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","transition","TransitionSuperseded","toParams","resolveState","paramsAreFiltered","resolveViews","viewsPromises","view","injectables","$template","load","globals","notify","controllerProvider","injectLocals","$$controller","$$state","$$controllerAs","TransitionPrevented","relative","fromParams","fromPath","toState","hash","redirectResult","toPath","keep","toLocals","reloadState","ownParams","shouldSkipReload","entering","exiting","onExit","includes","lossy","context","nonSearchParamsEqual","fromAndToState","notSearchParam","nonQueryParamKeys","nonQueryParams","nonQueryParamSet","reloadOnSearch","compositeName","","abstract","$ViewProvider","$templateFactory","async","$ViewScrollProvider","useAnchorScroll","$anchorScroll","scrollIntoView","$ViewDirective","$uiViewScroll","getService","getRenderer","animEnabled","ngMajorVer","ngMinorVer","$animator","statics","enter","leave","noanimation","minor","animate","terminal","transclude","tAttrs","$transclude","cleanupLastView","cleanOld","_previousEl","_currentScope","$destroy","previousEl","currentScope","_willBeDestroyed","currentEl","renderer","updateView","firstTime","newScope","getUiViewName","previousLocals","latestLocals","$new","autoScrollExp","$eval","onloadExp","onload","autoscroll","$ViewDirectiveFill","$controller","uiView","parseStateRef","ref","parsed","preparsed","paramExpr","stateContext","stateData","getTypeInfo","isSvg","isForm","isAnchor","clickable","clickHook","button","which","ctrlKey","metaKey","shiftKey","ignorePreventDefaultCount","defaultOpts","$StateRefDirective","uiSrefActive","uiSref","active","uiSrefOpts","$$addStateInfo","$set","$StateRefDynamicDirective","runStateRefLink","uiState","uiStateParams","uiStateOpts","watch","$StateRefActiveDirective","addState","stateParams","activeClass","stateHash","createStateHash","anyMatch","exactMatch","activeEqClass","uiSrefActiveEq","newState","$IsStateFilter","isFilter","$IncludedByStateFilter","includesFilter","defaultConfig","searchParams","decodePathArray","reverseString","unquoteDashes","allReversed","paramName","parameters","nTotal","nPath","paramVal","encodeDashes","encodeURIComponent","isPathParam","isDefaultValue","nextSegment","isFinalPathParam","$subPattern","sub","ArrayType","bindTo","callbackName","arrayWrap","arrayUnwrap","falsey","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","$arrayMode","major",41,"createLink","attributes","head","getElementsByTagName","appendChild","cssText","sheet","styleSheet","createTextNode"],"mappings":"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","file":"companyregistry-client.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\r\nvar MainViewController = require('./components/common/MainViewController');\r\nvar SideNavViewController = require('./components/nav/SideNavViewController');\r\nvar BeneficiaryViewController = require('./components/beneficiary/BeneficiaryViewController');\r\nvar CompanyViewController = require('./components/company/CompanyViewController');\r\nvar config = require('./config');\r\n\r\nvar moduleName = config.configBlock.namespace + '.controllers';\r\nvar controllersModule = ng.module(moduleName, [])\r\n    .controller('MainViewController', MainViewController.controller)\r\n    .controller('SideNavViewController', SideNavViewController.controller)\r\n    .controller('BeneficiaryViewController', BeneficiaryViewController.controller)\r\n    .controller('CompanyViewController', CompanyViewController.controller);\r\n\r\nexports.controllersModule = controllersModule;\r\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./components/beneficiary/BeneficiaryViewController\":13,\"./components/common/MainViewController\":15,\"./components/company/CompanyViewController\":26,\"./components/nav/SideNavViewController\":28,\"./config\":31}],2:[function(require,module,exports){\n(function (global){\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar MainViewDirective = require('./components/common/MainViewDirective');\nvar SideNavViewDirective = require('./components/nav/SideNavViewDirective');\nvar BeneficiaryViewDirective = require('./components/beneficiary/BeneficiaryViewDirective');\nvar BeneficiaryCreateViewDirective = require('./components/beneficiary/BeneficiaryCreateViewDirective');\nvar BeneficiaryUpdateViewDirective = require('./components/beneficiary/BeneficiaryUpdateViewDirective');\nvar BeneficiaryDeleteViewDirective = require('./components/beneficiary/BeneficiaryDeleteViewDirective');\nvar BeneficiaryListViewDirective = require('./components/beneficiary/BeneficiaryListViewDirective');\nvar BeneficiaryListFragmentViewDirective = require('./components/beneficiary/BeneficiaryListFragmentViewDirective');\nvar BeneficiaryDetailViewDirective = require('./components/beneficiary/BeneficiaryDetailViewDirective');\nvar BeneficiarySearchViewDirective = require('./components/beneficiary/BeneficiarySearchViewDirective');\nvar CompanyViewDirective = require('./components/company/CompanyViewDirective');\nvar CompanyCreateViewDirective = require('./components/company/CompanyCreateViewDirective');\nvar CompanyUpdateViewDirective = require('./components/company/CompanyUpdateViewDirective');\nvar CompanyDeleteViewDirective = require('./components/company/CompanyDeleteViewDirective');\nvar CompanyListViewDirective = require('./components/company/CompanyListViewDirective');\nvar CompanyListFragmentViewDirective = require('./components/company/CompanyListFragmentViewDirective');\nvar CompanySearchViewDirective = require('./components/company/CompanySearchViewDirective');\nvar config = require('./config');\n\nvar moduleName = config.configBlock.namespace + '.directives';\n\nvar directivesModule = ng.module(moduleName, [])\n    .directive('mainView', MainViewDirective.directive)\n    .directive('sideNavView', SideNavViewDirective.directive)\n    .directive('beneficiaryView', BeneficiaryViewDirective.directive)\n    .directive('beneficiaryCreateView', BeneficiaryCreateViewDirective.directive)\n    .directive('beneficiaryUpdateView', BeneficiaryUpdateViewDirective.directive)\n    .directive('beneficiaryDeleteView', BeneficiaryDeleteViewDirective.directive)\n    .directive('beneficiaryDetailView', BeneficiaryDetailViewDirective.directive)\n    .directive('beneficiarySearchView', BeneficiarySearchViewDirective.directive)\n    .directive('beneficiaryListView', BeneficiaryListViewDirective.directive)\n    .directive('beneficiaryListDetailView', BeneficiaryListViewDirective.directive)\n    .directive('beneficiaryListFragmentView', BeneficiaryListFragmentViewDirective.directive)\n    .directive('companyView', CompanyViewDirective.directive)\n    .directive('companyCreateView', CompanyCreateViewDirective.directive)\n    .directive('companyUpdateView', CompanyUpdateViewDirective.directive)\n    .directive('companyDeleteView', CompanyDeleteViewDirective.directive)\n    .directive('companySearchView', CompanySearchViewDirective.directive)\n    .directive('companyListView', CompanyListViewDirective.directive)\n    .directive('companyListFragmentView', CompanyListFragmentViewDirective.directive)\n\nexports.directivesModule = directivesModule;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./components/beneficiary/BeneficiaryCreateViewDirective\":5,\"./components/beneficiary/BeneficiaryDeleteViewDirective\":6,\"./components/beneficiary/BeneficiaryDetailViewDirective\":7,\"./components/beneficiary/BeneficiaryListFragmentViewDirective\":8,\"./components/beneficiary/BeneficiaryListViewDirective\":9,\"./components/beneficiary/BeneficiarySearchViewDirective\":10,\"./components/beneficiary/BeneficiaryUpdateViewDirective\":12,\"./components/beneficiary/BeneficiaryViewDirective\":14,\"./components/common/MainViewDirective\":16,\"./components/company/CompanyCreateViewDirective\":19,\"./components/company/CompanyDeleteViewDirective\":20,\"./components/company/CompanyListFragmentViewDirective\":21,\"./components/company/CompanyListViewDirective\":22,\"./components/company/CompanySearchViewDirective\":23,\"./components/company/CompanyUpdateViewDirective\":25,\"./components/company/CompanyViewDirective\":27,\"./components/nav/SideNavViewDirective\":29,\"./config\":31}],3:[function(require,module,exports){\n(function (global){\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar BeneficiaryService = require('./components/beneficiary/BeneficiaryService');\nvar CompanyService = require('./components/company/CompanyService');\nvar UtilService = require('./components/common/UtilService');\nvar config = require('./config');\n\nvar moduleName = config.configBlock.namespace + '.services';\nvar servicesModule = ng.module(moduleName, [])\n    .factory('beneficiaryService', BeneficiaryService.service)\n    .factory('companyService', CompanyService.service)\n    .factory('utilService', UtilService.service);\n\nexports.servicesModule = servicesModule;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./components/beneficiary/BeneficiaryService\":11,\"./components/common/UtilService\":18,\"./components/company/CompanyService\":24,\"./config\":31}],4:[function(require,module,exports){\n(function (global){\n/** Main app **/\n\n'use strict';\n\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar config = require('./config');\nvar constants = require('./constants');\nvar services = require('./angularservices');\nvar controllers = require('./angularcontrollers');\nvar directives = require('./angulardirectives');\n\nvar animateModule = require('angular-animate');\nvar translateModule = require('angular-translate');\nvar sanitizeModule = require('angular-sanitize');\nvar blockUIModule = require('angular-block-ui');\nvar uiRouterModule = require('angular-ui-router');\n\nrequire('angular-block-ui/dist/angular-block-ui.min.css');\n\nvar moduleName = config.configBlock.namespace;\n\n// Declare app level module which depends on services, controllers and directives\nng.module(moduleName, [animateModule, translateModule, sanitizeModule, blockUIModule, uiRouterModule,\n    services.servicesModule.name, controllers.controllersModule.name, directives.directivesModule.name,\n    'inform', 'inform-exception'/*, 'inform-http-exception'*/\n]);\n\nng.module(moduleName)\n  .config(config.configBlock.settings)\n  .config(config.configBlock.states)\n  .config(config.configBlock.blockUI)\n  .config(config.configBlock.inform)\n  .config(config.configBlock.hrefSanitize);\n\nng.module(moduleName)\n  .constant('CONSTANTS', constants.constants);\n\nvar runBlock = function() {\n\n    // Add code that needs a run block to execute here.\n};\n\nng.module(moduleName)\n  .run(runBlock);\n  // .run(config.configBlock.modal);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./angularcontrollers\":1,\"./angulardirectives\":2,\"./angularservices\":3,\"./config\":31,\"./constants\":32,\"angular-animate\":34,\"angular-block-ui\":35,\"angular-block-ui/dist/angular-block-ui.min.css\":36,\"angular-sanitize\":38,\"angular-translate\":39,\"angular-ui-router\":40}],5:[function(require,module,exports){\n/**\r\n * Beneficiary Form Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryCreateView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],6:[function(require,module,exports){\n/**\r\n * Company Delete Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryDeleteView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],7:[function(require,module,exports){\n/**\r\n * Beneficiary Detail View Component Directive\r\n *\r\n * @param {$parse} Angular parser service\r\n * @param {$rootScope} Angular rootScope service\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function($parse, $compile, $rootScope, $timeout) {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryDetailView.html',\r\n        restrict: 'AE',\r\n        //replace: true,\r\n        //transclude: true,\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        link: function(scope, el, attrs) {\r\n            $rootScope.$on('disableBeneficiary', function(ev, data) {\r\n                for (var i = 0; i < data.beneficiaries.length; i++) {\r\n                    if (data.beneficiaries[i].id === data.beneficiaryId) {\r\n                        var inputEls = angular.element(el.find('input[type=text]'));\r\n                        for (var j = 0; j < inputEls.length; j++) {\r\n                            angular.element(inputEls[j]).attr('disabled', '');\r\n                            $timeout(function() {\r\n                                $compile(inputEls[j])(scope);\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                //$compile(el)(scope);\r\n            });\r\n        }\r\n    };\r\n};\r\ndirective.$inject = [\"$parse\", \"$compile\", \"$rootScope\", \"$timeout\"];\r\n\r\nexports.directive = directive;\r\n\n},{}],8:[function(require,module,exports){\n/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryListFragmentView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiaries: '=',\r\n            delref: '='\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],9:[function(require,module,exports){\n/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryListView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],10:[function(require,module,exports){\n/**\r\n * Company Search Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiarySearchView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],11:[function(require,module,exports){\n/**\r\n * This service helps to perform http requests (GET, POST, PUT, DELETE) for beneficiary tasks\r\n *\r\n * @param {$http} The AngularJS http service\r\n * @param {$timeout} The AngularJS timeout service\r\n *\r\n * @ngInject\r\n */\r\nvar service = function($http, $timeout) {\r\n    'use strict';\r\n\r\n    var serviceInstance = {};\r\n    serviceInstance.selectedBeneficiaryId = null;\r\n    serviceInstance.popOnDelete = null;\r\n    serviceInstance.beneficiary = null;\r\n    serviceInstance.beneficiaries = [];\r\n\r\n    serviceInstance.getBeneficiary = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'GET',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.createBeneficiary = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            data: data,\r\n            method: 'POST',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n    serviceInstance.updateBeneficiary = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'PUT',\r\n            data: data,\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.deleteBeneficiary = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'DELETE',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$http\", \"$timeout\"];\r\n\r\nexports.service = service;\r\n\n},{}],12:[function(require,module,exports){\n/**\r\n * Beneficiary Form Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryUpdateView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],13:[function(require,module,exports){\n/**\r\n * Beneficiary View controller\r\n *\r\n * This controller is responsible for handing beneficiary form module related logic\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {$modal} Angular modal service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {utilService} Utility service\r\n * @param {blockUI} Block UI service\r\n * @param {inform} Inform provider service\r\n * @param {CONSTANTS} Project constants values\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function($rootScope, $scope, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, utilService, blockUI, inform, CONSTANTS) {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n    $scope.useExistingBeneficiary = false;\r\n    $scope.minimumValidBeneficiary = false;\r\n    $scope.beneficiaryId = null;\r\n    $scope.beneficiarySearched = false;\r\n    $scope.beneficiaryFound = false;\r\n    $scope.searchRequestSumbitted = false;\r\n    $scope.addRequestSubmitted = false;\r\n    $scope.addRequestAttempted = false;\r\n    $scope.updateRequestSubmitted = false;\r\n    $scope.updateRequestAttempted = false;\r\n    $scope.deleteRequestSubmitted = false;\r\n    $scope.deleteSuccessful = false;\r\n    $scope.serviceUrl = CONSTANTS.url.host + ':' + CONSTANTS.url.port + '/' + CONSTANTS.url.contextRoot;\r\n\r\n    $scope.initBeneficiary = {\r\n        \"firstName\": null,\r\n        \"lastName\": null\r\n    };\r\n\r\n    $scope.beneficiaries = beneficiaryService.beneficiaries.length > 0 ? beneficiaryService.beneficiaries : [];\r\n    $scope.beneficiary = beneficiaryService.beneficiary &&\r\n                         ($state.current.name === 'start.beneficiary.update' || $state.current.name === 'start.beneficiary.list.delete' || $state.current.name === 'start.beneficiary.search.delete') ?\r\n                         beneficiaryService.beneficiary : $scope.initBeneficiary;\r\n\r\n    $scope.resetBeneficiary = function() {\r\n        $timeout(function() {\r\n            $scope.beneficiary = $scope.initBeneficiary;\r\n            $scope.beneficiaries = [];\r\n        });\r\n    };\r\n\r\n    $scope.addBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.addRequestSubmitted = false;\r\n        beneficiaryService.beneficiary = $scope.beneficiary;\r\n        if (!utilService.isFormValid('beneficiaryDetailsForm')) {\r\n            $scope.addRequestAttempted = true;\r\n            $log.warn('form invalid');\r\n            inform.add('Invalid form. First name and Last name are required to create beneficiary', {\r\n                ttl: 3500,\r\n                type: 'danger'\r\n            });\r\n            // $scope.registerPopoverShow('#addBeneficiary');\r\n            return;\r\n        }\r\n\r\n        var beneficiaryCreateBlock = blockUI.instances.get('beneficiaryCreateBlock');\r\n        // beneficiaryCreateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        $scope.addRequestSubmitted = true;\r\n        beneficiaryService.createBeneficiary(url, $scope.beneficiary, function(result) {\r\n            $timeout(function() {\r\n                $log.info(result);\r\n                if (result && result.data) {\r\n                    if (result.data.id > 0) {\r\n                        inform.add('beneficiary created successfully.', {\r\n                            ttl: 2500\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.beneficiary', {}, {reload:true});\r\n                        }, 2500);\r\n                    } else {\r\n                        inform.add('Request completed, however beneficiary couldn\\'t be created.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating beneficiary.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.addRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // beneficiaryCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelAddBeneficiary = function() {\r\n        $state.go('start.beneficiary');\r\n    };\r\n\r\n    $scope.updateBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.updateRequestSubmitted = false;\r\n        beneficiaryService.beneficiary = $scope.beneficiary;\r\n        if (!utilService.isFormValid('beneficiaryDetailsForm')) {\r\n            $scope.updateRequestAttempted = true;\r\n            $log.warn('ccform invalid');\r\n            inform.add('Invalid form. First name and Last name are required to create beneficiary', {\r\n                ttl: 3500,\r\n                type: 'danger'\r\n            });\r\n            return;\r\n        }\r\n\r\n        // var beneficiaryUpdateBlock = blockUI.instances.get('beneficiaryUpdateBlock');\r\n        // beneficiaryUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        $scope.updateRequestSubmitted = true;\r\n        beneficiaryService.updateBeneficiary(url, $scope.beneficiary, function(result) {\r\n            $timeout(function() {\r\n                if (result && result.data) {\r\n                    if (result.data.status === true) {\r\n                        inform.add('beneficiary updated successfully.', {\r\n                            ttl: 4000\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.beneficiary.list', {}, {reload: true});\r\n                        }, 4500);\r\n                    } else {\r\n                        inform.add('Request completed successfully, but no update performed on beneficiary.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'beneficiary couldn\\'t be updated.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.updateRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // beneficiaryUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseBeneficiaryUpdate = function() {\r\n        $state.go('start.beneficiary.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.deleteBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.beneficiary = beneficiaryService.beneficiary;\r\n        // var beneficiaryUpdateBlock = blockUI.instances.get('beneficiaryUpdateBlock');\r\n        // beneficiaryUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + $scope.beneficiary.id;\r\n        beneficiaryService.deleteBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.deleteRequestSubmitted = true;\r\n                if (result && result.data && result.data.status === true) {\r\n                    $scope.deleteSuccessful = true;\r\n                } else {\r\n                  $log.info(result);\r\n                }\r\n                // beneficiaryUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseBeneficiaryDelete = function() {\r\n        $scope.$dismiss();\r\n        $state.go('start.beneficiary.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.fetchBeneficiary = function(id) {\r\n        $scope.beneficiaries.splice(0, $scope.beneficiaries.length);\r\n\r\n        var idSearch = !utilService.isBlank(id);\r\n        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        var url = idSearch ? baseUrl + '/' + id : baseUrl;\r\n        //var beneficiaryListBlock = blockUI.instances.get('beneficiaryListBlock');\r\n        //beneficiaryListBlock.start();\r\n        beneficiaryService.getBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.searchRequestSumbitted = true;\r\n                if (result && result.data) {\r\n                    if (idSearch) {\r\n                        $scope.beneficiaries.push(result.data);\r\n                    } else {\r\n                        $scope.beneficiaries = result.data;\r\n                    }\r\n                    beneficiaryService.beneficiaries = $scope.beneficiaries;\r\n                    $scope.beneficiaryFound = true;\r\n                }\r\n                //beneficiaryListBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.searchBeneficiary = function(id, $event) {\r\n        $event.stopPropagation();\r\n        $timeout(function() {\r\n            if (!utilService.isValidId(id)) {\r\n                $scope.registerPopoverShow('#searchExistingBeneficiaryId');\r\n                return;\r\n            }\r\n            $scope.fetchBeneficiary(id);\r\n        });\r\n    };\r\n\r\n    $scope.mutateBeneficiaryOptions = function(beneficiary, $index, $event) {\r\n        $event.stopPropagation();\r\n        beneficiaryService.selectedBeneficiaryId = '#beneficiary' + $index;\r\n        beneficiaryService.beneficiary = beneficiary;\r\n        $scope.registerPopoverPrep(beneficiaryService.selectedBeneficiaryId);\r\n        $scope.registerPopoverShow(beneficiaryService.selectedBeneficiaryId);\r\n    };\r\n\r\n    /* initialize popover */\r\n\r\n    $scope.discardMessage = function($event) {\r\n        $event ? $event.stopPropagation() : '';\r\n        beneficiaryService.popOnDelete = \"delete\";\r\n        $scope.registerPopoverHide('[id*=popover]');\r\n    };\r\n\r\n    beneficiaryService.popOnDelete = \"delete\";\r\n\r\n    $scope.registerPopoverPrep = function(id) {\r\n        angular.element($document.find(id)).popover({\r\n            trigger: 'manual'\r\n        });\r\n    };\r\n\r\n    $scope.registerPopoverShow = function(id) {\r\n        if (beneficiaryService.popOnDelete !== \"popover\") {\r\n            beneficiaryService.popOnDelete = \"popover\";\r\n            angular.element($document.find(id)).popover('show');\r\n        }\r\n    };\r\n\r\n    $scope.registerPopoverHide = function(id) {\r\n        var el = angular.element($document.find(id));\r\n        el ? el.popover('hide') : '';\r\n    };\r\n\r\n    $scope.registerPopoverPrep('#removeBeneficiary');\r\n    $scope.registerPopoverPrep('#addBeneficiary');\r\n    $scope.registerPopoverPrep('#updateBeneficiary');\r\n    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');\r\n    $scope.registerPopoverHide('[id*=popover]');\r\n\r\n    // clear all informs\r\n    inform.clear();\r\n};\r\ncontroller.$inject = [\"$rootScope\", \"$scope\", \"$timeout\", \"$window\", \"$document\", \"$log\", \"$state\", \"$modal\", \"beneficiaryService\", \"utilService\", \"blockUI\", \"inform\", \"CONSTANTS\"];\r\n\r\nexports.controller = controller;\r\n\n},{}],14:[function(require,module,exports){\n/**\r\n * Main Beneficiary Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],15:[function(require,module,exports){\n/**\r\n * Main View controller\r\n *\r\n * This controller is responsible for handing request from main view\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function() {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n};\r\n\r\nexports.controller = controller;\r\n\n},{}],16:[function(require,module,exports){\n/**\r\n * Main Directive\r\n *\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/common/MainView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'MainViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],17:[function(require,module,exports){\nvar stateConfig = {\r\n    /**\r\n     * Default to <company-create-view />\r\n     */\r\n    main: {\r\n        url: '/',\r\n        views: {\r\n            'main': {\r\n                template: '<main-view></main-view>'\r\n            },\r\n            'mainItem@start': {\r\n                template: '<company-create-view></company-create-view>'\r\n            }\r\n        }\r\n    },\r\n    company: {\r\n        initial: {\r\n            url: 'company',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-view></company-view>'\r\n                }\r\n            }\r\n        },\r\n        list: {\r\n            url: '/list',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-list-view></company-list-view>'\r\n                }\r\n            }\r\n        },\r\n        search: {\r\n            url: '/search',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-search-view></company-search-view>'\r\n                }\r\n            }\r\n        },\r\n        update: {\r\n            url: '/update',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-update-view></company-update-view>'\r\n                }\r\n            }\r\n        },\r\n        delete: {\r\n            // would be used under start.company.list state, hence url resolves to: #/company/list/delete\r\n            url: '/delete',\r\n            /**\r\n             * On state enter event listener\r\n             * @param  {$modal} Modal service\r\n             * @ngInject\r\n             */\r\n            onEnter: [\"$modal\", function($modal) {\r\n                $modal.open({\r\n                    template: '<company-delete-view></company-delete-view>',\r\n                    backdrop: 'static',\r\n                    keyboard: false,\r\n                    windowClass: 'modal',\r\n                    controller: 'CompanyViewController'\r\n                });\r\n            }]\r\n        }\r\n    },\r\n    beneficiary: {\r\n        initial: {\r\n            url: 'beneficiary',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-view></beneficiary-view>'\r\n                }\r\n            }\r\n        },\r\n        list: {\r\n            url: '/list',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-list-view></beneficiary-list-view>'\r\n                }\r\n            }\r\n        },\r\n        search: {\r\n            url: '/search',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-search-view></beneficiary-seach-view>'\r\n                }\r\n            }\r\n        },\r\n        update: {\r\n            url: '/update',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-update-view></beneficiary-update-view>'\r\n                }\r\n            }\r\n        },\r\n        delete: {\r\n            /** would be used under start.beneficiary.list or start.beneficiary.search state,\r\n             *  hence url resolves to: #/beneficiary/list/delete or  #/beneficiary/search/delete\r\n             */\r\n            url: '/delete',\r\n            /**\r\n             * On state enter event listener\r\n             * @param  {$modal} Modal service\r\n             * @ngInject\r\n             */\r\n            onEnter: [\"$modal\", function($modal) {\r\n                $modal.open({\r\n                    template: '<beneficiary-delete-view></beneficiary-delete-view>',\r\n                    backdrop: 'static',\r\n                    keyboard: false,\r\n                    windowClass: 'modal',\r\n                    controller: 'BeneficiaryViewController'\r\n                });\r\n            }]\r\n        }\r\n    }\r\n};\r\n\r\nexports.stateConfig = stateConfig;\r\n\n},{}],18:[function(require,module,exports){\n/**\r\n * This service provide custom word lookup for case normalization if one is not provided by the service client\r\n *\r\n * @param {$window} The angular window service\r\n * @ngInject\r\n */\r\nvar service = function($window) {\r\n    'use strict';\r\n    var serviceInstance = {};\r\n\r\n    serviceInstance.isFormValid = function(formId) {\r\n        var isValid = true;\r\n        var formEl = $window.document.getElementById(formId);\r\n        console.log(formEl);\r\n        if (!formEl || (formEl && formEl.className && formEl.className.indexOf('ng-invalid') > -1)) return false;\r\n        // otherwise, perform sanity check\r\n        var elements = $window.document.getElementById(formId).elements;\r\n        for (var i = 0, element = elements[i++]; i < elements.length; i++) {\r\n            if ((element.type === 'text' || element.type === 'checkbox' || element.type === 'radio' || element.type === 'date' || element.type === 'datetime-local' || element.type === 'email' || element.type === 'month' || element.type === 'number' || element.type === 'time' || element.type === 'url' || element.type === 'week' || element.type === 'textarea' || element.type === 'select') && (element.className.indexOf('ng-invalid') > -1)) {\r\n                isValid = false;\r\n                return isValid;\r\n            }\r\n        }\r\n\r\n        return isValid;\r\n    };\r\n\r\n    serviceInstance.isBlank = function(value) {\r\n        return angular.isUndefined(value) || value === null || value.length === 0;\r\n    };\r\n\r\n    serviceInstance.isValidId = function(id) {\r\n        return parseInt(id) >= 1;\r\n    }\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$window\"];\r\n\r\nexports.service = service;\r\n\n},{}],19:[function(require,module,exports){\n/**\r\n * Company Create Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyCreateView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],20:[function(require,module,exports){\n/**\r\n * Company Delete Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyDeleteView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],21:[function(require,module,exports){\n/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function() {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyListFragmentView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            companies: '=',\r\n            delref: '='\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],22:[function(require,module,exports){\n/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyListView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],23:[function(require,module,exports){\n/**\r\n * Company Search Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanySearchView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],24:[function(require,module,exports){\n/**\r\n * This service helps to perform http requests (GET, POST, PUT, DELETE) for company tasks\r\n *\r\n * @param {$http} The AngularJS http service\r\n * @param {$timeout} The AngularJS timeout service\r\n *\r\n * @ngInject\r\n */\r\nvar service = function($http, $timeout) {\r\n    'use strict';\r\n\r\n    var serviceInstance = {};\r\n    serviceInstance.selectedCompanyId = null;\r\n    serviceInstance.popOnDelete = null;\r\n    serviceInstance.company = null;\r\n    serviceInstance.companies = [];\r\n\r\n    serviceInstance.getCompany = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'GET',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.createCompany = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            data: data,\r\n            method: 'POST',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n    serviceInstance.updateCompany = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'PUT',\r\n            data: data,\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.deleteCompany = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'DELETE',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$http\", \"$timeout\"];\r\n\r\nexports.service = service;\r\n\n},{}],25:[function(require,module,exports){\n/**\r\n * Company Update Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyUpdateView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],26:[function(require,module,exports){\n/**\r\n * Company View controller\r\n *\r\n * This controller is responsible for handing company form module related logic\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$q} Angular promise service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {$modal} Angular modal service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n * @param {utilService} Utility service\r\n * @param {blockUI} Block UI service\r\n * @param {inform} Inform provider service\r\n * @param {CONSTANTS} Project constants values\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function($rootScope, $scope, $q, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, companyService, utilService, blockUI, inform, CONSTANTS) {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n    $scope.useExistingBeneficiary = false;\r\n    $scope.minimumValidBeneficiary = false;\r\n    $scope.beneficiaryId = null;\r\n    $scope.beneficiarySearched = false;\r\n    $scope.beneficiaryFound = false;\r\n    $scope.companyFound = false;\r\n    $scope.searchRequestSumbitted = false;\r\n    $scope.addRequestSubmitted = false;\r\n    $scope.updateRequestSubmitted = false;\r\n    $scope.deleteRequestSubmitted = false;\r\n    $scope.deleteSuccessful = false;\r\n    $scope.serviceUrl = CONSTANTS.url.host + ':' + CONSTANTS.url.port + '/' + CONSTANTS.url.contextRoot;\r\n\r\n    $scope.initCompany = {\r\n        \"name\": null,\r\n        \"address\": null,\r\n        \"city\": null,\r\n        \"country\": null,\r\n        \"email\": null,\r\n        \"phoneNumber\": null,\r\n        \"beneficiaries\": [{\r\n            \"id\": -1,\r\n            \"firstName\": null,\r\n            \"lastName\": null\r\n        }]\r\n    };\r\n\r\n    $scope.companies = companyService.companies.length > 0 ? companyService.companies : [];\r\n    $scope.company = companyService.company &&\r\n                    ($state.current.name === 'start.company.update' || $state.current.name === 'start.company.list.delete' || $state.current.name === 'start.company.search.delete') ?\r\n                    companyService.company : $scope.initCompany;\r\n\r\n    $scope.verifyMinimumValidBeneficiary = function() {\r\n        for (var i = 0; i < $scope.company.beneficiaries.length; i++) {\r\n            $scope.minimumValidBeneficiary = $scope.company.beneficiaries[i].id !== -1 ||\r\n                                            (!utilService.isBlank($scope.company.beneficiaries[i].firstName) && !utilService.isBlank($scope.company.beneficiaries[i].lastName));\r\n            if ($scope.minimumValidBeneficiary) {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n\r\n    $scope.resetCompany = function() {\r\n        $timeout(function() {\r\n            $scope.company = $scope.initCompany;\r\n            $scope.companies = [];\r\n        });\r\n    };\r\n\r\n    $scope.addCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.addRequestSubmitted = false;\r\n        companyService.company = $scope.company;\r\n        if (utilService.isFormValid('companyDetailsForm')) {\r\n            $scope.verifyMinimumValidBeneficiary();\r\n            if (!$scope.minimumValidBeneficiary) {\r\n                $scope.registerPopoverShow('#addCompany');\r\n                return;\r\n            }\r\n            $log.info('valid');\r\n        } else {\r\n            $log.warn('form invalid');\r\n            return;\r\n        }\r\n\r\n        var companyCreateBlock = blockUI.instances.get('companyCreateBlock');\r\n        // companyCreateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        $scope.addRequestSubmitted = true;\r\n        companyService.createCompany(url, $scope.company, function(result) {\r\n            $timeout(function() {\r\n                if (result && result.data) {\r\n                    if (result.data.id > 0) {\r\n                        inform.add('Company created successfully.', {\r\n                            ttl: 2500\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.company', {}, {reload:true});\r\n                        }, 2500);\r\n                    } else {\r\n                        inform.add('Request completed, however company couldn\\'t be created.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating company.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.addRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // companyCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelAddCompany = function() {\r\n        $state.go('start.company');\r\n    };\r\n\r\n    $scope.updateCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.updateRequestSubmitted = false;\r\n        companyService.company = $scope.company;\r\n        if (utilService.isFormValid('companyUpdateForm')) {\r\n            $scope.verifyMinimumValidBeneficiary();\r\n            if (!$scope.minimumValidBeneficiary) {\r\n                $scope.registerPopoverShow('#updateCompany');\r\n                return;\r\n            }\r\n        } else {\r\n            $log.warn('form invalid');\r\n            return;\r\n        }\r\n\r\n        // var companyUpdateBlock = blockUI.instances.get('companyUpdateBlock');\r\n        // companyUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        $scope.updateRequestSubmitted = true;\r\n        companyService.updateCompany(url, $scope.company, function(result) {\r\n            $timeout(function() {\r\n                if (result && result.data) {\r\n                    if (result.data.status === true) {\r\n                        inform.add('Company updated successfully.', {\r\n                            ttl: 4000\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.company.list', {}, {reload: true});\r\n                        }, 4500);\r\n                    } else {\r\n                        inform.add('Request completed successfully, but no update performed on company.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Company couldn\\'t be updated.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.updateRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // companyUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseCompanyUpdate = function() {\r\n        $state.go('start.company.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.deleteCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.company = companyService.company;\r\n        // var companyUpdateBlock = blockUI.instances.get('companyUpdateBlock');\r\n        // companyUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath + '/' + $scope.company.id;\r\n        companyService.deleteCompany(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.deleteRequestSubmitted = true;\r\n                if (result && result.data && result.data.status === true) {\r\n                    $scope.deleteSuccessful = true;\r\n                }\r\n                // companyUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseCompanyDelete = function() {\r\n        $scope.$dismiss();\r\n        $state.go('start.company.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.fetchCompany = function(id) {\r\n        $scope.companies.splice(0, $scope.companies.length);\r\n\r\n        var idSearch = !utilService.isBlank(id);\r\n        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        var url = idSearch ? baseUrl + '/' + id : baseUrl;\r\n        //var companyListBlock = blockUI.instances.get('companyListBlock');\r\n        //companyListBlock.start();\r\n        companyService.getCompany(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.searchRequestSumbitted = true;\r\n                if (result && result.data) {\r\n                    if (idSearch) {\r\n                        $scope.companies.push(result.data);\r\n                    } else {\r\n                        $scope.companies = result.data;\r\n                    }\r\n                    companyService.companies = $scope.companies;\r\n                    $scope.companyFound = true;\r\n                }\r\n                //companyListBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.searchCompany = function(id, $event) {\r\n        $event.stopPropagation();\r\n        $timeout(function() {\r\n            if (!utilService.isValidId(id)) {\r\n                $scope.registerPopoverShow('#searchExistingCompanyId');\r\n                return;\r\n            }\r\n            $scope.fetchCompany(id);\r\n        });\r\n    };\r\n\r\n    $scope.searchBeneficiary = function(id, $event) {\r\n        $event.stopPropagation();\r\n\r\n        if (!utilService.isValidId(id)) {\r\n            $scope.registerPopoverShow('#searchExistingBeneficiaryId');\r\n            return;\r\n        }\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + id;\r\n\r\n        var companySearchBlock = blockUI.instances.get('companySearchBlock');\r\n        companySearchBlock.start();\r\n        beneficiaryService.findBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.beneficiarySearched = true;\r\n                if (result && result.data) {\r\n                    $scope.verifyMinimumValidBeneficiary();\r\n                    // remove all empty forms\r\n                    if (!$scope.minimumValidBeneficiary) {\r\n                        $scope.company.beneficiaries.splice(0, $scope.company.beneficiaries.length);\r\n                    }\r\n                    $scope.company.beneficiaries.push(result.data);\r\n                    $scope.disableBeneficiary(result.data.id);\r\n                    $scope.minimumValidBeneficiary = true;\r\n                    $scope.beneficiaryFound = true;\r\n                    $scope.beneficiaryId = null;\r\n                }\r\n                companySearchBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.mutateCompanyOptions = function(company, $index, $event) {\r\n        $event.stopPropagation();\r\n        companyService.selectedCompanyId = '#company' + $index;\r\n        companyService.company = company;\r\n        $scope.registerPopoverPrep(companyService.selectedCompanyId);\r\n        $scope.registerPopoverShow(companyService.selectedCompanyId);\r\n    };\r\n\r\n    $scope.addBeneficiary = function() {\r\n        $scope.company.beneficiaries.push({\r\n            \"firstName\": \"\",\r\n            \"lastName\": \"\"\r\n        });\r\n    };\r\n\r\n    $scope.removeBeneficiary = function($event, beneficiary) {\r\n        $event.stopPropagation();\r\n        if ($scope.company.beneficiaries.indexOf(beneficiary) != -1) {\r\n            $timeout(function() {\r\n                if ($scope.company.beneficiaries.length === 1) {\r\n                    $scope.registerPopoverShow('#removeBeneficiary');\r\n                    return;\r\n                }\r\n                $scope.company.beneficiaries.splice($scope.company.beneficiaries.indexOf(beneficiary), 1);\r\n            });\r\n        }\r\n    };\r\n\r\n    $scope.disableBeneficiary = function(beneficiaryId) {\r\n        $rootScope.$emit('disableBeneficiary', {\r\n            beneficiaries: $scope.company.beneficiaries,\r\n            beneficiaryId: beneficiaryId\r\n        });\r\n    }\r\n\r\n    /* initialize popover */\r\n\r\n    $scope.discardMessage = function($event) {\r\n        $event ? $event.stopPropagation() : '';\r\n        companyService.popOnDelete = \"delete\";\r\n        $scope.registerPopoverHide('[id*=popover]');\r\n    };\r\n\r\n    companyService.popOnDelete = \"delete\";\r\n\r\n    $scope.registerPopoverPrep = function(id) {\r\n        angular.element($document.find(id)).popover({\r\n            trigger: 'manual'\r\n        });\r\n    };\r\n\r\n    $scope.registerPopoverShow = function(id) {\r\n        if (companyService.popOnDelete !== \"popover\") {\r\n            companyService.popOnDelete = \"popover\";\r\n            angular.element($document.find(id)).popover('show');\r\n        }\r\n    };\r\n\r\n    $scope.registerPopoverHide = function(id) {\r\n        var el = angular.element($document.find(id));\r\n        el ? el.popover('hide') : '';\r\n    };\r\n\r\n    $scope.registerPopoverPrep('#removeBeneficiary');\r\n    $scope.registerPopoverPrep('#addCompany');\r\n    $scope.registerPopoverPrep('#updateCompany');\r\n    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');\r\n    $scope.registerPopoverPrep('#searchExistingCompanyId');\r\n    $scope.registerPopoverHide('[id*=popover]');\r\n\r\n    // clear all informs\r\n    inform.clear();\r\n};\r\ncontroller.$inject = [\"$rootScope\", \"$scope\", \"$q\", \"$timeout\", \"$window\", \"$document\", \"$log\", \"$state\", \"$modal\", \"beneficiaryService\", \"companyService\", \"utilService\", \"blockUI\", \"inform\", \"CONSTANTS\"];\r\n\r\nexports.controller = controller;\r\n\n},{}],27:[function(require,module,exports){\n/**\r\n * Main Company Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyView.html',\r\n        restrict: 'AE',\r\n        scope: false\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],28:[function(require,module,exports){\n/**\r\n * Side Nav View controller\r\n *\r\n * This controller is responsible for handing request from side nav\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function() {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n};\r\n\r\nexports.controller = controller;\r\n\n},{}],29:[function(require,module,exports){\n/**\r\n * Side Nav Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/nav/SideNavView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'SideNavViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],30:[function(require,module,exports){\nvar translationsEN = {\n    \"BENEFICIARY\": {\n        \"ID\": \"Id\",\n        \"FIRST_NAME\": \"First name\",\n        \"LAST_NAME\": \"Last name\"\n    }\n};\n\nexports.translationsEN = translationsEN;\n\n},{}],31:[function(require,module,exports){\n'use strict';\r\n\r\nvar states = require('./components/common/States');\r\nvar configBlock = {\r\n    /**\r\n     * @param {$logProvider} The log provider service\r\n     * @param {$translateProvider} The angular translate service\r\n     * @ngInject\r\n     */\r\n    settings: [\"$logProvider\", \"$translateProvider\", function($logProvider, $translateProvider) {\r\n        $logProvider.debugEnabled(true); // Turns global logging with $log.debug on\r\n\r\n        var i18n_en = require('./components/nls/i18n-en');\r\n        $translateProvider.useSanitizeValueStrategy('sanitizeParameters');\r\n        $translateProvider.translations('en', i18n_en.translationsEN).useStaticFilesLoader({\r\n                files: [{\r\n                    prefix: './components/nls/i18n-',\r\n                    suffix: '.json'\r\n                }]\r\n            })\r\n            .preferredLanguage('en')\r\n            .fallbackLanguage('en');\r\n    }],\r\n    /**\r\n     * @param {$stateProvider} $stateProvider The UI router stateProvider service\r\n     * @param {$urlRouterProvider} The UI router urlRouterProvider service\r\n     * @param {$modalStateProvider} The custom modal state provider service\r\n     * @ngInject\r\n     */\r\n    states: [\"$stateProvider\", \"$urlRouterProvider\", function($stateProvider, $urlRouterProvider) {\r\n        $urlRouterProvider.otherwise('/');\r\n        $stateProvider\r\n            .state('start', states.stateConfig.main)\r\n            .state('start.company', states.stateConfig.company.initial)\r\n            .state('start.company.list', states.stateConfig.company.list)\r\n            .state('start.company.list.delete',  angular.copy(states.stateConfig.company.delete))\r\n            .state('start.company.search', states.stateConfig.company.search)\r\n            .state('start.company.search.delete', angular.copy(states.stateConfig.company.delete))\r\n            .state('start.company.update', states.stateConfig.company.update)\r\n            .state('start.beneficiary', states.stateConfig.beneficiary.initial)\r\n            .state('start.beneficiary.list', states.stateConfig.beneficiary.list)\r\n            .state('start.beneficiary.list.delete', angular.copy(states.stateConfig.beneficiary.delete))\r\n            .state('start.beneficiary.search', states.stateConfig.beneficiary.search)\r\n            .state('start.beneficiary.search.delete', angular.copy(states.stateConfig.beneficiary.delete))\r\n            .state('start.beneficiary.update', states.stateConfig.beneficiary.update)\r\n    }],\r\n\r\n    /**\r\n     * @param  {blockUIConfig} The block UI config service\r\n     * @ngInject\r\n     */\r\n    blockUI: [\"blockUIConfig\", function(blockUIConfig) {\r\n        blockUIConfig.delay = 100;\r\n        blockUIConfig.autoBlock = false;\r\n        blockUIConfig.autoInjectBodyBlock = false;\r\n        blockUIConfig.template = '<div><img src=\"dist/images/ajax-loader.gif\" /> Processing...</h1>';\r\n    }],\r\n\r\n    /**\r\n     * @param  {informProvider} The inform provider service\r\n     * @ngInject\r\n     */\r\n    inform: [\"informProvider\", function(informProvider) {\r\n        informProvider.defaults({\r\n            /**\r\n             * The time to live for the message in milliseconds.\r\n             * Default value is 5000. Specify <0 to make the message sticky.\r\n             */\r\n            ttl: -1,\r\n\r\n            /**\r\n             * The type of message to enable styling.\r\n             * Values can be 'default', 'primary', 'success', 'info', 'warning', 'danger' or any other custom required type.\r\n             * Default value is 'info'. If 'default' is specified as value, then 'info' is used\r\n             */\r\n            type: 'success',\r\n            /**\r\n             * Allow html formatting\r\n             * Default value is false\r\n             */\r\n            html: true\r\n        });\r\n    }],\r\n\r\n    /**\r\n     * Modal block\r\n     * @param  {$rootScope}  Angular root scope service\r\n     * @param  {$modalStack} Angular UI modal stack\r\n     * @ngInject\r\n     */\r\n    modal: [\"$rootScope\", \"$modalStack\", function($rootScope, $modalStack) {\r\n        $rootScope.$on('$stateChangeStart', function() {\r\n            var top = $modalStack.getTop();\r\n            if (top) {\r\n                $modalStack.dismiss(top.key);\r\n            }\r\n        });\r\n    }],\r\n\r\n    /**\r\n     * Href sanitization whitelist\r\n     * @param  {$compileProvide} Angular compile provider service\r\n     * @ngInject\r\n     */\r\n    hrefSanitize: [\"$compileProvider\", function($compileProvider) {\r\n        $compileProvider.aHrefSanitizationWhitelist(/^\\s*(https?|ftp|mailto|file|chrome-extension|blob:chrome-extension):/);\r\n    }],\r\n\r\n    namespace: 'com.companyregistry'\r\n};\r\n\r\nexports.configBlock = configBlock;\r\n\n},{\"./components/common/States\":17,\"./components/nls/i18n-en\":30}],32:[function(require,module,exports){\n'use strict';\r\n\r\nexports.constants = {\r\n    url: {\r\n\t\t\t\thost: 'http://localhost',\r\n\t\t\t\tport: '8080',\r\n\t\t\t\tcontextRoot: 'companyregistry',\r\n        companyContextPath: 'companies',\r\n        beneficiaryContextPath: 'beneficiaries'\r\n    }\r\n};\r\n\n},{}],33:[function(require,module,exports){\n/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* jshint ignore:start */\nvar noop        = angular.noop;\nvar extend      = angular.extend;\nvar jqLite      = angular.element;\nvar forEach     = angular.forEach;\nvar isArray     = angular.isArray;\nvar isString    = angular.isString;\nvar isObject    = angular.isObject;\nvar isUndefined = angular.isUndefined;\nvar isDefined   = angular.isDefined;\nvar isFunction  = angular.isFunction;\nvar isElement   = angular.isElement;\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar isPromiseLike = function(p) {\n  return p && p.then ? true : false;\n};\n\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return [];\n        break;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n        break;\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  }\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationOptions(element, target, newOptions) {\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof angular.element) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncancelled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\nvar $$AnimateChildrenDirective = [function() {\n  return function(scope, element, attrs) {\n    var val = attrs.ngAnimateChildren;\n    if (angular.isString(val) && val.length === 0) { //empty attribute\n      element.data(NG_ANIMATE_CHILDREN_DATA, true);\n    } else {\n      attrs.$observe('ngAnimateChildren', function(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      });\n    }\n  };\n}];\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and stlyes may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n * * `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occuring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a colapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for zegative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$animate',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $animate) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = \"$$ngAnimateParentKey\";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an interal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var cancelLastRAFRequest;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, options) {\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$animate.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle = parseFloat(options.delay);\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            value ? node.style.setProperty(prop, value)\n                  : node.style.removeProperty(prop);\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        var startTime, events = [];\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidently cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intential stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          element.on(events.join(' '), onAnimationProgress);\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n\n        function onAnimationProgress(event) {\n          event.stopPropagation();\n          var ev = event.originalEvent || event;\n          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();\n\n          /* Firefox (or possibly just Gecko) likes to not round values up\n           * when a ms measurement is used for the animation */\n          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n          /* $manualTimeStamp is a mocked timeStamp value which is set\n           * within browserTrigger(). This is only here so that tests can\n           * mock animations properly. Real events fallback to event.timeStamp,\n           * or, if they don't, then a timeStamp is automatically created for them.\n           * We're checking to see if the timeStamp surpasses the expected delay,\n           * but we're using elapsedTime instead of the timeStamp on the 2nd\n           * pre-condition since animations sometimes close off early */\n          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n            // we set this flag to ensure that if the transition is paused then, when resumed,\n            // the animation will automatically close itself since transitions cannot be paused.\n            animationCompleted = true;\n            close();\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragement case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coods object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      return {\n        start: function() {\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          var animationClosed = false;\n          var runner = new $$AnimateRunner({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            animationClosed = true;\n            applyOptions();\n            applyAnimationStyles(element, options);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(options, and) {\n    options = options || {};\n    var a = (options.addClass || '').length > 0;\n    var b = (options.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    var nO = newAnimation.options;\n    var cO = currentAnimation.options;\n\n    // if the exact same CSS class is added/removed then it's safe to cancel it\n    return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = {};\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationOptions(element, options) {\n      return mergeAnimationOptions(element, options, {});\n    }\n\n    function findCallbacks(element, event) {\n      var targetNode = getDomNode(element);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (entry.node.contains(targetNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    return {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n      },\n\n      off: function(event, container, callback) {\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n\n        function filterFromRegistry(list, matchContainer, matchCallback) {\n          var containerNode = extractElementNode(matchContainer);\n          return list.filter(function(entry) {\n            var isMatch = entry.node === containerNode &&\n                            (!matchCallback || entry.callback === matchCallback);\n            return !isMatch;\n          });\n        }\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n            var recordExists = disabledElementsLookup.get(node);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !recordExists;\n            } else {\n              // (element, bool) - Element setter\n              bool = !!bool;\n              if (!bool) {\n                disabledElementsLookup.put(node, true);\n              } else if (recordExists) {\n                disabledElementsLookup.remove(node);\n              }\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    function queueAnimation(element, event, options) {\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        close();\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationOptions(element, existingAnimation.options, options);\n            return existingAnimation.runner;\n          }\n        }\n\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationOptions(element, options);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationOptions(element, options);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation.options);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails.options));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n            });\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        switch (state) {\n          case RUNNING_STATE:\n            animationDetails.runner.end();\n            /* falls through */\n          case PRE_DIGEST_STATE:\n            if (animationDetails) {\n              activeAnimationsLookup.remove(child);\n            }\n            break;\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n\n      var parentHost = element.data(NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      while (parentElement && parentElement.length) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        var parentNode = parentElement[0];\n        if (parentNode.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentNode) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n          if (!rootElementDetected) {\n            parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);\n            if (parentHost) {\n              parentElement = parentHost;\n            }\n          }\n        }\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be apart of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        parentElement = parentElement.parent();\n      }\n\n      var allowAnimation = !parentAnimationDetected || animateChildren;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$AnimateAsyncRunFactory = ['$$rAF', function($$rAF) {\n  var waitQueue = [];\n\n  function waitForTick(fn) {\n    waitQueue.push(fn);\n    if (waitQueue.length > 1) return;\n    $$rAF(function() {\n      for (var i = 0; i < waitQueue.length; i++) {\n        waitQueue[i]();\n      }\n      waitQueue = [];\n    });\n  }\n\n  return function() {\n    var passed = false;\n    waitForTick(function() {\n      passed = true;\n    });\n    return function(callback) {\n      passed ? callback() : waitForTick(callback);\n    };\n  };\n}];\n\nvar $$AnimateRunnerFactory = ['$q', '$sniffer', '$$animateAsyncRun',\n                      function($q,   $sniffer,   $$animateAsyncRun) {\n\n  var INITIAL_STATE = 0;\n  var DONE_PENDING_STATE = 1;\n  var DONE_COMPLETE_STATE = 2;\n\n  AnimateRunner.chain = function(chain, callback) {\n    var index = 0;\n\n    next();\n    function next() {\n      if (index === chain.length) {\n        callback(true);\n        return;\n      }\n\n      chain[index](function(response) {\n        if (response === false) {\n          callback(false);\n          return;\n        }\n        index++;\n        next();\n      });\n    }\n  };\n\n  AnimateRunner.all = function(runners, callback) {\n    var count = 0;\n    var status = true;\n    forEach(runners, function(runner) {\n      runner.done(onProgress);\n    });\n\n    function onProgress(response) {\n      status = status && response;\n      if (++count === runners.length) {\n        callback(status);\n      }\n    }\n  };\n\n  function AnimateRunner(host) {\n    this.setHost(host);\n\n    this._doneCallbacks = [];\n    this._runInAnimationFrame = $$animateAsyncRun();\n    this._state = 0;\n  }\n\n  AnimateRunner.prototype = {\n    setHost: function(host) {\n      this.host = host || {};\n    },\n\n    done: function(fn) {\n      if (this._state === DONE_COMPLETE_STATE) {\n        fn();\n      } else {\n        this._doneCallbacks.push(fn);\n      }\n    },\n\n    progress: noop,\n\n    getPromise: function() {\n      if (!this.promise) {\n        var self = this;\n        this.promise = $q(function(resolve, reject) {\n          self.done(function(status) {\n            status === false ? reject() : resolve();\n          });\n        });\n      }\n      return this.promise;\n    },\n\n    then: function(resolveHandler, rejectHandler) {\n      return this.getPromise().then(resolveHandler, rejectHandler);\n    },\n\n    'catch': function(handler) {\n      return this.getPromise()['catch'](handler);\n    },\n\n    'finally': function(handler) {\n      return this.getPromise()['finally'](handler);\n    },\n\n    pause: function() {\n      if (this.host.pause) {\n        this.host.pause();\n      }\n    },\n\n    resume: function() {\n      if (this.host.resume) {\n        this.host.resume();\n      }\n    },\n\n    end: function() {\n      if (this.host.end) {\n        this.host.end();\n      }\n      this._resolve(true);\n    },\n\n    cancel: function() {\n      if (this.host.cancel) {\n        this.host.cancel();\n      }\n      this._resolve(false);\n    },\n\n    complete: function(response) {\n      var self = this;\n      if (self._state === INITIAL_STATE) {\n        self._state = DONE_PENDING_STATE;\n        self._runInAnimationFrame(function() {\n          self._resolve(response);\n        });\n      }\n    },\n\n    _resolve: function(response) {\n      if (this._state !== DONE_COMPLETE_STATE) {\n        forEach(this._doneCallbacks, function(fn) {\n          fn(response);\n        });\n        this._doneCallbacks.length = 0;\n        this._state = DONE_COMPLETE_STATE;\n      }\n    }\n  };\n\n  return AnimateRunner;\n}];\n\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effictively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check\n\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          getRunner(element).setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/* global angularAnimateModule: true,\n\n   $$AnimateAsyncRunFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateRunnerFactory,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,\n*/\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=true\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the ainmation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       }).start();\n*        runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       }).start();\n *\n *       runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n *\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix\n * will be evaluated for animation when any DOM changes occur in the application.\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [])\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .factory('$$AnimateRunner', $$AnimateRunnerFactory)\n  .factory('$$animateAsyncRun', $$AnimateAsyncRunFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n\n},{}],34:[function(require,module,exports){\nrequire('./angular-animate');\nmodule.exports = 'ngAnimate';\n\n},{\"./angular-animate\":33}],35:[function(require,module,exports){\n/*!\n   angular-block-ui v0.2.0\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\n   License: MIT\n*/\n(function(angular) {\n\nvar blkUI = angular.module('blockUI', []);\n\nblkUI.config([\"$provide\", \"$httpProvider\", function ($provide, $httpProvider) {\n\n  $provide.decorator('$exceptionHandler', ['$delegate', '$injector',\n    function ($delegate, $injector) {\n      var blockUI, blockUIConfig;\n\n      return function (exception, cause) {\n\n        blockUIConfig = blockUIConfig || $injector.get('blockUIConfig');\n\n        if (blockUIConfig.resetOnException) {\n          try {\n            blockUI = blockUI || $injector.get('blockUI');\n            blockUI.instances.reset();\n          } catch (ex) {\n            console.log('$exceptionHandler', exception);\n          }\n        }\n\n        $delegate(exception, cause);\n      };\n    }\n  ]);\n\n  $httpProvider.interceptors.push('blockUIHttpInterceptor');\n}]);\n\nblkUI.run([\"$document\", \"blockUIConfig\", \"$templateCache\", function ($document, blockUIConfig, $templateCache) {\n  if (blockUIConfig.autoInjectBodyBlock) {\n    $document.find('body').attr('block-ui', 'main');\n  }\n\n  if (blockUIConfig.template) {\n\n    // Swap the builtin template with the custom template.\n    // Create a magic cache key and place the template in the cache.\n\n    blockUIConfig.templateUrl = '$$block-ui-template$$';\n    $templateCache.put(blockUIConfig.templateUrl, blockUIConfig.template);\n  }\n}]);\n\nfunction moduleLoaded(name) {\n  try {\n    angular.module(name);\n  } catch(ex) {\n    return false;\n  }\n  return true;\n}\nblkUI.config([\"$provide\", function ($provide) {\n  $provide.decorator('$location', decorateLocation);\n}]);\n\nvar decorateLocation = [\n  '$delegate', 'blockUI', 'blockUIConfig',\n  function ($delegate, blockUI, blockUIConfig) {\n\n    if (blockUIConfig.blockBrowserNavigation) {\n\n      blockUI.$_blockLocationChange = true;\n\n      var overrides = ['url', 'path', 'search', 'hash', 'state'];\n\n      function hook(f) {\n        var s = $delegate[f];\n        $delegate[f] = function () {\n\n          //        console.log(f, Date.now(), arguments);\n\n          var result = s.apply($delegate, arguments);\n\n          // The call was a setter if the $location service is returned.\n\n          if (result === $delegate) {\n\n            // Mark the mainblock ui to allow the location change.\n\n            blockUI.$_blockLocationChange = false;\n          }\n\n          return result;\n        };\n      }\n\n      angular.forEach(overrides, hook);\n\n    }\n\n    return $delegate;\n}];\n\n// Called from block-ui-directive for the 'main' instance.\n\nfunction blockNavigation($scope, mainBlockUI, blockUIConfig) {\n\n  if (blockUIConfig.blockBrowserNavigation) {\n\n    function registerLocationChange() {\n\n      $scope.$on('$locationChangeStart', function (event) {\n\n        //        console.log('$locationChangeStart', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);\n\n        if (mainBlockUI.$_blockLocationChange && mainBlockUI.state().blockCount > 0) {\n          event.preventDefault();\n        }\n      });\n\n      $scope.$on('$locationChangeSuccess', function () {\n        mainBlockUI.$_blockLocationChange = blockUIConfig.blockBrowserNavigation;\n\n        //        console.log('$locationChangeSuccess', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);\n      });\n    }\n\n    if (moduleLoaded('ngRoute')) {\n\n      // After the initial content has been loaded we'll spy on any location\n      // changes and discard them when needed.\n\n      var fn = $scope.$on('$viewContentLoaded', function () {\n\n        // Unhook the view loaded and hook a function that will prevent\n        // location changes while the block is active.\n\n        fn();\n        registerLocationChange();\n\n      });\n\n    } else {\n      registerLocationChange();\n    }\n\n  }\n}\nblkUI.directive('blockUiContainer', [\"blockUIConfig\", \"blockUiContainerLinkFn\", function (blockUIConfig, blockUiContainerLinkFn) {\n  return {\n    scope: true,\n    restrict: 'A',\n    templateUrl: blockUIConfig.templateUrl,\n    compile: function($element) {\n      return blockUiContainerLinkFn;\n    }\n  };\n}]).factory('blockUiContainerLinkFn', [\"blockUI\", \"blockUIUtils\", function (blockUI, blockUIUtils) {\n\n  return function ($scope, $element, $attrs) {\n\n    var srvInstance = $element.inheritedData('block-ui');\n\n    if (!srvInstance) {\n      throw new Error('No parent block-ui service instance located.');\n    }\n\n    // Expose the state on the scope\n\n    $scope.state = srvInstance.state();\n\n//    $scope.$watch('state.blocking', function(value) {\n//      $element.toggleClass('block-ui-visible', !!value);\n//    });\n//\n//    $scope.$watch('state.blockCount > 0', function(value) {\n//      $element.toggleClass('block-ui-active', !!value);\n//    });\n  };\n}]);\nblkUI.directive('blockUi', [\"blockUiCompileFn\", function (blockUiCompileFn) {\n\n  return {\n    scope: true,\n    restrict: 'A',\n    compile: blockUiCompileFn\n  };\n\n}]).factory('blockUiCompileFn', [\"blockUiPreLinkFn\", function (blockUiPreLinkFn) {\n\n  return function ($element, $attrs) {\n\n    // Class should be added here to prevent an animation delay error.\n\n    $element.append('<div block-ui-container class=\"block-ui-container\"></div>');\n\n    return {\n      pre: blockUiPreLinkFn\n    };\n\n  };\n\n}]).factory('blockUiPreLinkFn', [\"blockUI\", \"blockUIUtils\", \"blockUIConfig\", function (blockUI, blockUIUtils, blockUIConfig) {\n\n  return function ($scope, $element, $attrs) {\n\n    // If the element does not have the class \"block-ui\" set, we set the\n    // default css classes from the config.\n\n    if (!$element.hasClass('block-ui')) {\n      $element.addClass(blockUIConfig.cssClass);\n    }\n\n    // Expose the blockUiMessageClass attribute value on the scope\n\n    $attrs.$observe('blockUiMessageClass', function (value) {\n      $scope.$_blockUiMessageClass = value;\n    });\n\n    // Create the blockUI instance\n    // Prefix underscore to prevent integers:\n    // https://github.com/McNull/angular-block-ui/pull/8\n\n    var instanceId = $attrs.blockUi || '_' + $scope.$id;\n    var srvInstance = blockUI.instances.get(instanceId);\n\n    // If this is the main (topmost) block element we'll also need to block any\n    // location changes while the block is active.\n\n    if (instanceId === 'main') {\n      blockNavigation($scope, srvInstance, blockUIConfig);\n    } else {\n      // Locate the parent blockUI instance\n      var parentInstance = $element.inheritedData('block-ui');\n\n      if (parentInstance) {\n        // TODO: assert if parent is already set to something else\n        srvInstance._parent = parentInstance;\n      }\n    }\n\n    // Ensure the instance is released when the scope is destroyed\n\n    $scope.$on('$destroy', function () {\n      srvInstance.release();\n    });\n\n    // Increase the reference count\n\n    srvInstance.addRef();\n\n    // Expose the state on the scope\n\n    $scope.$_blockUiState = srvInstance.state();\n\n    $scope.$watch('$_blockUiState.blocking', function (value) {\n      // Set the aria-busy attribute if needed\n      $element.attr('aria-busy', !!value);\n      $element.toggleClass('block-ui-visible', !!value);\n    });\n\n    $scope.$watch('$_blockUiState.blockCount > 0', function (value) {\n      $element.toggleClass('block-ui-active', !!value);\n    });\n\n    // If a pattern is provided assign it to the state\n\n    var pattern = $attrs.blockUiPattern;\n\n    if (pattern) {\n      var regExp = blockUIUtils.buildRegExp(pattern);\n      srvInstance.pattern(regExp);\n    }\n\n    // Store a reference to the service instance on the element\n\n    $element.data('block-ui', srvInstance);\n\n  };\n\n}]);\n//.factory('blockUiPostLinkFn', function(blockUIUtils) {\n//\n//  return function($scope, $element, $attrs) {\n//\n//    var $message;\n//\n//    $attrs.$observe('blockUiMessageClass', function(value) {\n//\n//      $message = $message || blockUIUtils.findElement($element, function($e) {\n//        return $e.hasClass('block-ui-message');\n//      });\n//\n//      $message.addClass(value);\n//\n//    });\n//  };\n//\n//});\nblkUI.constant('blockUIConfig', {\n    templateUrl: 'angular-block-ui/angular-block-ui.ng.html',\n    delay: 250,\n    message: \"Loading ...\",\n    autoBlock: true,\n    resetOnException: true,\n    requestFilter: angular.noop,\n    autoInjectBodyBlock: true,\n    cssClass: 'block-ui block-ui-anim-fade',\n    blockBrowserNavigation: false\n});\n\n\nblkUI.factory('blockUIHttpInterceptor', [\"$q\", \"$injector\", \"blockUIConfig\", \"$templateCache\", function($q, $injector, blockUIConfig, $templateCache) {\n\n  var blockUI;\n\n  function injectBlockUI() {\n    blockUI = blockUI || $injector.get('blockUI');\n  }\n\n  function stopBlockUI(config) {\n    if (blockUIConfig.autoBlock && (config && !config.$_noBlock && config.$_blocks)) {\n      injectBlockUI();\n      config.$_blocks.stop();\n    }\n  }\n\n  function error(rejection) {\n\n    try {\n      stopBlockUI(rejection.config);\n    } catch(ex) {\n      console.log('httpRequestError', ex);\n    }\n\n    return $q.reject(rejection);\n  }\n\n  return {\n    request: function(config) {\n\n      // Only block when autoBlock is enabled ...\n      // ... and the request doesn't match a cached template.\n\n      if (blockUIConfig.autoBlock &&\n        !(config.method == 'GET' && $templateCache.get(config.url))) {\n\n        // Don't block excluded requests\n\n        var result = blockUIConfig.requestFilter(config);\n\n        if (result === false) {\n          // Tag the config so we don't unblock this request\n          config.$_noBlock = true;\n        } else {\n\n          injectBlockUI();\n\n          config.$_blocks = blockUI.instances.locate(config);\n          config.$_blocks.start(result);\n        }\n      }\n\n      return config;\n    },\n\n    requestError: error,\n\n    response: function(response) {\n\n      // If the connection to the website goes down the response interceptor gets and error with \"cannot read property config of null\".\n      // https://github.com/McNull/angular-block-ui/issues/53\n\n      if(response) {\n        stopBlockUI(response.config);\n      }\n\n      return response;\n    },\n\n    responseError: error\n  };\n\n}]);\n\nblkUI.factory('blockUI', [\"blockUIConfig\", \"$timeout\", \"blockUIUtils\", \"$document\", function(blockUIConfig, $timeout, blockUIUtils, $document) {\n\n  var $body = $document.find('body');\n\n  function BlockUI(id) {\n\n    var self = this;\n\n    var state = {\n      id: id,\n      blockCount: 0,\n      message: blockUIConfig.message,\n      blocking: false\n    }, startPromise, doneCallbacks = [];\n\n    this._id = id;\n\n    this._refs = 0;\n\n    this.start = function(message) {\n\n      if(state.blockCount > 0) {\n        message = message || state.message || blockUIConfig.message;\n      } else {\n        message = message || blockUIConfig.message;\n      }\n\n      state.message = message;\n\n      state.blockCount++;\n\n      // Check if the focused element is part of the block scope\n\n      var $ae = angular.element($document[0].activeElement);\n\n      if($ae.length && blockUIUtils.isElementInBlockScope($ae, self)) {\n\n        // Let the active element lose focus and store a reference \n        // to restore focus when we're done (reset)\n\n        self._restoreFocus = $ae[0];\n\n        // https://github.com/McNull/angular-block-ui/issues/13\n        // http://stackoverflow.com/questions/22698058/apply-already-in-progress-error-when-using-typeahead-plugin-found-to-be-relate\n        // Queue the blur after any ng-blur expression.\n\n        $timeout(function() {\n          // Ensure we still need to blur\n          if(self._restoreFocus) {\n            self._restoreFocus.blur();\n          }\n        });\n      }\n\n      if (!startPromise) {\n        startPromise = $timeout(function() {\n          startPromise = null;\n          state.blocking = true;\n        }, blockUIConfig.delay);\n      }\n    };\n\n    this._cancelStartTimeout = function() {\n      if (startPromise) {\n        $timeout.cancel(startPromise);\n        startPromise = null;\n      }\n    };\n\n    this.stop = function() {\n      state.blockCount = Math.max(0, --state.blockCount);\n\n      if (state.blockCount === 0) {\n        self.reset(true);\n      }\n    };\n\n    this.message = function(value) {\n      state.message = value;\n    };\n\n    this.pattern = function(regexp) {\n      if (regexp !== undefined) {\n        self._pattern = regexp;\n      }\n\n      return self._pattern;\n    };\n\n    this.reset = function(executeCallbacks) {\n      \n      self._cancelStartTimeout();\n      state.blockCount = 0;\n      state.blocking = false;\n\n      // Restore the focus to the element that was active\n      // before the block start, but not if the user has \n      // focused something else while the block was active.\n\n      if(self._restoreFocus && \n         (!$document[0].activeElement || $document[0].activeElement === $body[0])) {\n        self._restoreFocus.focus();\n        self._restoreFocus = null;\n      }\n      \n      try {\n        if (executeCallbacks) {\n          angular.forEach(doneCallbacks, function(cb) {\n            cb();\n          });\n        }\n      } finally {\n        doneCallbacks.length = 0;\n      }\n    };\n\n    this.done = function(fn) {\n      doneCallbacks.push(fn);\n    };\n\n    this.state = function() {\n      return state;\n    };\n\n    this.addRef = function() {\n      self._refs += 1;\n    };\n\n    this.release = function() {\n      if(--self._refs <= 0) {\n        mainBlock.instances._destroy(self);\n      }\n    };\n  }\n\n  var instances = [];\n\n  instances.get = function(id) {\n\n    if(!isNaN(id)) {\n      throw new Error('BlockUI id cannot be a number');\n    }\n\n    var instance = instances[id];\n\n    if(!instance) {\n      // TODO: ensure no array instance trashing [xxx] -- current workaround: '_' + $scope.$id\n      instance = instances[id] = new BlockUI(id);\n      instances.push(instance);\n    }\n\n    return instance;\n  };\n\n  instances._destroy = function(idOrInstance) {\n    if (angular.isString(idOrInstance)) {\n      idOrInstance = instances[idOrInstance];\n    }\n\n    if (idOrInstance) {\n      idOrInstance.reset();\n\n      var i = blockUIUtils.indexOf(instances, idOrInstance);\n      instances.splice(i, 1);\n\n      delete instances[idOrInstance.state().id];\n    }\n  };\n  \n  instances.locate = function(request) {\n\n    var result = [];\n\n    // Add function wrappers that will be executed on every item\n    // in the array.\n    \n    blockUIUtils.forEachFnHook(result, 'start');\n    blockUIUtils.forEachFnHook(result, 'stop');\n\n    var i = instances.length;\n\n    while(i--) {\n      var instance = instances[i];\n      var pattern = instance._pattern;\n\n      if(pattern && pattern.test(request.url)) {\n        result.push(instance);\n      }\n    }\n\n    if(result.length === 0) {\n      result.push(mainBlock);\n    }\n\n    return result;\n  };\n\n  // Propagate the reset to all instances\n\n  blockUIUtils.forEachFnHook(instances, 'reset');\n\n  var mainBlock = instances.get('main');\n\n  mainBlock.addRef();\n  mainBlock.instances = instances;\n\n  return mainBlock;\n}]);\n\n\nblkUI.factory('blockUIUtils', function() {\n\n  var $ = angular.element;\n\n  var utils = {\n    buildRegExp: function(pattern) {\n      var match = pattern.match(/^\\/(.*)\\/([gim]*)$/), regExp;\n\n      if(match) {\n        regExp = new RegExp(match[1], match[2]);\n      } else {\n        throw Error('Incorrect regular expression format: ' + pattern);\n      }\n\n      return regExp;\n    },\n    forEachFn: function(arr, fnName, args) {\n      var i = arr.length;\n      while(i--) {\n        var t = arr[i];\n        t[fnName].apply(t, args);\n      }\n    },\n    forEachFnHook: function(arr, fnName) {\n      arr[fnName] = function() {\n        utils.forEachFn(this, fnName, arguments);\n      }\n    },\n    isElementInBlockScope: function($element, blockScope) {\n      var c = $element.inheritedData('block-ui');\n\n      while(c) {\n        if(c === blockScope) {\n          return true;\n        }\n\n        c = c._parent;\n      }\n\n      return false;\n    },\n    findElement: function ($element, predicateFn, traverse) {\n      var ret = null;\n\n      if (predicateFn($element)) {\n        ret = $element;\n      } else {\n\n        var $elements;\n\n        if (traverse) {\n          $elements = $element.parent();\n        } else {\n          $elements = $element.children();\n        }\n\n        var i = $elements.length;\n        while (!ret && i--) {\n          ret = utils.findElement($($elements[i]), predicateFn, traverse);\n        }\n      }\n\n      return ret;\n    },\n    indexOf: function(arr, obj, start) {\n//      if(Array.prototype.indexOf) {\n//        return arr.indexOf(obj, start);\n//      }\n\n      for (var i = (start || 0), j = arr.length; i < j; i++) {\n        if (arr[i] === obj) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  };\n\n  return utils;\n\n});\n// Automatically generated.\n// This file is already embedded in your main javascript output, there's no need to include this file\n// manually in the index.html. This file is only here for your debugging pleasures.\nangular.module('blockUI').run(['$templateCache', function($templateCache){\n  $templateCache.put('angular-block-ui/angular-block-ui.ng.html', '<div class=\\\"block-ui-overlay\\\"></div><div class=\\\"block-ui-message-container\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\"><div class=\\\"block-ui-message\\\" ng-class=\\\"$_blockUiMessageClass\\\">{{ state.message }}</div></div>');\n}]);\n})(angular);\nif (typeof module !== \"undefined\") module.exports = \"blockUI\";\n\n\n},{}],36:[function(require,module,exports){\nvar css = \"/*!\\n   angular-block-ui v0.2.0\\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\\n   License: MIT\\n*/\\n.block-ui {\\n  position: relative;\\n}\\nbody.block-ui {\\n  position: static;\\n}\\n.block-ui-main>.block-ui-container,\\nbody.block-ui>.block-ui-container {\\n  position: fixed;\\n}\\n.block-ui-container {\\n  position: absolute;\\n  z-index: 10000;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n  height: 0;\\n  overflow: hidden;\\n  opacity: 0;\\n  filter: alpha(opacity=00);\\n}\\n.block-ui-active>.block-ui-container {\\n  height: 100%;\\n  cursor: wait;\\n}\\n.block-ui-active .block-ui-active>.block-ui-container {\\n  height: 0;\\n}\\n.block-ui-visible>.block-ui-container {\\n  opacity: 1;\\n  filter: alpha(opacity=100);\\n}\\n.block-ui-overlay {\\n  width: 100%;\\n  height: 100%;\\n  opacity: .5;\\n  filter: alpha(opacity=50);\\n  background-color: #fff;\\n}\\n.block-ui-message-container {\\n  position: absolute;\\n  top: 35%;\\n  left: 0;\\n  right: 0;\\n  height: 0;\\n  text-align: center;\\n  z-index: 10001;\\n}\\n.block-ui-message {\\n  display: inline-block;\\n  text-align: left;\\n  background-color: #333;\\n  color: #f5f5f5;\\n  padding: 20px;\\n  border-radius: 4px;\\n  font-size: 20px;\\n  font-weight: 700;\\n  filter: alpha(opacity=100);\\n}\\n.block-ui-anim-fade>.block-ui-container {\\n  -webkit-transition: height 0s linear 200ms,opacity 200ms ease 0s;\\n  transition: height 0s linear 200ms,opacity 200ms ease 0s;\\n}\\n.block-ui-anim-fade.block-ui-active>.block-ui-container {\\n  -webkit-transition-delay: 0s;\\n  transition-delay: 0s;\\n}\\n\"; (require(\"browserify-css\").createStyle(css, { \"href\": \"node_modules\\\\angular-block-ui\\\\dist\\\\angular-block-ui.min.css\"})); module.exports = css;\n},{\"browserify-css\":41}],37:[function(require,module,exports){\n/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $sanitizeMinErr = angular.$$minErr('$sanitize');\n\n/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n\n/*\n * HTML Parser By Misko Hevery (misko@hevery.com)\n * based on:  HTML Parser By John Resig (ejohn.org)\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n *\n * // Use like so:\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n */\n\n\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string, however, since our parser is more strict than a typical browser\n *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a\n *   browser, won't make it through the sanitizer. The input may also contain SVG markup.\n *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and\n *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getInnerHtml()).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\nfunction $SanitizeProvider() {\n  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n    return function(html) {\n      var buf = [];\n      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n        return !/^unsafe/.test($$sanitizeUri(uri, isImage));\n      }));\n      return buf.join('');\n    };\n  }];\n}\n\nfunction sanitizeText(chars) {\n  var buf = [];\n  var writer = htmlSanitizeWriter(buf, angular.noop);\n  writer.chars(chars);\n  return buf.join('');\n}\n\n\n// Regular Expressions for parsing tags and attributes\nvar START_TAG_REGEXP =\n       /^<((?:[a-zA-Z])[\\w:-]*)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)\\s*(>?)/,\n  END_TAG_REGEXP = /^<\\/\\s*([\\w:-]+)[^>]*>/,\n  ATTR_REGEXP = /([\\w:-]+)(?:\\s*=\\s*(?:(?:\"((?:[^\"])*)\")|(?:'((?:[^'])*)')|([^>\\s]+)))?/g,\n  BEGIN_TAG_REGEXP = /^</,\n  BEGING_END_TAGE_REGEXP = /^<\\//,\n  COMMENT_REGEXP = /<!--(.*?)-->/g,\n  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,\n  CDATA_REGEXP = /<!\\[CDATA\\[(.*?)]]>/g,\n  SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n  // Match everything outside of normal chars and \" (quote character)\n  NON_ALPHANUMERIC_REGEXP = /([^\\#-~| |!])/g;\n\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\nvar voidElements = makeMap(\"area,br,col,hr,img,wbr\");\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\nvar optionalEndTagBlockElements = makeMap(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),\n    optionalEndTagInlineElements = makeMap(\"rp,rt\"),\n    optionalEndTagElements = angular.extend({},\n                                            optionalEndTagInlineElements,\n                                            optionalEndTagBlockElements);\n\n// Safe Block Elements - HTML5\nvar blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap(\"address,article,\" +\n        \"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,\" +\n        \"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul\"));\n\n// Inline Elements - HTML5\nvar inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap(\"a,abbr,acronym,b,\" +\n        \"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,\" +\n        \"samp,small,span,strike,strong,sub,sup,time,tt,u,var\"));\n\n// SVG Elements\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n// They can potentially allow for arbitrary javascript to be executed. See #11290\nvar svgElements = makeMap(\"circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,\" +\n        \"hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,\" +\n        \"radialGradient,rect,stop,svg,switch,text,title,tspan,use\");\n\n// Special Elements (can contain anything)\nvar specialElements = makeMap(\"script,style\");\n\nvar validElements = angular.extend({},\n                                   voidElements,\n                                   blockElements,\n                                   inlineElements,\n                                   optionalEndTagElements,\n                                   svgElements);\n\n//Attributes that have href and hence need to be sanitized\nvar uriAttrs = makeMap(\"background,cite,href,longdesc,src,usemap,xlink:href\");\n\nvar htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n    'valign,value,vspace,width');\n\n// SVG attributes (without \"id\" and \"name\" attributes)\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\nvar svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +\n    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\nvar validAttrs = angular.extend({},\n                                uriAttrs,\n                                svgAttrs,\n                                htmlAttrs);\n\nfunction makeMap(str, lowercaseKeys) {\n  var obj = {}, items = str.split(','), i;\n  for (i = 0; i < items.length; i++) {\n    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;\n  }\n  return obj;\n}\n\n\n/**\n * @example\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n * @param {string} html string\n * @param {object} handler\n */\nfunction htmlParser(html, handler) {\n  if (typeof html !== 'string') {\n    if (html === null || typeof html === 'undefined') {\n      html = '';\n    } else {\n      html = '' + html;\n    }\n  }\n  var index, chars, match, stack = [], last = html, text;\n  stack.last = function() { return stack[stack.length - 1]; };\n\n  while (html) {\n    text = '';\n    chars = true;\n\n    // Make sure we're not in a script or style element\n    if (!stack.last() || !specialElements[stack.last()]) {\n\n      // Comment\n      if (html.indexOf(\"<!--\") === 0) {\n        // comments containing -- are not allowed unless they terminate the comment\n        index = html.indexOf(\"--\", 4);\n\n        if (index >= 0 && html.lastIndexOf(\"-->\", index) === index) {\n          if (handler.comment) handler.comment(html.substring(4, index));\n          html = html.substring(index + 3);\n          chars = false;\n        }\n      // DOCTYPE\n      } else if (DOCTYPE_REGEXP.test(html)) {\n        match = html.match(DOCTYPE_REGEXP);\n\n        if (match) {\n          html = html.replace(match[0], '');\n          chars = false;\n        }\n      // end tag\n      } else if (BEGING_END_TAGE_REGEXP.test(html)) {\n        match = html.match(END_TAG_REGEXP);\n\n        if (match) {\n          html = html.substring(match[0].length);\n          match[0].replace(END_TAG_REGEXP, parseEndTag);\n          chars = false;\n        }\n\n      // start tag\n      } else if (BEGIN_TAG_REGEXP.test(html)) {\n        match = html.match(START_TAG_REGEXP);\n\n        if (match) {\n          // We only have a valid start-tag if there is a '>'.\n          if (match[4]) {\n            html = html.substring(match[0].length);\n            match[0].replace(START_TAG_REGEXP, parseStartTag);\n          }\n          chars = false;\n        } else {\n          // no ending tag found --- this piece should be encoded as an entity.\n          text += '<';\n          html = html.substring(1);\n        }\n      }\n\n      if (chars) {\n        index = html.indexOf(\"<\");\n\n        text += index < 0 ? html : html.substring(0, index);\n        html = index < 0 ? \"\" : html.substring(index);\n\n        if (handler.chars) handler.chars(decodeEntities(text));\n      }\n\n    } else {\n      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\\W\\w].\n      html = html.replace(new RegExp(\"([\\\\W\\\\w]*)<\\\\s*\\\\/\\\\s*\" + stack.last() + \"[^>]*>\", 'i'),\n        function(all, text) {\n          text = text.replace(COMMENT_REGEXP, \"$1\").replace(CDATA_REGEXP, \"$1\");\n\n          if (handler.chars) handler.chars(decodeEntities(text));\n\n          return \"\";\n      });\n\n      parseEndTag(\"\", stack.last());\n    }\n\n    if (html == last) {\n      throw $sanitizeMinErr('badparse', \"The sanitizer was unable to parse the following block \" +\n                                        \"of html: {0}\", html);\n    }\n    last = html;\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function parseStartTag(tag, tagName, rest, unary) {\n    tagName = angular.lowercase(tagName);\n    if (blockElements[tagName]) {\n      while (stack.last() && inlineElements[stack.last()]) {\n        parseEndTag(\"\", stack.last());\n      }\n    }\n\n    if (optionalEndTagElements[tagName] && stack.last() == tagName) {\n      parseEndTag(\"\", tagName);\n    }\n\n    unary = voidElements[tagName] || !!unary;\n\n    if (!unary) {\n      stack.push(tagName);\n    }\n\n    var attrs = {};\n\n    rest.replace(ATTR_REGEXP,\n      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {\n        var value = doubleQuotedValue\n          || singleQuotedValue\n          || unquotedValue\n          || '';\n\n        attrs[name] = decodeEntities(value);\n    });\n    if (handler.start) handler.start(tagName, attrs, unary);\n  }\n\n  function parseEndTag(tag, tagName) {\n    var pos = 0, i;\n    tagName = angular.lowercase(tagName);\n    if (tagName) {\n      // Find the closest opened tag of the same type\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos] == tagName) break;\n      }\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (i = stack.length - 1; i >= pos; i--)\n        if (handler.end) handler.end(stack[i]);\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n    }\n  }\n}\n\nvar hiddenPre=document.createElement(\"pre\");\n/**\n * decodes all entities into regular string\n * @param value\n * @returns {string} A string with decoded entities.\n */\nfunction decodeEntities(value) {\n  if (!value) { return ''; }\n\n  hiddenPre.innerHTML = value.replace(/</g,\"&lt;\");\n  // innerText depends on styling as it doesn't display hidden elements.\n  // Therefore, it's better to use textContent not to cause unnecessary reflows.\n  return hiddenPre.textContent;\n}\n\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n * @returns {string} escaped text\n */\nfunction encodeEntities(value) {\n  return value.\n    replace(/&/g, '&amp;').\n    replace(SURROGATE_PAIR_REGEXP, function(value) {\n      var hi = value.charCodeAt(0);\n      var low = value.charCodeAt(1);\n      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n    }).\n    replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n      return '&#' + value.charCodeAt(0) + ';';\n    }).\n    replace(/</g, '&lt;').\n    replace(/>/g, '&gt;');\n}\n\n/**\n * create an HTML/XML writer which writes to buffer\n * @param {Array} buf use buf.jain('') to get out sanitized html string\n * @returns {object} in the form of {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * }\n */\nfunction htmlSanitizeWriter(buf, uriValidator) {\n  var ignore = false;\n  var out = angular.bind(buf, buf.push);\n  return {\n    start: function(tag, attrs, unary) {\n      tag = angular.lowercase(tag);\n      if (!ignore && specialElements[tag]) {\n        ignore = tag;\n      }\n      if (!ignore && validElements[tag] === true) {\n        out('<');\n        out(tag);\n        angular.forEach(attrs, function(value, key) {\n          var lkey=angular.lowercase(key);\n          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n          if (validAttrs[lkey] === true &&\n            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n            out(' ');\n            out(key);\n            out('=\"');\n            out(encodeEntities(value));\n            out('\"');\n          }\n        });\n        out(unary ? '/>' : '>');\n      }\n    },\n    end: function(tag) {\n        tag = angular.lowercase(tag);\n        if (!ignore && validElements[tag] === true) {\n          out('</');\n          out(tag);\n          out('>');\n        }\n        if (tag == ignore) {\n          ignore = false;\n        }\n      },\n    chars: function(chars) {\n        if (!ignore) {\n          out(encodeEntities(chars));\n        }\n      }\n  };\n}\n\n\n// define ngSanitize module and register $sanitize service\nangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n/* global sanitizeText: false */\n\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.\n * @returns {string} Html-linkified text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n       <script>\n         angular.module('linkyExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', function($scope) {\n             $scope.snippet =\n               'Pretty text with some links:\\n'+\n               'http://angularjs.org/,\\n'+\n               'mailto:us@somewhere.org,\\n'+\n               'another@somewhere.org,\\n'+\n               'and one more: ftp://127.0.0.1/.';\n             $scope.snippetWithTarget = 'http://angularjs.org/';\n           }]);\n       </script>\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Filter</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithTarget | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n     </file>\n   </example>\n */\nangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n  var LINKY_URL_REGEXP =\n        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n      MAILTO_REGEXP = /^mailto:/i;\n\n  return function(text, target) {\n    if (!text) return text;\n    var match;\n    var raw = text;\n    var html = [];\n    var url;\n    var i;\n    while ((match = raw.match(LINKY_URL_REGEXP))) {\n      // We can not end in these as they are sometimes found at the end of the sentence\n      url = match[0];\n      // if we did not match ftp/http/www/mailto then assume mailto\n      if (!match[2] && !match[4]) {\n        url = (match[3] ? 'http://' : 'mailto:') + url;\n      }\n      i = match.index;\n      addText(raw.substr(0, i));\n      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n      raw = raw.substring(i + match[0].length);\n    }\n    addText(raw);\n    return $sanitize(html.join(''));\n\n    function addText(text) {\n      if (!text) {\n        return;\n      }\n      html.push(sanitizeText(text));\n    }\n\n    function addLink(url, text) {\n      html.push('<a ');\n      if (angular.isDefined(target)) {\n        html.push('target=\"',\n                  target,\n                  '\" ');\n      }\n      html.push('href=\"',\n                url.replace(/\"/g, '&quot;'),\n                '\">');\n      addText(text);\n      html.push('</a>');\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n\n},{}],38:[function(require,module,exports){\nrequire('./angular-sanitize');\nmodule.exports = 'ngSanitize';\n\n},{\"./angular-sanitize\":37}],39:[function(require,module,exports){\n/*!\n * angular-translate - v2.10.0 - 2016-02-28\n * \n * Copyright (c) 2016 The angular-translate team, Pascal Precht; Licensed MIT\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define([], function () {\n      return (factory());\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    factory();\n  }\n}(this, function () {\n\n/**\n * @ngdoc overview\n * @name pascalprecht.translate\n *\n * @description\n * The main module which holds everything together.\n */\nangular.module('pascalprecht.translate', ['ng'])\n  .run(runTranslate);\n\nfunction runTranslate($translate) {\n\n  'use strict';\n\n  var key = $translate.storageKey(),\n    storage = $translate.storage();\n\n  var fallbackFromIncorrectStorageValue = function () {\n    var preferred = $translate.preferredLanguage();\n    if (angular.isString(preferred)) {\n      $translate.use(preferred);\n      // $translate.use() will also remember the language.\n      // So, we don't need to call storage.put() here.\n    } else {\n      storage.put(key, $translate.use());\n    }\n  };\n\n  fallbackFromIncorrectStorageValue.displayName = 'fallbackFromIncorrectStorageValue';\n\n  if (storage) {\n    if (!storage.get(key)) {\n      fallbackFromIncorrectStorageValue();\n    } else {\n      $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);\n    }\n  } else if (angular.isString($translate.preferredLanguage())) {\n    $translate.use($translate.preferredLanguage());\n  }\n}\nrunTranslate.$inject = ['$translate'];\n\nrunTranslate.displayName = 'runTranslate';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateSanitizationProvider\n *\n * @description\n *\n * Configurations for $translateSanitization\n */\nangular.module('pascalprecht.translate').provider('$translateSanitization', $translateSanitizationProvider);\n\nfunction $translateSanitizationProvider () {\n\n  'use strict';\n\n  var $sanitize,\n      currentStrategy = null, // TODO change to either 'sanitize', 'escape' or ['sanitize', 'escapeParameters'] in 3.0.\n      hasConfiguredStrategy = false,\n      hasShownNoStrategyConfiguredWarning = false,\n      strategies;\n\n  /**\n   * Definition of a sanitization strategy function\n   * @callback StrategyFunction\n   * @param {string|object} value - value to be sanitized (either a string or an interpolated value map)\n   * @param {string} mode - either 'text' for a string (translation) or 'params' for the interpolated params\n   * @return {string|object}\n   */\n\n  /**\n   * @ngdoc property\n   * @name strategies\n   * @propertyOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Following strategies are built-in:\n   * <dl>\n   *   <dt>sanitize</dt>\n   *   <dd>Sanitizes HTML in the translation text using $sanitize</dd>\n   *   <dt>escape</dt>\n   *   <dd>Escapes HTML in the translation</dd>\n   *   <dt>sanitizeParameters</dt>\n   *   <dd>Sanitizes HTML in the values of the interpolation parameters using $sanitize</dd>\n   *   <dt>escapeParameters</dt>\n   *   <dd>Escapes HTML in the values of the interpolation parameters</dd>\n   *   <dt>escaped</dt>\n   *   <dd>Support legacy strategy name 'escaped' for backwards compatibility (will be removed in 3.0)</dd>\n   * </dl>\n   *\n   */\n\n  strategies = {\n    sanitize: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlSanitizeValue(value);\n      }\n      return value;\n    },\n    escape: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlEscapeValue(value);\n      }\n      return value;\n    },\n    sanitizeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlSanitizeValue);\n      }\n      return value;\n    },\n    escapeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlEscapeValue);\n      }\n      return value;\n    }\n  };\n  // Support legacy strategy name 'escaped' for backwards compatibility.\n  // TODO should be removed in 3.0\n  strategies.escaped = strategies.escapeParameters;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#addStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Adds a sanitization strategy to the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @param {StrategyFunction} strategyFunction - strategy function\n   * @returns {object} this\n   */\n  this.addStrategy = function (strategyName, strategyFunction) {\n    strategies[strategyName] = strategyFunction;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#removeStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Removes a sanitization strategy from the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @returns {object} this\n   */\n  this.removeStrategy = function (strategyName) {\n    delete strategies[strategyName];\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#useStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n   *\n   * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n   * @returns {object} this\n   */\n  this.useStrategy = function (strategy) {\n    hasConfiguredStrategy = true;\n    currentStrategy = strategy;\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translateSanitization\n   * @requires $injector\n   * @requires $log\n   *\n   * @description\n   * Sanitizes interpolation parameters and translated texts.\n   *\n   */\n  this.$get = ['$injector', '$log', function ($injector, $log) {\n\n    var cachedStrategyMap = {};\n\n    var applyStrategies = function (value, mode, selectedStrategies) {\n      angular.forEach(selectedStrategies, function (selectedStrategy) {\n        if (angular.isFunction(selectedStrategy)) {\n          value = selectedStrategy(value, mode);\n        } else if (angular.isFunction(strategies[selectedStrategy])) {\n          value = strategies[selectedStrategy](value, mode);\n        } else if (angular.isString(strategies[selectedStrategy])) {\n          if (!cachedStrategyMap[strategies[selectedStrategy]]) {\n            try {\n              cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);\n            } catch (e) {\n              cachedStrategyMap[strategies[selectedStrategy]] = function() {};\n              throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n            }\n          }\n          value = cachedStrategyMap[strategies[selectedStrategy]](value, mode);\n        } else {\n          throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n        }\n      });\n      return value;\n    };\n\n    // TODO: should be removed in 3.0\n    var showNoStrategyConfiguredWarning = function () {\n      if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {\n        $log.warn('pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.');\n        hasShownNoStrategyConfiguredWarning = true;\n      }\n    };\n\n    if ($injector.has('$sanitize')) {\n      $sanitize = $injector.get('$sanitize');\n    }\n\n    return {\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#useStrategy\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n       *\n       * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n       */\n      useStrategy: (function (self) {\n        return function (strategy) {\n          self.useStrategy(strategy);\n        };\n      })(this),\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#sanitize\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Sanitizes a value.\n       *\n       * @param {string|object} value The value which should be sanitized.\n       * @param {string} mode The current sanitization mode, either 'params' or 'text'.\n       * @param {string|StrategyFunction|array} [strategy] Optional custom strategy which should be used instead of the currently selected strategy.\n       * @returns {string|object} sanitized value\n       */\n      sanitize: function (value, mode, strategy) {\n        if (!currentStrategy) {\n          showNoStrategyConfiguredWarning();\n        }\n\n        if (arguments.length < 3) {\n          strategy = currentStrategy;\n        }\n\n        if (!strategy) {\n          return value;\n        }\n\n        var selectedStrategies = angular.isArray(strategy) ? strategy : [strategy];\n        return applyStrategies(value, mode, selectedStrategies);\n      }\n    };\n  }];\n\n  var htmlEscapeValue = function (value) {\n    var element = angular.element('<div></div>');\n    element.text(value); // not chainable, see #1044\n    return element.html();\n  };\n\n  var htmlSanitizeValue = function (value) {\n    if (!$sanitize) {\n      throw new Error('pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as \\'escape\\'.');\n    }\n    return $sanitize(value);\n  };\n\n  var mapInterpolationParameters = function (value, iteratee, stack) {\n    if (angular.isObject(value)) {\n      var result = angular.isArray(value) ? [] : {};\n\n      if (!stack) {\n        stack = [];\n      } else {\n        if (stack.indexOf(value) > -1) {\n          throw new Error('pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object');\n        }\n      }\n\n      stack.push(value);\n      angular.forEach(value, function (propertyValue, propertyKey) {\n        result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack);\n      });\n      stack.splice(-1, 1); // remove last\n\n      return result;\n    } else if (angular.isNumber(value)) {\n      return value;\n    } else {\n      return iteratee(value);\n    }\n  };\n}\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateProvider\n * @description\n *\n * $translateProvider allows developers to register translation-tables, asynchronous loaders\n * and similar to configure translation behavior directly inside of a module.\n *\n */\nangular.module('pascalprecht.translate')\n.constant('pascalprechtTranslateOverrider', {})\n.provider('$translate', $translate);\n\nfunction $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {\n\n  'use strict';\n\n  var $translationTable = {},\n      $preferredLanguage,\n      $availableLanguageKeys = [],\n      $languageKeyAliases,\n      $fallbackLanguage,\n      $fallbackWasString,\n      $uses,\n      $nextLang,\n      $storageFactory,\n      $storageKey = $STORAGE_KEY,\n      $storagePrefix,\n      $missingTranslationHandlerFactory,\n      $interpolationFactory,\n      $interpolatorFactories = [],\n      $loaderFactory,\n      $cloakClassName = 'translate-cloak',\n      $loaderOptions,\n      $notFoundIndicatorLeft,\n      $notFoundIndicatorRight,\n      $postCompilingEnabled = false,\n      $forceAsyncReloadEnabled = false,\n      $nestedObjectDelimeter = '.',\n      $isReady = false,\n      loaderCache,\n      directivePriority = 0,\n      statefulFilter = true,\n      uniformLanguageTagResolver = 'default',\n      languageTagResolver = {\n        'default': function (tag) {\n          return (tag || '').split('-').join('_');\n        },\n        java: function (tag) {\n          var temp = (tag || '').split('-').join('_');\n          var parts = temp.split('_');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '_' + parts[1].toUpperCase()) : temp;\n        },\n        bcp47: function (tag) {\n          var temp = (tag || '').split('_').join('-');\n          var parts = temp.split('-');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '-' + parts[1].toUpperCase()) : temp;\n        }\n      };\n\n  var version = '2.10.0';\n\n  // tries to determine the browsers language\n  var getFirstBrowserLanguage = function () {\n\n    // internal purpose only\n    if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {\n      return pascalprechtTranslateOverrider.getLocale();\n    }\n\n    var nav = $windowProvider.$get().navigator,\n        browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],\n        i,\n        language;\n\n    // support for HTML 5.1 \"navigator.languages\"\n    if (angular.isArray(nav.languages)) {\n      for (i = 0; i < nav.languages.length; i++) {\n        language = nav.languages[i];\n        if (language && language.length) {\n          return language;\n        }\n      }\n    }\n\n    // support for other well known properties in browsers\n    for (i = 0; i < browserLanguagePropertyKeys.length; i++) {\n      language = nav[browserLanguagePropertyKeys[i]];\n      if (language && language.length) {\n        return language;\n      }\n    }\n\n    return null;\n  };\n  getFirstBrowserLanguage.displayName = 'angular-translate/service: getFirstBrowserLanguage';\n\n  // tries to determine the browsers locale\n  var getLocale = function () {\n    var locale = getFirstBrowserLanguage() || '';\n    if (languageTagResolver[uniformLanguageTagResolver]) {\n      locale = languageTagResolver[uniformLanguageTagResolver](locale);\n    }\n    return locale;\n  };\n  getLocale.displayName = 'angular-translate/service: getLocale';\n\n  /**\n   * @name indexOf\n   * @private\n   *\n   * @description\n   * indexOf polyfill. Kinda sorta.\n   *\n   * @param {array} array Array to search in.\n   * @param {string} searchElement Element to search for.\n   *\n   * @returns {int} Index of search element.\n   */\n  var indexOf = function(array, searchElement) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === searchElement) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  var negotiateLocale = function (preferred) {\n    if(!preferred) {\n      return;\n    }\n\n    var avail = [],\n        locale = angular.lowercase(preferred),\n        i = 0,\n        n = $availableLanguageKeys.length;\n\n    for (; i < n; i++) {\n      avail.push(angular.lowercase($availableLanguageKeys[i]));\n    }\n\n    // Check for an exact match in our list of available keys\n    if (indexOf(avail, locale) > -1) {\n      return preferred;\n    }\n\n    if ($languageKeyAliases) {\n      var alias;\n      for (var langKeyAlias in $languageKeyAliases) {\n        var hasWildcardKey = false;\n        var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) &&\n          angular.lowercase(langKeyAlias) === angular.lowercase(preferred);\n\n        if (langKeyAlias.slice(-1) === '*') {\n          hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length-1);\n        }\n        if (hasExactKey || hasWildcardKey) {\n          alias = $languageKeyAliases[langKeyAlias];\n          if (indexOf(avail, angular.lowercase(alias)) > -1) {\n            return alias;\n          }\n        }\n      }\n    }\n\n    // Check for a language code without region\n    var parts = preferred.split('_');\n\n    if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {\n      return parts[0];\n    }\n\n    // If everything fails, return undefined.\n    return;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translations\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a new translation table for specific language key.\n   *\n   * To register a translation table for specific language, pass a defined language\n   * key as first parameter.\n   *\n   * <pre>\n   *  // register translation table for language: 'de_DE'\n   *  $translateProvider.translations('de_DE', {\n   *    'GREETING': 'Hallo Welt!'\n   *  });\n   *\n   *  // register another one\n   *  $translateProvider.translations('en_US', {\n   *    'GREETING': 'Hello world!'\n   *  });\n   * </pre>\n   *\n   * When registering multiple translation tables for for the same language key,\n   * the actual translation table gets extended. This allows you to define module\n   * specific translation which only get added, once a specific module is loaded in\n   * your app.\n   *\n   * Invoking this method with no arguments returns the translation table which was\n   * registered with no language key. Invoking it with a language key returns the\n   * related translation table.\n   *\n   * @param {string} key A language key.\n   * @param {object} translationTable A plain old JavaScript object that represents a translation table.\n   *\n   */\n  var translations = function (langKey, translationTable) {\n\n    if (!langKey && !translationTable) {\n      return $translationTable;\n    }\n\n    if (langKey && !translationTable) {\n      if (angular.isString(langKey)) {\n        return $translationTable[langKey];\n      }\n    } else {\n      if (!angular.isObject($translationTable[langKey])) {\n        $translationTable[langKey] = {};\n      }\n      angular.extend($translationTable[langKey], flatObject(translationTable));\n    }\n    return this;\n  };\n\n  this.translations = translations;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#cloakClassName\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the class name for `translate-cloak` directive.\n   * Default class name is `translate-cloak`.\n   *\n   * @param {string} name translate-cloak class name\n   */\n  this.cloakClassName = function (name) {\n    if (!name) {\n      return $cloakClassName;\n    }\n    $cloakClassName = name;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#nestedObjectDelimeter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the delimiter for namespaced translations.\n   * Default delimiter is `.`.\n   *\n   * @param {string} delimiter namespace separator\n   */\n  this.nestedObjectDelimeter = function (delimiter) {\n    if (!delimiter) {\n      return $nestedObjectDelimeter;\n    }\n    $nestedObjectDelimeter = delimiter;\n    return this;\n  };\n\n  /**\n   * @name flatObject\n   * @private\n   *\n   * @description\n   * Flats an object. This function is used to flatten given translation data with\n   * namespaces, so they are later accessible via dot notation.\n   */\n  var flatObject = function (data, path, result, prevKey) {\n    var key, keyWithPath, keyWithShortPath, val;\n\n    if (!path) {\n      path = [];\n    }\n    if (!result) {\n      result = {};\n    }\n    for (key in data) {\n      if (!Object.prototype.hasOwnProperty.call(data, key)) {\n        continue;\n      }\n      val = data[key];\n      if (angular.isObject(val)) {\n        flatObject(val, path.concat(key), result, key);\n      } else {\n        keyWithPath = path.length ? ('' + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key) : key;\n        if(path.length && key === prevKey){\n          // Create shortcut path (foo.bar == foo.bar.bar)\n          keyWithShortPath = '' + path.join($nestedObjectDelimeter);\n          // Link it to original path\n          result[keyWithShortPath] = '@:' + keyWithPath;\n        }\n        result[keyWithPath] = val;\n      }\n    }\n    return result;\n  };\n  flatObject.displayName = 'flatObject';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#addInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Adds interpolation services to angular-translate, so it can manage them.\n   *\n   * @param {object} factory Interpolation service factory\n   */\n  this.addInterpolation = function (factory) {\n    $interpolatorFactories.push(factory);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMessageFormatInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use interpolation functionality of messageformat.js.\n   * This is useful when having high level pluralization and gender selection.\n   */\n  this.useMessageFormatInterpolation = function () {\n    return this.useInterpolation('$translateMessageFormatInterpolation');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which interpolation style to use as default, application-wide.\n   * Simply pass a factory/service name. The interpolation service has to implement\n   * the correct interface.\n   *\n   * @param {string} factory Interpolation service name.\n   */\n  this.useInterpolation = function (factory) {\n    $interpolationFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useSanitizeStrategy\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Simply sets a sanitation strategy type.\n   *\n   * @param {string} value Strategy type.\n   */\n  this.useSanitizeValueStrategy = function (value) {\n    $translateSanitizationProvider.useStrategy(value);\n    return this;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#preferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use for translation\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **prefer**.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.preferredLanguage = function(langKey) {\n    if (langKey) {\n      setupPreferredLanguage(langKey);\n      return this;\n    }\n    return $preferredLanguage;\n  };\n  var setupPreferredLanguage = function (langKey) {\n    if (langKey) {\n      $preferredLanguage = langKey;\n    }\n    return $preferredLanguage;\n  };\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicator\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found. E.g. when\n   * setting the indicator as 'X' and one tries to translate a translation id\n   * called `NOT_FOUND`, this will result in `X NOT_FOUND X`.\n   *\n   * Internally this methods sets a left indicator and a right indicator using\n   * `$translateProvider.translationNotFoundIndicatorLeft()` and\n   * `$translateProvider.translationNotFoundIndicatorRight()`.\n   *\n   * **Note**: These methods automatically add a whitespace between the indicators\n   * and the translation id.\n   *\n   * @param {string} indicator An indicator, could be any string.\n   */\n  this.translationNotFoundIndicator = function (indicator) {\n    this.translationNotFoundIndicatorLeft(indicator);\n    this.translationNotFoundIndicatorRight(indicator);\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found left to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorLeft = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorLeft;\n    }\n    $notFoundIndicatorLeft = indicator;\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found right to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorRight = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorRight;\n    }\n    $notFoundIndicatorRight = indicator;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#fallbackLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use when missing translations\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **fallback**.\n   *\n   * @param {string||array} langKey A language key.\n   *\n   */\n  this.fallbackLanguage = function (langKey) {\n    fallbackStack(langKey);\n    return this;\n  };\n\n  var fallbackStack = function (langKey) {\n    if (langKey) {\n      if (angular.isString(langKey)) {\n        $fallbackWasString = true;\n        $fallbackLanguage = [ langKey ];\n      } else if (angular.isArray(langKey)) {\n        $fallbackWasString = false;\n        $fallbackLanguage = langKey;\n      }\n      if (angular.isString($preferredLanguage)  && indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n        $fallbackLanguage.push($preferredLanguage);\n      }\n\n      return this;\n    } else {\n      if ($fallbackWasString) {\n        return $fallbackLanguage[0];\n      } else {\n        return $fallbackLanguage;\n      }\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#use\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Set which translation table to use for translation by given language key. When\n   * trying to 'use' a language which isn't provided, it'll throw an error.\n   *\n   * You actually don't have to use this method since `$translateProvider#preferredLanguage`\n   * does the job too.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.use = function (langKey) {\n    if (langKey) {\n      if (!$translationTable[langKey] && (!$loaderFactory)) {\n        // only throw an error, when not loading translation data asynchronously\n        throw new Error('$translateProvider couldn\\'t find translationTable for langKey: \\'' + langKey + '\\'');\n      }\n      $uses = langKey;\n      return this;\n    }\n    return $uses;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storageKey\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which key must represent the choosed language by a user in the storage.\n   *\n   * @param {string} key A key for the storage.\n   */\n  var storageKey = function(key) {\n    if (!key) {\n      if ($storagePrefix) {\n        return $storagePrefix + $storageKey;\n      }\n      return $storageKey;\n    }\n    $storageKey = key;\n    return this;\n  };\n\n  this.storageKey = storageKey;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useUrlLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateUrlLoader` extension service as loader.\n   *\n   * @param {string} url Url\n   * @param {Object=} options Optional configuration object\n   */\n  this.useUrlLoader = function (url, options) {\n    return this.useLoader('$translateUrlLoader', angular.extend({ url: url }, options));\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStaticFilesLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateStaticFilesLoader` extension service as loader.\n   *\n   * @param {Object=} options Optional configuration object\n   */\n  this.useStaticFilesLoader = function (options) {\n    return this.useLoader('$translateStaticFilesLoader', options);\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use any other service as loader.\n   *\n   * @param {string} loaderFactory Factory name to use\n   * @param {Object=} options Optional configuration object\n   */\n  this.useLoader = function (loaderFactory, options) {\n    $loaderFactory = loaderFactory;\n    $loaderOptions = options || {};\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLocalStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateLocalStorage` service as storage layer.\n   *\n   */\n  this.useLocalStorage = function () {\n    return this.useStorage('$translateLocalStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useCookieStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateCookieStorage` service as storage layer.\n   */\n  this.useCookieStorage = function () {\n    return this.useStorage('$translateCookieStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use custom service as storage layer.\n   */\n  this.useStorage = function (storageFactory) {\n    $storageFactory = storageFactory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storagePrefix\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets prefix for storage key.\n   *\n   * @param {string} prefix Storage key prefix\n   */\n  this.storagePrefix = function (prefix) {\n    if (!prefix) {\n      return prefix;\n    }\n    $storagePrefix = prefix;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandlerLog\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use built-in log handler when trying to translate\n   * a translation Id which doesn't exist.\n   *\n   * This is actually a shortcut method for `useMissingTranslationHandler()`.\n   *\n   */\n  this.useMissingTranslationHandlerLog = function () {\n    return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandler\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Expects a factory name which later gets instantiated with `$injector`.\n   * This method can be used to tell angular-translate to use a custom\n   * missingTranslationHandler. Just build a factory which returns a function\n   * and expects a translation id as argument.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.useMissingTranslationHandler('customHandler');\n   *  });\n   *\n   *  app.factory('customHandler', function (dep1, dep2) {\n   *    return function (translationId) {\n   *      // something with translationId and dep1 and dep2\n   *    };\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.useMissingTranslationHandler = function (factory) {\n    $missingTranslationHandlerFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#usePostCompiling\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If post compiling is enabled, all translated values will be processed\n   * again with AngularJS' $compile.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.usePostCompiling(true);\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.usePostCompiling = function (value) {\n    $postCompilingEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#forceAsyncReload\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If force async reload is enabled, async loader will always be called\n   * even if $translationTable already contains the language key, adding\n   * possible new entries to the $translationTable.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.forceAsyncReload(true);\n   *  });\n   * </pre>\n   *\n   * @param {boolean} value - valid values are true or false\n   */\n  this.forceAsyncReload = function (value) {\n    $forceAsyncReloadEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#uniformLanguageTag\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which language tag should be used as a result when determining\n   * the current browser language.\n   *\n   * This setting must be set before invoking {@link pascalprecht.translate.$translateProvider#methods_determinePreferredLanguage determinePreferredLanguage()}.\n   *\n   * <pre>\n   * $translateProvider\n   *   .uniformLanguageTag('bcp47')\n   *   .determinePreferredLanguage()\n   * </pre>\n   *\n   * The resolver currently supports:\n   * * default\n   *     (traditionally: hyphens will be converted into underscores, i.e. en-US => en_US)\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_us\n   * * java\n   *     like default, but the second part will be always in uppercase\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_US\n   * * BCP 47 (RFC 4646 & 4647)\n   *     en-US => en-US\n   *     en_US => en-US\n   *     en-us => en-US\n   *\n   * See also:\n   * * http://en.wikipedia.org/wiki/IETF_language_tag\n   * * http://www.w3.org/International/core/langtags/\n   * * http://tools.ietf.org/html/bcp47\n   *\n   * @param {string|object} options - options (or standard)\n   * @param {string} options.standard - valid values are 'default', 'bcp47', 'java'\n   */\n  this.uniformLanguageTag = function (options) {\n\n    if (!options) {\n      options = {};\n    } else if (angular.isString(options)) {\n      options = {\n        standard: options\n      };\n    }\n\n    uniformLanguageTagResolver = options.standard;\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#determinePreferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to try to determine on its own which language key\n   * to set as preferred language. When `fn` is given, angular-translate uses it\n   * to determine a language key, otherwise it uses the built-in `getLocale()`\n   * method.\n   *\n   * The `getLocale()` returns a language key in the format `[lang]_[country]` or\n   * `[lang]` depending on what the browser provides.\n   *\n   * Use this method at your own risk, since not all browsers return a valid\n   * locale (see {@link pascalprecht.translate.$translateProvider#methods_uniformLanguageTag uniformLanguageTag()}).\n   *\n   * @param {Function=} fn Function to determine a browser's locale\n   */\n  this.determinePreferredLanguage = function (fn) {\n\n    var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();\n\n    if (!$availableLanguageKeys.length) {\n      $preferredLanguage = locale;\n    } else {\n      $preferredLanguage = negotiateLocale(locale) || locale;\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#registerAvailableLanguageKeys\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a set of language keys the app will work with. Use this method in\n   * combination with\n   * {@link pascalprecht.translate.$translateProvider#determinePreferredLanguage determinePreferredLanguage}.\n   * When available languages keys are registered, angular-translate\n   * tries to find the best fitting language key depending on the browsers locale,\n   * considering your language key convention.\n   *\n   * @param {object} languageKeys Array of language keys the your app will use\n   * @param {object=} aliases Alias map.\n   */\n  this.registerAvailableLanguageKeys = function (languageKeys, aliases) {\n    if (languageKeys) {\n      $availableLanguageKeys = languageKeys;\n      if (aliases) {\n        $languageKeyAliases = aliases;\n      }\n      return this;\n    }\n    return $availableLanguageKeys;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoaderCache\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a cache for internal $http based loaders.\n   * {@link pascalprecht.translate.$translationCache $translationCache}.\n   * When false the cache will be disabled (default). When true or undefined\n   * the cache will be a default (see $cacheFactory). When an object it will\n   * be treat as a cache object itself: the usage is $http({cache: cache})\n   *\n   * @param {object} cache boolean, string or cache-object\n   */\n  this.useLoaderCache = function (cache) {\n    if (cache === false) {\n      // disable cache\n      loaderCache = undefined;\n    } else if (cache === true) {\n      // enable cache using AJS defaults\n      loaderCache = true;\n    } else if (typeof(cache) === 'undefined') {\n      // enable cache using default\n      loaderCache = '$translationCache';\n    } else if (cache) {\n      // enable cache using given one (see $cacheFactory)\n      loaderCache = cache;\n    }\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#directivePriority\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets the default priority of the translate directive. The standard value is `0`.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {number} priority for the translate-directive\n   */\n  this.directivePriority = function (priority) {\n    if (priority === undefined) {\n      // getter\n      return directivePriority;\n    } else {\n      // setter with chaining\n      directivePriority = priority;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#statefulFilter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Since AngularJS 1.3, filters which are not stateless (depending at the scope)\n   * have to explicit define this behavior.\n   * Sets whether the translate filter should be stateful or stateless. The standard value is `true`\n   * meaning being stateful.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {boolean} state - defines the state of the filter\n   */\n  this.statefulFilter = function (state) {\n    if (state === undefined) {\n      // getter\n      return statefulFilter;\n    } else {\n      // setter with chaining\n      statefulFilter = state;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translate\n   * @requires $interpolate\n   * @requires $log\n   * @requires $rootScope\n   * @requires $q\n   *\n   * @description\n   * The `$translate` service is the actual core of angular-translate. It expects a translation id\n   * and optional interpolate parameters to translate contents.\n   *\n   * <pre>\n   *  $translate('HEADLINE_TEXT').then(function (translation) {\n   *    $scope.translatedText = translation;\n   *  });\n   * </pre>\n   *\n   * @param {string|array} translationId A token which represents a translation id\n   *                                     This can be optionally an array of translation ids which\n   *                                     results that the function returns an object where each key\n   *                                     is the translation id and the value the translation.\n   * @param {object=} interpolateParams An object hash for dynamic values\n   * @param {string} interpolationId The id of the interpolation to use\n   * @param {string} forceLanguage A language to be used instead of the current language\n   * @returns {object} promise\n   */\n  this.$get = [\n    '$log',\n    '$injector',\n    '$rootScope',\n    '$q',\n    function ($log, $injector, $rootScope, $q) {\n\n      var Storage,\n          defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),\n          pendingLoader = false,\n          interpolatorHashMap = {},\n          langPromises = {},\n          fallbackIndex,\n          startFallbackIteration;\n\n      var $translate = function (translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage) {\n\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          // Inspired by Q.allSettled by Kris Kowal\n          // https://github.com/kriskowal/q/blob/b0fa72980717dc202ffc3cbf03b936e10ebbb9d7/q.js#L1553-1563\n          // This transforms all promises regardless resolved or rejected\n          var translateAll = function (translationIds) {\n            var results = {}; // storing the actual results\n            var promises = []; // promises to wait for\n            // Wraps the promise a) being always resolved and b) storing the link id->value\n            var translate = function (translationId) {\n              var deferred = $q.defer();\n              var regardless = function (value) {\n                results[translationId] = value;\n                deferred.resolve([translationId, value]);\n              };\n              // we don't care whether the promise was resolved or rejected; just store the values\n              $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage).then(regardless, regardless);\n              return deferred.promise;\n            };\n            for (var i = 0, c = translationIds.length; i < c; i++) {\n              promises.push(translate(translationIds[i]));\n            }\n            // wait for all (including storing to results)\n            return $q.all(promises).then(function () {\n              // return the results\n              return results;\n            });\n          };\n          return translateAll(translationId);\n        }\n\n        var deferred = $q.defer();\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var promiseToWaitFor = (function () {\n          var promise = $preferredLanguage ?\n            langPromises[$preferredLanguage] :\n            langPromises[uses];\n\n          fallbackIndex = 0;\n\n          if ($storageFactory && !promise) {\n            // looks like there's no pending promise for $preferredLanguage or\n            // $uses. Maybe there's one pending for a language that comes from\n            // storage.\n            var langKey = Storage.get($storageKey);\n            promise = langPromises[langKey];\n\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n                var index = indexOf($fallbackLanguage, langKey);\n                // maybe the language from storage is also defined as fallback language\n                // we increase the fallback language index to not search in that language\n                // as fallback, since it's probably the first used language\n                // in that case the index starts after the first element\n                fallbackIndex = (index === 0) ? 1 : 0;\n\n                // but we can make sure to ALWAYS fallback to preferred language at least\n                if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n                  $fallbackLanguage.push($preferredLanguage);\n                }\n            }\n          }\n          return promise;\n        }());\n\n        if (!promiseToWaitFor) {\n          // no promise to wait for? okay. Then there's no loader registered\n          // nor is a one pending for language that comes from storage.\n          // We can just translate.\n          determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n        } else {\n          var promiseResolved = function () {\n            // $uses may have changed while waiting\n            if (!forceLanguage) {\n              uses = $uses;\n            }\n            determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n          };\n          promiseResolved.displayName = 'promiseResolved';\n\n          promiseToWaitFor['finally'](promiseResolved);\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name applyNotFoundIndicators\n       * @private\n       *\n       * @description\n       * Applies not fount indicators to given translation id, if needed.\n       * This function gets only executed, if a translation id doesn't exist,\n       * which is why a translation id is expected as argument.\n       *\n       * @param {string} translationId Translation id.\n       * @returns {string} Same as given translation id but applied with not found\n       * indicators.\n       */\n      var applyNotFoundIndicators = function (translationId) {\n        // applying notFoundIndicators\n        if ($notFoundIndicatorLeft) {\n          translationId = [$notFoundIndicatorLeft, translationId].join(' ');\n        }\n        if ($notFoundIndicatorRight) {\n          translationId = [translationId, $notFoundIndicatorRight].join(' ');\n        }\n        return translationId;\n      };\n\n      /**\n       * @name useLanguage\n       * @private\n       *\n       * @description\n       * Makes actual use of a language by setting a given language key as used\n       * language and informs registered interpolators to also use the given\n       * key as locale.\n       *\n       * @param {key} Locale key.\n       */\n      var useLanguage = function (key) {\n        $uses = key;\n\n        // make sure to store new language key before triggering success event\n        if ($storageFactory) {\n          Storage.put($translate.storageKey(), $uses);\n        }\n\n        $rootScope.$emit('$translateChangeSuccess', {language: key});\n\n        // inform default interpolator\n        defaultInterpolator.setLocale($uses);\n\n        var eachInterpolator = function (interpolator, id) {\n          interpolatorHashMap[id].setLocale($uses);\n        };\n        eachInterpolator.displayName = 'eachInterpolatorLocaleSetter';\n\n        // inform all others too!\n        angular.forEach(interpolatorHashMap, eachInterpolator);\n        $rootScope.$emit('$translateChangeEnd', {language: key});\n      };\n\n      /**\n       * @name loadAsync\n       * @private\n       *\n       * @description\n       * Kicks of registered async loader using `$injector` and applies existing\n       * loader options. When resolved, it updates translation tables accordingly\n       * or rejects with given language key.\n       *\n       * @param {string} key Language key.\n       * @return {Promise} A promise.\n       */\n      var loadAsync = function (key) {\n        if (!key) {\n          throw 'No language key specified for loading.';\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateLoadingStart', {language: key});\n        pendingLoader = true;\n\n        var cache = loaderCache;\n        if (typeof(cache) === 'string') {\n          // getting on-demand instance of loader\n          cache = $injector.get(cache);\n        }\n\n        var loaderOptions = angular.extend({}, $loaderOptions, {\n          key: key,\n          $http: angular.extend({}, {\n            cache: cache\n          }, $loaderOptions.$http)\n        });\n\n        var onLoaderSuccess = function (data) {\n          var translationTable = {};\n          $rootScope.$emit('$translateLoadingSuccess', {language: key});\n\n          if (angular.isArray(data)) {\n            angular.forEach(data, function (table) {\n              angular.extend(translationTable, flatObject(table));\n            });\n          } else {\n            angular.extend(translationTable, flatObject(data));\n          }\n          pendingLoader = false;\n          deferred.resolve({\n            key: key,\n            table: translationTable\n          });\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderSuccess.displayName = 'onLoaderSuccess';\n\n        var onLoaderError = function (key) {\n          $rootScope.$emit('$translateLoadingError', {language: key});\n          deferred.reject(key);\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderError.displayName = 'onLoaderError';\n\n        $injector.get($loaderFactory)(loaderOptions)\n          .then(onLoaderSuccess, onLoaderError);\n\n        return deferred.promise;\n      };\n\n      if ($storageFactory) {\n        Storage = $injector.get($storageFactory);\n\n        if (!Storage.get || !Storage.put) {\n          throw new Error('Couldn\\'t use storage \\'' + $storageFactory + '\\', missing get() or put() method!');\n        }\n      }\n\n      // if we have additional interpolations that were added via\n      // $translateProvider.addInterpolation(), we have to map'em\n      if ($interpolatorFactories.length) {\n        var eachInterpolationFactory = function (interpolatorFactory) {\n          var interpolator = $injector.get(interpolatorFactory);\n          // setting initial locale for each interpolation service\n          interpolator.setLocale($preferredLanguage || $uses);\n          // make'em recognizable through id\n          interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;\n        };\n        eachInterpolationFactory.displayName = 'interpolationFactoryAdder';\n\n        angular.forEach($interpolatorFactories, eachInterpolationFactory);\n      }\n\n      /**\n       * @name getTranslationTable\n       * @private\n       *\n       * @description\n       * Returns a promise that resolves to the translation table\n       * or is rejected if an error occurred.\n       *\n       * @param langKey\n       * @returns {Q.promise}\n       */\n      var getTranslationTable = function (langKey) {\n        var deferred = $q.defer();\n        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {\n          deferred.resolve($translationTable[langKey]);\n        } else if (langPromises[langKey]) {\n          var onResolve = function (data) {\n            translations(data.key, data.table);\n            deferred.resolve(data.table);\n          };\n          onResolve.displayName = 'translationTableResolver';\n          langPromises[langKey].then(onResolve, deferred.reject);\n        } else {\n          deferred.reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslation\n       * @private\n       *\n       * @description\n       * Returns a promise that will resolve to the translation\n       * or be rejected if no translation was found for the language.\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise}\n       */\n      var getFallbackTranslation = function (langKey, translationId, interpolateParams, Interpolator) {\n        var deferred = $q.defer();\n\n        var onResolve = function (translationTable) {\n          if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n            Interpolator.setLocale(langKey);\n            var translation = translationTable[translationId];\n            if (translation.substr(0, 2) === '@:') {\n              getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator)\n                .then(deferred.resolve, deferred.reject);\n            } else {\n              deferred.resolve(Interpolator.interpolate(translationTable[translationId], interpolateParams));\n            }\n            Interpolator.setLocale($uses);\n          } else {\n            deferred.reject();\n          }\n        };\n        onResolve.displayName = 'fallbackTranslationResolver';\n\n        getTranslationTable(langKey).then(onResolve, deferred.reject);\n\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslationInstant\n       * @private\n       *\n       * @description\n       * Returns a translation\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var getFallbackTranslationInstant = function (langKey, translationId, interpolateParams, Interpolator) {\n        var result, translationTable = $translationTable[langKey];\n\n        if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n          Interpolator.setLocale(langKey);\n          result = Interpolator.interpolate(translationTable[translationId], interpolateParams);\n          if (result.substr(0, 2) === '@:') {\n            return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);\n          }\n          Interpolator.setLocale($uses);\n        }\n\n        return result;\n      };\n\n\n      /**\n       * @name translateByHandler\n       * @private\n       *\n       * Translate by missing translation handler.\n       *\n       * @param translationId\n       * @returns translation created by $missingTranslationHandler or translationId is $missingTranslationHandler is\n       * absent\n       */\n      var translateByHandler = function (translationId, interpolateParams) {\n        // If we have a handler factory - we might also call it here to determine if it provides\n        // a default text for a translationid that can't be found anywhere in our tables\n        if ($missingTranslationHandlerFactory) {\n          var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams);\n          if (resultString !== undefined) {\n            return resultString;\n          } else {\n            return translationId;\n          }\n        } else {\n          return translationId;\n        }\n      };\n\n      /**\n       * @name resolveForFallbackLanguage\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise that will resolve to the translation.\n       */\n      var resolveForFallbackLanguage = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        var deferred = $q.defer();\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(\n            deferred.resolve,\n            function () {\n              // Look in the next fallback language for a translation.\n              // It delays the resolving by passing another promise to resolve.\n              resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve);\n            }\n          );\n        } else {\n          // No translation found in any fallback language\n          // if a default translation text is set in the directive, then return this as a result\n          if (defaultTranslationText) {\n            deferred.resolve(defaultTranslationText);\n          } else {\n            // if no default translation is set and an error handler is defined, send it to the handler\n            // and then return the result\n            deferred.resolve(translateByHandler(translationId, interpolateParams));\n          }\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name resolveForFallbackLanguageInstant\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var resolveForFallbackLanguageInstant = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {\n        var result;\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);\n          if (!result) {\n            result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);\n          }\n        }\n        return result;\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise, that resolves to the translation.\n       */\n      var fallbackTranslation = function (translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguage((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText);\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {String} translation\n       */\n      var fallbackTranslationInstant = function (translationId, interpolateParams, Interpolator) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguageInstant((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator);\n      };\n\n      var determineTranslation = function (translationId, interpolateParams, interpolationId, defaultTranslationText, uses) {\n\n        var deferred = $q.defer();\n\n        var table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n\n            $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses)\n              .then(deferred.resolve, deferred.reject);\n          } else {\n            deferred.resolve(Interpolator.interpolate(translation, interpolateParams));\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText)\n                .then(function (translation) {\n                  deferred.resolve(translation);\n                }, function (_translationId) {\n                  deferred.reject(applyNotFoundIndicators(_translationId));\n                });\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n              } else {\n                deferred.resolve(missingTranslationHandlerTranslation);\n              }\n          } else {\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n            } else {\n              deferred.reject(applyNotFoundIndicators(translationId));\n            }\n          }\n        }\n        return deferred.promise;\n      };\n\n      var determineTranslationInstant = function (translationId, interpolateParams, interpolationId, uses) {\n\n        var result, table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = defaultInterpolator;\n\n        // if the interpolation id exists use custom interpolator\n        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {\n          Interpolator = interpolatorHashMap[interpolationId];\n        }\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n            result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses);\n          } else {\n            result = Interpolator.interpolate(translation, interpolateParams);\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackIndex = 0;\n            result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            result = missingTranslationHandlerTranslation;\n          } else {\n            result = applyNotFoundIndicators(translationId);\n          }\n        }\n\n        return result;\n      };\n\n      var clearNextLangAndPromise = function(key) {\n        if ($nextLang === key) {\n          $nextLang = undefined;\n        }\n        langPromises[key] = undefined;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#preferredLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the preferred language.\n       *\n       * @param {string} langKey language String or Array to be used as preferredLanguage (changing at runtime)\n       *\n       * @return {string} preferred language key\n       */\n      $translate.preferredLanguage = function (langKey) {\n        if(langKey) {\n          setupPreferredLanguage(langKey);\n        }\n        return $preferredLanguage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#cloakClassName\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured class name for `translate-cloak` directive.\n       *\n       * @return {string} cloakClassName\n       */\n      $translate.cloakClassName = function () {\n        return $cloakClassName;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#nestedObjectDelimeter\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured delimiter for nested namespaces.\n       *\n       * @return {string} nestedObjectDelimeter\n       */\n      $translate.nestedObjectDelimeter = function () {\n        return $nestedObjectDelimeter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#fallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the fallback languages or sets a new fallback stack.\n       *\n       * @param {string=} langKey language String or Array of fallback languages to be used (to change stack at runtime)\n       *\n       * @return {string||array} fallback language key\n       */\n      $translate.fallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          fallbackStack(langKey);\n\n          // as we might have an async loader initiated and a new translation language might have been defined\n          // we need to add the promise to the stack also. So - iterate.\n          if ($loaderFactory) {\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n              for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n                if (!langPromises[$fallbackLanguage[i]]) {\n                  langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);\n                }\n              }\n            }\n          }\n          $translate.use($translate.use());\n        }\n        if ($fallbackWasString) {\n          return $fallbackLanguage[0];\n        } else {\n          return $fallbackLanguage;\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#useFallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Sets the first key of the fallback language stack to be used for translation.\n       * Therefore all languages in the fallback array BEFORE this key will be skipped!\n       *\n       * @param {string=} langKey Contains the langKey the iteration shall start with. Set to false if you want to\n       * get back to the whole stack\n       */\n      $translate.useFallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          if (!langKey) {\n            startFallbackIteration = 0;\n          } else {\n            var langKeyPosition = indexOf($fallbackLanguage, langKey);\n            if (langKeyPosition > -1) {\n              startFallbackIteration = langKeyPosition;\n            }\n          }\n\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#proposedLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key of language that is currently loaded asynchronously.\n       *\n       * @return {string} language key\n       */\n      $translate.proposedLanguage = function () {\n        return $nextLang;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns registered storage.\n       *\n       * @return {object} Storage\n       */\n      $translate.storage = function () {\n        return Storage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#negotiateLocale\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a language key based on available languages and language aliases. If a\n       * language key cannot be resolved, returns undefined.\n       *\n       * If no or a falsy key is given, returns undefined.\n       *\n       * @param {string} [key] Language key\n       * @return {string|undefined} Language key or undefined if no language key is found.\n       */\n      $translate.negotiateLocale = negotiateLocale;\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#use\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Tells angular-translate which language to use by given language key. This method is\n       * used to change language at runtime. It also takes care of storing the language\n       * key in a configured store to let your app remember the choosed language.\n       *\n       * When trying to 'use' a language which isn't available it tries to load it\n       * asynchronously with registered loaders.\n       *\n       * Returns promise object with loaded language file data or string of the currently used language.\n       *\n       * If no or a falsy key is given it returns the currently used language key.\n       * The returned string will be ```undefined``` if setting up $translate hasn't finished.\n       * @example\n       * $translate.use(\"en_US\").then(function(data){\n       *   $scope.text = $translate(\"HELLO\");\n       * });\n       *\n       * @param {string} [key] Language key\n       * @return {object|string} Promise with loaded language data or the language key if a falsy param was given.\n       */\n      $translate.use = function (key) {\n        if (!key) {\n          return $uses;\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateChangeStart', {language: key});\n\n        // Try to get the aliased language key\n        var aliasedKey = negotiateLocale(key);\n        if (aliasedKey) {\n          key = aliasedKey;\n        }\n\n        // if there isn't a translation table for the language we've requested,\n        // we load it asynchronously\n        $nextLang = key;\n        if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {\n          langPromises[key] = loadAsync(key).then(function (translation) {\n            translations(translation.key, translation.table);\n            deferred.resolve(translation.key);\n            if ($nextLang === key) {\n              useLanguage(translation.key);\n            }\n            return translation;\n          }, function (key) {\n            $rootScope.$emit('$translateChangeError', {language: key});\n            deferred.reject(key);\n            $rootScope.$emit('$translateChangeEnd', {language: key});\n            return $q.reject(key);\n          });\n          langPromises[key]['finally'](function () {\n            clearNextLangAndPromise(key);\n          });\n        } else if (langPromises[key]) {\n          // we are already loading this asynchronously\n          // resolve our new deferred when the old langPromise is resolved\n          langPromises[key].then(function (translation) {\n            if ($nextLang === translation.key) {\n              useLanguage(translation.key);\n            }\n            deferred.resolve(translation.key);\n            return translation;\n          }, function (key) {\n            // find first available fallback language if that request has failed\n            if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0) {\n              return $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);\n            } else {\n              return deferred.reject(key);\n            }\n          });\n        } else {\n          deferred.resolve(key);\n          useLanguage(key);\n        }\n\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storageKey\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the key for the storage.\n       *\n       * @return {string} storage key\n       */\n      $translate.storageKey = function () {\n        return storageKey();\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isPostCompilingEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether post compiling is enabled or not\n       *\n       * @return {bool} storage key\n       */\n      $translate.isPostCompilingEnabled = function () {\n        return $postCompilingEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isForceAsyncReloadEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether force async reload is enabled or not\n       *\n       * @return {boolean} forceAsyncReload value\n       */\n      $translate.isForceAsyncReloadEnabled = function () {\n        return $forceAsyncReloadEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#refresh\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Refreshes a translation table pointed by the given langKey. If langKey is not specified,\n       * the module will drop all existent translation tables and load new version of those which\n       * are currently in use.\n       *\n       * Refresh means that the module will drop target translation table and try to load it again.\n       *\n       * In case there are no loaders registered the refresh() method will throw an Error.\n       *\n       * If the module is able to refresh translation tables refresh() method will broadcast\n       * $translateRefreshStart and $translateRefreshEnd events.\n       *\n       * @example\n       * // this will drop all currently existent translation tables and reload those which are\n       * // currently in use\n       * $translate.refresh();\n       * // this will refresh a translation table for the en_US language\n       * $translate.refresh('en_US');\n       *\n       * @param {string} langKey A language key of the table, which has to be refreshed\n       *\n       * @return {promise} Promise, which will be resolved in case a translation tables refreshing\n       * process is finished successfully, and reject if not.\n       */\n      $translate.refresh = function (langKey) {\n        if (!$loaderFactory) {\n          throw new Error('Couldn\\'t refresh translation table, no loader registered!');\n        }\n\n        var deferred = $q.defer();\n\n        function resolve() {\n          deferred.resolve();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        function reject() {\n          deferred.reject();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        $rootScope.$emit('$translateRefreshStart', {language: langKey});\n\n        if (!langKey) {\n          // if there's no language key specified we refresh ALL THE THINGS!\n          var tables = [], loadingKeys = {};\n\n          // reload registered fallback languages\n          if ($fallbackLanguage && $fallbackLanguage.length) {\n            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n              tables.push(loadAsync($fallbackLanguage[i]));\n              loadingKeys[$fallbackLanguage[i]] = true;\n            }\n          }\n\n          // reload currently used language\n          if ($uses && !loadingKeys[$uses]) {\n            tables.push(loadAsync($uses));\n          }\n\n          var allTranslationsLoaded = function (tableData) {\n            $translationTable = {};\n            angular.forEach(tableData, function (data) {\n              translations(data.key, data.table);\n            });\n            if ($uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          allTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          $q.all(tables).then(allTranslationsLoaded, reject);\n\n        } else if ($translationTable[langKey]) {\n\n          var oneTranslationsLoaded = function (data) {\n            translations(data.key, data.table);\n            if (langKey === $uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          oneTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          loadAsync(langKey).then(oneTranslationsLoaded, reject);\n\n        } else {\n          reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#instant\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a translation instantly from the internal state of loaded translation. All rules\n       * regarding the current language, the preferred language of even fallback languages will be\n       * used except any promise handling. If a language was not found, an asynchronous loading\n       * will be invoked in the background.\n       *\n       * @param {string|array} translationId A token which represents a translation id\n       *                                     This can be optionally an array of translation ids which\n       *                                     results that the function's promise returns an object where\n       *                                     each key is the translation id and the value the translation.\n       * @param {object} interpolateParams Params\n       * @param {string} interpolationId The id of the interpolation to use\n       * @param {string} forceLanguage A language to be used instead of the current language\n       *\n       * @return {string|object} translation\n       */\n      $translate.instant = function (translationId, interpolateParams, interpolationId, forceLanguage) {\n\n        // we don't want to re-negotiate $uses\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Detect undefined and null values to shorten the execution and prevent exceptions\n        if (translationId === null || angular.isUndefined(translationId)) {\n          return translationId;\n        }\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          var results = {};\n          for (var i = 0, c = translationId.length; i < c; i++) {\n            results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage);\n          }\n          return results;\n        }\n\n        // We discarded unacceptable values. So we just need to verify if translationId is empty String\n        if (angular.isString(translationId) && translationId.length < 1) {\n          return translationId;\n        }\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var result, possibleLangKeys = [];\n        if ($preferredLanguage) {\n          possibleLangKeys.push($preferredLanguage);\n        }\n        if (uses) {\n          possibleLangKeys.push(uses);\n        }\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);\n        }\n        for (var j = 0, d = possibleLangKeys.length; j < d; j++) {\n          var possibleLangKey = possibleLangKeys[j];\n          if ($translationTable[possibleLangKey]) {\n            if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {\n              result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses);\n            }\n          }\n          if (typeof result !== 'undefined') {\n            break;\n          }\n        }\n\n        if (!result && result !== '') {\n          if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {\n            result = applyNotFoundIndicators(translationId);\n          } else {\n            // Return translation of default interpolator if not found anything.\n            result = defaultInterpolator.interpolate(translationId, interpolateParams);\n            if ($missingTranslationHandlerFactory && !pendingLoader) {\n              result = translateByHandler(translationId, interpolateParams);\n            }\n          }\n        }\n\n        return result;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#versionInfo\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the current version information for the angular-translate library\n       *\n       * @return {string} angular-translate version\n       */\n      $translate.versionInfo = function () {\n        return version;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#loaderCache\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the defined loaderCache.\n       *\n       * @return {boolean|string|object} current value of loaderCache\n       */\n      $translate.loaderCache = function () {\n        return loaderCache;\n      };\n\n      // internal purpose only\n      $translate.directivePriority = function () {\n        return directivePriority;\n      };\n\n      // internal purpose only\n      $translate.statefulFilter = function () {\n        return statefulFilter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_onReady onReady()}.\n       *\n       * @return {boolean} current value of ready\n       */\n      $translate.isReady = function () {\n        return $isReady;\n      };\n\n      var $onReadyDeferred = $q.defer();\n      $onReadyDeferred.promise.then(function () {\n        $isReady = true;\n      });\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#onReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_isReady isReady()}.\n       *\n       * @param {Function=} fn Function to invoke when service is ready\n       * @return {object} Promise resolved when service is ready\n       */\n      $translate.onReady = function (fn) {\n        var deferred = $q.defer();\n        if (angular.isFunction(fn)) {\n          deferred.promise.then(fn);\n        }\n        if ($isReady) {\n          deferred.resolve();\n        } else {\n          $onReadyDeferred.promise.then(deferred.resolve);\n        }\n        return deferred.promise;\n      };\n\n      // Whenever $translateReady is being fired, this will ensure the state of $isReady\n      var globalOnReadyListener = $rootScope.$on('$translateReady', function () {\n        $onReadyDeferred.resolve();\n        globalOnReadyListener(); // one time only\n        globalOnReadyListener = null;\n      });\n      var globalOnChangeListener = $rootScope.$on('$translateChangeEnd', function () {\n        $onReadyDeferred.resolve();\n        globalOnChangeListener(); // one time only\n        globalOnChangeListener = null;\n      });\n\n      if ($loaderFactory) {\n\n        // If at least one async loader is defined and there are no\n        // (default) translations available we should try to load them.\n        if (angular.equals($translationTable, {})) {\n          if ($translate.use()) {\n            $translate.use($translate.use());\n          }\n        }\n\n        // Also, if there are any fallback language registered, we start\n        // loading them asynchronously as soon as we can.\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          var processAsyncResult = function (translation) {\n            translations(translation.key, translation.table);\n            $rootScope.$emit('$translateChangeEnd', { language: translation.key });\n            return translation;\n          };\n          for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n            var fallbackLanguageId = $fallbackLanguage[i];\n            if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {\n              langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);\n            }\n          }\n        }\n      } else {\n        $rootScope.$emit('$translateReady', { language: $translate.use() });\n      }\n\n      return $translate;\n    }\n  ];\n}\n$translate.$inject = ['$STORAGE_KEY', '$windowProvider', '$translateSanitizationProvider', 'pascalprechtTranslateOverrider'];\n\n$translate.displayName = 'displayName';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateDefaultInterpolation\n * @requires $interpolate\n *\n * @description\n * Uses angular's `$interpolate` services to interpolate strings against some values.\n *\n * Be aware to configure a proper sanitization strategy.\n *\n * See also:\n * * {@link pascalprecht.translate.$translateSanitization}\n *\n * @return {object} $translateDefaultInterpolation Interpolator service\n */\nangular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', $translateDefaultInterpolation);\n\nfunction $translateDefaultInterpolation ($interpolate, $translateSanitization) {\n\n  'use strict';\n\n  var $translateInterpolator = {},\n      $locale,\n      $identifier = 'default';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#setLocale\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Sets current locale (this is currently not use in this interpolation).\n   *\n   * @param {string} locale Language key or locale.\n   */\n  $translateInterpolator.setLocale = function (locale) {\n    $locale = locale;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#getInterpolationIdentifier\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Returns an identifier for this interpolation service.\n   *\n   * @returns {string} $identifier\n   */\n  $translateInterpolator.getInterpolationIdentifier = function () {\n    return $identifier;\n  };\n\n  /**\n   * @deprecated will be removed in 3.0\n   * @see {@link pascalprecht.translate.$translateSanitization}\n   */\n  $translateInterpolator.useSanitizeValueStrategy = function (value) {\n    $translateSanitization.useStrategy(value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#interpolate\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Interpolates given string agains given interpolate params using angulars\n   * `$interpolate` service.\n   *\n   * @returns {string} interpolated string.\n   */\n  $translateInterpolator.interpolate = function (string, interpolationParams) {\n    interpolationParams = interpolationParams || {};\n    interpolationParams = $translateSanitization.sanitize(interpolationParams, 'params');\n\n    var interpolatedText = $interpolate(string)(interpolationParams);\n    interpolatedText = $translateSanitization.sanitize(interpolatedText, 'text');\n\n    return interpolatedText;\n  };\n\n  return $translateInterpolator;\n}\n$translateDefaultInterpolation.$inject = ['$interpolate', '$translateSanitization'];\n\n$translateDefaultInterpolation.displayName = '$translateDefaultInterpolation';\n\nangular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translate\n * @requires $compile\n * @requires $filter\n * @requires $interpolate\n * @restrict AE\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate Translation id which could be either string or interpolated string.\n * @param {string=} translate-values Values to pass into translation id. Can be passed as object literal string or interpolated object.\n * @param {string=} translate-attr-ATTR translate Translation id and put it into ATTR attribute.\n * @param {string=} translate-default will be used unless translation was successful\n * @param {boolean=} translate-compile (default true if present) defines locally activation of {@link pascalprecht.translate.$translateProvider#methods_usePostCompiling}\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre translate=\"TRANSLATION_ID\"></pre>\n        <pre translate>TRANSLATION_ID</pre>\n        <pre translate translate-attr-title=\"TRANSLATION_ID\"></pre>\n        <pre translate=\"{{translationId}}\"></pre>\n        <pre translate>{{translationId}}</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{value: 5}\"></pre>\n        <pre translate translate-values=\"{value: 5}\">WITH_VALUES</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n        <pre translate translate-values=\"{{values}}\">WITH_VALUES</pre>\n        <pre translate translate-attr-title=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        }).preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n    <file name=\"scenario.js\">\n      it('should translate', function () {\n        inject(function ($rootScope, $compile) {\n          $rootScope.translationId = 'TRANSLATION_ID';\n\n          element = $compile('<p translate=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate=\"{{translationId}}\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>TRANSLATION_ID</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>{{translationId}}</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate translate-attr-title=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.attr('title')).toBe('Hello there!');\n        });\n      });\n    </file>\n   </example>\n */\n.directive('translate', translateDirective);\nfunction translateDirective($translate, $q, $interpolate, $compile, $parse, $rootScope) {\n\n  'use strict';\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  return {\n    restrict: 'AE',\n    scope: true,\n    priority: $translate.directivePriority(),\n    compile: function (tElement, tAttr) {\n\n      var translateValuesExist = (tAttr.translateValues) ?\n        tAttr.translateValues : undefined;\n\n      var translateInterpolation = (tAttr.translateInterpolation) ?\n        tAttr.translateInterpolation : undefined;\n\n      var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);\n\n      var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',\n          watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';\n\n      return function linkFn(scope, iElement, iAttr) {\n\n        scope.interpolateParams = {};\n        scope.preText = '';\n        scope.postText = '';\n        scope.translateNamespace = getTranslateNamespace(scope);\n        var translationIds = {};\n\n        var initInterpolationParams = function (interpolateParams, iAttr, tAttr) {\n          // initial setup\n          if (iAttr.translateValues) {\n            angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));\n          }\n          // initially fetch all attributes if existing and fill the params\n          if (translateValueExist) {\n            for (var attr in tAttr) {\n              if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n                var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);\n                interpolateParams[attributeName] = tAttr[attr];\n              }\n            }\n          }\n        };\n\n        // Ensures any change of the attribute \"translate\" containing the id will\n        // be re-stored to the scope's \"translationId\".\n        // If the attribute has no content, the element's text value (white spaces trimmed off) will be used.\n        var observeElementTranslation = function (translationId) {\n\n          // Remove any old watcher\n          if (angular.isFunction(observeElementTranslation._unwatchOld)) {\n            observeElementTranslation._unwatchOld();\n            observeElementTranslation._unwatchOld = undefined;\n          }\n\n          if (angular.equals(translationId , '') || !angular.isDefined(translationId)) {\n            var iElementText = trim.apply(iElement.text());\n\n            // Resolve translation id by inner html if required\n            var interpolateMatches = iElementText.match(interpolateRegExp);\n            // Interpolate translation id if required\n            if (angular.isArray(interpolateMatches)) {\n              scope.preText = interpolateMatches[1];\n              scope.postText = interpolateMatches[3];\n              translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);\n              var watcherMatches = iElementText.match(watcherRegExp);\n              if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {\n                observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function (newValue) {\n                  translationIds.translate = newValue;\n                  updateTranslations();\n                });\n              }\n            } else {\n              // do not assigne the translation id if it is empty.\n              translationIds.translate = !iElementText ? undefined : iElementText;\n            }\n          } else {\n            translationIds.translate = translationId;\n          }\n          updateTranslations();\n        };\n\n        var observeAttributeTranslation = function (translateAttr) {\n          iAttr.$observe(translateAttr, function (translationId) {\n            translationIds[translateAttr] = translationId;\n            updateTranslations();\n          });\n        };\n\n        // initial setup with values\n        initInterpolationParams(scope.interpolateParams, iAttr, tAttr);\n\n        var firstAttributeChangedEvent = true;\n        iAttr.$observe('translate', function (translationId) {\n          if (typeof translationId === 'undefined') {\n            // case of element \"<translate>xyz</translate>\"\n            observeElementTranslation('');\n          } else {\n            // case of regular attribute\n            if (translationId !== '' || !firstAttributeChangedEvent) {\n              translationIds.translate = translationId;\n              updateTranslations();\n            }\n          }\n          firstAttributeChangedEvent = false;\n        });\n\n        for (var translateAttr in iAttr) {\n          if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr') {\n            observeAttributeTranslation(translateAttr);\n          }\n        }\n\n        iAttr.$observe('translateDefault', function (value) {\n          scope.defaultText = value;\n          updateTranslations();\n        });\n\n        if (translateValuesExist) {\n          iAttr.$observe('translateValues', function (interpolateParams) {\n            if (interpolateParams) {\n              scope.$parent.$watch(function () {\n                angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));\n              });\n            }\n          });\n        }\n\n        if (translateValueExist) {\n          var observeValueAttribute = function (attrName) {\n            iAttr.$observe(attrName, function (value) {\n              var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);\n              scope.interpolateParams[attributeName] = value;\n            });\n          };\n          for (var attr in iAttr) {\n            if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n              observeValueAttribute(attr);\n            }\n          }\n        }\n\n        // Master update function\n        var updateTranslations = function () {\n          for (var key in translationIds) {\n\n            if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {\n              updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);\n            }\n          }\n        };\n\n        // Put translation processing function outside loop\n        var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {\n          if (translationId) {\n            // if translation id starts with '.' and translateNamespace given, prepend namespace\n            if (translateNamespace && translationId.charAt(0) === '.') {\n              translationId = translateNamespace + translationId;\n            }\n\n            $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage)\n              .then(function (translation) {\n                applyTranslation(translation, scope, true, translateAttr);\n              }, function (translationId) {\n                applyTranslation(translationId, scope, false, translateAttr);\n              });\n          } else {\n            // as an empty string cannot be translated, we can solve this using successful=false\n            applyTranslation(translationId, scope, false, translateAttr);\n          }\n        };\n\n        var applyTranslation = function (value, scope, successful, translateAttr) {\n          if (translateAttr === 'translate') {\n            // default translate into innerHTML\n            if (!successful && typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n            iElement.empty().append(scope.preText + value + scope.postText);\n            var globallyEnabled = $translate.isPostCompilingEnabled();\n            var locallyDefined = typeof tAttr.translateCompile !== 'undefined';\n            var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';\n            if ((globallyEnabled && !locallyDefined) || locallyEnabled) {\n              $compile(iElement.contents())(scope);\n            }\n          } else {\n            // translate attribute\n            if (!successful && typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n            var attributeName = iAttr.$attr[translateAttr];\n            if (attributeName.substr(0, 5) === 'data-') {\n              // ensure html5 data prefix is stripped\n              attributeName = attributeName.substr(5);\n            }\n            attributeName = attributeName.substr(15);\n            iElement.attr(attributeName, value);\n          }\n        };\n\n        if (translateValuesExist || translateValueExist || iAttr.translateDefault) {\n          scope.$watch('interpolateParams', updateTranslations, true);\n        }\n        scope.$watch('translateLanguage', updateTranslations);\n\n        // Ensures the text will be refreshed after the current language was changed\n        // w/ $translate.use(...)\n        var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);\n\n        // ensure translation will be looked up at least one\n        if (iElement.text().length) {\n          if (iAttr.translate) {\n            observeElementTranslation(iAttr.translate);\n          } else {\n            observeElementTranslation('');\n          }\n        } else if (iAttr.translate) {\n          // ensure attribute will be not skipped\n          observeElementTranslation(iAttr.translate);\n        }\n        updateTranslations();\n        scope.$on('$destroy', unbind);\n      };\n    }\n  };\n}\ntranslateDirective.$inject = ['$translate', '$q', '$interpolate', '$compile', '$parse', '$rootScope'];\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateDirective.displayName = 'translateDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateCloak\n * @requires $rootScope\n * @requires $translate\n * @restrict A\n *\n * $description\n * Adds a `translate-cloak` class name to the given element where this directive\n * is applied initially and removes it, once a loader has finished loading.\n *\n * This directive can be used to prevent initial flickering when loading translation\n * data asynchronously.\n *\n * The class name is defined in\n * {@link pascalprecht.translate.$translateProvider#cloakClassName $translate.cloakClassName()}.\n *\n * @param {string=} translate-cloak If a translationId is provided, it will be used for showing\n *                                  or hiding the cloak. Basically it relies on the translation\n *                                  resolve.\n */\n.directive('translateCloak', translateCloakDirective);\n\nfunction translateCloakDirective($translate, $rootScope) {\n\n  'use strict';\n\n  return {\n    compile: function (tElement) {\n      var applyCloak = function () {\n        tElement.addClass($translate.cloakClassName());\n      },\n      removeCloak = function () {\n        tElement.removeClass($translate.cloakClassName());\n      };\n      $translate.onReady(function () {\n        removeCloak();\n      });\n      applyCloak();\n\n      return function linkFn(scope, iElement, iAttr) {\n        if (iAttr.translateCloak && iAttr.translateCloak.length) {\n          // Register a watcher for the defined translation allowing a fine tuned cloak\n          iAttr.$observe('translateCloak', function (translationId) {\n            $translate(translationId).then(removeCloak, applyCloak);\n          });\n          // Register for change events as this is being another indicicator revalidating the cloak)\n          $rootScope.$on('$translateChangeSuccess', function () {\n            $translate(iAttr.translateCloak).then(removeCloak, applyCloak);\n          });\n        }\n      };\n    }\n  };\n}\ntranslateCloakDirective.$inject = ['$translate', '$rootScope'];\n\ntranslateCloakDirective.displayName = 'translateCloakDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateNamespace\n * @restrict A\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate namespace name which could be either string or interpolated string.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div translate-namespace=\"CONTENT\">\n\n        <div>\n            <h1 translate>.HEADERS.TITLE</h1>\n            <h1 translate>.HEADERS.WELCOME</h1>\n        </div>\n\n        <div translate-namespace=\".HEADERS\">\n            <h1 translate>.TITLE</h1>\n            <h1 translate>.WELCOME</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'CONTENT': {\n            'HEADERS': {\n                TITLE: 'Title'\n            }\n          },\n          'CONTENT.HEADERS.WELCOME': 'Welcome'\n        }).preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateNamespace', translateNamespaceDirective);\n\nfunction translateNamespaceDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return {\n        pre: function (scope, iElement, iAttrs) {\n          scope.translateNamespace = getTranslateNamespace(scope);\n\n          if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === '.') {\n            scope.translateNamespace += iAttrs.translateNamespace;\n          } else {\n            scope.translateNamespace = iAttrs.translateNamespace;\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateNamespaceDirective.displayName = 'translateNamespaceDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateLanguage\n * @restrict A\n *\n * @description\n * Forces the language to the directives in the underlying scope.\n *\n * @param {string=} translate language that will be negotiated.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div>\n\n        <div>\n            <h1 translate>HELLO</h1>\n        </div>\n\n        <div translate-language=\"de\">\n            <h1 translate>HELLO</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider\n          .translations('en',{\n            'HELLO': 'Hello world!'\n          })\n          .translations('de',{\n            'HELLO': 'Hallo Welt!'\n          })\n          .translations(.preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateLanguage', translateLanguageDirective);\n\nfunction translateLanguageDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return function linkFn(scope, iElement, iAttrs) {\n        iAttrs.$observe('translateLanguage', function (newTranslateLanguage) {\n          scope.translateLanguage = newTranslateLanguage;\n        });\n      };\n    }\n  };\n}\n\ntranslateLanguageDirective.displayName = 'translateLanguageDirective';\n\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc filter\n * @name pascalprecht.translate.filter:translate\n * @requires $parse\n * @requires pascalprecht.translate.$translate\n * @function\n *\n * @description\n * Uses `$translate` service to translate contents. Accepts interpolate parameters\n * to pass dynamized values though translation.\n *\n * @param {string} translationId A translation id to be translated.\n * @param {*=} interpolateParams Optional object literal (as hash or string) to pass values into translation.\n *\n * @returns {string} Translated text.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre>{{ 'TRANSLATION_ID' | translate }}</pre>\n        <pre>{{ translationId | translate }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:'{value: 5}' }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:values }}</pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en', {\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        });\n        $translateProvider.preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n   </example>\n */\n.filter('translate', translateFilterFactory);\n\nfunction translateFilterFactory($parse, $translate) {\n\n  'use strict';\n\n  var translateFilter = function (translationId, interpolateParams, interpolation, forceLanguage) {\n\n    if (!angular.isObject(interpolateParams)) {\n      interpolateParams = $parse(interpolateParams)(this);\n    }\n\n    return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);\n  };\n\n  if ($translate.statefulFilter()) {\n    translateFilter.$stateful = true;\n  }\n\n  return translateFilter;\n}\ntranslateFilterFactory.$inject = ['$parse', '$translate'];\n\ntranslateFilterFactory.displayName = 'translateFilterFactory';\n\nangular.module('pascalprecht.translate')\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translationCache\n * @requires $cacheFactory\n *\n * @description\n * The first time a translation table is used, it is loaded in the translation cache for quick retrieval. You\n * can load translation tables directly into the cache by consuming the\n * `$translationCache` service directly.\n *\n * @return {object} $cacheFactory object.\n */\n  .factory('$translationCache', $translationCache);\n\nfunction $translationCache($cacheFactory) {\n\n  'use strict';\n\n  return $cacheFactory('translations');\n}\n$translationCache.$inject = ['$cacheFactory'];\n\n$translationCache.displayName = '$translationCache';\nreturn 'pascalprecht.translate';\n\n}));\n\n},{}],40:[function(require,module,exports){\n/**\n * State-based routing for AngularJS\n * @version v0.2.18\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    toJson = angular.toJson;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i] || !parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:\n        result = result.replace(/\\/$/, '');\n        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  var param, paramVal;\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    param = this.params[paramName];\n    paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n    param = this.params[paramName];\n    paramVal = searchParams[paramName];\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validates\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      var isFinalPathParam = i + 1 === nPath;\n\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n\n      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      if (encoded.length === 0) continue;\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        if (isArray(val) && val.length === 0) return val;\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  // Use tildes to pre-encode slashes.\n  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n  // and bidirectional encoding/decoding fails.\n  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    \"string\": {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    \"int\": {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    \"bool\": {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    \"date\": {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    \"json\": {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    \"any\": { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\n      if (angular.isString(config.type))\n        return $types[config.type];\n      if (config.type instanceof Type)\n        return config.type;\n      return new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {function} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|function} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. \n   * \n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|function} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n\n        isHtml5 = isHtml5 && $sniffer.history;\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. Only parameters specified in the state definition can be overridden, new \n     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n     *    have changed.  It will reload the resolves and views of the current state and parent states.\n     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n     *    the transition reloads the resolves and views for that matched state, and all its children states.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n      \n      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n      if (hash) toParams['#'] = hash;\n      \n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n          if ($state.transition == null) $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .factory('$stateParams', function () { return {}; })\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\nvar ngMajorVer = angular.version.major;\nvar ngMinorVer = angular.version.minor;\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations\n * will be applied to the ui-view)\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = {\n      enter: function (element, target, cb) { target.after(element); cb(); },\n      leave: function (element, cb) { element.remove(); cb(); }\n    };\n\n    if (!!attrs.noanimation) return statics;\n\n    function animEnabled(element) {\n      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);\n      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();\n      return (!!$animator);\n    }\n\n    // ng 1.2+\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          if (!animEnabled(element)) {\n            statics.enter(element, target, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function(element, cb) {\n          if (!animEnabled(element)) {\n            statics.leave(element, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        }\n      };\n    }\n\n    // ng 1.1.5\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics;\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          var _previousEl = previousEl;\n          var _currentScope = currentScope;\n\n          if (_currentScope) {\n            _currentScope._willBeDestroyed = true;\n          }\n\n          function cleanOld() {\n            if (_previousEl) {\n              _previousEl.remove();\n            }\n\n            if (_currentScope) {\n              _currentScope.$destroy();\n            }\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              cleanOld();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n          } else {\n            cleanOld();\n            previousEl = null;\n          }\n\n          currentEl = null;\n          currentScope = null;\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          currentScope.$emit('$viewContentLoaded', name);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var inherited = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\nfunction clickHook(el, $state, $timeout, type, current) {\n  return function(e) {\n    var button = e.which || e.button, target = current();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function() {\n        $state.go(target.state, target.params, target.options);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\n      e.preventDefault = function() {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\nfunction defaultOpts(el, $state) {\n  return { relative: stateContext(el) || $state.$current, inherit: true };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n * URL, the directive will automatically generate & update the `href` attribute via\n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n * the link will trigger a state transition with optional parameters.\n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative\n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the\n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n *\n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n      var def    = { state: ref.state, href: null, params: null };\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n\n      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\n      var update = function(val) {\n        if (val) def.params = angular.copy(val);\n        def.href = $state.href(ref.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(ref.state, def.params);\n        if (def.href !== null) attrs.$set(type.attr, def.href);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n        def.params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-state\n *\n * @requires ui.router.state.uiSref\n *\n * @restrict A\n *\n * @description\n * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n * params and override options.\n *\n * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}\n * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDynamicDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n      var def    = { state: null, params: null, options: null, href: null };\n\n      function runStateRefLink (group) {\n        def.state = group[0]; def.params = group[1]; def.options = group[2];\n        def.href = $state.href(def.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(def.state, def.params);\n        if (def.href) attrs.$set(type.attr, def.href);\n      }\n\n      scope.$watch(watch, runStateRefLink, true);\n      runStateRefLink(scope.$eval(watch));\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * It is also possible to pass ui-sref-active an expression that evaluates\n * to an object hash, whose keys represent active class names and whose\n * values represent the respective state names/globs.\n * ui-sref-active will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * @Example\n * Given the following template, with \"admin\" being an abstract state:\n * <pre>\n * <div ui-sref-active=\"{'active': 'admin.*'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * </pre>\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied\n * to both the <div> and <a> elements. It is important to note that the state\n * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n      try {\n        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n      } catch (e) {\n        // Do nothing. uiSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n      if (isObject(uiSrefActive)) {\n        forEach(uiSrefActive, function(stateOrName, activeClass) {\n          if (isString(stateOrName)) {\n            var ref = parseStateRef(stateOrName, $state.current.name);\n            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n          }\n        });\n      }\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ui-sref-active, so we\n        // shadow the one that comes from ui-sref\n        if (isObject(uiSrefActive) && states.length > 0) {\n          return;\n        }\n        addState(newState, newParams, uiSrefActive);\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      function addState(stateName, stateParams, activeClass) {\n        var state = $state.get(stateName, stateContext($element));\n        var stateHash = createStateHash(stateName, stateParams);\n\n        states.push({\n          state: state || { name: stateName },\n          params: stateParams,\n          hash: stateHash\n        });\n\n        activeClasses[stateHash] = activeClass;\n      }\n\n      /**\n       * @param {string} state\n       * @param {Object|string} [params]\n       * @return {string}\n       */\n      function createStateHash(state, params) {\n        if (!isString(state)) {\n          throw new Error('state should be a string');\n        }\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        params = $scope.$eval(params);\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        return state;\n      }\n\n      // Update route state\n      function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }\n\n      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n      function removeClass(el, className) { el.removeClass(className); }\n      function anyMatch(state, params) { return $state.includes(state.name, params); }\n      function exactMatch(state, params) { return $state.is(state.name, params); }\n\n      update();\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n  .directive('uiState', $StateRefDynamicDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state, params) {\n    return $state.is(state, params);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state, params, options) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n},{}],41:[function(require,module,exports){\n'use strict';\n// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.\n\nmodule.exports = {\n    // Create a <link> tag with optional data attributes\n    createLink: function(href, attributes) {\n        var head = document.head || document.getElementsByTagName('head')[0];\n        var link = document.createElement('link');\n\n        link.href = href;\n        link.rel = 'stylesheet';\n\n        for (var key in attributes) {\n            if ( ! attributes.hasOwnProperty(key)) {\n                continue;\n            }\n            var value = attributes[key];\n            link.setAttribute('data-' + key, value);\n        }\n\n        head.appendChild(link);\n    },\n    // Create a <style> tag with optional data attributes\n    createStyle: function(cssText, attributes) {\n        var head = document.head || document.getElementsByTagName('head')[0],\n            style = document.createElement('style');\n\n        style.type = 'text/css';\n\n        for (var key in attributes) {\n            if ( ! attributes.hasOwnProperty(key)) {\n                continue;\n            }\n            var value = attributes[key];\n            style.setAttribute('data-' + key, value);\n        }\n        \n        if (style.sheet) { // for jsdom and IE9+\n            style.innerHTML = cssText;\n            style.sheet.cssText = cssText;\n            head.appendChild(style);\n        } else if (style.styleSheet) { // for IE8 and below\n            head.appendChild(style);\n            style.styleSheet.cssText = cssText;\n        } else { // for Chrome, Firefox, and Safari\n            style.appendChild(document.createTextNode(cssText));\n            head.appendChild(style);\n        }\n    }\n};\n\n},{}]},{},[4])\n\n","var ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\r\nvar MainViewController = require('./components/common/MainViewController');\r\nvar SideNavViewController = require('./components/nav/SideNavViewController');\r\nvar BeneficiaryViewController = require('./components/beneficiary/BeneficiaryViewController');\r\nvar CompanyViewController = require('./components/company/CompanyViewController');\r\nvar config = require('./config');\r\n\r\nvar moduleName = config.configBlock.namespace + '.controllers';\r\nvar controllersModule = ng.module(moduleName, [])\r\n    .controller('MainViewController', MainViewController.controller)\r\n    .controller('SideNavViewController', SideNavViewController.controller)\r\n    .controller('BeneficiaryViewController', BeneficiaryViewController.controller)\r\n    .controller('CompanyViewController', CompanyViewController.controller);\r\n\r\nexports.controllersModule = controllersModule;\r\n","var ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar MainViewDirective = require('./components/common/MainViewDirective');\nvar SideNavViewDirective = require('./components/nav/SideNavViewDirective');\nvar BeneficiaryViewDirective = require('./components/beneficiary/BeneficiaryViewDirective');\nvar BeneficiaryCreateViewDirective = require('./components/beneficiary/BeneficiaryCreateViewDirective');\nvar BeneficiaryUpdateViewDirective = require('./components/beneficiary/BeneficiaryUpdateViewDirective');\nvar BeneficiaryDeleteViewDirective = require('./components/beneficiary/BeneficiaryDeleteViewDirective');\nvar BeneficiaryListViewDirective = require('./components/beneficiary/BeneficiaryListViewDirective');\nvar BeneficiaryListFragmentViewDirective = require('./components/beneficiary/BeneficiaryListFragmentViewDirective');\nvar BeneficiaryDetailViewDirective = require('./components/beneficiary/BeneficiaryDetailViewDirective');\nvar BeneficiarySearchViewDirective = require('./components/beneficiary/BeneficiarySearchViewDirective');\nvar CompanyViewDirective = require('./components/company/CompanyViewDirective');\nvar CompanyCreateViewDirective = require('./components/company/CompanyCreateViewDirective');\nvar CompanyUpdateViewDirective = require('./components/company/CompanyUpdateViewDirective');\nvar CompanyDeleteViewDirective = require('./components/company/CompanyDeleteViewDirective');\nvar CompanyListViewDirective = require('./components/company/CompanyListViewDirective');\nvar CompanyListFragmentViewDirective = require('./components/company/CompanyListFragmentViewDirective');\nvar CompanySearchViewDirective = require('./components/company/CompanySearchViewDirective');\nvar config = require('./config');\n\nvar moduleName = config.configBlock.namespace + '.directives';\n\nvar directivesModule = ng.module(moduleName, [])\n    .directive('mainView', MainViewDirective.directive)\n    .directive('sideNavView', SideNavViewDirective.directive)\n    .directive('beneficiaryView', BeneficiaryViewDirective.directive)\n    .directive('beneficiaryCreateView', BeneficiaryCreateViewDirective.directive)\n    .directive('beneficiaryUpdateView', BeneficiaryUpdateViewDirective.directive)\n    .directive('beneficiaryDeleteView', BeneficiaryDeleteViewDirective.directive)\n    .directive('beneficiaryDetailView', BeneficiaryDetailViewDirective.directive)\n    .directive('beneficiarySearchView', BeneficiarySearchViewDirective.directive)\n    .directive('beneficiaryListView', BeneficiaryListViewDirective.directive)\n    .directive('beneficiaryListDetailView', BeneficiaryListViewDirective.directive)\n    .directive('beneficiaryListFragmentView', BeneficiaryListFragmentViewDirective.directive)\n    .directive('companyView', CompanyViewDirective.directive)\n    .directive('companyCreateView', CompanyCreateViewDirective.directive)\n    .directive('companyUpdateView', CompanyUpdateViewDirective.directive)\n    .directive('companyDeleteView', CompanyDeleteViewDirective.directive)\n    .directive('companySearchView', CompanySearchViewDirective.directive)\n    .directive('companyListView', CompanyListViewDirective.directive)\n    .directive('companyListFragmentView', CompanyListFragmentViewDirective.directive)\n\nexports.directivesModule = directivesModule;\n","var ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar BeneficiaryService = require('./components/beneficiary/BeneficiaryService');\nvar CompanyService = require('./components/company/CompanyService');\nvar UtilService = require('./components/common/UtilService');\nvar config = require('./config');\n\nvar moduleName = config.configBlock.namespace + '.services';\nvar servicesModule = ng.module(moduleName, [])\n    .factory('beneficiaryService', BeneficiaryService.service)\n    .factory('companyService', CompanyService.service)\n    .factory('utilService', UtilService.service);\n\nexports.servicesModule = servicesModule;\n","/** Main app **/\n\n'use strict';\n\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar config = require('./config');\nvar constants = require('./constants');\nvar services = require('./angularservices');\nvar controllers = require('./angularcontrollers');\nvar directives = require('./angulardirectives');\n\nvar animateModule = require('angular-animate');\nvar translateModule = require('angular-translate');\nvar sanitizeModule = require('angular-sanitize');\nvar blockUIModule = require('angular-block-ui');\nvar uiRouterModule = require('angular-ui-router');\n\nrequire('angular-block-ui/dist/angular-block-ui.min.css');\n\nvar moduleName = config.configBlock.namespace;\n\n// Declare app level module which depends on services, controllers and directives\nng.module(moduleName, [animateModule, translateModule, sanitizeModule, blockUIModule, uiRouterModule,\n    services.servicesModule.name, controllers.controllersModule.name, directives.directivesModule.name,\n    'inform', 'inform-exception'/*, 'inform-http-exception'*/\n]);\n\nng.module(moduleName)\n  .config(config.configBlock.settings)\n  .config(config.configBlock.states)\n  .config(config.configBlock.blockUI)\n  .config(config.configBlock.inform)\n  .config(config.configBlock.hrefSanitize);\n\nng.module(moduleName)\n  .constant('CONSTANTS', constants.constants);\n\nvar runBlock = function() {\n\n    // Add code that needs a run block to execute here.\n};\n\nng.module(moduleName)\n  .run(runBlock);\n  // .run(config.configBlock.modal);\n","/**\r\n * Beneficiary Form Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryCreateView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Delete Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryDeleteView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Beneficiary Detail View Component Directive\r\n *\r\n * @param {$parse} Angular parser service\r\n * @param {$rootScope} Angular rootScope service\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function($parse, $compile, $rootScope, $timeout) {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryDetailView.html',\r\n        restrict: 'AE',\r\n        //replace: true,\r\n        //transclude: true,\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        link: function(scope, el, attrs) {\r\n            $rootScope.$on('disableBeneficiary', function(ev, data) {\r\n                for (var i = 0; i < data.beneficiaries.length; i++) {\r\n                    if (data.beneficiaries[i].id === data.beneficiaryId) {\r\n                        var inputEls = angular.element(el.find('input[type=text]'));\r\n                        for (var j = 0; j < inputEls.length; j++) {\r\n                            angular.element(inputEls[j]).attr('disabled', '');\r\n                            $timeout(function() {\r\n                                $compile(inputEls[j])(scope);\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                //$compile(el)(scope);\r\n            });\r\n        }\r\n    };\r\n};\r\ndirective.$inject = [\"$parse\", \"$compile\", \"$rootScope\", \"$timeout\"];\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryListFragmentView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiaries: '=',\r\n            delref: '='\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryListView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Search Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiarySearchView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * This service helps to perform http requests (GET, POST, PUT, DELETE) for beneficiary tasks\r\n *\r\n * @param {$http} The AngularJS http service\r\n * @param {$timeout} The AngularJS timeout service\r\n *\r\n * @ngInject\r\n */\r\nvar service = function($http, $timeout) {\r\n    'use strict';\r\n\r\n    var serviceInstance = {};\r\n    serviceInstance.selectedBeneficiaryId = null;\r\n    serviceInstance.popOnDelete = null;\r\n    serviceInstance.beneficiary = null;\r\n    serviceInstance.beneficiaries = [];\r\n\r\n    serviceInstance.getBeneficiary = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'GET',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.createBeneficiary = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            data: data,\r\n            method: 'POST',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n    serviceInstance.updateBeneficiary = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'PUT',\r\n            data: data,\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.deleteBeneficiary = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'DELETE',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$http\", \"$timeout\"];\r\n\r\nexports.service = service;\r\n","/**\r\n * Beneficiary Form Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryUpdateView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Beneficiary View controller\r\n *\r\n * This controller is responsible for handing beneficiary form module related logic\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {$modal} Angular modal service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {utilService} Utility service\r\n * @param {blockUI} Block UI service\r\n * @param {inform} Inform provider service\r\n * @param {CONSTANTS} Project constants values\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function($rootScope, $scope, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, utilService, blockUI, inform, CONSTANTS) {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n    $scope.useExistingBeneficiary = false;\r\n    $scope.minimumValidBeneficiary = false;\r\n    $scope.beneficiaryId = null;\r\n    $scope.beneficiarySearched = false;\r\n    $scope.beneficiaryFound = false;\r\n    $scope.searchRequestSumbitted = false;\r\n    $scope.addRequestSubmitted = false;\r\n    $scope.addRequestAttempted = false;\r\n    $scope.updateRequestSubmitted = false;\r\n    $scope.updateRequestAttempted = false;\r\n    $scope.deleteRequestSubmitted = false;\r\n    $scope.deleteSuccessful = false;\r\n    $scope.serviceUrl = CONSTANTS.url.host + ':' + CONSTANTS.url.port + '/' + CONSTANTS.url.contextRoot;\r\n\r\n    $scope.initBeneficiary = {\r\n        \"firstName\": null,\r\n        \"lastName\": null\r\n    };\r\n\r\n    $scope.beneficiaries = beneficiaryService.beneficiaries.length > 0 ? beneficiaryService.beneficiaries : [];\r\n    $scope.beneficiary = beneficiaryService.beneficiary &&\r\n                         ($state.current.name === 'start.beneficiary.update' || $state.current.name === 'start.beneficiary.list.delete' || $state.current.name === 'start.beneficiary.search.delete') ?\r\n                         beneficiaryService.beneficiary : $scope.initBeneficiary;\r\n\r\n    $scope.resetBeneficiary = function() {\r\n        $timeout(function() {\r\n            $scope.beneficiary = $scope.initBeneficiary;\r\n            $scope.beneficiaries = [];\r\n        });\r\n    };\r\n\r\n    $scope.addBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.addRequestSubmitted = false;\r\n        beneficiaryService.beneficiary = $scope.beneficiary;\r\n        if (!utilService.isFormValid('beneficiaryDetailsForm')) {\r\n            $scope.addRequestAttempted = true;\r\n            $log.warn('form invalid');\r\n            inform.add('Invalid form. First name and Last name are required to create beneficiary', {\r\n                ttl: 3500,\r\n                type: 'danger'\r\n            });\r\n            // $scope.registerPopoverShow('#addBeneficiary');\r\n            return;\r\n        }\r\n\r\n        var beneficiaryCreateBlock = blockUI.instances.get('beneficiaryCreateBlock');\r\n        // beneficiaryCreateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        $scope.addRequestSubmitted = true;\r\n        beneficiaryService.createBeneficiary(url, $scope.beneficiary, function(result) {\r\n            $timeout(function() {\r\n                $log.info(result);\r\n                if (result && result.data) {\r\n                    if (result.data.id > 0) {\r\n                        inform.add('beneficiary created successfully.', {\r\n                            ttl: 2500\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.beneficiary', {}, {reload:true});\r\n                        }, 2500);\r\n                    } else {\r\n                        inform.add('Request completed, however beneficiary couldn\\'t be created.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating beneficiary.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.addRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // beneficiaryCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelAddBeneficiary = function() {\r\n        $state.go('start.beneficiary');\r\n    };\r\n\r\n    $scope.updateBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.updateRequestSubmitted = false;\r\n        beneficiaryService.beneficiary = $scope.beneficiary;\r\n        if (!utilService.isFormValid('beneficiaryDetailsForm')) {\r\n            $scope.updateRequestAttempted = true;\r\n            $log.warn('ccform invalid');\r\n            inform.add('Invalid form. First name and Last name are required to create beneficiary', {\r\n                ttl: 3500,\r\n                type: 'danger'\r\n            });\r\n            return;\r\n        }\r\n\r\n        // var beneficiaryUpdateBlock = blockUI.instances.get('beneficiaryUpdateBlock');\r\n        // beneficiaryUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        $scope.updateRequestSubmitted = true;\r\n        beneficiaryService.updateBeneficiary(url, $scope.beneficiary, function(result) {\r\n            $timeout(function() {\r\n                if (result && result.data) {\r\n                    if (result.data.status === true) {\r\n                        inform.add('beneficiary updated successfully.', {\r\n                            ttl: 4000\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.beneficiary.list', {}, {reload: true});\r\n                        }, 4500);\r\n                    } else {\r\n                        inform.add('Request completed successfully, but no update performed on beneficiary.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'beneficiary couldn\\'t be updated.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.updateRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // beneficiaryUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseBeneficiaryUpdate = function() {\r\n        $state.go('start.beneficiary.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.deleteBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.beneficiary = beneficiaryService.beneficiary;\r\n        // var beneficiaryUpdateBlock = blockUI.instances.get('beneficiaryUpdateBlock');\r\n        // beneficiaryUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + $scope.beneficiary.id;\r\n        beneficiaryService.deleteBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.deleteRequestSubmitted = true;\r\n                if (result && result.data && result.data.status === true) {\r\n                    $scope.deleteSuccessful = true;\r\n                } else {\r\n                  $log.info(result);\r\n                }\r\n                // beneficiaryUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseBeneficiaryDelete = function() {\r\n        $scope.$dismiss();\r\n        $state.go('start.beneficiary.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.fetchBeneficiary = function(id) {\r\n        $scope.beneficiaries.splice(0, $scope.beneficiaries.length);\r\n\r\n        var idSearch = !utilService.isBlank(id);\r\n        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        var url = idSearch ? baseUrl + '/' + id : baseUrl;\r\n        //var beneficiaryListBlock = blockUI.instances.get('beneficiaryListBlock');\r\n        //beneficiaryListBlock.start();\r\n        beneficiaryService.getBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.searchRequestSumbitted = true;\r\n                if (result && result.data) {\r\n                    if (idSearch) {\r\n                        $scope.beneficiaries.push(result.data);\r\n                    } else {\r\n                        $scope.beneficiaries = result.data;\r\n                    }\r\n                    beneficiaryService.beneficiaries = $scope.beneficiaries;\r\n                    $scope.beneficiaryFound = true;\r\n                }\r\n                //beneficiaryListBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.searchBeneficiary = function(id, $event) {\r\n        $event.stopPropagation();\r\n        $timeout(function() {\r\n            if (!utilService.isValidId(id)) {\r\n                $scope.registerPopoverShow('#searchExistingBeneficiaryId');\r\n                return;\r\n            }\r\n            $scope.fetchBeneficiary(id);\r\n        });\r\n    };\r\n\r\n    $scope.mutateBeneficiaryOptions = function(beneficiary, $index, $event) {\r\n        $event.stopPropagation();\r\n        beneficiaryService.selectedBeneficiaryId = '#beneficiary' + $index;\r\n        beneficiaryService.beneficiary = beneficiary;\r\n        $scope.registerPopoverPrep(beneficiaryService.selectedBeneficiaryId);\r\n        $scope.registerPopoverShow(beneficiaryService.selectedBeneficiaryId);\r\n    };\r\n\r\n    /* initialize popover */\r\n\r\n    $scope.discardMessage = function($event) {\r\n        $event ? $event.stopPropagation() : '';\r\n        beneficiaryService.popOnDelete = \"delete\";\r\n        $scope.registerPopoverHide('[id*=popover]');\r\n    };\r\n\r\n    beneficiaryService.popOnDelete = \"delete\";\r\n\r\n    $scope.registerPopoverPrep = function(id) {\r\n        angular.element($document.find(id)).popover({\r\n            trigger: 'manual'\r\n        });\r\n    };\r\n\r\n    $scope.registerPopoverShow = function(id) {\r\n        if (beneficiaryService.popOnDelete !== \"popover\") {\r\n            beneficiaryService.popOnDelete = \"popover\";\r\n            angular.element($document.find(id)).popover('show');\r\n        }\r\n    };\r\n\r\n    $scope.registerPopoverHide = function(id) {\r\n        var el = angular.element($document.find(id));\r\n        el ? el.popover('hide') : '';\r\n    };\r\n\r\n    $scope.registerPopoverPrep('#removeBeneficiary');\r\n    $scope.registerPopoverPrep('#addBeneficiary');\r\n    $scope.registerPopoverPrep('#updateBeneficiary');\r\n    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');\r\n    $scope.registerPopoverHide('[id*=popover]');\r\n\r\n    // clear all informs\r\n    inform.clear();\r\n};\r\ncontroller.$inject = [\"$rootScope\", \"$scope\", \"$timeout\", \"$window\", \"$document\", \"$log\", \"$state\", \"$modal\", \"beneficiaryService\", \"utilService\", \"blockUI\", \"inform\", \"CONSTANTS\"];\r\n\r\nexports.controller = controller;\r\n","/**\r\n * Main Beneficiary Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Main View controller\r\n *\r\n * This controller is responsible for handing request from main view\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function() {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n};\r\n\r\nexports.controller = controller;\r\n","/**\r\n * Main Directive\r\n *\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/common/MainView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'MainViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","var stateConfig = {\r\n    /**\r\n     * Default to <company-create-view />\r\n     */\r\n    main: {\r\n        url: '/',\r\n        views: {\r\n            'main': {\r\n                template: '<main-view></main-view>'\r\n            },\r\n            'mainItem@start': {\r\n                template: '<company-create-view></company-create-view>'\r\n            }\r\n        }\r\n    },\r\n    company: {\r\n        initial: {\r\n            url: 'company',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-view></company-view>'\r\n                }\r\n            }\r\n        },\r\n        list: {\r\n            url: '/list',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-list-view></company-list-view>'\r\n                }\r\n            }\r\n        },\r\n        search: {\r\n            url: '/search',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-search-view></company-search-view>'\r\n                }\r\n            }\r\n        },\r\n        update: {\r\n            url: '/update',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-update-view></company-update-view>'\r\n                }\r\n            }\r\n        },\r\n        delete: {\r\n            // would be used under start.company.list state, hence url resolves to: #/company/list/delete\r\n            url: '/delete',\r\n            /**\r\n             * On state enter event listener\r\n             * @param  {$modal} Modal service\r\n             * @ngInject\r\n             */\r\n            onEnter: [\"$modal\", function($modal) {\r\n                $modal.open({\r\n                    template: '<company-delete-view></company-delete-view>',\r\n                    backdrop: 'static',\r\n                    keyboard: false,\r\n                    windowClass: 'modal',\r\n                    controller: 'CompanyViewController'\r\n                });\r\n            }]\r\n        }\r\n    },\r\n    beneficiary: {\r\n        initial: {\r\n            url: 'beneficiary',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-view></beneficiary-view>'\r\n                }\r\n            }\r\n        },\r\n        list: {\r\n            url: '/list',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-list-view></beneficiary-list-view>'\r\n                }\r\n            }\r\n        },\r\n        search: {\r\n            url: '/search',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-search-view></beneficiary-seach-view>'\r\n                }\r\n            }\r\n        },\r\n        update: {\r\n            url: '/update',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-update-view></beneficiary-update-view>'\r\n                }\r\n            }\r\n        },\r\n        delete: {\r\n            /** would be used under start.beneficiary.list or start.beneficiary.search state,\r\n             *  hence url resolves to: #/beneficiary/list/delete or  #/beneficiary/search/delete\r\n             */\r\n            url: '/delete',\r\n            /**\r\n             * On state enter event listener\r\n             * @param  {$modal} Modal service\r\n             * @ngInject\r\n             */\r\n            onEnter: [\"$modal\", function($modal) {\r\n                $modal.open({\r\n                    template: '<beneficiary-delete-view></beneficiary-delete-view>',\r\n                    backdrop: 'static',\r\n                    keyboard: false,\r\n                    windowClass: 'modal',\r\n                    controller: 'BeneficiaryViewController'\r\n                });\r\n            }]\r\n        }\r\n    }\r\n};\r\n\r\nexports.stateConfig = stateConfig;\r\n","/**\r\n * This service provide custom word lookup for case normalization if one is not provided by the service client\r\n *\r\n * @param {$window} The angular window service\r\n * @ngInject\r\n */\r\nvar service = function($window) {\r\n    'use strict';\r\n    var serviceInstance = {};\r\n\r\n    serviceInstance.isFormValid = function(formId) {\r\n        var isValid = true;\r\n        var formEl = $window.document.getElementById(formId);\r\n        console.log(formEl);\r\n        if (!formEl || (formEl && formEl.className && formEl.className.indexOf('ng-invalid') > -1)) return false;\r\n        // otherwise, perform sanity check\r\n        var elements = $window.document.getElementById(formId).elements;\r\n        for (var i = 0, element = elements[i++]; i < elements.length; i++) {\r\n            if ((element.type === 'text' || element.type === 'checkbox' || element.type === 'radio' || element.type === 'date' || element.type === 'datetime-local' || element.type === 'email' || element.type === 'month' || element.type === 'number' || element.type === 'time' || element.type === 'url' || element.type === 'week' || element.type === 'textarea' || element.type === 'select') && (element.className.indexOf('ng-invalid') > -1)) {\r\n                isValid = false;\r\n                return isValid;\r\n            }\r\n        }\r\n\r\n        return isValid;\r\n    };\r\n\r\n    serviceInstance.isBlank = function(value) {\r\n        return angular.isUndefined(value) || value === null || value.length === 0;\r\n    };\r\n\r\n    serviceInstance.isValidId = function(id) {\r\n        return parseInt(id) >= 1;\r\n    }\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$window\"];\r\n\r\nexports.service = service;\r\n","/**\r\n * Company Create Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyCreateView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Delete Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyDeleteView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function() {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyListFragmentView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            companies: '=',\r\n            delref: '='\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyListView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Search Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanySearchView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * This service helps to perform http requests (GET, POST, PUT, DELETE) for company tasks\r\n *\r\n * @param {$http} The AngularJS http service\r\n * @param {$timeout} The AngularJS timeout service\r\n *\r\n * @ngInject\r\n */\r\nvar service = function($http, $timeout) {\r\n    'use strict';\r\n\r\n    var serviceInstance = {};\r\n    serviceInstance.selectedCompanyId = null;\r\n    serviceInstance.popOnDelete = null;\r\n    serviceInstance.company = null;\r\n    serviceInstance.companies = [];\r\n\r\n    serviceInstance.getCompany = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'GET',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.createCompany = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            data: data,\r\n            method: 'POST',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n    serviceInstance.updateCompany = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'PUT',\r\n            data: data,\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.deleteCompany = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'DELETE',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$http\", \"$timeout\"];\r\n\r\nexports.service = service;\r\n","/**\r\n * Company Update Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyUpdateView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company View controller\r\n *\r\n * This controller is responsible for handing company form module related logic\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$q} Angular promise service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {$modal} Angular modal service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n * @param {utilService} Utility service\r\n * @param {blockUI} Block UI service\r\n * @param {inform} Inform provider service\r\n * @param {CONSTANTS} Project constants values\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function($rootScope, $scope, $q, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, companyService, utilService, blockUI, inform, CONSTANTS) {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n    $scope.useExistingBeneficiary = false;\r\n    $scope.minimumValidBeneficiary = false;\r\n    $scope.beneficiaryId = null;\r\n    $scope.beneficiarySearched = false;\r\n    $scope.beneficiaryFound = false;\r\n    $scope.companyFound = false;\r\n    $scope.searchRequestSumbitted = false;\r\n    $scope.addRequestSubmitted = false;\r\n    $scope.updateRequestSubmitted = false;\r\n    $scope.deleteRequestSubmitted = false;\r\n    $scope.deleteSuccessful = false;\r\n    $scope.serviceUrl = CONSTANTS.url.host + ':' + CONSTANTS.url.port + '/' + CONSTANTS.url.contextRoot;\r\n\r\n    $scope.initCompany = {\r\n        \"name\": null,\r\n        \"address\": null,\r\n        \"city\": null,\r\n        \"country\": null,\r\n        \"email\": null,\r\n        \"phoneNumber\": null,\r\n        \"beneficiaries\": [{\r\n            \"id\": -1,\r\n            \"firstName\": null,\r\n            \"lastName\": null\r\n        }]\r\n    };\r\n\r\n    $scope.companies = companyService.companies.length > 0 ? companyService.companies : [];\r\n    $scope.company = companyService.company &&\r\n                    ($state.current.name === 'start.company.update' || $state.current.name === 'start.company.list.delete' || $state.current.name === 'start.company.search.delete') ?\r\n                    companyService.company : $scope.initCompany;\r\n\r\n    $scope.verifyMinimumValidBeneficiary = function() {\r\n        for (var i = 0; i < $scope.company.beneficiaries.length; i++) {\r\n            $scope.minimumValidBeneficiary = $scope.company.beneficiaries[i].id !== -1 ||\r\n                                            (!utilService.isBlank($scope.company.beneficiaries[i].firstName) && !utilService.isBlank($scope.company.beneficiaries[i].lastName));\r\n            if ($scope.minimumValidBeneficiary) {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n\r\n    $scope.resetCompany = function() {\r\n        $timeout(function() {\r\n            $scope.company = $scope.initCompany;\r\n            $scope.companies = [];\r\n        });\r\n    };\r\n\r\n    $scope.addCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.addRequestSubmitted = false;\r\n        companyService.company = $scope.company;\r\n        if (utilService.isFormValid('companyDetailsForm')) {\r\n            $scope.verifyMinimumValidBeneficiary();\r\n            if (!$scope.minimumValidBeneficiary) {\r\n                $scope.registerPopoverShow('#addCompany');\r\n                return;\r\n            }\r\n            $log.info('valid');\r\n        } else {\r\n            $log.warn('form invalid');\r\n            return;\r\n        }\r\n\r\n        var companyCreateBlock = blockUI.instances.get('companyCreateBlock');\r\n        // companyCreateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        $scope.addRequestSubmitted = true;\r\n        companyService.createCompany(url, $scope.company, function(result) {\r\n            $timeout(function() {\r\n                if (result && result.data) {\r\n                    if (result.data.id > 0) {\r\n                        inform.add('Company created successfully.', {\r\n                            ttl: 2500\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.company', {}, {reload:true});\r\n                        }, 2500);\r\n                    } else {\r\n                        inform.add('Request completed, however company couldn\\'t be created.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating company.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.addRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // companyCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelAddCompany = function() {\r\n        $state.go('start.company');\r\n    };\r\n\r\n    $scope.updateCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.updateRequestSubmitted = false;\r\n        companyService.company = $scope.company;\r\n        if (utilService.isFormValid('companyUpdateForm')) {\r\n            $scope.verifyMinimumValidBeneficiary();\r\n            if (!$scope.minimumValidBeneficiary) {\r\n                $scope.registerPopoverShow('#updateCompany');\r\n                return;\r\n            }\r\n        } else {\r\n            $log.warn('form invalid');\r\n            return;\r\n        }\r\n\r\n        // var companyUpdateBlock = blockUI.instances.get('companyUpdateBlock');\r\n        // companyUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        $scope.updateRequestSubmitted = true;\r\n        companyService.updateCompany(url, $scope.company, function(result) {\r\n            $timeout(function() {\r\n                if (result && result.data) {\r\n                    if (result.data.status === true) {\r\n                        inform.add('Company updated successfully.', {\r\n                            ttl: 4000\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.company.list', {}, {reload: true});\r\n                        }, 4500);\r\n                    } else {\r\n                        inform.add('Request completed successfully, but no update performed on company.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Company couldn\\'t be updated.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.updateRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                // companyUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseCompanyUpdate = function() {\r\n        $state.go('start.company.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.deleteCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.company = companyService.company;\r\n        // var companyUpdateBlock = blockUI.instances.get('companyUpdateBlock');\r\n        // companyUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath + '/' + $scope.company.id;\r\n        companyService.deleteCompany(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.deleteRequestSubmitted = true;\r\n                if (result && result.data && result.data.status === true) {\r\n                    $scope.deleteSuccessful = true;\r\n                }\r\n                // companyUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseCompanyDelete = function() {\r\n        $scope.$dismiss();\r\n        $state.go('start.company.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.fetchCompany = function(id) {\r\n        $scope.companies.splice(0, $scope.companies.length);\r\n\r\n        var idSearch = !utilService.isBlank(id);\r\n        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        var url = idSearch ? baseUrl + '/' + id : baseUrl;\r\n        //var companyListBlock = blockUI.instances.get('companyListBlock');\r\n        //companyListBlock.start();\r\n        companyService.getCompany(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.searchRequestSumbitted = true;\r\n                if (result && result.data) {\r\n                    if (idSearch) {\r\n                        $scope.companies.push(result.data);\r\n                    } else {\r\n                        $scope.companies = result.data;\r\n                    }\r\n                    companyService.companies = $scope.companies;\r\n                    $scope.companyFound = true;\r\n                }\r\n                //companyListBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.searchCompany = function(id, $event) {\r\n        $event.stopPropagation();\r\n        $timeout(function() {\r\n            if (!utilService.isValidId(id)) {\r\n                $scope.registerPopoverShow('#searchExistingCompanyId');\r\n                return;\r\n            }\r\n            $scope.fetchCompany(id);\r\n        });\r\n    };\r\n\r\n    $scope.searchBeneficiary = function(id, $event) {\r\n        $event.stopPropagation();\r\n\r\n        if (!utilService.isValidId(id)) {\r\n            $scope.registerPopoverShow('#searchExistingBeneficiaryId');\r\n            return;\r\n        }\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + id;\r\n\r\n        var companySearchBlock = blockUI.instances.get('companySearchBlock');\r\n        companySearchBlock.start();\r\n        beneficiaryService.findBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.beneficiarySearched = true;\r\n                if (result && result.data) {\r\n                    $scope.verifyMinimumValidBeneficiary();\r\n                    // remove all empty forms\r\n                    if (!$scope.minimumValidBeneficiary) {\r\n                        $scope.company.beneficiaries.splice(0, $scope.company.beneficiaries.length);\r\n                    }\r\n                    $scope.company.beneficiaries.push(result.data);\r\n                    $scope.disableBeneficiary(result.data.id);\r\n                    $scope.minimumValidBeneficiary = true;\r\n                    $scope.beneficiaryFound = true;\r\n                    $scope.beneficiaryId = null;\r\n                }\r\n                companySearchBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.mutateCompanyOptions = function(company, $index, $event) {\r\n        $event.stopPropagation();\r\n        companyService.selectedCompanyId = '#company' + $index;\r\n        companyService.company = company;\r\n        $scope.registerPopoverPrep(companyService.selectedCompanyId);\r\n        $scope.registerPopoverShow(companyService.selectedCompanyId);\r\n    };\r\n\r\n    $scope.addBeneficiary = function() {\r\n        $scope.company.beneficiaries.push({\r\n            \"firstName\": \"\",\r\n            \"lastName\": \"\"\r\n        });\r\n    };\r\n\r\n    $scope.removeBeneficiary = function($event, beneficiary) {\r\n        $event.stopPropagation();\r\n        if ($scope.company.beneficiaries.indexOf(beneficiary) != -1) {\r\n            $timeout(function() {\r\n                if ($scope.company.beneficiaries.length === 1) {\r\n                    $scope.registerPopoverShow('#removeBeneficiary');\r\n                    return;\r\n                }\r\n                $scope.company.beneficiaries.splice($scope.company.beneficiaries.indexOf(beneficiary), 1);\r\n            });\r\n        }\r\n    };\r\n\r\n    $scope.disableBeneficiary = function(beneficiaryId) {\r\n        $rootScope.$emit('disableBeneficiary', {\r\n            beneficiaries: $scope.company.beneficiaries,\r\n            beneficiaryId: beneficiaryId\r\n        });\r\n    }\r\n\r\n    /* initialize popover */\r\n\r\n    $scope.discardMessage = function($event) {\r\n        $event ? $event.stopPropagation() : '';\r\n        companyService.popOnDelete = \"delete\";\r\n        $scope.registerPopoverHide('[id*=popover]');\r\n    };\r\n\r\n    companyService.popOnDelete = \"delete\";\r\n\r\n    $scope.registerPopoverPrep = function(id) {\r\n        angular.element($document.find(id)).popover({\r\n            trigger: 'manual'\r\n        });\r\n    };\r\n\r\n    $scope.registerPopoverShow = function(id) {\r\n        if (companyService.popOnDelete !== \"popover\") {\r\n            companyService.popOnDelete = \"popover\";\r\n            angular.element($document.find(id)).popover('show');\r\n        }\r\n    };\r\n\r\n    $scope.registerPopoverHide = function(id) {\r\n        var el = angular.element($document.find(id));\r\n        el ? el.popover('hide') : '';\r\n    };\r\n\r\n    $scope.registerPopoverPrep('#removeBeneficiary');\r\n    $scope.registerPopoverPrep('#addCompany');\r\n    $scope.registerPopoverPrep('#updateCompany');\r\n    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');\r\n    $scope.registerPopoverPrep('#searchExistingCompanyId');\r\n    $scope.registerPopoverHide('[id*=popover]');\r\n\r\n    // clear all informs\r\n    inform.clear();\r\n};\r\ncontroller.$inject = [\"$rootScope\", \"$scope\", \"$q\", \"$timeout\", \"$window\", \"$document\", \"$log\", \"$state\", \"$modal\", \"beneficiaryService\", \"companyService\", \"utilService\", \"blockUI\", \"inform\", \"CONSTANTS\"];\r\n\r\nexports.controller = controller;\r\n","/**\r\n * Main Company Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyView.html',\r\n        restrict: 'AE',\r\n        scope: false\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Side Nav View controller\r\n *\r\n * This controller is responsible for handing request from side nav\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function() {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n};\r\n\r\nexports.controller = controller;\r\n","/**\r\n * Side Nav Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/nav/SideNavView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'SideNavViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","var translationsEN = {\n    \"BENEFICIARY\": {\n        \"ID\": \"Id\",\n        \"FIRST_NAME\": \"First name\",\n        \"LAST_NAME\": \"Last name\"\n    }\n};\n\nexports.translationsEN = translationsEN;\n","'use strict';\r\n\r\nvar states = require('./components/common/States');\r\nvar configBlock = {\r\n    /**\r\n     * @param {$logProvider} The log provider service\r\n     * @param {$translateProvider} The angular translate service\r\n     * @ngInject\r\n     */\r\n    settings: [\"$logProvider\", \"$translateProvider\", function($logProvider, $translateProvider) {\r\n        $logProvider.debugEnabled(true); // Turns global logging with $log.debug on\r\n\r\n        var i18n_en = require('./components/nls/i18n-en');\r\n        $translateProvider.useSanitizeValueStrategy('sanitizeParameters');\r\n        $translateProvider.translations('en', i18n_en.translationsEN).useStaticFilesLoader({\r\n                files: [{\r\n                    prefix: './components/nls/i18n-',\r\n                    suffix: '.json'\r\n                }]\r\n            })\r\n            .preferredLanguage('en')\r\n            .fallbackLanguage('en');\r\n    }],\r\n    /**\r\n     * @param {$stateProvider} $stateProvider The UI router stateProvider service\r\n     * @param {$urlRouterProvider} The UI router urlRouterProvider service\r\n     * @param {$modalStateProvider} The custom modal state provider service\r\n     * @ngInject\r\n     */\r\n    states: [\"$stateProvider\", \"$urlRouterProvider\", function($stateProvider, $urlRouterProvider) {\r\n        $urlRouterProvider.otherwise('/');\r\n        $stateProvider\r\n            .state('start', states.stateConfig.main)\r\n            .state('start.company', states.stateConfig.company.initial)\r\n            .state('start.company.list', states.stateConfig.company.list)\r\n            .state('start.company.list.delete',  angular.copy(states.stateConfig.company.delete))\r\n            .state('start.company.search', states.stateConfig.company.search)\r\n            .state('start.company.search.delete', angular.copy(states.stateConfig.company.delete))\r\n            .state('start.company.update', states.stateConfig.company.update)\r\n            .state('start.beneficiary', states.stateConfig.beneficiary.initial)\r\n            .state('start.beneficiary.list', states.stateConfig.beneficiary.list)\r\n            .state('start.beneficiary.list.delete', angular.copy(states.stateConfig.beneficiary.delete))\r\n            .state('start.beneficiary.search', states.stateConfig.beneficiary.search)\r\n            .state('start.beneficiary.search.delete', angular.copy(states.stateConfig.beneficiary.delete))\r\n            .state('start.beneficiary.update', states.stateConfig.beneficiary.update)\r\n    }],\r\n\r\n    /**\r\n     * @param  {blockUIConfig} The block UI config service\r\n     * @ngInject\r\n     */\r\n    blockUI: [\"blockUIConfig\", function(blockUIConfig) {\r\n        blockUIConfig.delay = 100;\r\n        blockUIConfig.autoBlock = false;\r\n        blockUIConfig.autoInjectBodyBlock = false;\r\n        blockUIConfig.template = '<div><img src=\"dist/images/ajax-loader.gif\" /> Processing...</h1>';\r\n    }],\r\n\r\n    /**\r\n     * @param  {informProvider} The inform provider service\r\n     * @ngInject\r\n     */\r\n    inform: [\"informProvider\", function(informProvider) {\r\n        informProvider.defaults({\r\n            /**\r\n             * The time to live for the message in milliseconds.\r\n             * Default value is 5000. Specify <0 to make the message sticky.\r\n             */\r\n            ttl: -1,\r\n\r\n            /**\r\n             * The type of message to enable styling.\r\n             * Values can be 'default', 'primary', 'success', 'info', 'warning', 'danger' or any other custom required type.\r\n             * Default value is 'info'. If 'default' is specified as value, then 'info' is used\r\n             */\r\n            type: 'success',\r\n            /**\r\n             * Allow html formatting\r\n             * Default value is false\r\n             */\r\n            html: true\r\n        });\r\n    }],\r\n\r\n    /**\r\n     * Modal block\r\n     * @param  {$rootScope}  Angular root scope service\r\n     * @param  {$modalStack} Angular UI modal stack\r\n     * @ngInject\r\n     */\r\n    modal: [\"$rootScope\", \"$modalStack\", function($rootScope, $modalStack) {\r\n        $rootScope.$on('$stateChangeStart', function() {\r\n            var top = $modalStack.getTop();\r\n            if (top) {\r\n                $modalStack.dismiss(top.key);\r\n            }\r\n        });\r\n    }],\r\n\r\n    /**\r\n     * Href sanitization whitelist\r\n     * @param  {$compileProvide} Angular compile provider service\r\n     * @ngInject\r\n     */\r\n    hrefSanitize: [\"$compileProvider\", function($compileProvider) {\r\n        $compileProvider.aHrefSanitizationWhitelist(/^\\s*(https?|ftp|mailto|file|chrome-extension|blob:chrome-extension):/);\r\n    }],\r\n\r\n    namespace: 'com.companyregistry'\r\n};\r\n\r\nexports.configBlock = configBlock;\r\n","'use strict';\r\n\r\nexports.constants = {\r\n    url: {\r\n\t\t\t\thost: 'http://localhost',\r\n\t\t\t\tport: '8080',\r\n\t\t\t\tcontextRoot: 'companyregistry',\r\n        companyContextPath: 'companies',\r\n        beneficiaryContextPath: 'beneficiaries'\r\n    }\r\n};\r\n","/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* jshint ignore:start */\nvar noop        = angular.noop;\nvar extend      = angular.extend;\nvar jqLite      = angular.element;\nvar forEach     = angular.forEach;\nvar isArray     = angular.isArray;\nvar isString    = angular.isString;\nvar isObject    = angular.isObject;\nvar isUndefined = angular.isUndefined;\nvar isDefined   = angular.isDefined;\nvar isFunction  = angular.isFunction;\nvar isElement   = angular.isElement;\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar isPromiseLike = function(p) {\n  return p && p.then ? true : false;\n};\n\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return [];\n        break;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n        break;\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  }\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationOptions(element, target, newOptions) {\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof angular.element) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncancelled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\nvar $$AnimateChildrenDirective = [function() {\n  return function(scope, element, attrs) {\n    var val = attrs.ngAnimateChildren;\n    if (angular.isString(val) && val.length === 0) { //empty attribute\n      element.data(NG_ANIMATE_CHILDREN_DATA, true);\n    } else {\n      attrs.$observe('ngAnimateChildren', function(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      });\n    }\n  };\n}];\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and stlyes may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n * * `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occuring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a colapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for zegative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$animate',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $animate) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = \"$$ngAnimateParentKey\";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an interal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var cancelLastRAFRequest;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, options) {\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$animate.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle = parseFloat(options.delay);\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            value ? node.style.setProperty(prop, value)\n                  : node.style.removeProperty(prop);\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        var startTime, events = [];\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidently cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intential stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          element.on(events.join(' '), onAnimationProgress);\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n\n        function onAnimationProgress(event) {\n          event.stopPropagation();\n          var ev = event.originalEvent || event;\n          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();\n\n          /* Firefox (or possibly just Gecko) likes to not round values up\n           * when a ms measurement is used for the animation */\n          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n          /* $manualTimeStamp is a mocked timeStamp value which is set\n           * within browserTrigger(). This is only here so that tests can\n           * mock animations properly. Real events fallback to event.timeStamp,\n           * or, if they don't, then a timeStamp is automatically created for them.\n           * We're checking to see if the timeStamp surpasses the expected delay,\n           * but we're using elapsedTime instead of the timeStamp on the 2nd\n           * pre-condition since animations sometimes close off early */\n          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n            // we set this flag to ensure that if the transition is paused then, when resumed,\n            // the animation will automatically close itself since transitions cannot be paused.\n            animationCompleted = true;\n            close();\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragement case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coods object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      return {\n        start: function() {\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          var animationClosed = false;\n          var runner = new $$AnimateRunner({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            animationClosed = true;\n            applyOptions();\n            applyAnimationStyles(element, options);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(options, and) {\n    options = options || {};\n    var a = (options.addClass || '').length > 0;\n    var b = (options.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    var nO = newAnimation.options;\n    var cO = currentAnimation.options;\n\n    // if the exact same CSS class is added/removed then it's safe to cancel it\n    return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = {};\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationOptions(element, options) {\n      return mergeAnimationOptions(element, options, {});\n    }\n\n    function findCallbacks(element, event) {\n      var targetNode = getDomNode(element);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (entry.node.contains(targetNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    return {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n      },\n\n      off: function(event, container, callback) {\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n\n        function filterFromRegistry(list, matchContainer, matchCallback) {\n          var containerNode = extractElementNode(matchContainer);\n          return list.filter(function(entry) {\n            var isMatch = entry.node === containerNode &&\n                            (!matchCallback || entry.callback === matchCallback);\n            return !isMatch;\n          });\n        }\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n            var recordExists = disabledElementsLookup.get(node);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !recordExists;\n            } else {\n              // (element, bool) - Element setter\n              bool = !!bool;\n              if (!bool) {\n                disabledElementsLookup.put(node, true);\n              } else if (recordExists) {\n                disabledElementsLookup.remove(node);\n              }\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    function queueAnimation(element, event, options) {\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        close();\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationOptions(element, existingAnimation.options, options);\n            return existingAnimation.runner;\n          }\n        }\n\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationOptions(element, options);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationOptions(element, options);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation.options);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails.options));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n            });\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        switch (state) {\n          case RUNNING_STATE:\n            animationDetails.runner.end();\n            /* falls through */\n          case PRE_DIGEST_STATE:\n            if (animationDetails) {\n              activeAnimationsLookup.remove(child);\n            }\n            break;\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n\n      var parentHost = element.data(NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      while (parentElement && parentElement.length) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        var parentNode = parentElement[0];\n        if (parentNode.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentNode) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n          if (!rootElementDetected) {\n            parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);\n            if (parentHost) {\n              parentElement = parentHost;\n            }\n          }\n        }\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be apart of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        parentElement = parentElement.parent();\n      }\n\n      var allowAnimation = !parentAnimationDetected || animateChildren;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$AnimateAsyncRunFactory = ['$$rAF', function($$rAF) {\n  var waitQueue = [];\n\n  function waitForTick(fn) {\n    waitQueue.push(fn);\n    if (waitQueue.length > 1) return;\n    $$rAF(function() {\n      for (var i = 0; i < waitQueue.length; i++) {\n        waitQueue[i]();\n      }\n      waitQueue = [];\n    });\n  }\n\n  return function() {\n    var passed = false;\n    waitForTick(function() {\n      passed = true;\n    });\n    return function(callback) {\n      passed ? callback() : waitForTick(callback);\n    };\n  };\n}];\n\nvar $$AnimateRunnerFactory = ['$q', '$sniffer', '$$animateAsyncRun',\n                      function($q,   $sniffer,   $$animateAsyncRun) {\n\n  var INITIAL_STATE = 0;\n  var DONE_PENDING_STATE = 1;\n  var DONE_COMPLETE_STATE = 2;\n\n  AnimateRunner.chain = function(chain, callback) {\n    var index = 0;\n\n    next();\n    function next() {\n      if (index === chain.length) {\n        callback(true);\n        return;\n      }\n\n      chain[index](function(response) {\n        if (response === false) {\n          callback(false);\n          return;\n        }\n        index++;\n        next();\n      });\n    }\n  };\n\n  AnimateRunner.all = function(runners, callback) {\n    var count = 0;\n    var status = true;\n    forEach(runners, function(runner) {\n      runner.done(onProgress);\n    });\n\n    function onProgress(response) {\n      status = status && response;\n      if (++count === runners.length) {\n        callback(status);\n      }\n    }\n  };\n\n  function AnimateRunner(host) {\n    this.setHost(host);\n\n    this._doneCallbacks = [];\n    this._runInAnimationFrame = $$animateAsyncRun();\n    this._state = 0;\n  }\n\n  AnimateRunner.prototype = {\n    setHost: function(host) {\n      this.host = host || {};\n    },\n\n    done: function(fn) {\n      if (this._state === DONE_COMPLETE_STATE) {\n        fn();\n      } else {\n        this._doneCallbacks.push(fn);\n      }\n    },\n\n    progress: noop,\n\n    getPromise: function() {\n      if (!this.promise) {\n        var self = this;\n        this.promise = $q(function(resolve, reject) {\n          self.done(function(status) {\n            status === false ? reject() : resolve();\n          });\n        });\n      }\n      return this.promise;\n    },\n\n    then: function(resolveHandler, rejectHandler) {\n      return this.getPromise().then(resolveHandler, rejectHandler);\n    },\n\n    'catch': function(handler) {\n      return this.getPromise()['catch'](handler);\n    },\n\n    'finally': function(handler) {\n      return this.getPromise()['finally'](handler);\n    },\n\n    pause: function() {\n      if (this.host.pause) {\n        this.host.pause();\n      }\n    },\n\n    resume: function() {\n      if (this.host.resume) {\n        this.host.resume();\n      }\n    },\n\n    end: function() {\n      if (this.host.end) {\n        this.host.end();\n      }\n      this._resolve(true);\n    },\n\n    cancel: function() {\n      if (this.host.cancel) {\n        this.host.cancel();\n      }\n      this._resolve(false);\n    },\n\n    complete: function(response) {\n      var self = this;\n      if (self._state === INITIAL_STATE) {\n        self._state = DONE_PENDING_STATE;\n        self._runInAnimationFrame(function() {\n          self._resolve(response);\n        });\n      }\n    },\n\n    _resolve: function(response) {\n      if (this._state !== DONE_COMPLETE_STATE) {\n        forEach(this._doneCallbacks, function(fn) {\n          fn(response);\n        });\n        this._doneCallbacks.length = 0;\n        this._state = DONE_COMPLETE_STATE;\n      }\n    }\n  };\n\n  return AnimateRunner;\n}];\n\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effictively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check\n\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          getRunner(element).setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/* global angularAnimateModule: true,\n\n   $$AnimateAsyncRunFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateRunnerFactory,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,\n*/\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=true\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the ainmation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       }).start();\n*        runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       }).start();\n *\n *       runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n *\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix\n * will be evaluated for animation when any DOM changes occur in the application.\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [])\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .factory('$$AnimateRunner', $$AnimateRunnerFactory)\n  .factory('$$animateAsyncRun', $$AnimateAsyncRunFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n","require('./angular-animate');\nmodule.exports = 'ngAnimate';\n","/*!\n   angular-block-ui v0.2.0\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\n   License: MIT\n*/\n(function(angular) {\n\nvar blkUI = angular.module('blockUI', []);\n\nblkUI.config([\"$provide\", \"$httpProvider\", function ($provide, $httpProvider) {\n\n  $provide.decorator('$exceptionHandler', ['$delegate', '$injector',\n    function ($delegate, $injector) {\n      var blockUI, blockUIConfig;\n\n      return function (exception, cause) {\n\n        blockUIConfig = blockUIConfig || $injector.get('blockUIConfig');\n\n        if (blockUIConfig.resetOnException) {\n          try {\n            blockUI = blockUI || $injector.get('blockUI');\n            blockUI.instances.reset();\n          } catch (ex) {\n            console.log('$exceptionHandler', exception);\n          }\n        }\n\n        $delegate(exception, cause);\n      };\n    }\n  ]);\n\n  $httpProvider.interceptors.push('blockUIHttpInterceptor');\n}]);\n\nblkUI.run([\"$document\", \"blockUIConfig\", \"$templateCache\", function ($document, blockUIConfig, $templateCache) {\n  if (blockUIConfig.autoInjectBodyBlock) {\n    $document.find('body').attr('block-ui', 'main');\n  }\n\n  if (blockUIConfig.template) {\n\n    // Swap the builtin template with the custom template.\n    // Create a magic cache key and place the template in the cache.\n\n    blockUIConfig.templateUrl = '$$block-ui-template$$';\n    $templateCache.put(blockUIConfig.templateUrl, blockUIConfig.template);\n  }\n}]);\n\nfunction moduleLoaded(name) {\n  try {\n    angular.module(name);\n  } catch(ex) {\n    return false;\n  }\n  return true;\n}\nblkUI.config([\"$provide\", function ($provide) {\n  $provide.decorator('$location', decorateLocation);\n}]);\n\nvar decorateLocation = [\n  '$delegate', 'blockUI', 'blockUIConfig',\n  function ($delegate, blockUI, blockUIConfig) {\n\n    if (blockUIConfig.blockBrowserNavigation) {\n\n      blockUI.$_blockLocationChange = true;\n\n      var overrides = ['url', 'path', 'search', 'hash', 'state'];\n\n      function hook(f) {\n        var s = $delegate[f];\n        $delegate[f] = function () {\n\n          //        console.log(f, Date.now(), arguments);\n\n          var result = s.apply($delegate, arguments);\n\n          // The call was a setter if the $location service is returned.\n\n          if (result === $delegate) {\n\n            // Mark the mainblock ui to allow the location change.\n\n            blockUI.$_blockLocationChange = false;\n          }\n\n          return result;\n        };\n      }\n\n      angular.forEach(overrides, hook);\n\n    }\n\n    return $delegate;\n}];\n\n// Called from block-ui-directive for the 'main' instance.\n\nfunction blockNavigation($scope, mainBlockUI, blockUIConfig) {\n\n  if (blockUIConfig.blockBrowserNavigation) {\n\n    function registerLocationChange() {\n\n      $scope.$on('$locationChangeStart', function (event) {\n\n        //        console.log('$locationChangeStart', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);\n\n        if (mainBlockUI.$_blockLocationChange && mainBlockUI.state().blockCount > 0) {\n          event.preventDefault();\n        }\n      });\n\n      $scope.$on('$locationChangeSuccess', function () {\n        mainBlockUI.$_blockLocationChange = blockUIConfig.blockBrowserNavigation;\n\n        //        console.log('$locationChangeSuccess', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);\n      });\n    }\n\n    if (moduleLoaded('ngRoute')) {\n\n      // After the initial content has been loaded we'll spy on any location\n      // changes and discard them when needed.\n\n      var fn = $scope.$on('$viewContentLoaded', function () {\n\n        // Unhook the view loaded and hook a function that will prevent\n        // location changes while the block is active.\n\n        fn();\n        registerLocationChange();\n\n      });\n\n    } else {\n      registerLocationChange();\n    }\n\n  }\n}\nblkUI.directive('blockUiContainer', [\"blockUIConfig\", \"blockUiContainerLinkFn\", function (blockUIConfig, blockUiContainerLinkFn) {\n  return {\n    scope: true,\n    restrict: 'A',\n    templateUrl: blockUIConfig.templateUrl,\n    compile: function($element) {\n      return blockUiContainerLinkFn;\n    }\n  };\n}]).factory('blockUiContainerLinkFn', [\"blockUI\", \"blockUIUtils\", function (blockUI, blockUIUtils) {\n\n  return function ($scope, $element, $attrs) {\n\n    var srvInstance = $element.inheritedData('block-ui');\n\n    if (!srvInstance) {\n      throw new Error('No parent block-ui service instance located.');\n    }\n\n    // Expose the state on the scope\n\n    $scope.state = srvInstance.state();\n\n//    $scope.$watch('state.blocking', function(value) {\n//      $element.toggleClass('block-ui-visible', !!value);\n//    });\n//\n//    $scope.$watch('state.blockCount > 0', function(value) {\n//      $element.toggleClass('block-ui-active', !!value);\n//    });\n  };\n}]);\nblkUI.directive('blockUi', [\"blockUiCompileFn\", function (blockUiCompileFn) {\n\n  return {\n    scope: true,\n    restrict: 'A',\n    compile: blockUiCompileFn\n  };\n\n}]).factory('blockUiCompileFn', [\"blockUiPreLinkFn\", function (blockUiPreLinkFn) {\n\n  return function ($element, $attrs) {\n\n    // Class should be added here to prevent an animation delay error.\n\n    $element.append('<div block-ui-container class=\"block-ui-container\"></div>');\n\n    return {\n      pre: blockUiPreLinkFn\n    };\n\n  };\n\n}]).factory('blockUiPreLinkFn', [\"blockUI\", \"blockUIUtils\", \"blockUIConfig\", function (blockUI, blockUIUtils, blockUIConfig) {\n\n  return function ($scope, $element, $attrs) {\n\n    // If the element does not have the class \"block-ui\" set, we set the\n    // default css classes from the config.\n\n    if (!$element.hasClass('block-ui')) {\n      $element.addClass(blockUIConfig.cssClass);\n    }\n\n    // Expose the blockUiMessageClass attribute value on the scope\n\n    $attrs.$observe('blockUiMessageClass', function (value) {\n      $scope.$_blockUiMessageClass = value;\n    });\n\n    // Create the blockUI instance\n    // Prefix underscore to prevent integers:\n    // https://github.com/McNull/angular-block-ui/pull/8\n\n    var instanceId = $attrs.blockUi || '_' + $scope.$id;\n    var srvInstance = blockUI.instances.get(instanceId);\n\n    // If this is the main (topmost) block element we'll also need to block any\n    // location changes while the block is active.\n\n    if (instanceId === 'main') {\n      blockNavigation($scope, srvInstance, blockUIConfig);\n    } else {\n      // Locate the parent blockUI instance\n      var parentInstance = $element.inheritedData('block-ui');\n\n      if (parentInstance) {\n        // TODO: assert if parent is already set to something else\n        srvInstance._parent = parentInstance;\n      }\n    }\n\n    // Ensure the instance is released when the scope is destroyed\n\n    $scope.$on('$destroy', function () {\n      srvInstance.release();\n    });\n\n    // Increase the reference count\n\n    srvInstance.addRef();\n\n    // Expose the state on the scope\n\n    $scope.$_blockUiState = srvInstance.state();\n\n    $scope.$watch('$_blockUiState.blocking', function (value) {\n      // Set the aria-busy attribute if needed\n      $element.attr('aria-busy', !!value);\n      $element.toggleClass('block-ui-visible', !!value);\n    });\n\n    $scope.$watch('$_blockUiState.blockCount > 0', function (value) {\n      $element.toggleClass('block-ui-active', !!value);\n    });\n\n    // If a pattern is provided assign it to the state\n\n    var pattern = $attrs.blockUiPattern;\n\n    if (pattern) {\n      var regExp = blockUIUtils.buildRegExp(pattern);\n      srvInstance.pattern(regExp);\n    }\n\n    // Store a reference to the service instance on the element\n\n    $element.data('block-ui', srvInstance);\n\n  };\n\n}]);\n//.factory('blockUiPostLinkFn', function(blockUIUtils) {\n//\n//  return function($scope, $element, $attrs) {\n//\n//    var $message;\n//\n//    $attrs.$observe('blockUiMessageClass', function(value) {\n//\n//      $message = $message || blockUIUtils.findElement($element, function($e) {\n//        return $e.hasClass('block-ui-message');\n//      });\n//\n//      $message.addClass(value);\n//\n//    });\n//  };\n//\n//});\nblkUI.constant('blockUIConfig', {\n    templateUrl: 'angular-block-ui/angular-block-ui.ng.html',\n    delay: 250,\n    message: \"Loading ...\",\n    autoBlock: true,\n    resetOnException: true,\n    requestFilter: angular.noop,\n    autoInjectBodyBlock: true,\n    cssClass: 'block-ui block-ui-anim-fade',\n    blockBrowserNavigation: false\n});\n\n\nblkUI.factory('blockUIHttpInterceptor', [\"$q\", \"$injector\", \"blockUIConfig\", \"$templateCache\", function($q, $injector, blockUIConfig, $templateCache) {\n\n  var blockUI;\n\n  function injectBlockUI() {\n    blockUI = blockUI || $injector.get('blockUI');\n  }\n\n  function stopBlockUI(config) {\n    if (blockUIConfig.autoBlock && (config && !config.$_noBlock && config.$_blocks)) {\n      injectBlockUI();\n      config.$_blocks.stop();\n    }\n  }\n\n  function error(rejection) {\n\n    try {\n      stopBlockUI(rejection.config);\n    } catch(ex) {\n      console.log('httpRequestError', ex);\n    }\n\n    return $q.reject(rejection);\n  }\n\n  return {\n    request: function(config) {\n\n      // Only block when autoBlock is enabled ...\n      // ... and the request doesn't match a cached template.\n\n      if (blockUIConfig.autoBlock &&\n        !(config.method == 'GET' && $templateCache.get(config.url))) {\n\n        // Don't block excluded requests\n\n        var result = blockUIConfig.requestFilter(config);\n\n        if (result === false) {\n          // Tag the config so we don't unblock this request\n          config.$_noBlock = true;\n        } else {\n\n          injectBlockUI();\n\n          config.$_blocks = blockUI.instances.locate(config);\n          config.$_blocks.start(result);\n        }\n      }\n\n      return config;\n    },\n\n    requestError: error,\n\n    response: function(response) {\n\n      // If the connection to the website goes down the response interceptor gets and error with \"cannot read property config of null\".\n      // https://github.com/McNull/angular-block-ui/issues/53\n\n      if(response) {\n        stopBlockUI(response.config);\n      }\n\n      return response;\n    },\n\n    responseError: error\n  };\n\n}]);\n\nblkUI.factory('blockUI', [\"blockUIConfig\", \"$timeout\", \"blockUIUtils\", \"$document\", function(blockUIConfig, $timeout, blockUIUtils, $document) {\n\n  var $body = $document.find('body');\n\n  function BlockUI(id) {\n\n    var self = this;\n\n    var state = {\n      id: id,\n      blockCount: 0,\n      message: blockUIConfig.message,\n      blocking: false\n    }, startPromise, doneCallbacks = [];\n\n    this._id = id;\n\n    this._refs = 0;\n\n    this.start = function(message) {\n\n      if(state.blockCount > 0) {\n        message = message || state.message || blockUIConfig.message;\n      } else {\n        message = message || blockUIConfig.message;\n      }\n\n      state.message = message;\n\n      state.blockCount++;\n\n      // Check if the focused element is part of the block scope\n\n      var $ae = angular.element($document[0].activeElement);\n\n      if($ae.length && blockUIUtils.isElementInBlockScope($ae, self)) {\n\n        // Let the active element lose focus and store a reference \n        // to restore focus when we're done (reset)\n\n        self._restoreFocus = $ae[0];\n\n        // https://github.com/McNull/angular-block-ui/issues/13\n        // http://stackoverflow.com/questions/22698058/apply-already-in-progress-error-when-using-typeahead-plugin-found-to-be-relate\n        // Queue the blur after any ng-blur expression.\n\n        $timeout(function() {\n          // Ensure we still need to blur\n          if(self._restoreFocus) {\n            self._restoreFocus.blur();\n          }\n        });\n      }\n\n      if (!startPromise) {\n        startPromise = $timeout(function() {\n          startPromise = null;\n          state.blocking = true;\n        }, blockUIConfig.delay);\n      }\n    };\n\n    this._cancelStartTimeout = function() {\n      if (startPromise) {\n        $timeout.cancel(startPromise);\n        startPromise = null;\n      }\n    };\n\n    this.stop = function() {\n      state.blockCount = Math.max(0, --state.blockCount);\n\n      if (state.blockCount === 0) {\n        self.reset(true);\n      }\n    };\n\n    this.message = function(value) {\n      state.message = value;\n    };\n\n    this.pattern = function(regexp) {\n      if (regexp !== undefined) {\n        self._pattern = regexp;\n      }\n\n      return self._pattern;\n    };\n\n    this.reset = function(executeCallbacks) {\n      \n      self._cancelStartTimeout();\n      state.blockCount = 0;\n      state.blocking = false;\n\n      // Restore the focus to the element that was active\n      // before the block start, but not if the user has \n      // focused something else while the block was active.\n\n      if(self._restoreFocus && \n         (!$document[0].activeElement || $document[0].activeElement === $body[0])) {\n        self._restoreFocus.focus();\n        self._restoreFocus = null;\n      }\n      \n      try {\n        if (executeCallbacks) {\n          angular.forEach(doneCallbacks, function(cb) {\n            cb();\n          });\n        }\n      } finally {\n        doneCallbacks.length = 0;\n      }\n    };\n\n    this.done = function(fn) {\n      doneCallbacks.push(fn);\n    };\n\n    this.state = function() {\n      return state;\n    };\n\n    this.addRef = function() {\n      self._refs += 1;\n    };\n\n    this.release = function() {\n      if(--self._refs <= 0) {\n        mainBlock.instances._destroy(self);\n      }\n    };\n  }\n\n  var instances = [];\n\n  instances.get = function(id) {\n\n    if(!isNaN(id)) {\n      throw new Error('BlockUI id cannot be a number');\n    }\n\n    var instance = instances[id];\n\n    if(!instance) {\n      // TODO: ensure no array instance trashing [xxx] -- current workaround: '_' + $scope.$id\n      instance = instances[id] = new BlockUI(id);\n      instances.push(instance);\n    }\n\n    return instance;\n  };\n\n  instances._destroy = function(idOrInstance) {\n    if (angular.isString(idOrInstance)) {\n      idOrInstance = instances[idOrInstance];\n    }\n\n    if (idOrInstance) {\n      idOrInstance.reset();\n\n      var i = blockUIUtils.indexOf(instances, idOrInstance);\n      instances.splice(i, 1);\n\n      delete instances[idOrInstance.state().id];\n    }\n  };\n  \n  instances.locate = function(request) {\n\n    var result = [];\n\n    // Add function wrappers that will be executed on every item\n    // in the array.\n    \n    blockUIUtils.forEachFnHook(result, 'start');\n    blockUIUtils.forEachFnHook(result, 'stop');\n\n    var i = instances.length;\n\n    while(i--) {\n      var instance = instances[i];\n      var pattern = instance._pattern;\n\n      if(pattern && pattern.test(request.url)) {\n        result.push(instance);\n      }\n    }\n\n    if(result.length === 0) {\n      result.push(mainBlock);\n    }\n\n    return result;\n  };\n\n  // Propagate the reset to all instances\n\n  blockUIUtils.forEachFnHook(instances, 'reset');\n\n  var mainBlock = instances.get('main');\n\n  mainBlock.addRef();\n  mainBlock.instances = instances;\n\n  return mainBlock;\n}]);\n\n\nblkUI.factory('blockUIUtils', function() {\n\n  var $ = angular.element;\n\n  var utils = {\n    buildRegExp: function(pattern) {\n      var match = pattern.match(/^\\/(.*)\\/([gim]*)$/), regExp;\n\n      if(match) {\n        regExp = new RegExp(match[1], match[2]);\n      } else {\n        throw Error('Incorrect regular expression format: ' + pattern);\n      }\n\n      return regExp;\n    },\n    forEachFn: function(arr, fnName, args) {\n      var i = arr.length;\n      while(i--) {\n        var t = arr[i];\n        t[fnName].apply(t, args);\n      }\n    },\n    forEachFnHook: function(arr, fnName) {\n      arr[fnName] = function() {\n        utils.forEachFn(this, fnName, arguments);\n      }\n    },\n    isElementInBlockScope: function($element, blockScope) {\n      var c = $element.inheritedData('block-ui');\n\n      while(c) {\n        if(c === blockScope) {\n          return true;\n        }\n\n        c = c._parent;\n      }\n\n      return false;\n    },\n    findElement: function ($element, predicateFn, traverse) {\n      var ret = null;\n\n      if (predicateFn($element)) {\n        ret = $element;\n      } else {\n\n        var $elements;\n\n        if (traverse) {\n          $elements = $element.parent();\n        } else {\n          $elements = $element.children();\n        }\n\n        var i = $elements.length;\n        while (!ret && i--) {\n          ret = utils.findElement($($elements[i]), predicateFn, traverse);\n        }\n      }\n\n      return ret;\n    },\n    indexOf: function(arr, obj, start) {\n//      if(Array.prototype.indexOf) {\n//        return arr.indexOf(obj, start);\n//      }\n\n      for (var i = (start || 0), j = arr.length; i < j; i++) {\n        if (arr[i] === obj) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  };\n\n  return utils;\n\n});\n// Automatically generated.\n// This file is already embedded in your main javascript output, there's no need to include this file\n// manually in the index.html. This file is only here for your debugging pleasures.\nangular.module('blockUI').run(['$templateCache', function($templateCache){\n  $templateCache.put('angular-block-ui/angular-block-ui.ng.html', '<div class=\\\"block-ui-overlay\\\"></div><div class=\\\"block-ui-message-container\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\"><div class=\\\"block-ui-message\\\" ng-class=\\\"$_blockUiMessageClass\\\">{{ state.message }}</div></div>');\n}]);\n})(angular);\nif (typeof module !== \"undefined\") module.exports = \"blockUI\";\n//# sourceMappingURL=angular-block-ui.js.map\n","var css = \"/*!\\n   angular-block-ui v0.2.0\\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\\n   License: MIT\\n*/\\n.block-ui {\\n  position: relative;\\n}\\nbody.block-ui {\\n  position: static;\\n}\\n.block-ui-main>.block-ui-container,\\nbody.block-ui>.block-ui-container {\\n  position: fixed;\\n}\\n.block-ui-container {\\n  position: absolute;\\n  z-index: 10000;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n  height: 0;\\n  overflow: hidden;\\n  opacity: 0;\\n  filter: alpha(opacity=00);\\n}\\n.block-ui-active>.block-ui-container {\\n  height: 100%;\\n  cursor: wait;\\n}\\n.block-ui-active .block-ui-active>.block-ui-container {\\n  height: 0;\\n}\\n.block-ui-visible>.block-ui-container {\\n  opacity: 1;\\n  filter: alpha(opacity=100);\\n}\\n.block-ui-overlay {\\n  width: 100%;\\n  height: 100%;\\n  opacity: .5;\\n  filter: alpha(opacity=50);\\n  background-color: #fff;\\n}\\n.block-ui-message-container {\\n  position: absolute;\\n  top: 35%;\\n  left: 0;\\n  right: 0;\\n  height: 0;\\n  text-align: center;\\n  z-index: 10001;\\n}\\n.block-ui-message {\\n  display: inline-block;\\n  text-align: left;\\n  background-color: #333;\\n  color: #f5f5f5;\\n  padding: 20px;\\n  border-radius: 4px;\\n  font-size: 20px;\\n  font-weight: 700;\\n  filter: alpha(opacity=100);\\n}\\n.block-ui-anim-fade>.block-ui-container {\\n  -webkit-transition: height 0s linear 200ms,opacity 200ms ease 0s;\\n  transition: height 0s linear 200ms,opacity 200ms ease 0s;\\n}\\n.block-ui-anim-fade.block-ui-active>.block-ui-container {\\n  -webkit-transition-delay: 0s;\\n  transition-delay: 0s;\\n}\\n\"; (require(\"browserify-css\").createStyle(css, { \"href\": \"node_modules\\\\angular-block-ui\\\\dist\\\\angular-block-ui.min.css\"})); module.exports = css;","/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $sanitizeMinErr = angular.$$minErr('$sanitize');\n\n/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n\n/*\n * HTML Parser By Misko Hevery (misko@hevery.com)\n * based on:  HTML Parser By John Resig (ejohn.org)\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n *\n * // Use like so:\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n */\n\n\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string, however, since our parser is more strict than a typical browser\n *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a\n *   browser, won't make it through the sanitizer. The input may also contain SVG markup.\n *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and\n *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getInnerHtml()).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\nfunction $SanitizeProvider() {\n  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n    return function(html) {\n      var buf = [];\n      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n        return !/^unsafe/.test($$sanitizeUri(uri, isImage));\n      }));\n      return buf.join('');\n    };\n  }];\n}\n\nfunction sanitizeText(chars) {\n  var buf = [];\n  var writer = htmlSanitizeWriter(buf, angular.noop);\n  writer.chars(chars);\n  return buf.join('');\n}\n\n\n// Regular Expressions for parsing tags and attributes\nvar START_TAG_REGEXP =\n       /^<((?:[a-zA-Z])[\\w:-]*)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)\\s*(>?)/,\n  END_TAG_REGEXP = /^<\\/\\s*([\\w:-]+)[^>]*>/,\n  ATTR_REGEXP = /([\\w:-]+)(?:\\s*=\\s*(?:(?:\"((?:[^\"])*)\")|(?:'((?:[^'])*)')|([^>\\s]+)))?/g,\n  BEGIN_TAG_REGEXP = /^</,\n  BEGING_END_TAGE_REGEXP = /^<\\//,\n  COMMENT_REGEXP = /<!--(.*?)-->/g,\n  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,\n  CDATA_REGEXP = /<!\\[CDATA\\[(.*?)]]>/g,\n  SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n  // Match everything outside of normal chars and \" (quote character)\n  NON_ALPHANUMERIC_REGEXP = /([^\\#-~| |!])/g;\n\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\nvar voidElements = makeMap(\"area,br,col,hr,img,wbr\");\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\nvar optionalEndTagBlockElements = makeMap(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),\n    optionalEndTagInlineElements = makeMap(\"rp,rt\"),\n    optionalEndTagElements = angular.extend({},\n                                            optionalEndTagInlineElements,\n                                            optionalEndTagBlockElements);\n\n// Safe Block Elements - HTML5\nvar blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap(\"address,article,\" +\n        \"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,\" +\n        \"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul\"));\n\n// Inline Elements - HTML5\nvar inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap(\"a,abbr,acronym,b,\" +\n        \"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,\" +\n        \"samp,small,span,strike,strong,sub,sup,time,tt,u,var\"));\n\n// SVG Elements\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n// They can potentially allow for arbitrary javascript to be executed. See #11290\nvar svgElements = makeMap(\"circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,\" +\n        \"hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,\" +\n        \"radialGradient,rect,stop,svg,switch,text,title,tspan,use\");\n\n// Special Elements (can contain anything)\nvar specialElements = makeMap(\"script,style\");\n\nvar validElements = angular.extend({},\n                                   voidElements,\n                                   blockElements,\n                                   inlineElements,\n                                   optionalEndTagElements,\n                                   svgElements);\n\n//Attributes that have href and hence need to be sanitized\nvar uriAttrs = makeMap(\"background,cite,href,longdesc,src,usemap,xlink:href\");\n\nvar htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n    'valign,value,vspace,width');\n\n// SVG attributes (without \"id\" and \"name\" attributes)\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\nvar svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +\n    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\nvar validAttrs = angular.extend({},\n                                uriAttrs,\n                                svgAttrs,\n                                htmlAttrs);\n\nfunction makeMap(str, lowercaseKeys) {\n  var obj = {}, items = str.split(','), i;\n  for (i = 0; i < items.length; i++) {\n    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;\n  }\n  return obj;\n}\n\n\n/**\n * @example\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n * @param {string} html string\n * @param {object} handler\n */\nfunction htmlParser(html, handler) {\n  if (typeof html !== 'string') {\n    if (html === null || typeof html === 'undefined') {\n      html = '';\n    } else {\n      html = '' + html;\n    }\n  }\n  var index, chars, match, stack = [], last = html, text;\n  stack.last = function() { return stack[stack.length - 1]; };\n\n  while (html) {\n    text = '';\n    chars = true;\n\n    // Make sure we're not in a script or style element\n    if (!stack.last() || !specialElements[stack.last()]) {\n\n      // Comment\n      if (html.indexOf(\"<!--\") === 0) {\n        // comments containing -- are not allowed unless they terminate the comment\n        index = html.indexOf(\"--\", 4);\n\n        if (index >= 0 && html.lastIndexOf(\"-->\", index) === index) {\n          if (handler.comment) handler.comment(html.substring(4, index));\n          html = html.substring(index + 3);\n          chars = false;\n        }\n      // DOCTYPE\n      } else if (DOCTYPE_REGEXP.test(html)) {\n        match = html.match(DOCTYPE_REGEXP);\n\n        if (match) {\n          html = html.replace(match[0], '');\n          chars = false;\n        }\n      // end tag\n      } else if (BEGING_END_TAGE_REGEXP.test(html)) {\n        match = html.match(END_TAG_REGEXP);\n\n        if (match) {\n          html = html.substring(match[0].length);\n          match[0].replace(END_TAG_REGEXP, parseEndTag);\n          chars = false;\n        }\n\n      // start tag\n      } else if (BEGIN_TAG_REGEXP.test(html)) {\n        match = html.match(START_TAG_REGEXP);\n\n        if (match) {\n          // We only have a valid start-tag if there is a '>'.\n          if (match[4]) {\n            html = html.substring(match[0].length);\n            match[0].replace(START_TAG_REGEXP, parseStartTag);\n          }\n          chars = false;\n        } else {\n          // no ending tag found --- this piece should be encoded as an entity.\n          text += '<';\n          html = html.substring(1);\n        }\n      }\n\n      if (chars) {\n        index = html.indexOf(\"<\");\n\n        text += index < 0 ? html : html.substring(0, index);\n        html = index < 0 ? \"\" : html.substring(index);\n\n        if (handler.chars) handler.chars(decodeEntities(text));\n      }\n\n    } else {\n      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\\W\\w].\n      html = html.replace(new RegExp(\"([\\\\W\\\\w]*)<\\\\s*\\\\/\\\\s*\" + stack.last() + \"[^>]*>\", 'i'),\n        function(all, text) {\n          text = text.replace(COMMENT_REGEXP, \"$1\").replace(CDATA_REGEXP, \"$1\");\n\n          if (handler.chars) handler.chars(decodeEntities(text));\n\n          return \"\";\n      });\n\n      parseEndTag(\"\", stack.last());\n    }\n\n    if (html == last) {\n      throw $sanitizeMinErr('badparse', \"The sanitizer was unable to parse the following block \" +\n                                        \"of html: {0}\", html);\n    }\n    last = html;\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function parseStartTag(tag, tagName, rest, unary) {\n    tagName = angular.lowercase(tagName);\n    if (blockElements[tagName]) {\n      while (stack.last() && inlineElements[stack.last()]) {\n        parseEndTag(\"\", stack.last());\n      }\n    }\n\n    if (optionalEndTagElements[tagName] && stack.last() == tagName) {\n      parseEndTag(\"\", tagName);\n    }\n\n    unary = voidElements[tagName] || !!unary;\n\n    if (!unary) {\n      stack.push(tagName);\n    }\n\n    var attrs = {};\n\n    rest.replace(ATTR_REGEXP,\n      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {\n        var value = doubleQuotedValue\n          || singleQuotedValue\n          || unquotedValue\n          || '';\n\n        attrs[name] = decodeEntities(value);\n    });\n    if (handler.start) handler.start(tagName, attrs, unary);\n  }\n\n  function parseEndTag(tag, tagName) {\n    var pos = 0, i;\n    tagName = angular.lowercase(tagName);\n    if (tagName) {\n      // Find the closest opened tag of the same type\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos] == tagName) break;\n      }\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (i = stack.length - 1; i >= pos; i--)\n        if (handler.end) handler.end(stack[i]);\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n    }\n  }\n}\n\nvar hiddenPre=document.createElement(\"pre\");\n/**\n * decodes all entities into regular string\n * @param value\n * @returns {string} A string with decoded entities.\n */\nfunction decodeEntities(value) {\n  if (!value) { return ''; }\n\n  hiddenPre.innerHTML = value.replace(/</g,\"&lt;\");\n  // innerText depends on styling as it doesn't display hidden elements.\n  // Therefore, it's better to use textContent not to cause unnecessary reflows.\n  return hiddenPre.textContent;\n}\n\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n * @returns {string} escaped text\n */\nfunction encodeEntities(value) {\n  return value.\n    replace(/&/g, '&amp;').\n    replace(SURROGATE_PAIR_REGEXP, function(value) {\n      var hi = value.charCodeAt(0);\n      var low = value.charCodeAt(1);\n      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n    }).\n    replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n      return '&#' + value.charCodeAt(0) + ';';\n    }).\n    replace(/</g, '&lt;').\n    replace(/>/g, '&gt;');\n}\n\n/**\n * create an HTML/XML writer which writes to buffer\n * @param {Array} buf use buf.jain('') to get out sanitized html string\n * @returns {object} in the form of {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * }\n */\nfunction htmlSanitizeWriter(buf, uriValidator) {\n  var ignore = false;\n  var out = angular.bind(buf, buf.push);\n  return {\n    start: function(tag, attrs, unary) {\n      tag = angular.lowercase(tag);\n      if (!ignore && specialElements[tag]) {\n        ignore = tag;\n      }\n      if (!ignore && validElements[tag] === true) {\n        out('<');\n        out(tag);\n        angular.forEach(attrs, function(value, key) {\n          var lkey=angular.lowercase(key);\n          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n          if (validAttrs[lkey] === true &&\n            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n            out(' ');\n            out(key);\n            out('=\"');\n            out(encodeEntities(value));\n            out('\"');\n          }\n        });\n        out(unary ? '/>' : '>');\n      }\n    },\n    end: function(tag) {\n        tag = angular.lowercase(tag);\n        if (!ignore && validElements[tag] === true) {\n          out('</');\n          out(tag);\n          out('>');\n        }\n        if (tag == ignore) {\n          ignore = false;\n        }\n      },\n    chars: function(chars) {\n        if (!ignore) {\n          out(encodeEntities(chars));\n        }\n      }\n  };\n}\n\n\n// define ngSanitize module and register $sanitize service\nangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n/* global sanitizeText: false */\n\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.\n * @returns {string} Html-linkified text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n       <script>\n         angular.module('linkyExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', function($scope) {\n             $scope.snippet =\n               'Pretty text with some links:\\n'+\n               'http://angularjs.org/,\\n'+\n               'mailto:us@somewhere.org,\\n'+\n               'another@somewhere.org,\\n'+\n               'and one more: ftp://127.0.0.1/.';\n             $scope.snippetWithTarget = 'http://angularjs.org/';\n           }]);\n       </script>\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Filter</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithTarget | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n     </file>\n   </example>\n */\nangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n  var LINKY_URL_REGEXP =\n        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n      MAILTO_REGEXP = /^mailto:/i;\n\n  return function(text, target) {\n    if (!text) return text;\n    var match;\n    var raw = text;\n    var html = [];\n    var url;\n    var i;\n    while ((match = raw.match(LINKY_URL_REGEXP))) {\n      // We can not end in these as they are sometimes found at the end of the sentence\n      url = match[0];\n      // if we did not match ftp/http/www/mailto then assume mailto\n      if (!match[2] && !match[4]) {\n        url = (match[3] ? 'http://' : 'mailto:') + url;\n      }\n      i = match.index;\n      addText(raw.substr(0, i));\n      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n      raw = raw.substring(i + match[0].length);\n    }\n    addText(raw);\n    return $sanitize(html.join(''));\n\n    function addText(text) {\n      if (!text) {\n        return;\n      }\n      html.push(sanitizeText(text));\n    }\n\n    function addLink(url, text) {\n      html.push('<a ');\n      if (angular.isDefined(target)) {\n        html.push('target=\"',\n                  target,\n                  '\" ');\n      }\n      html.push('href=\"',\n                url.replace(/\"/g, '&quot;'),\n                '\">');\n      addText(text);\n      html.push('</a>');\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n","require('./angular-sanitize');\nmodule.exports = 'ngSanitize';\n","/*!\n * angular-translate - v2.10.0 - 2016-02-28\n * \n * Copyright (c) 2016 The angular-translate team, Pascal Precht; Licensed MIT\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define([], function () {\n      return (factory());\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    factory();\n  }\n}(this, function () {\n\n/**\n * @ngdoc overview\n * @name pascalprecht.translate\n *\n * @description\n * The main module which holds everything together.\n */\nangular.module('pascalprecht.translate', ['ng'])\n  .run(runTranslate);\n\nfunction runTranslate($translate) {\n\n  'use strict';\n\n  var key = $translate.storageKey(),\n    storage = $translate.storage();\n\n  var fallbackFromIncorrectStorageValue = function () {\n    var preferred = $translate.preferredLanguage();\n    if (angular.isString(preferred)) {\n      $translate.use(preferred);\n      // $translate.use() will also remember the language.\n      // So, we don't need to call storage.put() here.\n    } else {\n      storage.put(key, $translate.use());\n    }\n  };\n\n  fallbackFromIncorrectStorageValue.displayName = 'fallbackFromIncorrectStorageValue';\n\n  if (storage) {\n    if (!storage.get(key)) {\n      fallbackFromIncorrectStorageValue();\n    } else {\n      $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);\n    }\n  } else if (angular.isString($translate.preferredLanguage())) {\n    $translate.use($translate.preferredLanguage());\n  }\n}\nrunTranslate.$inject = ['$translate'];\n\nrunTranslate.displayName = 'runTranslate';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateSanitizationProvider\n *\n * @description\n *\n * Configurations for $translateSanitization\n */\nangular.module('pascalprecht.translate').provider('$translateSanitization', $translateSanitizationProvider);\n\nfunction $translateSanitizationProvider () {\n\n  'use strict';\n\n  var $sanitize,\n      currentStrategy = null, // TODO change to either 'sanitize', 'escape' or ['sanitize', 'escapeParameters'] in 3.0.\n      hasConfiguredStrategy = false,\n      hasShownNoStrategyConfiguredWarning = false,\n      strategies;\n\n  /**\n   * Definition of a sanitization strategy function\n   * @callback StrategyFunction\n   * @param {string|object} value - value to be sanitized (either a string or an interpolated value map)\n   * @param {string} mode - either 'text' for a string (translation) or 'params' for the interpolated params\n   * @return {string|object}\n   */\n\n  /**\n   * @ngdoc property\n   * @name strategies\n   * @propertyOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Following strategies are built-in:\n   * <dl>\n   *   <dt>sanitize</dt>\n   *   <dd>Sanitizes HTML in the translation text using $sanitize</dd>\n   *   <dt>escape</dt>\n   *   <dd>Escapes HTML in the translation</dd>\n   *   <dt>sanitizeParameters</dt>\n   *   <dd>Sanitizes HTML in the values of the interpolation parameters using $sanitize</dd>\n   *   <dt>escapeParameters</dt>\n   *   <dd>Escapes HTML in the values of the interpolation parameters</dd>\n   *   <dt>escaped</dt>\n   *   <dd>Support legacy strategy name 'escaped' for backwards compatibility (will be removed in 3.0)</dd>\n   * </dl>\n   *\n   */\n\n  strategies = {\n    sanitize: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlSanitizeValue(value);\n      }\n      return value;\n    },\n    escape: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlEscapeValue(value);\n      }\n      return value;\n    },\n    sanitizeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlSanitizeValue);\n      }\n      return value;\n    },\n    escapeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlEscapeValue);\n      }\n      return value;\n    }\n  };\n  // Support legacy strategy name 'escaped' for backwards compatibility.\n  // TODO should be removed in 3.0\n  strategies.escaped = strategies.escapeParameters;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#addStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Adds a sanitization strategy to the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @param {StrategyFunction} strategyFunction - strategy function\n   * @returns {object} this\n   */\n  this.addStrategy = function (strategyName, strategyFunction) {\n    strategies[strategyName] = strategyFunction;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#removeStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Removes a sanitization strategy from the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @returns {object} this\n   */\n  this.removeStrategy = function (strategyName) {\n    delete strategies[strategyName];\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#useStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n   *\n   * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n   * @returns {object} this\n   */\n  this.useStrategy = function (strategy) {\n    hasConfiguredStrategy = true;\n    currentStrategy = strategy;\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translateSanitization\n   * @requires $injector\n   * @requires $log\n   *\n   * @description\n   * Sanitizes interpolation parameters and translated texts.\n   *\n   */\n  this.$get = ['$injector', '$log', function ($injector, $log) {\n\n    var cachedStrategyMap = {};\n\n    var applyStrategies = function (value, mode, selectedStrategies) {\n      angular.forEach(selectedStrategies, function (selectedStrategy) {\n        if (angular.isFunction(selectedStrategy)) {\n          value = selectedStrategy(value, mode);\n        } else if (angular.isFunction(strategies[selectedStrategy])) {\n          value = strategies[selectedStrategy](value, mode);\n        } else if (angular.isString(strategies[selectedStrategy])) {\n          if (!cachedStrategyMap[strategies[selectedStrategy]]) {\n            try {\n              cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);\n            } catch (e) {\n              cachedStrategyMap[strategies[selectedStrategy]] = function() {};\n              throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n            }\n          }\n          value = cachedStrategyMap[strategies[selectedStrategy]](value, mode);\n        } else {\n          throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n        }\n      });\n      return value;\n    };\n\n    // TODO: should be removed in 3.0\n    var showNoStrategyConfiguredWarning = function () {\n      if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {\n        $log.warn('pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.');\n        hasShownNoStrategyConfiguredWarning = true;\n      }\n    };\n\n    if ($injector.has('$sanitize')) {\n      $sanitize = $injector.get('$sanitize');\n    }\n\n    return {\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#useStrategy\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n       *\n       * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n       */\n      useStrategy: (function (self) {\n        return function (strategy) {\n          self.useStrategy(strategy);\n        };\n      })(this),\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#sanitize\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Sanitizes a value.\n       *\n       * @param {string|object} value The value which should be sanitized.\n       * @param {string} mode The current sanitization mode, either 'params' or 'text'.\n       * @param {string|StrategyFunction|array} [strategy] Optional custom strategy which should be used instead of the currently selected strategy.\n       * @returns {string|object} sanitized value\n       */\n      sanitize: function (value, mode, strategy) {\n        if (!currentStrategy) {\n          showNoStrategyConfiguredWarning();\n        }\n\n        if (arguments.length < 3) {\n          strategy = currentStrategy;\n        }\n\n        if (!strategy) {\n          return value;\n        }\n\n        var selectedStrategies = angular.isArray(strategy) ? strategy : [strategy];\n        return applyStrategies(value, mode, selectedStrategies);\n      }\n    };\n  }];\n\n  var htmlEscapeValue = function (value) {\n    var element = angular.element('<div></div>');\n    element.text(value); // not chainable, see #1044\n    return element.html();\n  };\n\n  var htmlSanitizeValue = function (value) {\n    if (!$sanitize) {\n      throw new Error('pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as \\'escape\\'.');\n    }\n    return $sanitize(value);\n  };\n\n  var mapInterpolationParameters = function (value, iteratee, stack) {\n    if (angular.isObject(value)) {\n      var result = angular.isArray(value) ? [] : {};\n\n      if (!stack) {\n        stack = [];\n      } else {\n        if (stack.indexOf(value) > -1) {\n          throw new Error('pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object');\n        }\n      }\n\n      stack.push(value);\n      angular.forEach(value, function (propertyValue, propertyKey) {\n        result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack);\n      });\n      stack.splice(-1, 1); // remove last\n\n      return result;\n    } else if (angular.isNumber(value)) {\n      return value;\n    } else {\n      return iteratee(value);\n    }\n  };\n}\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateProvider\n * @description\n *\n * $translateProvider allows developers to register translation-tables, asynchronous loaders\n * and similar to configure translation behavior directly inside of a module.\n *\n */\nangular.module('pascalprecht.translate')\n.constant('pascalprechtTranslateOverrider', {})\n.provider('$translate', $translate);\n\nfunction $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {\n\n  'use strict';\n\n  var $translationTable = {},\n      $preferredLanguage,\n      $availableLanguageKeys = [],\n      $languageKeyAliases,\n      $fallbackLanguage,\n      $fallbackWasString,\n      $uses,\n      $nextLang,\n      $storageFactory,\n      $storageKey = $STORAGE_KEY,\n      $storagePrefix,\n      $missingTranslationHandlerFactory,\n      $interpolationFactory,\n      $interpolatorFactories = [],\n      $loaderFactory,\n      $cloakClassName = 'translate-cloak',\n      $loaderOptions,\n      $notFoundIndicatorLeft,\n      $notFoundIndicatorRight,\n      $postCompilingEnabled = false,\n      $forceAsyncReloadEnabled = false,\n      $nestedObjectDelimeter = '.',\n      $isReady = false,\n      loaderCache,\n      directivePriority = 0,\n      statefulFilter = true,\n      uniformLanguageTagResolver = 'default',\n      languageTagResolver = {\n        'default': function (tag) {\n          return (tag || '').split('-').join('_');\n        },\n        java: function (tag) {\n          var temp = (tag || '').split('-').join('_');\n          var parts = temp.split('_');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '_' + parts[1].toUpperCase()) : temp;\n        },\n        bcp47: function (tag) {\n          var temp = (tag || '').split('_').join('-');\n          var parts = temp.split('-');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '-' + parts[1].toUpperCase()) : temp;\n        }\n      };\n\n  var version = '2.10.0';\n\n  // tries to determine the browsers language\n  var getFirstBrowserLanguage = function () {\n\n    // internal purpose only\n    if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {\n      return pascalprechtTranslateOverrider.getLocale();\n    }\n\n    var nav = $windowProvider.$get().navigator,\n        browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],\n        i,\n        language;\n\n    // support for HTML 5.1 \"navigator.languages\"\n    if (angular.isArray(nav.languages)) {\n      for (i = 0; i < nav.languages.length; i++) {\n        language = nav.languages[i];\n        if (language && language.length) {\n          return language;\n        }\n      }\n    }\n\n    // support for other well known properties in browsers\n    for (i = 0; i < browserLanguagePropertyKeys.length; i++) {\n      language = nav[browserLanguagePropertyKeys[i]];\n      if (language && language.length) {\n        return language;\n      }\n    }\n\n    return null;\n  };\n  getFirstBrowserLanguage.displayName = 'angular-translate/service: getFirstBrowserLanguage';\n\n  // tries to determine the browsers locale\n  var getLocale = function () {\n    var locale = getFirstBrowserLanguage() || '';\n    if (languageTagResolver[uniformLanguageTagResolver]) {\n      locale = languageTagResolver[uniformLanguageTagResolver](locale);\n    }\n    return locale;\n  };\n  getLocale.displayName = 'angular-translate/service: getLocale';\n\n  /**\n   * @name indexOf\n   * @private\n   *\n   * @description\n   * indexOf polyfill. Kinda sorta.\n   *\n   * @param {array} array Array to search in.\n   * @param {string} searchElement Element to search for.\n   *\n   * @returns {int} Index of search element.\n   */\n  var indexOf = function(array, searchElement) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === searchElement) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  var negotiateLocale = function (preferred) {\n    if(!preferred) {\n      return;\n    }\n\n    var avail = [],\n        locale = angular.lowercase(preferred),\n        i = 0,\n        n = $availableLanguageKeys.length;\n\n    for (; i < n; i++) {\n      avail.push(angular.lowercase($availableLanguageKeys[i]));\n    }\n\n    // Check for an exact match in our list of available keys\n    if (indexOf(avail, locale) > -1) {\n      return preferred;\n    }\n\n    if ($languageKeyAliases) {\n      var alias;\n      for (var langKeyAlias in $languageKeyAliases) {\n        var hasWildcardKey = false;\n        var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) &&\n          angular.lowercase(langKeyAlias) === angular.lowercase(preferred);\n\n        if (langKeyAlias.slice(-1) === '*') {\n          hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length-1);\n        }\n        if (hasExactKey || hasWildcardKey) {\n          alias = $languageKeyAliases[langKeyAlias];\n          if (indexOf(avail, angular.lowercase(alias)) > -1) {\n            return alias;\n          }\n        }\n      }\n    }\n\n    // Check for a language code without region\n    var parts = preferred.split('_');\n\n    if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {\n      return parts[0];\n    }\n\n    // If everything fails, return undefined.\n    return;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translations\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a new translation table for specific language key.\n   *\n   * To register a translation table for specific language, pass a defined language\n   * key as first parameter.\n   *\n   * <pre>\n   *  // register translation table for language: 'de_DE'\n   *  $translateProvider.translations('de_DE', {\n   *    'GREETING': 'Hallo Welt!'\n   *  });\n   *\n   *  // register another one\n   *  $translateProvider.translations('en_US', {\n   *    'GREETING': 'Hello world!'\n   *  });\n   * </pre>\n   *\n   * When registering multiple translation tables for for the same language key,\n   * the actual translation table gets extended. This allows you to define module\n   * specific translation which only get added, once a specific module is loaded in\n   * your app.\n   *\n   * Invoking this method with no arguments returns the translation table which was\n   * registered with no language key. Invoking it with a language key returns the\n   * related translation table.\n   *\n   * @param {string} key A language key.\n   * @param {object} translationTable A plain old JavaScript object that represents a translation table.\n   *\n   */\n  var translations = function (langKey, translationTable) {\n\n    if (!langKey && !translationTable) {\n      return $translationTable;\n    }\n\n    if (langKey && !translationTable) {\n      if (angular.isString(langKey)) {\n        return $translationTable[langKey];\n      }\n    } else {\n      if (!angular.isObject($translationTable[langKey])) {\n        $translationTable[langKey] = {};\n      }\n      angular.extend($translationTable[langKey], flatObject(translationTable));\n    }\n    return this;\n  };\n\n  this.translations = translations;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#cloakClassName\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the class name for `translate-cloak` directive.\n   * Default class name is `translate-cloak`.\n   *\n   * @param {string} name translate-cloak class name\n   */\n  this.cloakClassName = function (name) {\n    if (!name) {\n      return $cloakClassName;\n    }\n    $cloakClassName = name;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#nestedObjectDelimeter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the delimiter for namespaced translations.\n   * Default delimiter is `.`.\n   *\n   * @param {string} delimiter namespace separator\n   */\n  this.nestedObjectDelimeter = function (delimiter) {\n    if (!delimiter) {\n      return $nestedObjectDelimeter;\n    }\n    $nestedObjectDelimeter = delimiter;\n    return this;\n  };\n\n  /**\n   * @name flatObject\n   * @private\n   *\n   * @description\n   * Flats an object. This function is used to flatten given translation data with\n   * namespaces, so they are later accessible via dot notation.\n   */\n  var flatObject = function (data, path, result, prevKey) {\n    var key, keyWithPath, keyWithShortPath, val;\n\n    if (!path) {\n      path = [];\n    }\n    if (!result) {\n      result = {};\n    }\n    for (key in data) {\n      if (!Object.prototype.hasOwnProperty.call(data, key)) {\n        continue;\n      }\n      val = data[key];\n      if (angular.isObject(val)) {\n        flatObject(val, path.concat(key), result, key);\n      } else {\n        keyWithPath = path.length ? ('' + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key) : key;\n        if(path.length && key === prevKey){\n          // Create shortcut path (foo.bar == foo.bar.bar)\n          keyWithShortPath = '' + path.join($nestedObjectDelimeter);\n          // Link it to original path\n          result[keyWithShortPath] = '@:' + keyWithPath;\n        }\n        result[keyWithPath] = val;\n      }\n    }\n    return result;\n  };\n  flatObject.displayName = 'flatObject';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#addInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Adds interpolation services to angular-translate, so it can manage them.\n   *\n   * @param {object} factory Interpolation service factory\n   */\n  this.addInterpolation = function (factory) {\n    $interpolatorFactories.push(factory);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMessageFormatInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use interpolation functionality of messageformat.js.\n   * This is useful when having high level pluralization and gender selection.\n   */\n  this.useMessageFormatInterpolation = function () {\n    return this.useInterpolation('$translateMessageFormatInterpolation');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which interpolation style to use as default, application-wide.\n   * Simply pass a factory/service name. The interpolation service has to implement\n   * the correct interface.\n   *\n   * @param {string} factory Interpolation service name.\n   */\n  this.useInterpolation = function (factory) {\n    $interpolationFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useSanitizeStrategy\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Simply sets a sanitation strategy type.\n   *\n   * @param {string} value Strategy type.\n   */\n  this.useSanitizeValueStrategy = function (value) {\n    $translateSanitizationProvider.useStrategy(value);\n    return this;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#preferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use for translation\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **prefer**.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.preferredLanguage = function(langKey) {\n    if (langKey) {\n      setupPreferredLanguage(langKey);\n      return this;\n    }\n    return $preferredLanguage;\n  };\n  var setupPreferredLanguage = function (langKey) {\n    if (langKey) {\n      $preferredLanguage = langKey;\n    }\n    return $preferredLanguage;\n  };\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicator\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found. E.g. when\n   * setting the indicator as 'X' and one tries to translate a translation id\n   * called `NOT_FOUND`, this will result in `X NOT_FOUND X`.\n   *\n   * Internally this methods sets a left indicator and a right indicator using\n   * `$translateProvider.translationNotFoundIndicatorLeft()` and\n   * `$translateProvider.translationNotFoundIndicatorRight()`.\n   *\n   * **Note**: These methods automatically add a whitespace between the indicators\n   * and the translation id.\n   *\n   * @param {string} indicator An indicator, could be any string.\n   */\n  this.translationNotFoundIndicator = function (indicator) {\n    this.translationNotFoundIndicatorLeft(indicator);\n    this.translationNotFoundIndicatorRight(indicator);\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found left to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorLeft = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorLeft;\n    }\n    $notFoundIndicatorLeft = indicator;\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found right to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorRight = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorRight;\n    }\n    $notFoundIndicatorRight = indicator;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#fallbackLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use when missing translations\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **fallback**.\n   *\n   * @param {string||array} langKey A language key.\n   *\n   */\n  this.fallbackLanguage = function (langKey) {\n    fallbackStack(langKey);\n    return this;\n  };\n\n  var fallbackStack = function (langKey) {\n    if (langKey) {\n      if (angular.isString(langKey)) {\n        $fallbackWasString = true;\n        $fallbackLanguage = [ langKey ];\n      } else if (angular.isArray(langKey)) {\n        $fallbackWasString = false;\n        $fallbackLanguage = langKey;\n      }\n      if (angular.isString($preferredLanguage)  && indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n        $fallbackLanguage.push($preferredLanguage);\n      }\n\n      return this;\n    } else {\n      if ($fallbackWasString) {\n        return $fallbackLanguage[0];\n      } else {\n        return $fallbackLanguage;\n      }\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#use\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Set which translation table to use for translation by given language key. When\n   * trying to 'use' a language which isn't provided, it'll throw an error.\n   *\n   * You actually don't have to use this method since `$translateProvider#preferredLanguage`\n   * does the job too.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.use = function (langKey) {\n    if (langKey) {\n      if (!$translationTable[langKey] && (!$loaderFactory)) {\n        // only throw an error, when not loading translation data asynchronously\n        throw new Error('$translateProvider couldn\\'t find translationTable for langKey: \\'' + langKey + '\\'');\n      }\n      $uses = langKey;\n      return this;\n    }\n    return $uses;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storageKey\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which key must represent the choosed language by a user in the storage.\n   *\n   * @param {string} key A key for the storage.\n   */\n  var storageKey = function(key) {\n    if (!key) {\n      if ($storagePrefix) {\n        return $storagePrefix + $storageKey;\n      }\n      return $storageKey;\n    }\n    $storageKey = key;\n    return this;\n  };\n\n  this.storageKey = storageKey;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useUrlLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateUrlLoader` extension service as loader.\n   *\n   * @param {string} url Url\n   * @param {Object=} options Optional configuration object\n   */\n  this.useUrlLoader = function (url, options) {\n    return this.useLoader('$translateUrlLoader', angular.extend({ url: url }, options));\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStaticFilesLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateStaticFilesLoader` extension service as loader.\n   *\n   * @param {Object=} options Optional configuration object\n   */\n  this.useStaticFilesLoader = function (options) {\n    return this.useLoader('$translateStaticFilesLoader', options);\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use any other service as loader.\n   *\n   * @param {string} loaderFactory Factory name to use\n   * @param {Object=} options Optional configuration object\n   */\n  this.useLoader = function (loaderFactory, options) {\n    $loaderFactory = loaderFactory;\n    $loaderOptions = options || {};\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLocalStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateLocalStorage` service as storage layer.\n   *\n   */\n  this.useLocalStorage = function () {\n    return this.useStorage('$translateLocalStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useCookieStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateCookieStorage` service as storage layer.\n   */\n  this.useCookieStorage = function () {\n    return this.useStorage('$translateCookieStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use custom service as storage layer.\n   */\n  this.useStorage = function (storageFactory) {\n    $storageFactory = storageFactory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storagePrefix\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets prefix for storage key.\n   *\n   * @param {string} prefix Storage key prefix\n   */\n  this.storagePrefix = function (prefix) {\n    if (!prefix) {\n      return prefix;\n    }\n    $storagePrefix = prefix;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandlerLog\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use built-in log handler when trying to translate\n   * a translation Id which doesn't exist.\n   *\n   * This is actually a shortcut method for `useMissingTranslationHandler()`.\n   *\n   */\n  this.useMissingTranslationHandlerLog = function () {\n    return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandler\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Expects a factory name which later gets instantiated with `$injector`.\n   * This method can be used to tell angular-translate to use a custom\n   * missingTranslationHandler. Just build a factory which returns a function\n   * and expects a translation id as argument.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.useMissingTranslationHandler('customHandler');\n   *  });\n   *\n   *  app.factory('customHandler', function (dep1, dep2) {\n   *    return function (translationId) {\n   *      // something with translationId and dep1 and dep2\n   *    };\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.useMissingTranslationHandler = function (factory) {\n    $missingTranslationHandlerFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#usePostCompiling\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If post compiling is enabled, all translated values will be processed\n   * again with AngularJS' $compile.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.usePostCompiling(true);\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.usePostCompiling = function (value) {\n    $postCompilingEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#forceAsyncReload\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If force async reload is enabled, async loader will always be called\n   * even if $translationTable already contains the language key, adding\n   * possible new entries to the $translationTable.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.forceAsyncReload(true);\n   *  });\n   * </pre>\n   *\n   * @param {boolean} value - valid values are true or false\n   */\n  this.forceAsyncReload = function (value) {\n    $forceAsyncReloadEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#uniformLanguageTag\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which language tag should be used as a result when determining\n   * the current browser language.\n   *\n   * This setting must be set before invoking {@link pascalprecht.translate.$translateProvider#methods_determinePreferredLanguage determinePreferredLanguage()}.\n   *\n   * <pre>\n   * $translateProvider\n   *   .uniformLanguageTag('bcp47')\n   *   .determinePreferredLanguage()\n   * </pre>\n   *\n   * The resolver currently supports:\n   * * default\n   *     (traditionally: hyphens will be converted into underscores, i.e. en-US => en_US)\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_us\n   * * java\n   *     like default, but the second part will be always in uppercase\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_US\n   * * BCP 47 (RFC 4646 & 4647)\n   *     en-US => en-US\n   *     en_US => en-US\n   *     en-us => en-US\n   *\n   * See also:\n   * * http://en.wikipedia.org/wiki/IETF_language_tag\n   * * http://www.w3.org/International/core/langtags/\n   * * http://tools.ietf.org/html/bcp47\n   *\n   * @param {string|object} options - options (or standard)\n   * @param {string} options.standard - valid values are 'default', 'bcp47', 'java'\n   */\n  this.uniformLanguageTag = function (options) {\n\n    if (!options) {\n      options = {};\n    } else if (angular.isString(options)) {\n      options = {\n        standard: options\n      };\n    }\n\n    uniformLanguageTagResolver = options.standard;\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#determinePreferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to try to determine on its own which language key\n   * to set as preferred language. When `fn` is given, angular-translate uses it\n   * to determine a language key, otherwise it uses the built-in `getLocale()`\n   * method.\n   *\n   * The `getLocale()` returns a language key in the format `[lang]_[country]` or\n   * `[lang]` depending on what the browser provides.\n   *\n   * Use this method at your own risk, since not all browsers return a valid\n   * locale (see {@link pascalprecht.translate.$translateProvider#methods_uniformLanguageTag uniformLanguageTag()}).\n   *\n   * @param {Function=} fn Function to determine a browser's locale\n   */\n  this.determinePreferredLanguage = function (fn) {\n\n    var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();\n\n    if (!$availableLanguageKeys.length) {\n      $preferredLanguage = locale;\n    } else {\n      $preferredLanguage = negotiateLocale(locale) || locale;\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#registerAvailableLanguageKeys\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a set of language keys the app will work with. Use this method in\n   * combination with\n   * {@link pascalprecht.translate.$translateProvider#determinePreferredLanguage determinePreferredLanguage}.\n   * When available languages keys are registered, angular-translate\n   * tries to find the best fitting language key depending on the browsers locale,\n   * considering your language key convention.\n   *\n   * @param {object} languageKeys Array of language keys the your app will use\n   * @param {object=} aliases Alias map.\n   */\n  this.registerAvailableLanguageKeys = function (languageKeys, aliases) {\n    if (languageKeys) {\n      $availableLanguageKeys = languageKeys;\n      if (aliases) {\n        $languageKeyAliases = aliases;\n      }\n      return this;\n    }\n    return $availableLanguageKeys;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoaderCache\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a cache for internal $http based loaders.\n   * {@link pascalprecht.translate.$translationCache $translationCache}.\n   * When false the cache will be disabled (default). When true or undefined\n   * the cache will be a default (see $cacheFactory). When an object it will\n   * be treat as a cache object itself: the usage is $http({cache: cache})\n   *\n   * @param {object} cache boolean, string or cache-object\n   */\n  this.useLoaderCache = function (cache) {\n    if (cache === false) {\n      // disable cache\n      loaderCache = undefined;\n    } else if (cache === true) {\n      // enable cache using AJS defaults\n      loaderCache = true;\n    } else if (typeof(cache) === 'undefined') {\n      // enable cache using default\n      loaderCache = '$translationCache';\n    } else if (cache) {\n      // enable cache using given one (see $cacheFactory)\n      loaderCache = cache;\n    }\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#directivePriority\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets the default priority of the translate directive. The standard value is `0`.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {number} priority for the translate-directive\n   */\n  this.directivePriority = function (priority) {\n    if (priority === undefined) {\n      // getter\n      return directivePriority;\n    } else {\n      // setter with chaining\n      directivePriority = priority;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#statefulFilter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Since AngularJS 1.3, filters which are not stateless (depending at the scope)\n   * have to explicit define this behavior.\n   * Sets whether the translate filter should be stateful or stateless. The standard value is `true`\n   * meaning being stateful.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {boolean} state - defines the state of the filter\n   */\n  this.statefulFilter = function (state) {\n    if (state === undefined) {\n      // getter\n      return statefulFilter;\n    } else {\n      // setter with chaining\n      statefulFilter = state;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translate\n   * @requires $interpolate\n   * @requires $log\n   * @requires $rootScope\n   * @requires $q\n   *\n   * @description\n   * The `$translate` service is the actual core of angular-translate. It expects a translation id\n   * and optional interpolate parameters to translate contents.\n   *\n   * <pre>\n   *  $translate('HEADLINE_TEXT').then(function (translation) {\n   *    $scope.translatedText = translation;\n   *  });\n   * </pre>\n   *\n   * @param {string|array} translationId A token which represents a translation id\n   *                                     This can be optionally an array of translation ids which\n   *                                     results that the function returns an object where each key\n   *                                     is the translation id and the value the translation.\n   * @param {object=} interpolateParams An object hash for dynamic values\n   * @param {string} interpolationId The id of the interpolation to use\n   * @param {string} forceLanguage A language to be used instead of the current language\n   * @returns {object} promise\n   */\n  this.$get = [\n    '$log',\n    '$injector',\n    '$rootScope',\n    '$q',\n    function ($log, $injector, $rootScope, $q) {\n\n      var Storage,\n          defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),\n          pendingLoader = false,\n          interpolatorHashMap = {},\n          langPromises = {},\n          fallbackIndex,\n          startFallbackIteration;\n\n      var $translate = function (translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage) {\n\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          // Inspired by Q.allSettled by Kris Kowal\n          // https://github.com/kriskowal/q/blob/b0fa72980717dc202ffc3cbf03b936e10ebbb9d7/q.js#L1553-1563\n          // This transforms all promises regardless resolved or rejected\n          var translateAll = function (translationIds) {\n            var results = {}; // storing the actual results\n            var promises = []; // promises to wait for\n            // Wraps the promise a) being always resolved and b) storing the link id->value\n            var translate = function (translationId) {\n              var deferred = $q.defer();\n              var regardless = function (value) {\n                results[translationId] = value;\n                deferred.resolve([translationId, value]);\n              };\n              // we don't care whether the promise was resolved or rejected; just store the values\n              $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage).then(regardless, regardless);\n              return deferred.promise;\n            };\n            for (var i = 0, c = translationIds.length; i < c; i++) {\n              promises.push(translate(translationIds[i]));\n            }\n            // wait for all (including storing to results)\n            return $q.all(promises).then(function () {\n              // return the results\n              return results;\n            });\n          };\n          return translateAll(translationId);\n        }\n\n        var deferred = $q.defer();\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var promiseToWaitFor = (function () {\n          var promise = $preferredLanguage ?\n            langPromises[$preferredLanguage] :\n            langPromises[uses];\n\n          fallbackIndex = 0;\n\n          if ($storageFactory && !promise) {\n            // looks like there's no pending promise for $preferredLanguage or\n            // $uses. Maybe there's one pending for a language that comes from\n            // storage.\n            var langKey = Storage.get($storageKey);\n            promise = langPromises[langKey];\n\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n                var index = indexOf($fallbackLanguage, langKey);\n                // maybe the language from storage is also defined as fallback language\n                // we increase the fallback language index to not search in that language\n                // as fallback, since it's probably the first used language\n                // in that case the index starts after the first element\n                fallbackIndex = (index === 0) ? 1 : 0;\n\n                // but we can make sure to ALWAYS fallback to preferred language at least\n                if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n                  $fallbackLanguage.push($preferredLanguage);\n                }\n            }\n          }\n          return promise;\n        }());\n\n        if (!promiseToWaitFor) {\n          // no promise to wait for? okay. Then there's no loader registered\n          // nor is a one pending for language that comes from storage.\n          // We can just translate.\n          determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n        } else {\n          var promiseResolved = function () {\n            // $uses may have changed while waiting\n            if (!forceLanguage) {\n              uses = $uses;\n            }\n            determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n          };\n          promiseResolved.displayName = 'promiseResolved';\n\n          promiseToWaitFor['finally'](promiseResolved);\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name applyNotFoundIndicators\n       * @private\n       *\n       * @description\n       * Applies not fount indicators to given translation id, if needed.\n       * This function gets only executed, if a translation id doesn't exist,\n       * which is why a translation id is expected as argument.\n       *\n       * @param {string} translationId Translation id.\n       * @returns {string} Same as given translation id but applied with not found\n       * indicators.\n       */\n      var applyNotFoundIndicators = function (translationId) {\n        // applying notFoundIndicators\n        if ($notFoundIndicatorLeft) {\n          translationId = [$notFoundIndicatorLeft, translationId].join(' ');\n        }\n        if ($notFoundIndicatorRight) {\n          translationId = [translationId, $notFoundIndicatorRight].join(' ');\n        }\n        return translationId;\n      };\n\n      /**\n       * @name useLanguage\n       * @private\n       *\n       * @description\n       * Makes actual use of a language by setting a given language key as used\n       * language and informs registered interpolators to also use the given\n       * key as locale.\n       *\n       * @param {key} Locale key.\n       */\n      var useLanguage = function (key) {\n        $uses = key;\n\n        // make sure to store new language key before triggering success event\n        if ($storageFactory) {\n          Storage.put($translate.storageKey(), $uses);\n        }\n\n        $rootScope.$emit('$translateChangeSuccess', {language: key});\n\n        // inform default interpolator\n        defaultInterpolator.setLocale($uses);\n\n        var eachInterpolator = function (interpolator, id) {\n          interpolatorHashMap[id].setLocale($uses);\n        };\n        eachInterpolator.displayName = 'eachInterpolatorLocaleSetter';\n\n        // inform all others too!\n        angular.forEach(interpolatorHashMap, eachInterpolator);\n        $rootScope.$emit('$translateChangeEnd', {language: key});\n      };\n\n      /**\n       * @name loadAsync\n       * @private\n       *\n       * @description\n       * Kicks of registered async loader using `$injector` and applies existing\n       * loader options. When resolved, it updates translation tables accordingly\n       * or rejects with given language key.\n       *\n       * @param {string} key Language key.\n       * @return {Promise} A promise.\n       */\n      var loadAsync = function (key) {\n        if (!key) {\n          throw 'No language key specified for loading.';\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateLoadingStart', {language: key});\n        pendingLoader = true;\n\n        var cache = loaderCache;\n        if (typeof(cache) === 'string') {\n          // getting on-demand instance of loader\n          cache = $injector.get(cache);\n        }\n\n        var loaderOptions = angular.extend({}, $loaderOptions, {\n          key: key,\n          $http: angular.extend({}, {\n            cache: cache\n          }, $loaderOptions.$http)\n        });\n\n        var onLoaderSuccess = function (data) {\n          var translationTable = {};\n          $rootScope.$emit('$translateLoadingSuccess', {language: key});\n\n          if (angular.isArray(data)) {\n            angular.forEach(data, function (table) {\n              angular.extend(translationTable, flatObject(table));\n            });\n          } else {\n            angular.extend(translationTable, flatObject(data));\n          }\n          pendingLoader = false;\n          deferred.resolve({\n            key: key,\n            table: translationTable\n          });\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderSuccess.displayName = 'onLoaderSuccess';\n\n        var onLoaderError = function (key) {\n          $rootScope.$emit('$translateLoadingError', {language: key});\n          deferred.reject(key);\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderError.displayName = 'onLoaderError';\n\n        $injector.get($loaderFactory)(loaderOptions)\n          .then(onLoaderSuccess, onLoaderError);\n\n        return deferred.promise;\n      };\n\n      if ($storageFactory) {\n        Storage = $injector.get($storageFactory);\n\n        if (!Storage.get || !Storage.put) {\n          throw new Error('Couldn\\'t use storage \\'' + $storageFactory + '\\', missing get() or put() method!');\n        }\n      }\n\n      // if we have additional interpolations that were added via\n      // $translateProvider.addInterpolation(), we have to map'em\n      if ($interpolatorFactories.length) {\n        var eachInterpolationFactory = function (interpolatorFactory) {\n          var interpolator = $injector.get(interpolatorFactory);\n          // setting initial locale for each interpolation service\n          interpolator.setLocale($preferredLanguage || $uses);\n          // make'em recognizable through id\n          interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;\n        };\n        eachInterpolationFactory.displayName = 'interpolationFactoryAdder';\n\n        angular.forEach($interpolatorFactories, eachInterpolationFactory);\n      }\n\n      /**\n       * @name getTranslationTable\n       * @private\n       *\n       * @description\n       * Returns a promise that resolves to the translation table\n       * or is rejected if an error occurred.\n       *\n       * @param langKey\n       * @returns {Q.promise}\n       */\n      var getTranslationTable = function (langKey) {\n        var deferred = $q.defer();\n        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {\n          deferred.resolve($translationTable[langKey]);\n        } else if (langPromises[langKey]) {\n          var onResolve = function (data) {\n            translations(data.key, data.table);\n            deferred.resolve(data.table);\n          };\n          onResolve.displayName = 'translationTableResolver';\n          langPromises[langKey].then(onResolve, deferred.reject);\n        } else {\n          deferred.reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslation\n       * @private\n       *\n       * @description\n       * Returns a promise that will resolve to the translation\n       * or be rejected if no translation was found for the language.\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise}\n       */\n      var getFallbackTranslation = function (langKey, translationId, interpolateParams, Interpolator) {\n        var deferred = $q.defer();\n\n        var onResolve = function (translationTable) {\n          if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n            Interpolator.setLocale(langKey);\n            var translation = translationTable[translationId];\n            if (translation.substr(0, 2) === '@:') {\n              getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator)\n                .then(deferred.resolve, deferred.reject);\n            } else {\n              deferred.resolve(Interpolator.interpolate(translationTable[translationId], interpolateParams));\n            }\n            Interpolator.setLocale($uses);\n          } else {\n            deferred.reject();\n          }\n        };\n        onResolve.displayName = 'fallbackTranslationResolver';\n\n        getTranslationTable(langKey).then(onResolve, deferred.reject);\n\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslationInstant\n       * @private\n       *\n       * @description\n       * Returns a translation\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var getFallbackTranslationInstant = function (langKey, translationId, interpolateParams, Interpolator) {\n        var result, translationTable = $translationTable[langKey];\n\n        if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n          Interpolator.setLocale(langKey);\n          result = Interpolator.interpolate(translationTable[translationId], interpolateParams);\n          if (result.substr(0, 2) === '@:') {\n            return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);\n          }\n          Interpolator.setLocale($uses);\n        }\n\n        return result;\n      };\n\n\n      /**\n       * @name translateByHandler\n       * @private\n       *\n       * Translate by missing translation handler.\n       *\n       * @param translationId\n       * @returns translation created by $missingTranslationHandler or translationId is $missingTranslationHandler is\n       * absent\n       */\n      var translateByHandler = function (translationId, interpolateParams) {\n        // If we have a handler factory - we might also call it here to determine if it provides\n        // a default text for a translationid that can't be found anywhere in our tables\n        if ($missingTranslationHandlerFactory) {\n          var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams);\n          if (resultString !== undefined) {\n            return resultString;\n          } else {\n            return translationId;\n          }\n        } else {\n          return translationId;\n        }\n      };\n\n      /**\n       * @name resolveForFallbackLanguage\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise that will resolve to the translation.\n       */\n      var resolveForFallbackLanguage = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        var deferred = $q.defer();\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(\n            deferred.resolve,\n            function () {\n              // Look in the next fallback language for a translation.\n              // It delays the resolving by passing another promise to resolve.\n              resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve);\n            }\n          );\n        } else {\n          // No translation found in any fallback language\n          // if a default translation text is set in the directive, then return this as a result\n          if (defaultTranslationText) {\n            deferred.resolve(defaultTranslationText);\n          } else {\n            // if no default translation is set and an error handler is defined, send it to the handler\n            // and then return the result\n            deferred.resolve(translateByHandler(translationId, interpolateParams));\n          }\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name resolveForFallbackLanguageInstant\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var resolveForFallbackLanguageInstant = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {\n        var result;\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);\n          if (!result) {\n            result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);\n          }\n        }\n        return result;\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise, that resolves to the translation.\n       */\n      var fallbackTranslation = function (translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguage((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText);\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {String} translation\n       */\n      var fallbackTranslationInstant = function (translationId, interpolateParams, Interpolator) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguageInstant((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator);\n      };\n\n      var determineTranslation = function (translationId, interpolateParams, interpolationId, defaultTranslationText, uses) {\n\n        var deferred = $q.defer();\n\n        var table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n\n            $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses)\n              .then(deferred.resolve, deferred.reject);\n          } else {\n            deferred.resolve(Interpolator.interpolate(translation, interpolateParams));\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText)\n                .then(function (translation) {\n                  deferred.resolve(translation);\n                }, function (_translationId) {\n                  deferred.reject(applyNotFoundIndicators(_translationId));\n                });\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n              } else {\n                deferred.resolve(missingTranslationHandlerTranslation);\n              }\n          } else {\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n            } else {\n              deferred.reject(applyNotFoundIndicators(translationId));\n            }\n          }\n        }\n        return deferred.promise;\n      };\n\n      var determineTranslationInstant = function (translationId, interpolateParams, interpolationId, uses) {\n\n        var result, table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = defaultInterpolator;\n\n        // if the interpolation id exists use custom interpolator\n        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {\n          Interpolator = interpolatorHashMap[interpolationId];\n        }\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n            result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses);\n          } else {\n            result = Interpolator.interpolate(translation, interpolateParams);\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackIndex = 0;\n            result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            result = missingTranslationHandlerTranslation;\n          } else {\n            result = applyNotFoundIndicators(translationId);\n          }\n        }\n\n        return result;\n      };\n\n      var clearNextLangAndPromise = function(key) {\n        if ($nextLang === key) {\n          $nextLang = undefined;\n        }\n        langPromises[key] = undefined;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#preferredLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the preferred language.\n       *\n       * @param {string} langKey language String or Array to be used as preferredLanguage (changing at runtime)\n       *\n       * @return {string} preferred language key\n       */\n      $translate.preferredLanguage = function (langKey) {\n        if(langKey) {\n          setupPreferredLanguage(langKey);\n        }\n        return $preferredLanguage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#cloakClassName\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured class name for `translate-cloak` directive.\n       *\n       * @return {string} cloakClassName\n       */\n      $translate.cloakClassName = function () {\n        return $cloakClassName;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#nestedObjectDelimeter\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured delimiter for nested namespaces.\n       *\n       * @return {string} nestedObjectDelimeter\n       */\n      $translate.nestedObjectDelimeter = function () {\n        return $nestedObjectDelimeter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#fallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the fallback languages or sets a new fallback stack.\n       *\n       * @param {string=} langKey language String or Array of fallback languages to be used (to change stack at runtime)\n       *\n       * @return {string||array} fallback language key\n       */\n      $translate.fallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          fallbackStack(langKey);\n\n          // as we might have an async loader initiated and a new translation language might have been defined\n          // we need to add the promise to the stack also. So - iterate.\n          if ($loaderFactory) {\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n              for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n                if (!langPromises[$fallbackLanguage[i]]) {\n                  langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);\n                }\n              }\n            }\n          }\n          $translate.use($translate.use());\n        }\n        if ($fallbackWasString) {\n          return $fallbackLanguage[0];\n        } else {\n          return $fallbackLanguage;\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#useFallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Sets the first key of the fallback language stack to be used for translation.\n       * Therefore all languages in the fallback array BEFORE this key will be skipped!\n       *\n       * @param {string=} langKey Contains the langKey the iteration shall start with. Set to false if you want to\n       * get back to the whole stack\n       */\n      $translate.useFallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          if (!langKey) {\n            startFallbackIteration = 0;\n          } else {\n            var langKeyPosition = indexOf($fallbackLanguage, langKey);\n            if (langKeyPosition > -1) {\n              startFallbackIteration = langKeyPosition;\n            }\n          }\n\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#proposedLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key of language that is currently loaded asynchronously.\n       *\n       * @return {string} language key\n       */\n      $translate.proposedLanguage = function () {\n        return $nextLang;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns registered storage.\n       *\n       * @return {object} Storage\n       */\n      $translate.storage = function () {\n        return Storage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#negotiateLocale\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a language key based on available languages and language aliases. If a\n       * language key cannot be resolved, returns undefined.\n       *\n       * If no or a falsy key is given, returns undefined.\n       *\n       * @param {string} [key] Language key\n       * @return {string|undefined} Language key or undefined if no language key is found.\n       */\n      $translate.negotiateLocale = negotiateLocale;\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#use\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Tells angular-translate which language to use by given language key. This method is\n       * used to change language at runtime. It also takes care of storing the language\n       * key in a configured store to let your app remember the choosed language.\n       *\n       * When trying to 'use' a language which isn't available it tries to load it\n       * asynchronously with registered loaders.\n       *\n       * Returns promise object with loaded language file data or string of the currently used language.\n       *\n       * If no or a falsy key is given it returns the currently used language key.\n       * The returned string will be ```undefined``` if setting up $translate hasn't finished.\n       * @example\n       * $translate.use(\"en_US\").then(function(data){\n       *   $scope.text = $translate(\"HELLO\");\n       * });\n       *\n       * @param {string} [key] Language key\n       * @return {object|string} Promise with loaded language data or the language key if a falsy param was given.\n       */\n      $translate.use = function (key) {\n        if (!key) {\n          return $uses;\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateChangeStart', {language: key});\n\n        // Try to get the aliased language key\n        var aliasedKey = negotiateLocale(key);\n        if (aliasedKey) {\n          key = aliasedKey;\n        }\n\n        // if there isn't a translation table for the language we've requested,\n        // we load it asynchronously\n        $nextLang = key;\n        if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {\n          langPromises[key] = loadAsync(key).then(function (translation) {\n            translations(translation.key, translation.table);\n            deferred.resolve(translation.key);\n            if ($nextLang === key) {\n              useLanguage(translation.key);\n            }\n            return translation;\n          }, function (key) {\n            $rootScope.$emit('$translateChangeError', {language: key});\n            deferred.reject(key);\n            $rootScope.$emit('$translateChangeEnd', {language: key});\n            return $q.reject(key);\n          });\n          langPromises[key]['finally'](function () {\n            clearNextLangAndPromise(key);\n          });\n        } else if (langPromises[key]) {\n          // we are already loading this asynchronously\n          // resolve our new deferred when the old langPromise is resolved\n          langPromises[key].then(function (translation) {\n            if ($nextLang === translation.key) {\n              useLanguage(translation.key);\n            }\n            deferred.resolve(translation.key);\n            return translation;\n          }, function (key) {\n            // find first available fallback language if that request has failed\n            if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0) {\n              return $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);\n            } else {\n              return deferred.reject(key);\n            }\n          });\n        } else {\n          deferred.resolve(key);\n          useLanguage(key);\n        }\n\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storageKey\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the key for the storage.\n       *\n       * @return {string} storage key\n       */\n      $translate.storageKey = function () {\n        return storageKey();\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isPostCompilingEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether post compiling is enabled or not\n       *\n       * @return {bool} storage key\n       */\n      $translate.isPostCompilingEnabled = function () {\n        return $postCompilingEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isForceAsyncReloadEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether force async reload is enabled or not\n       *\n       * @return {boolean} forceAsyncReload value\n       */\n      $translate.isForceAsyncReloadEnabled = function () {\n        return $forceAsyncReloadEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#refresh\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Refreshes a translation table pointed by the given langKey. If langKey is not specified,\n       * the module will drop all existent translation tables and load new version of those which\n       * are currently in use.\n       *\n       * Refresh means that the module will drop target translation table and try to load it again.\n       *\n       * In case there are no loaders registered the refresh() method will throw an Error.\n       *\n       * If the module is able to refresh translation tables refresh() method will broadcast\n       * $translateRefreshStart and $translateRefreshEnd events.\n       *\n       * @example\n       * // this will drop all currently existent translation tables and reload those which are\n       * // currently in use\n       * $translate.refresh();\n       * // this will refresh a translation table for the en_US language\n       * $translate.refresh('en_US');\n       *\n       * @param {string} langKey A language key of the table, which has to be refreshed\n       *\n       * @return {promise} Promise, which will be resolved in case a translation tables refreshing\n       * process is finished successfully, and reject if not.\n       */\n      $translate.refresh = function (langKey) {\n        if (!$loaderFactory) {\n          throw new Error('Couldn\\'t refresh translation table, no loader registered!');\n        }\n\n        var deferred = $q.defer();\n\n        function resolve() {\n          deferred.resolve();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        function reject() {\n          deferred.reject();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        $rootScope.$emit('$translateRefreshStart', {language: langKey});\n\n        if (!langKey) {\n          // if there's no language key specified we refresh ALL THE THINGS!\n          var tables = [], loadingKeys = {};\n\n          // reload registered fallback languages\n          if ($fallbackLanguage && $fallbackLanguage.length) {\n            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n              tables.push(loadAsync($fallbackLanguage[i]));\n              loadingKeys[$fallbackLanguage[i]] = true;\n            }\n          }\n\n          // reload currently used language\n          if ($uses && !loadingKeys[$uses]) {\n            tables.push(loadAsync($uses));\n          }\n\n          var allTranslationsLoaded = function (tableData) {\n            $translationTable = {};\n            angular.forEach(tableData, function (data) {\n              translations(data.key, data.table);\n            });\n            if ($uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          allTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          $q.all(tables).then(allTranslationsLoaded, reject);\n\n        } else if ($translationTable[langKey]) {\n\n          var oneTranslationsLoaded = function (data) {\n            translations(data.key, data.table);\n            if (langKey === $uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          oneTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          loadAsync(langKey).then(oneTranslationsLoaded, reject);\n\n        } else {\n          reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#instant\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a translation instantly from the internal state of loaded translation. All rules\n       * regarding the current language, the preferred language of even fallback languages will be\n       * used except any promise handling. If a language was not found, an asynchronous loading\n       * will be invoked in the background.\n       *\n       * @param {string|array} translationId A token which represents a translation id\n       *                                     This can be optionally an array of translation ids which\n       *                                     results that the function's promise returns an object where\n       *                                     each key is the translation id and the value the translation.\n       * @param {object} interpolateParams Params\n       * @param {string} interpolationId The id of the interpolation to use\n       * @param {string} forceLanguage A language to be used instead of the current language\n       *\n       * @return {string|object} translation\n       */\n      $translate.instant = function (translationId, interpolateParams, interpolationId, forceLanguage) {\n\n        // we don't want to re-negotiate $uses\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Detect undefined and null values to shorten the execution and prevent exceptions\n        if (translationId === null || angular.isUndefined(translationId)) {\n          return translationId;\n        }\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          var results = {};\n          for (var i = 0, c = translationId.length; i < c; i++) {\n            results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage);\n          }\n          return results;\n        }\n\n        // We discarded unacceptable values. So we just need to verify if translationId is empty String\n        if (angular.isString(translationId) && translationId.length < 1) {\n          return translationId;\n        }\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var result, possibleLangKeys = [];\n        if ($preferredLanguage) {\n          possibleLangKeys.push($preferredLanguage);\n        }\n        if (uses) {\n          possibleLangKeys.push(uses);\n        }\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);\n        }\n        for (var j = 0, d = possibleLangKeys.length; j < d; j++) {\n          var possibleLangKey = possibleLangKeys[j];\n          if ($translationTable[possibleLangKey]) {\n            if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {\n              result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses);\n            }\n          }\n          if (typeof result !== 'undefined') {\n            break;\n          }\n        }\n\n        if (!result && result !== '') {\n          if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {\n            result = applyNotFoundIndicators(translationId);\n          } else {\n            // Return translation of default interpolator if not found anything.\n            result = defaultInterpolator.interpolate(translationId, interpolateParams);\n            if ($missingTranslationHandlerFactory && !pendingLoader) {\n              result = translateByHandler(translationId, interpolateParams);\n            }\n          }\n        }\n\n        return result;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#versionInfo\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the current version information for the angular-translate library\n       *\n       * @return {string} angular-translate version\n       */\n      $translate.versionInfo = function () {\n        return version;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#loaderCache\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the defined loaderCache.\n       *\n       * @return {boolean|string|object} current value of loaderCache\n       */\n      $translate.loaderCache = function () {\n        return loaderCache;\n      };\n\n      // internal purpose only\n      $translate.directivePriority = function () {\n        return directivePriority;\n      };\n\n      // internal purpose only\n      $translate.statefulFilter = function () {\n        return statefulFilter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_onReady onReady()}.\n       *\n       * @return {boolean} current value of ready\n       */\n      $translate.isReady = function () {\n        return $isReady;\n      };\n\n      var $onReadyDeferred = $q.defer();\n      $onReadyDeferred.promise.then(function () {\n        $isReady = true;\n      });\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#onReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_isReady isReady()}.\n       *\n       * @param {Function=} fn Function to invoke when service is ready\n       * @return {object} Promise resolved when service is ready\n       */\n      $translate.onReady = function (fn) {\n        var deferred = $q.defer();\n        if (angular.isFunction(fn)) {\n          deferred.promise.then(fn);\n        }\n        if ($isReady) {\n          deferred.resolve();\n        } else {\n          $onReadyDeferred.promise.then(deferred.resolve);\n        }\n        return deferred.promise;\n      };\n\n      // Whenever $translateReady is being fired, this will ensure the state of $isReady\n      var globalOnReadyListener = $rootScope.$on('$translateReady', function () {\n        $onReadyDeferred.resolve();\n        globalOnReadyListener(); // one time only\n        globalOnReadyListener = null;\n      });\n      var globalOnChangeListener = $rootScope.$on('$translateChangeEnd', function () {\n        $onReadyDeferred.resolve();\n        globalOnChangeListener(); // one time only\n        globalOnChangeListener = null;\n      });\n\n      if ($loaderFactory) {\n\n        // If at least one async loader is defined and there are no\n        // (default) translations available we should try to load them.\n        if (angular.equals($translationTable, {})) {\n          if ($translate.use()) {\n            $translate.use($translate.use());\n          }\n        }\n\n        // Also, if there are any fallback language registered, we start\n        // loading them asynchronously as soon as we can.\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          var processAsyncResult = function (translation) {\n            translations(translation.key, translation.table);\n            $rootScope.$emit('$translateChangeEnd', { language: translation.key });\n            return translation;\n          };\n          for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n            var fallbackLanguageId = $fallbackLanguage[i];\n            if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {\n              langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);\n            }\n          }\n        }\n      } else {\n        $rootScope.$emit('$translateReady', { language: $translate.use() });\n      }\n\n      return $translate;\n    }\n  ];\n}\n$translate.$inject = ['$STORAGE_KEY', '$windowProvider', '$translateSanitizationProvider', 'pascalprechtTranslateOverrider'];\n\n$translate.displayName = 'displayName';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateDefaultInterpolation\n * @requires $interpolate\n *\n * @description\n * Uses angular's `$interpolate` services to interpolate strings against some values.\n *\n * Be aware to configure a proper sanitization strategy.\n *\n * See also:\n * * {@link pascalprecht.translate.$translateSanitization}\n *\n * @return {object} $translateDefaultInterpolation Interpolator service\n */\nangular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', $translateDefaultInterpolation);\n\nfunction $translateDefaultInterpolation ($interpolate, $translateSanitization) {\n\n  'use strict';\n\n  var $translateInterpolator = {},\n      $locale,\n      $identifier = 'default';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#setLocale\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Sets current locale (this is currently not use in this interpolation).\n   *\n   * @param {string} locale Language key or locale.\n   */\n  $translateInterpolator.setLocale = function (locale) {\n    $locale = locale;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#getInterpolationIdentifier\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Returns an identifier for this interpolation service.\n   *\n   * @returns {string} $identifier\n   */\n  $translateInterpolator.getInterpolationIdentifier = function () {\n    return $identifier;\n  };\n\n  /**\n   * @deprecated will be removed in 3.0\n   * @see {@link pascalprecht.translate.$translateSanitization}\n   */\n  $translateInterpolator.useSanitizeValueStrategy = function (value) {\n    $translateSanitization.useStrategy(value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#interpolate\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Interpolates given string agains given interpolate params using angulars\n   * `$interpolate` service.\n   *\n   * @returns {string} interpolated string.\n   */\n  $translateInterpolator.interpolate = function (string, interpolationParams) {\n    interpolationParams = interpolationParams || {};\n    interpolationParams = $translateSanitization.sanitize(interpolationParams, 'params');\n\n    var interpolatedText = $interpolate(string)(interpolationParams);\n    interpolatedText = $translateSanitization.sanitize(interpolatedText, 'text');\n\n    return interpolatedText;\n  };\n\n  return $translateInterpolator;\n}\n$translateDefaultInterpolation.$inject = ['$interpolate', '$translateSanitization'];\n\n$translateDefaultInterpolation.displayName = '$translateDefaultInterpolation';\n\nangular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translate\n * @requires $compile\n * @requires $filter\n * @requires $interpolate\n * @restrict AE\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate Translation id which could be either string or interpolated string.\n * @param {string=} translate-values Values to pass into translation id. Can be passed as object literal string or interpolated object.\n * @param {string=} translate-attr-ATTR translate Translation id and put it into ATTR attribute.\n * @param {string=} translate-default will be used unless translation was successful\n * @param {boolean=} translate-compile (default true if present) defines locally activation of {@link pascalprecht.translate.$translateProvider#methods_usePostCompiling}\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre translate=\"TRANSLATION_ID\"></pre>\n        <pre translate>TRANSLATION_ID</pre>\n        <pre translate translate-attr-title=\"TRANSLATION_ID\"></pre>\n        <pre translate=\"{{translationId}}\"></pre>\n        <pre translate>{{translationId}}</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{value: 5}\"></pre>\n        <pre translate translate-values=\"{value: 5}\">WITH_VALUES</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n        <pre translate translate-values=\"{{values}}\">WITH_VALUES</pre>\n        <pre translate translate-attr-title=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        }).preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n    <file name=\"scenario.js\">\n      it('should translate', function () {\n        inject(function ($rootScope, $compile) {\n          $rootScope.translationId = 'TRANSLATION_ID';\n\n          element = $compile('<p translate=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate=\"{{translationId}}\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>TRANSLATION_ID</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>{{translationId}}</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate translate-attr-title=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.attr('title')).toBe('Hello there!');\n        });\n      });\n    </file>\n   </example>\n */\n.directive('translate', translateDirective);\nfunction translateDirective($translate, $q, $interpolate, $compile, $parse, $rootScope) {\n\n  'use strict';\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  return {\n    restrict: 'AE',\n    scope: true,\n    priority: $translate.directivePriority(),\n    compile: function (tElement, tAttr) {\n\n      var translateValuesExist = (tAttr.translateValues) ?\n        tAttr.translateValues : undefined;\n\n      var translateInterpolation = (tAttr.translateInterpolation) ?\n        tAttr.translateInterpolation : undefined;\n\n      var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);\n\n      var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',\n          watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';\n\n      return function linkFn(scope, iElement, iAttr) {\n\n        scope.interpolateParams = {};\n        scope.preText = '';\n        scope.postText = '';\n        scope.translateNamespace = getTranslateNamespace(scope);\n        var translationIds = {};\n\n        var initInterpolationParams = function (interpolateParams, iAttr, tAttr) {\n          // initial setup\n          if (iAttr.translateValues) {\n            angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));\n          }\n          // initially fetch all attributes if existing and fill the params\n          if (translateValueExist) {\n            for (var attr in tAttr) {\n              if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n                var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);\n                interpolateParams[attributeName] = tAttr[attr];\n              }\n            }\n          }\n        };\n\n        // Ensures any change of the attribute \"translate\" containing the id will\n        // be re-stored to the scope's \"translationId\".\n        // If the attribute has no content, the element's text value (white spaces trimmed off) will be used.\n        var observeElementTranslation = function (translationId) {\n\n          // Remove any old watcher\n          if (angular.isFunction(observeElementTranslation._unwatchOld)) {\n            observeElementTranslation._unwatchOld();\n            observeElementTranslation._unwatchOld = undefined;\n          }\n\n          if (angular.equals(translationId , '') || !angular.isDefined(translationId)) {\n            var iElementText = trim.apply(iElement.text());\n\n            // Resolve translation id by inner html if required\n            var interpolateMatches = iElementText.match(interpolateRegExp);\n            // Interpolate translation id if required\n            if (angular.isArray(interpolateMatches)) {\n              scope.preText = interpolateMatches[1];\n              scope.postText = interpolateMatches[3];\n              translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);\n              var watcherMatches = iElementText.match(watcherRegExp);\n              if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {\n                observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function (newValue) {\n                  translationIds.translate = newValue;\n                  updateTranslations();\n                });\n              }\n            } else {\n              // do not assigne the translation id if it is empty.\n              translationIds.translate = !iElementText ? undefined : iElementText;\n            }\n          } else {\n            translationIds.translate = translationId;\n          }\n          updateTranslations();\n        };\n\n        var observeAttributeTranslation = function (translateAttr) {\n          iAttr.$observe(translateAttr, function (translationId) {\n            translationIds[translateAttr] = translationId;\n            updateTranslations();\n          });\n        };\n\n        // initial setup with values\n        initInterpolationParams(scope.interpolateParams, iAttr, tAttr);\n\n        var firstAttributeChangedEvent = true;\n        iAttr.$observe('translate', function (translationId) {\n          if (typeof translationId === 'undefined') {\n            // case of element \"<translate>xyz</translate>\"\n            observeElementTranslation('');\n          } else {\n            // case of regular attribute\n            if (translationId !== '' || !firstAttributeChangedEvent) {\n              translationIds.translate = translationId;\n              updateTranslations();\n            }\n          }\n          firstAttributeChangedEvent = false;\n        });\n\n        for (var translateAttr in iAttr) {\n          if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr') {\n            observeAttributeTranslation(translateAttr);\n          }\n        }\n\n        iAttr.$observe('translateDefault', function (value) {\n          scope.defaultText = value;\n          updateTranslations();\n        });\n\n        if (translateValuesExist) {\n          iAttr.$observe('translateValues', function (interpolateParams) {\n            if (interpolateParams) {\n              scope.$parent.$watch(function () {\n                angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));\n              });\n            }\n          });\n        }\n\n        if (translateValueExist) {\n          var observeValueAttribute = function (attrName) {\n            iAttr.$observe(attrName, function (value) {\n              var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);\n              scope.interpolateParams[attributeName] = value;\n            });\n          };\n          for (var attr in iAttr) {\n            if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n              observeValueAttribute(attr);\n            }\n          }\n        }\n\n        // Master update function\n        var updateTranslations = function () {\n          for (var key in translationIds) {\n\n            if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {\n              updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);\n            }\n          }\n        };\n\n        // Put translation processing function outside loop\n        var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {\n          if (translationId) {\n            // if translation id starts with '.' and translateNamespace given, prepend namespace\n            if (translateNamespace && translationId.charAt(0) === '.') {\n              translationId = translateNamespace + translationId;\n            }\n\n            $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage)\n              .then(function (translation) {\n                applyTranslation(translation, scope, true, translateAttr);\n              }, function (translationId) {\n                applyTranslation(translationId, scope, false, translateAttr);\n              });\n          } else {\n            // as an empty string cannot be translated, we can solve this using successful=false\n            applyTranslation(translationId, scope, false, translateAttr);\n          }\n        };\n\n        var applyTranslation = function (value, scope, successful, translateAttr) {\n          if (translateAttr === 'translate') {\n            // default translate into innerHTML\n            if (!successful && typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n            iElement.empty().append(scope.preText + value + scope.postText);\n            var globallyEnabled = $translate.isPostCompilingEnabled();\n            var locallyDefined = typeof tAttr.translateCompile !== 'undefined';\n            var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';\n            if ((globallyEnabled && !locallyDefined) || locallyEnabled) {\n              $compile(iElement.contents())(scope);\n            }\n          } else {\n            // translate attribute\n            if (!successful && typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n            var attributeName = iAttr.$attr[translateAttr];\n            if (attributeName.substr(0, 5) === 'data-') {\n              // ensure html5 data prefix is stripped\n              attributeName = attributeName.substr(5);\n            }\n            attributeName = attributeName.substr(15);\n            iElement.attr(attributeName, value);\n          }\n        };\n\n        if (translateValuesExist || translateValueExist || iAttr.translateDefault) {\n          scope.$watch('interpolateParams', updateTranslations, true);\n        }\n        scope.$watch('translateLanguage', updateTranslations);\n\n        // Ensures the text will be refreshed after the current language was changed\n        // w/ $translate.use(...)\n        var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);\n\n        // ensure translation will be looked up at least one\n        if (iElement.text().length) {\n          if (iAttr.translate) {\n            observeElementTranslation(iAttr.translate);\n          } else {\n            observeElementTranslation('');\n          }\n        } else if (iAttr.translate) {\n          // ensure attribute will be not skipped\n          observeElementTranslation(iAttr.translate);\n        }\n        updateTranslations();\n        scope.$on('$destroy', unbind);\n      };\n    }\n  };\n}\ntranslateDirective.$inject = ['$translate', '$q', '$interpolate', '$compile', '$parse', '$rootScope'];\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateDirective.displayName = 'translateDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateCloak\n * @requires $rootScope\n * @requires $translate\n * @restrict A\n *\n * $description\n * Adds a `translate-cloak` class name to the given element where this directive\n * is applied initially and removes it, once a loader has finished loading.\n *\n * This directive can be used to prevent initial flickering when loading translation\n * data asynchronously.\n *\n * The class name is defined in\n * {@link pascalprecht.translate.$translateProvider#cloakClassName $translate.cloakClassName()}.\n *\n * @param {string=} translate-cloak If a translationId is provided, it will be used for showing\n *                                  or hiding the cloak. Basically it relies on the translation\n *                                  resolve.\n */\n.directive('translateCloak', translateCloakDirective);\n\nfunction translateCloakDirective($translate, $rootScope) {\n\n  'use strict';\n\n  return {\n    compile: function (tElement) {\n      var applyCloak = function () {\n        tElement.addClass($translate.cloakClassName());\n      },\n      removeCloak = function () {\n        tElement.removeClass($translate.cloakClassName());\n      };\n      $translate.onReady(function () {\n        removeCloak();\n      });\n      applyCloak();\n\n      return function linkFn(scope, iElement, iAttr) {\n        if (iAttr.translateCloak && iAttr.translateCloak.length) {\n          // Register a watcher for the defined translation allowing a fine tuned cloak\n          iAttr.$observe('translateCloak', function (translationId) {\n            $translate(translationId).then(removeCloak, applyCloak);\n          });\n          // Register for change events as this is being another indicicator revalidating the cloak)\n          $rootScope.$on('$translateChangeSuccess', function () {\n            $translate(iAttr.translateCloak).then(removeCloak, applyCloak);\n          });\n        }\n      };\n    }\n  };\n}\ntranslateCloakDirective.$inject = ['$translate', '$rootScope'];\n\ntranslateCloakDirective.displayName = 'translateCloakDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateNamespace\n * @restrict A\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate namespace name which could be either string or interpolated string.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div translate-namespace=\"CONTENT\">\n\n        <div>\n            <h1 translate>.HEADERS.TITLE</h1>\n            <h1 translate>.HEADERS.WELCOME</h1>\n        </div>\n\n        <div translate-namespace=\".HEADERS\">\n            <h1 translate>.TITLE</h1>\n            <h1 translate>.WELCOME</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'CONTENT': {\n            'HEADERS': {\n                TITLE: 'Title'\n            }\n          },\n          'CONTENT.HEADERS.WELCOME': 'Welcome'\n        }).preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateNamespace', translateNamespaceDirective);\n\nfunction translateNamespaceDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return {\n        pre: function (scope, iElement, iAttrs) {\n          scope.translateNamespace = getTranslateNamespace(scope);\n\n          if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === '.') {\n            scope.translateNamespace += iAttrs.translateNamespace;\n          } else {\n            scope.translateNamespace = iAttrs.translateNamespace;\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateNamespaceDirective.displayName = 'translateNamespaceDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateLanguage\n * @restrict A\n *\n * @description\n * Forces the language to the directives in the underlying scope.\n *\n * @param {string=} translate language that will be negotiated.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div>\n\n        <div>\n            <h1 translate>HELLO</h1>\n        </div>\n\n        <div translate-language=\"de\">\n            <h1 translate>HELLO</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider\n          .translations('en',{\n            'HELLO': 'Hello world!'\n          })\n          .translations('de',{\n            'HELLO': 'Hallo Welt!'\n          })\n          .translations(.preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateLanguage', translateLanguageDirective);\n\nfunction translateLanguageDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return function linkFn(scope, iElement, iAttrs) {\n        iAttrs.$observe('translateLanguage', function (newTranslateLanguage) {\n          scope.translateLanguage = newTranslateLanguage;\n        });\n      };\n    }\n  };\n}\n\ntranslateLanguageDirective.displayName = 'translateLanguageDirective';\n\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc filter\n * @name pascalprecht.translate.filter:translate\n * @requires $parse\n * @requires pascalprecht.translate.$translate\n * @function\n *\n * @description\n * Uses `$translate` service to translate contents. Accepts interpolate parameters\n * to pass dynamized values though translation.\n *\n * @param {string} translationId A translation id to be translated.\n * @param {*=} interpolateParams Optional object literal (as hash or string) to pass values into translation.\n *\n * @returns {string} Translated text.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre>{{ 'TRANSLATION_ID' | translate }}</pre>\n        <pre>{{ translationId | translate }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:'{value: 5}' }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:values }}</pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en', {\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        });\n        $translateProvider.preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n   </example>\n */\n.filter('translate', translateFilterFactory);\n\nfunction translateFilterFactory($parse, $translate) {\n\n  'use strict';\n\n  var translateFilter = function (translationId, interpolateParams, interpolation, forceLanguage) {\n\n    if (!angular.isObject(interpolateParams)) {\n      interpolateParams = $parse(interpolateParams)(this);\n    }\n\n    return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);\n  };\n\n  if ($translate.statefulFilter()) {\n    translateFilter.$stateful = true;\n  }\n\n  return translateFilter;\n}\ntranslateFilterFactory.$inject = ['$parse', '$translate'];\n\ntranslateFilterFactory.displayName = 'translateFilterFactory';\n\nangular.module('pascalprecht.translate')\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translationCache\n * @requires $cacheFactory\n *\n * @description\n * The first time a translation table is used, it is loaded in the translation cache for quick retrieval. You\n * can load translation tables directly into the cache by consuming the\n * `$translationCache` service directly.\n *\n * @return {object} $cacheFactory object.\n */\n  .factory('$translationCache', $translationCache);\n\nfunction $translationCache($cacheFactory) {\n\n  'use strict';\n\n  return $cacheFactory('translations');\n}\n$translationCache.$inject = ['$cacheFactory'];\n\n$translationCache.displayName = '$translationCache';\nreturn 'pascalprecht.translate';\n\n}));\n","/**\n * State-based routing for AngularJS\n * @version v0.2.18\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    toJson = angular.toJson;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i] || !parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:\n        result = result.replace(/\\/$/, '');\n        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  var param, paramVal;\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    param = this.params[paramName];\n    paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n    param = this.params[paramName];\n    paramVal = searchParams[paramName];\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validates\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      var isFinalPathParam = i + 1 === nPath;\n\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n\n      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      if (encoded.length === 0) continue;\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        if (isArray(val) && val.length === 0) return val;\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  // Use tildes to pre-encode slashes.\n  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n  // and bidirectional encoding/decoding fails.\n  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    \"string\": {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    \"int\": {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    \"bool\": {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    \"date\": {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    \"json\": {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    \"any\": { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\n      if (angular.isString(config.type))\n        return $types[config.type];\n      if (config.type instanceof Type)\n        return config.type;\n      return new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {function} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|function} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. \n   * \n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|function} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n\n        isHtml5 = isHtml5 && $sniffer.history;\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. Only parameters specified in the state definition can be overridden, new \n     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n     *    have changed.  It will reload the resolves and views of the current state and parent states.\n     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n     *    the transition reloads the resolves and views for that matched state, and all its children states.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n      \n      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n      if (hash) toParams['#'] = hash;\n      \n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n          if ($state.transition == null) $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .factory('$stateParams', function () { return {}; })\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\nvar ngMajorVer = angular.version.major;\nvar ngMinorVer = angular.version.minor;\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations\n * will be applied to the ui-view)\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = {\n      enter: function (element, target, cb) { target.after(element); cb(); },\n      leave: function (element, cb) { element.remove(); cb(); }\n    };\n\n    if (!!attrs.noanimation) return statics;\n\n    function animEnabled(element) {\n      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);\n      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();\n      return (!!$animator);\n    }\n\n    // ng 1.2+\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          if (!animEnabled(element)) {\n            statics.enter(element, target, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function(element, cb) {\n          if (!animEnabled(element)) {\n            statics.leave(element, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        }\n      };\n    }\n\n    // ng 1.1.5\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics;\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          var _previousEl = previousEl;\n          var _currentScope = currentScope;\n\n          if (_currentScope) {\n            _currentScope._willBeDestroyed = true;\n          }\n\n          function cleanOld() {\n            if (_previousEl) {\n              _previousEl.remove();\n            }\n\n            if (_currentScope) {\n              _currentScope.$destroy();\n            }\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              cleanOld();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n          } else {\n            cleanOld();\n            previousEl = null;\n          }\n\n          currentEl = null;\n          currentScope = null;\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          currentScope.$emit('$viewContentLoaded', name);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var inherited = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\nfunction clickHook(el, $state, $timeout, type, current) {\n  return function(e) {\n    var button = e.which || e.button, target = current();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function() {\n        $state.go(target.state, target.params, target.options);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\n      e.preventDefault = function() {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\nfunction defaultOpts(el, $state) {\n  return { relative: stateContext(el) || $state.$current, inherit: true };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n * URL, the directive will automatically generate & update the `href` attribute via\n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n * the link will trigger a state transition with optional parameters.\n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative\n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the\n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n *\n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n      var def    = { state: ref.state, href: null, params: null };\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n\n      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\n      var update = function(val) {\n        if (val) def.params = angular.copy(val);\n        def.href = $state.href(ref.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(ref.state, def.params);\n        if (def.href !== null) attrs.$set(type.attr, def.href);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n        def.params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-state\n *\n * @requires ui.router.state.uiSref\n *\n * @restrict A\n *\n * @description\n * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n * params and override options.\n *\n * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}\n * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDynamicDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n      var def    = { state: null, params: null, options: null, href: null };\n\n      function runStateRefLink (group) {\n        def.state = group[0]; def.params = group[1]; def.options = group[2];\n        def.href = $state.href(def.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(def.state, def.params);\n        if (def.href) attrs.$set(type.attr, def.href);\n      }\n\n      scope.$watch(watch, runStateRefLink, true);\n      runStateRefLink(scope.$eval(watch));\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * It is also possible to pass ui-sref-active an expression that evaluates\n * to an object hash, whose keys represent active class names and whose\n * values represent the respective state names/globs.\n * ui-sref-active will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * @Example\n * Given the following template, with \"admin\" being an abstract state:\n * <pre>\n * <div ui-sref-active=\"{'active': 'admin.*'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * </pre>\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied\n * to both the <div> and <a> elements. It is important to note that the state\n * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n      try {\n        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n      } catch (e) {\n        // Do nothing. uiSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n      if (isObject(uiSrefActive)) {\n        forEach(uiSrefActive, function(stateOrName, activeClass) {\n          if (isString(stateOrName)) {\n            var ref = parseStateRef(stateOrName, $state.current.name);\n            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n          }\n        });\n      }\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ui-sref-active, so we\n        // shadow the one that comes from ui-sref\n        if (isObject(uiSrefActive) && states.length > 0) {\n          return;\n        }\n        addState(newState, newParams, uiSrefActive);\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      function addState(stateName, stateParams, activeClass) {\n        var state = $state.get(stateName, stateContext($element));\n        var stateHash = createStateHash(stateName, stateParams);\n\n        states.push({\n          state: state || { name: stateName },\n          params: stateParams,\n          hash: stateHash\n        });\n\n        activeClasses[stateHash] = activeClass;\n      }\n\n      /**\n       * @param {string} state\n       * @param {Object|string} [params]\n       * @return {string}\n       */\n      function createStateHash(state, params) {\n        if (!isString(state)) {\n          throw new Error('state should be a string');\n        }\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        params = $scope.$eval(params);\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        return state;\n      }\n\n      // Update route state\n      function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }\n\n      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n      function removeClass(el, className) { el.removeClass(className); }\n      function anyMatch(state, params) { return $state.includes(state.name, params); }\n      function exactMatch(state, params) { return $state.is(state.name, params); }\n\n      update();\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n  .directive('uiState', $StateRefDynamicDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state, params) {\n    return $state.is(state, params);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state, params, options) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);","'use strict';\n// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.\n\nmodule.exports = {\n    // Create a <link> tag with optional data attributes\n    createLink: function(href, attributes) {\n        var head = document.head || document.getElementsByTagName('head')[0];\n        var link = document.createElement('link');\n\n        link.href = href;\n        link.rel = 'stylesheet';\n\n        for (var key in attributes) {\n            if ( ! attributes.hasOwnProperty(key)) {\n                continue;\n            }\n            var value = attributes[key];\n            link.setAttribute('data-' + key, value);\n        }\n\n        head.appendChild(link);\n    },\n    // Create a <style> tag with optional data attributes\n    createStyle: function(cssText, attributes) {\n        var head = document.head || document.getElementsByTagName('head')[0],\n            style = document.createElement('style');\n\n        style.type = 'text/css';\n\n        for (var key in attributes) {\n            if ( ! attributes.hasOwnProperty(key)) {\n                continue;\n            }\n            var value = attributes[key];\n            style.setAttribute('data-' + key, value);\n        }\n        \n        if (style.sheet) { // for jsdom and IE9+\n            style.innerHTML = cssText;\n            style.sheet.cssText = cssText;\n            head.appendChild(style);\n        } else if (style.styleSheet) { // for IE8 and below\n            head.appendChild(style);\n            style.styleSheet.cssText = cssText;\n        } else { // for Chrome, Firefox, and Safari\n            style.appendChild(document.createTextNode(cssText));\n            head.appendChild(style);\n        }\n    }\n};\n"],"sourceRoot":"/source/"}