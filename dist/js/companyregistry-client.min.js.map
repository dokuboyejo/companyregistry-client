{"version":3,"sources":["node_modules/browser-pack/_prelude.js","companyregistry-client.js","app/angularcontrollers.js","app/angulardirectives.js","app/angularservices.js","app/app.js","app/components/beneficiary/BeneficiaryCreateViewDirective.js","app/components/beneficiary/BeneficiaryDeleteViewDirective.js","app/components/beneficiary/BeneficiaryDetailViewDirective.js","app/components/beneficiary/BeneficiaryListFragmentViewDirective.js","app/components/beneficiary/BeneficiaryListViewDirective.js","app/components/beneficiary/BeneficiarySearchViewDirective.js","app/components/beneficiary/BeneficiaryService.js","app/components/beneficiary/BeneficiaryUpdateViewDirective.js","app/components/beneficiary/BeneficiaryViewController.js","app/components/beneficiary/BeneficiaryViewDirective.js","app/components/common/MainViewController.js","app/components/common/MainViewDirective.js","app/components/common/States.js","app/components/common/UtilService.js","app/components/company/CompanyCreateViewDirective.js","app/components/company/CompanyDeleteViewDirective.js","app/components/company/CompanyListFragmentViewDirective.js","app/components/company/CompanyListViewDirective.js","app/components/company/CompanySearchViewDirective.js","app/components/company/CompanyService.js","app/components/company/CompanyUpdateViewDirective.js","app/components/company/CompanyViewController.js","app/components/company/CompanyViewDirective.js","app/components/nav/SideNavViewController.js","app/components/nav/SideNavViewDirective.js","app/components/nls/i18n-en.js","app/config.js","app/constants.js","node_modules/angular-animate/angular-animate.js","node_modules/angular-animate/index.js","node_modules/angular-block-ui/dist/angular-block-ui.js","node_modules/angular-block-ui/dist/angular-block-ui.min.css","node_modules/angular-sanitize/angular-sanitize.js","node_modules/angular-sanitize/index.js","node_modules/angular-translate/dist/angular-translate.js","node_modules/angular-ui-router/release/angular-ui-router.js","node_modules/browserify-css/browser.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","global","ng","window","MainViewController","SideNavViewController","BeneficiaryViewController","CompanyViewController","config","moduleName","configBlock","namespace","controllersModule","controller","this","self","./components/beneficiary/BeneficiaryViewController","./components/common/MainViewController","./components/company/CompanyViewController","./components/nav/SideNavViewController","./config",2,"MainViewDirective","SideNavViewDirective","BeneficiaryViewDirective","BeneficiaryCreateViewDirective","BeneficiaryUpdateViewDirective","BeneficiaryDeleteViewDirective","BeneficiaryListViewDirective","BeneficiaryListFragmentViewDirective","BeneficiaryDetailViewDirective","BeneficiarySearchViewDirective","CompanyViewDirective","CompanyCreateViewDirective","CompanyUpdateViewDirective","CompanyDeleteViewDirective","CompanyListViewDirective","CompanyListFragmentViewDirective","CompanySearchViewDirective","directivesModule","directive","./components/beneficiary/BeneficiaryCreateViewDirective","./components/beneficiary/BeneficiaryDeleteViewDirective","./components/beneficiary/BeneficiaryDetailViewDirective","./components/beneficiary/BeneficiaryListFragmentViewDirective","./components/beneficiary/BeneficiaryListViewDirective","./components/beneficiary/BeneficiarySearchViewDirective","./components/beneficiary/BeneficiaryUpdateViewDirective","./components/beneficiary/BeneficiaryViewDirective","./components/common/MainViewDirective","./components/company/CompanyCreateViewDirective","./components/company/CompanyDeleteViewDirective","./components/company/CompanyListFragmentViewDirective","./components/company/CompanyListViewDirective","./components/company/CompanySearchViewDirective","./components/company/CompanyUpdateViewDirective","./components/company/CompanyViewDirective","./components/nav/SideNavViewDirective",3,"BeneficiaryService","CompanyService","UtilService","servicesModule","factory","service","./components/beneficiary/BeneficiaryService","./components/common/UtilService","./components/company/CompanyService",4,"constants","services","controllers","directives","animateModule","translateModule","sanitizeModule","blockUIModule","uiRouterModule","name","settings","states","blockUI","inform","hrefSanitize","constant","runBlock","run","./angularcontrollers","./angulardirectives","./angularservices","./constants","angular-animate","angular-block-ui","angular-block-ui/dist/angular-block-ui.min.css","angular-sanitize","angular-translate","angular-ui-router",5,"templateUrl","restrict","scope","beneficiary","controllerAs",6,7,"$parse","$compile","$rootScope","$timeout","link","el","attrs","$on","ev","data","beneficiaries","id","beneficiaryId","inputEls","angular","element","find","j","attr","$inject",8,"delref",9,10,11,"$http","serviceInstance","selectedBeneficiaryId","popOnDelete","getBeneficiary","url","callback","method","then","results","error","errorData","status","message","createBeneficiary","updateBeneficiary","deleteBeneficiary",12,13,"$scope","$window","$document","$log","$state","$modal","beneficiaryService","utilService","CONSTANTS","useExistingBeneficiary","minimumValidBeneficiary","beneficiarySearched","beneficiaryFound","searchRequestSumbitted","addRequestSubmitted","addRequestAttempted","updateRequestSubmitted","updateRequestAttempted","deleteRequestSubmitted","deleteSuccessful","serviceUrl","path","initBeneficiary","firstName","lastName","current","resetBeneficiary","addBeneficiary","$event","stopPropagation","isFormValid","warn","add","ttl","type","beneficiaryCreateBlock","instances","get","start","beneficiaryContextPath","result","go","reload","errorMessage","stop","cancelAddBeneficiary","beneficiaryUpdateBlock","cancelOrCloseBeneficiaryUpdate","beneficiaryDeleteBlock","info","cancelOrCloseBeneficiaryDelete","$dismiss","fetchBeneficiary","splice","idSearch","isBlank","baseUrl","beneficiaryListBlock","push","searchBeneficiary","isValidId","registerPopoverShow","mutateBeneficiaryOptions","$index","registerPopoverPrep","discardMessage","registerPopoverHide","popover","trigger","clear",14,15,16,17,"stateConfig","main","views","template","mainItem@start","company","initial","list","search","update","delete","onEnter","open","backdrop","keyboard","windowClass",18,"formId","isValid","formEl","document","getElementById","className","indexOf","elements","value","isUndefined","parseInt",19,20,21,"companies",22,23,24,"selectedCompanyId","getCompany","dataType","createCompany","console","log","updateCompany","deleteCompany",25,26,"$q","companyService","companyFound","initCompany","address","city","country","email","phoneNumber","verifyMinimumValidBeneficiary","resetCompany","addCompany","companyCreateBlock","companyContextPath","cancelAddCompany","companyUpdateBlock","cancelOrCloseCompanyUpdate","companyDeleteBlock","cancelOrCloseCompanyDelete","fetchCompany","companyListBlock","searchCompany","disableBeneficiary","mutateCompanyOptions","removeBeneficiary","$emit",27,28,29,30,"translationsEN","BENEFICIARY","ID","FIRST_NAME","LAST_NAME",31,"$logProvider","$translateProvider","debugEnabled","i18n_en","useSanitizeValueStrategy","translations","useStaticFilesLoader","files","prefix","suffix","preferredLanguage","fallbackLanguage","$stateProvider","$urlRouterProvider","otherwise","state","copy","blockUIConfig","delay","autoInjectBodyBlock","informProvider","defaults","html","modal","$modalStack","top","getTop","dismiss","key","$compileProvider","aHrefSanitizationWhitelist","./components/common/States","./components/nls/i18n-en",32,33,"undefined","assertArg","arg","reason","ngMinErr","mergeClasses","b","isArray","join","packageStyles","options","styles","to","from","pendClasses","classes","fix","isPrefix","isString","split","forEach","klass","removeFromArray","arr","val","index","stripCommentsFromElement","jqLite","nodeType","ELEMENT_NODE","extractElementNode","elm","$$addClass","$$jqLite","addClass","$$removeClass","removeClass","applyAnimationClassesFactory","prepareAnimationOptions","$$prepared","domOperation","noop","$$domOperationFired","applyAnimationStyles","applyAnimationFromStyles","applyAnimationToStyles","css","mergeAnimationOptions","target","newOptions","toAdd","toRemove","resolveElementClasses","preparationClasses","concatWithSpace","realDomOperation","extend","existing","splitClassesToLookup","obj","ADD_CLASS","REMOVE_CLASS","flags","prop","allow","getDomNode","applyGeneratedPreparationClasses","event","EVENT_CLASS_PREFIX","ADD_CLASS_SUFFIX","REMOVE_CLASS_SUFFIX","clearGeneratedClasses","activeClasses","blockTransitions","node","duration","applyInlineStyle","TRANSITION_DELAY_PROP","blockKeyframeAnimations","applyBlock","ANIMATION_PROP","ANIMATION_PLAYSTATE_KEY","styleTuple","style","getCssKeyframeDurationStyle","ANIMATION_DURATION_PROP","getCssDelayStyle","isKeyframeAnimation","ANIMATION_DELAY_PROP","computeCssStyles","properties","Object","create","detectedStyles","getComputedStyle","formalStyleName","actualStyleName","c","charAt","parseMaxTime","str","maxValue","values","substring","parseFloat","Math","max","truthyTimingValue","getCssTransitionDurationStyle","applyOnlyDuration","TRANSITION_PROP","DURATION_KEY","createLocalCacheLookup","cache","flush","count","entry","total","put","registerRestorableStyles","backup","isDefined","getPropertyValue","TRANSITIONEND_EVENT","ANIMATIONEND_EVENT","isObject","isFunction","isElement","ACTIVE_CLASS_SUFFIX","NG_ANIMATE_CLASSNAME","NG_ANIMATE_CHILDREN_DATA","CSS_PREFIX","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","PROPERTY_KEY","DELAY_KEY","TIMING_KEY","ANIMATION_ITERATION_COUNT_KEY","SAFE_FAST_FORWARD_DURATION_VALUE","TRANSITION_DURATION_PROP","$$rAFSchedulerFactory","$$rAF","scheduler","tasks","queue","concat","nextTick","items","shift","cancelFn","waitUntilQuiet","fn","$$AnimateChildrenDirective","ngAnimateChildren","$observe","ANIMATE_TIMER_KEY","ONE_SECOND","ELAPSED_TIME_MAX_DECIMAL_PLACES","CLOSING_TIME_BUFFER","DETECT_CSS_PROPERTIES","transitionDuration","transitionDelay","transitionProperty","animationDuration","animationDelay","animationIterationCount","DETECT_STAGGER_CSS_PROPERTIES","$AnimateCssProvider","$animateProvider","gcsLookup","gcsStaggerLookup","$get","$$AnimateRunner","$$forceReflow","$sniffer","$$rAFScheduler","$animate","gcsHashFn","extraClasses","KEY","parentNode","parentID","parentCounter","getAttribute","computeCachedCssStyles","cacheKey","timings","computeCachedCssStaggerStyles","stagger","staggerClassName","rafWaitQueue","pageWidth","computeTimings","aD","tD","maxDelay","maxDuration","applyAnimationClasses","endFn","close","rejected","animationClosed","animationCompleted","animationPaused","$$skipPreparationClasses","temporaryStyles","keys","restoreStyles","setProperty","removeProperty","onDone","runner","complete","applyBlocking","blockTransition","blockKeyframeAnimation","closeAndReturnNoopAnimator","end","cancel","$$willAnimate","triggerAnimationStart","recalculateTimingStyles","fullClassName","relativeDelay","hasTransitions","hasAnimations","applyAnimationDelay","delayStyle","maxDelayTime","maxDurationTime","easing","easeProp","easeVal","events","startTime","Date","now","timerTime","endTime","animationsData","setupFallbackTimer","currentTimerData","expectedEndTime","timer","onAnimationExpired","on","onAnimationProgress","cleanupStyles","removeData","originalEvent","timeStamp","$manualTimeStamp","elapsedTime","toFixed","playPause","playAnimation","maxStagger","itemIndex","floor","runnerHost","resume","pause","enabled","animations","transitions","isStructural","structural","structuralClassName","addRemoveClassName","applyClassesEarly","trim","hasToStyles","containsKeyframeAnimation","keyframeStyle","staggerVal","transitionStyle","durationStyle","staggerIndex","isFirst","skipBlocking","hasTransitionAll","applyTransitionDuration","applyAnimationDuration","applyTransitionDelay","$$AnimateCssDriverProvider","$$animationProvider","isDocumentFragment","drivers","NG_ANIMATE_SHIM_CLASS_NAME","NG_ANIMATE_ANCHOR_CLASS_NAME","NG_OUT_ANCHOR_CLASS_NAME","NG_IN_ANCHOR_CLASS_NAME","$animateCss","$rootElement","filterCssClasses","replace","getUniqueValues","filter","prepareAnchoredAnimation","outAnchor","inAnchor","calculateAnchorStyles","anchor","coords","getBoundingClientRect","bodyNode","scrollTop","scrollLeft","prepareOutAnimation","animator","clone","getClassVal","prepareInAnimation","endingClasses","startingClasses","remove","cloneNode","rootBodyElement","append","animatorIn","animatorOut","startingAnimator","currentAnimation","done","prepareFromToAnchorAnimation","anchors","fromAnimation","prepareRegularAnimation","toAnimation","anchorAnimations","outElement","inElement","animationRunners","animation","all","animationDetails","body","rootNode","contains","$$AnimateJsProvider","$injector","lookupAnimations","matches","flagMap","animationFactory","$$registeredAnimations","applyOptions","executeAnimationFn","args","classesToAdd","classesToRemove","apply","groupEventedAnimations","fnName","operations","ani","endProgressCb","resolved","onAnimationComplete","cancelled","packageAnimations","runners","animateFn","reject","arguments","before","after","afterFn","beforeFn","toUpperCase","substr","onComplete","success","endAnimations","closeActiveAnimations","chain","$$AnimateJsDriverProvider","$$animateJs","prepareAnimation","endFnFactory","NG_ANIMATE_ATTR_NAME","NG_ANIMATE_PIN_DATA","$$AnimateQueueProvider","isAllowed","ruleType","previousAnimation","rules","some","hasAnimationClasses","and","PRE_DIGEST_STATE","RUNNING_STATE","skip","newAnimation","nO","cO","$$HashMap","$$animation","$templateRequest","postDigestTaskFactory","postDigestCalled","$$postDigest","normalizeAnimationOptions","findCallbacks","targetNode","entries","callbackRegistry","queueAnimation","notifyProgress","phase","runInNextPostDigestOrNow","callbacks","progress","parent","isAnimatableClassName","skipAnimations","animationsEnabled","disabledElementsLookup","existingAnimation","activeAnimationsLookup","hasExistingAnimation","areAnimationsAllowed","closeChildAnimations","skipAnimationFlag","cancelAnimationFlag","joinAnimationFlag","isValidAnimation","clearElementAnimationState","counter","markElementAnimationState","animationCancelled","parentElement","realRunner","setHost","children","querySelectorAll","child","removeAttribute","isMatchingElement","nodeOrElmA","nodeOrElmB","animateChildren","bodyElement","bodyElementDetected","nodeName","rootElementDetected","parentAnimationDetected","parentHost","details","allowAnimation","setAttribute","oldValue","newValue","deregisterWatch","$watch","totalPendingRequests","isEmpty","classNameFilter","test","container","off","filterFromRegistry","matchContainer","matchCallback","containerNode","isMatch","pin","bool","argCount","hasElement","recordExists","$$AnimateAsyncRunFactory","waitForTick","waitQueue","passed","$$AnimateRunnerFactory","$$animateAsyncRun","AnimateRunner","host","_doneCallbacks","_runInAnimationFrame","_state","INITIAL_STATE","DONE_PENDING_STATE","DONE_COMPLETE_STATE","next","response","onProgress","prototype","getPromise","promise","resolve","resolveHandler","rejectHandler","catch","handler","finally","_resolve","$$AnimationProvider","setRunner","RUNNER_STORAGE_KEY","removeRunner","getRunner","NG_ANIMATE_REF_ATTR","sortAnimations","processNode","processed","elementNode","domNode","lookup","parentEntry","tree","flatten","remainingLevelEntries","nextLevelEntries","row","childEntry","animationQueue","getAnchorNodes","SELECTOR","hasAttribute","groupAnimations","preparedAnimations","refLookup","enterOrMove","anchorNodes","direction","animationID","usedIndicesLookup","anchorGroups","indexKey","toString","lookupKey","group","beforeStart","cssClassesIntersection","out","in","aa","invokeFirstDriver","driverName","has","driver","tempClasses","updateAnimationRunners","newRunner","handleDestroyedElement","groupedAnimations","toBeSortedAnimations","animationEntry","startAnimationFn","closeFn","targetElement","operation","animationRunner","provider",34,"./angular-animate",35,"moduleLoaded","ex","blockNavigation","mainBlockUI","registerLocationChange","$_blockLocationChange","blockCount","preventDefault","blockBrowserNavigation","blkUI","$provide","$httpProvider","decorator","$delegate","exception","cause","resetOnException","reset","interceptors","$templateCache","decorateLocation","hook","overrides","blockUiContainerLinkFn","compile","$element","blockUIUtils","$attrs","srvInstance","inheritedData","blockUiCompileFn","blockUiPreLinkFn","pre","hasClass","cssClass","$_blockUiMessageClass","instanceId","blockUi","$id","parentInstance","_parent","release","addRef","$_blockUiState","toggleClass","pattern","blockUiPattern","regExp","buildRegExp","autoBlock","requestFilter","injectBlockUI","stopBlockUI","$_noBlock","$_blocks","rejection","request","locate","requestError","responseError","BlockUI","startPromise","blocking","doneCallbacks","_id","_refs","$ae","activeElement","isElementInBlockScope","_restoreFocus","blur","_cancelStartTimeout","regexp","_pattern","executeCallbacks","$body","focus","cb","mainBlock","_destroy","isNaN","instance","idOrInstance","forEachFnHook","$","utils","match","RegExp","forEachFn","blockScope","findElement","predicateFn","traverse","ret","$elements",36,"createStyle","href","browserify-css",37,"$SanitizeProvider","$$sanitizeUri","buf","htmlParser","htmlSanitizeWriter","uri","isImage","sanitizeText","chars","writer","makeMap","lowercaseKeys","lowercase","parseStartTag","tag","tagName","rest","unary","blockElements","stack","last","inlineElements","parseEndTag","optionalEndTagElements","voidElements","ATTR_REGEXP","doubleQuotedValue","singleQuotedValue","unquotedValue","decodeEntities","pos","text","specialElements","COMMENT_REGEXP","CDATA_REGEXP","lastIndexOf","comment","DOCTYPE_REGEXP","BEGING_END_TAGE_REGEXP","END_TAG_REGEXP","BEGIN_TAG_REGEXP","START_TAG_REGEXP","$sanitizeMinErr","hiddenPre","innerHTML","textContent","encodeEntities","SURROGATE_PAIR_REGEXP","hi","charCodeAt","low","NON_ALPHANUMERIC_REGEXP","uriValidator","ignore","bind","validElements","lkey","validAttrs","uriAttrs","$$minErr","optionalEndTagBlockElements","optionalEndTagInlineElements","svgElements","htmlAttrs","svgAttrs","createElement","$sanitize","LINKY_URL_REGEXP","MAILTO_REGEXP","addText","addLink","raw",38,"./angular-sanitize",39,"root","define","amd","runTranslate","$translate","storageKey","storage","fallbackFromIncorrectStorageValue","preferred","use","displayName","$translateSanitizationProvider","strategies","currentStrategy","hasConfiguredStrategy","hasShownNoStrategyConfiguredWarning","sanitize","mode","htmlSanitizeValue","escape","htmlEscapeValue","sanitizeParameters","mapInterpolationParameters","escapeParameters","escaped","addStrategy","strategyName","strategyFunction","removeStrategy","useStrategy","strategy","cachedStrategyMap","applyStrategies","selectedStrategies","selectedStrategy","showNoStrategyConfiguredWarning","iteratee","propertyValue","propertyKey","isNumber","$STORAGE_KEY","$windowProvider","pascalprechtTranslateOverrider","$preferredLanguage","$languageKeyAliases","$fallbackLanguage","$fallbackWasString","$uses","$nextLang","$storageFactory","$storagePrefix","$missingTranslationHandlerFactory","$interpolationFactory","$loaderFactory","$loaderOptions","$notFoundIndicatorLeft","$notFoundIndicatorRight","loaderCache","$translationTable","$availableLanguageKeys","$storageKey","$interpolatorFactories","$cloakClassName","$postCompilingEnabled","$forceAsyncReloadEnabled","$nestedObjectDelimeter","$isReady","directivePriority","statefulFilter","uniformLanguageTagResolver","languageTagResolver","default","java","temp","parts","toLowerCase","bcp47","version","getFirstBrowserLanguage","getLocale","language","nav","navigator","browserLanguagePropertyKeys","languages","locale","array","searchElement","len","negotiateLocale","avail","alias","langKeyAlias","hasWildcardKey","hasExactKey","hasOwnProperty","slice","langKey","translationTable","flatObject","cloakClassName","nestedObjectDelimeter","delimiter","prevKey","keyWithPath","keyWithShortPath","addInterpolation","useMessageFormatInterpolation","useInterpolation","setupPreferredLanguage","translationNotFoundIndicator","indicator","translationNotFoundIndicatorLeft","translationNotFoundIndicatorRight","fallbackStack","useUrlLoader","useLoader","loaderFactory","useLocalStorage","useStorage","useCookieStorage","storageFactory","storagePrefix","useMissingTranslationHandlerLog","useMissingTranslationHandler","usePostCompiling","forceAsyncReload","uniformLanguageTag","standard","determinePreferredLanguage","registerAvailableLanguageKeys","languageKeys","aliases","useLoaderCache","priority","Storage","fallbackIndex","startFallbackIteration","defaultInterpolator","pendingLoader","interpolatorHashMap","langPromises","translationId","interpolateParams","interpolationId","defaultTranslationText","forceLanguage","uses","translateAll","translationIds","promises","translate","deferred","defer","regardless","promiseToWaitFor","promiseResolved","determineTranslation","applyNotFoundIndicators","useLanguage","setLocale","eachInterpolator","interpolator","loadAsync","loaderOptions","onLoaderSuccess","table","onLoaderError","eachInterpolationFactory","interpolatorFactory","getInterpolationIdentifier","getTranslationTable","onResolve","getFallbackTranslation","Interpolator","translation","interpolate","getFallbackTranslationInstant","translateByHandler","resultString","resolveForFallbackLanguage","fallbackLanguageIndex","resolveForFallbackLanguageInstant","fallbackTranslation","fallbackTranslationInstant","missingTranslationHandlerTranslation","_translationId","determineTranslationInstant","clearNextLangAndPromise","useFallbackLanguage","langKeyPosition","proposedLanguage","aliasedKey","isPostCompilingEnabled","isForceAsyncReloadEnabled","refresh","oneTranslationsLoaded","tables","loadingKeys","allTranslationsLoaded","tableData","instant","possibleLangKeys","d","possibleLangKey","versionInfo","isReady","$onReadyDeferred","onReady","globalOnReadyListener","globalOnChangeListener","equals","processAsyncResult","fallbackLanguageId","$translateDefaultInterpolation","$interpolate","$translateSanitization","$locale","$translateInterpolator","$identifier","string","interpolationParams","interpolatedText","translateDirective","tElement","tAttr","translateValuesExist","translateValues","translateInterpolation","translateValueExist","outerHTML","interpolateRegExp","startSymbol","endSymbol","watcherRegExp","iElement","iAttr","preText","postText","translateNamespace","getTranslateNamespace","initInterpolationParams","$parent","attributeName","observeElementTranslation","_unwatchOld","iElementText","interpolateMatches","watcherMatches","updateTranslations","observeAttributeTranslation","translateAttr","firstAttributeChangedEvent","defaultText","observeValueAttribute","attrName","updateTranslation","translateLanguage","applyTranslation","successful","empty","globallyEnabled","locallyDefined","translateCompile","locallyEnabled","contents","$attr","translateDefault","unbind","translateCloakDirective","applyCloak","removeCloak","translateCloak","translateNamespaceDirective","iAttrs","translateLanguageDirective","newTranslateLanguage","translateFilterFactory","translateFilter","interpolation","$stateful","$translationCache","$cacheFactory",40,"inherit","extra","merge","dst","ancestors","first","second","objectKeys","object","Array","Number","ceil","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","params","equalForKeys","k","filterByKeys","filtered","pick","omit","collection","map","$Resolve","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","when","$$promises","$$values","study","invocables","visit","visited","cycle","plan","annotate","param","pop","isResolve","invocableKeys","locals","wait","merged","$$inheritedValues","resolution","fail","$$failure","invoke","invocable","onfailure","invocation","proceed","waitParams","dep","ii","$TemplateFactory","fromConfig","fromString","fromUrl","templateProvider","fromProvider","headers","Accept","UrlMatcher","parentMatcher","addParameter","location","paramNames","$$UMFP","Param","quoteRegExp","squash","optional","surroundPattern","matchDetails","m","isSearch","segment","cfg","caseInsensitive","placeholder","searchPlaceholder","compiled","segments","$$new","ParamSet","source","p","exec","isOptional","lastIndex","sourceSearch","sourcePath","strict","$$paramNames","Type","$UrlMatcherFactory","valToString","valFromString","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","$types","injector","def","defaultSquashPolicy","enqueue","defaultTypes","encode","decode","is","int","date","getFullYear","getMonth","getDate","capture","valueOf","toISOString","json","toJson","fromJson","any","identity","$$getDefaultValue","strictMode","isMatcher","definition","definitionFn","unwrapShorthand","isShorthand","$$fn","getType","urlType","getArrayMode","arrayDefaults","arrayParamNomenclature","getSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","item","defaultValue","$value","hasReplaceVal","$replace","replacement","$normalize","$asArray","dynamic","$$parent","$$keys","reverse","paramset","paramValues","$$equals","paramValues1","paramValues2","equal","left","right","$$validates","rawVal","normalized","encoded","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","what","handleIfMatch","$match","$location","$browser","appendBasePath","isHtml5","absolute","baseHref","evt","check","rule","handled","defaultPrevented","lastPushedUrl","listen","listener","interceptDeferred","sync","read","urlMatcher","format","$$avoidResync","validates","html5Mode","history","hashPrefix","slash","port","protocol","redirect","handlerIsString","matcher","regex","sticky","deferIntercept","$StateProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","pathLength","queueState","parentName","flushQueuedChildren","queued","registerState","stateBuilder","$delegates","abstractKey","$stateParams","navigable","transitionTo","isGlob","doesStateMatchGlob","glob","globSegments","unshift","MAX_VALUE","func","$view","$resolve","$urlRouter","handleRedirect","$broadcast","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","transition","TransitionSuperseded","toParams","resolveState","paramsAreFiltered","resolveViews","viewsPromises","view","injectables","$template","load","globals","notify","controllerProvider","injectLocals","$$controller","$$state","$$controllerAs","TransitionPrevented","relative","fromParams","fromPath","toState","hash","redirectResult","toPath","keep","toLocals","reloadState","ownParams","shouldSkipReload","entering","exiting","onExit","includes","lossy","context","nonSearchParamsEqual","fromAndToState","notSearchParam","nonQueryParamKeys","nonQueryParams","nonQueryParamSet","reloadOnSearch","compositeName","","abstract","$ViewProvider","$templateFactory","async","$ViewScrollProvider","useAnchorScroll","$anchorScroll","scrollIntoView","$ViewDirective","$uiViewScroll","getService","getRenderer","animEnabled","ngMajorVer","ngMinorVer","$animator","statics","enter","leave","noanimation","minor","animate","terminal","transclude","tAttrs","$transclude","cleanupLastView","cleanOld","_previousEl","_currentScope","$destroy","previousEl","currentScope","_willBeDestroyed","currentEl","renderer","updateView","firstTime","newScope","getUiViewName","previousLocals","latestLocals","$new","autoScrollExp","$eval","onloadExp","onload","autoscroll","$ViewDirectiveFill","$controller","uiView","parseStateRef","ref","parsed","preparsed","paramExpr","stateContext","stateData","getTypeInfo","isSvg","isForm","isAnchor","clickable","clickHook","button","which","ctrlKey","metaKey","shiftKey","ignorePreventDefaultCount","defaultOpts","$StateRefDirective","uiSrefActive","uiSref","active","uiSrefOpts","$$addStateInfo","$set","$StateRefDynamicDirective","runStateRefLink","uiState","uiStateParams","uiStateOpts","watch","$StateRefActiveDirective","addState","stateParams","activeClass","stateHash","createStateHash","anyMatch","exactMatch","activeEqClass","uiSrefActiveEq","newState","$IsStateFilter","isFilter","$IncludedByStateFilter","includesFilter","defaultConfig","searchParams","decodePathArray","reverseString","unquoteDashes","allReversed","paramName","parameters","nTotal","nPath","paramVal","encodeDashes","encodeURIComponent","isPathParam","isDefaultValue","nextSegment","isFinalPathParam","$subPattern","sub","ArrayType","bindTo","callbackName","arrayWrap","arrayUnwrap","falsey","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","$arrayMode","major",41,"createLink","attributes","head","getElementsByTagName","appendChild","cssText","sheet","styleSheet","createTextNode"],"mappings":"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","file":"companyregistry-client.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\r\nvar MainViewController = require('./components/common/MainViewController');\r\nvar SideNavViewController = require('./components/nav/SideNavViewController');\r\nvar BeneficiaryViewController = require('./components/beneficiary/BeneficiaryViewController');\r\nvar CompanyViewController = require('./components/company/CompanyViewController');\r\nvar config = require('./config');\r\n\r\nvar moduleName = config.configBlock.namespace + '.controllers';\r\nvar controllersModule = ng.module(moduleName, [])\r\n    .controller('MainViewController', MainViewController.controller)\r\n    .controller('SideNavViewController', SideNavViewController.controller)\r\n    .controller('BeneficiaryViewController', BeneficiaryViewController.controller)\r\n    .controller('CompanyViewController', CompanyViewController.controller);\r\n\r\nexports.controllersModule = controllersModule;\r\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./components/beneficiary/BeneficiaryViewController\":13,\"./components/common/MainViewController\":15,\"./components/company/CompanyViewController\":26,\"./components/nav/SideNavViewController\":28,\"./config\":31}],2:[function(require,module,exports){\n(function (global){\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar MainViewDirective = require('./components/common/MainViewDirective');\nvar SideNavViewDirective = require('./components/nav/SideNavViewDirective');\nvar BeneficiaryViewDirective = require('./components/beneficiary/BeneficiaryViewDirective');\nvar BeneficiaryCreateViewDirective = require('./components/beneficiary/BeneficiaryCreateViewDirective');\nvar BeneficiaryUpdateViewDirective = require('./components/beneficiary/BeneficiaryUpdateViewDirective');\nvar BeneficiaryDeleteViewDirective = require('./components/beneficiary/BeneficiaryDeleteViewDirective');\nvar BeneficiaryListViewDirective = require('./components/beneficiary/BeneficiaryListViewDirective');\nvar BeneficiaryListFragmentViewDirective = require('./components/beneficiary/BeneficiaryListFragmentViewDirective');\nvar BeneficiaryDetailViewDirective = require('./components/beneficiary/BeneficiaryDetailViewDirective');\nvar BeneficiarySearchViewDirective = require('./components/beneficiary/BeneficiarySearchViewDirective');\nvar CompanyViewDirective = require('./components/company/CompanyViewDirective');\nvar CompanyCreateViewDirective = require('./components/company/CompanyCreateViewDirective');\nvar CompanyUpdateViewDirective = require('./components/company/CompanyUpdateViewDirective');\nvar CompanyDeleteViewDirective = require('./components/company/CompanyDeleteViewDirective');\nvar CompanyListViewDirective = require('./components/company/CompanyListViewDirective');\nvar CompanyListFragmentViewDirective = require('./components/company/CompanyListFragmentViewDirective');\nvar CompanySearchViewDirective = require('./components/company/CompanySearchViewDirective');\nvar config = require('./config');\n\nvar moduleName = config.configBlock.namespace + '.directives';\n\nvar directivesModule = ng.module(moduleName, [])\n    .directive('mainView', MainViewDirective.directive)\n    .directive('sideNavView', SideNavViewDirective.directive)\n    .directive('beneficiaryView', BeneficiaryViewDirective.directive)\n    .directive('beneficiaryCreateView', BeneficiaryCreateViewDirective.directive)\n    .directive('beneficiaryUpdateView', BeneficiaryUpdateViewDirective.directive)\n    .directive('beneficiaryDeleteView', BeneficiaryDeleteViewDirective.directive)\n    .directive('beneficiaryDetailView', BeneficiaryDetailViewDirective.directive)\n    .directive('beneficiarySearchView', BeneficiarySearchViewDirective.directive)\n    .directive('beneficiaryListView', BeneficiaryListViewDirective.directive)\n    .directive('beneficiaryListDetailView', BeneficiaryListViewDirective.directive)\n    .directive('beneficiaryListFragmentView', BeneficiaryListFragmentViewDirective.directive)\n    .directive('companyView', CompanyViewDirective.directive)\n    .directive('companyCreateView', CompanyCreateViewDirective.directive)\n    .directive('companyUpdateView', CompanyUpdateViewDirective.directive)\n    .directive('companyDeleteView', CompanyDeleteViewDirective.directive)\n    .directive('companySearchView', CompanySearchViewDirective.directive)\n    .directive('companyListView', CompanyListViewDirective.directive)\n    .directive('companyListFragmentView', CompanyListFragmentViewDirective.directive)\n\nexports.directivesModule = directivesModule;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./components/beneficiary/BeneficiaryCreateViewDirective\":5,\"./components/beneficiary/BeneficiaryDeleteViewDirective\":6,\"./components/beneficiary/BeneficiaryDetailViewDirective\":7,\"./components/beneficiary/BeneficiaryListFragmentViewDirective\":8,\"./components/beneficiary/BeneficiaryListViewDirective\":9,\"./components/beneficiary/BeneficiarySearchViewDirective\":10,\"./components/beneficiary/BeneficiaryUpdateViewDirective\":12,\"./components/beneficiary/BeneficiaryViewDirective\":14,\"./components/common/MainViewDirective\":16,\"./components/company/CompanyCreateViewDirective\":19,\"./components/company/CompanyDeleteViewDirective\":20,\"./components/company/CompanyListFragmentViewDirective\":21,\"./components/company/CompanyListViewDirective\":22,\"./components/company/CompanySearchViewDirective\":23,\"./components/company/CompanyUpdateViewDirective\":25,\"./components/company/CompanyViewDirective\":27,\"./components/nav/SideNavViewDirective\":29,\"./config\":31}],3:[function(require,module,exports){\n(function (global){\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar BeneficiaryService = require('./components/beneficiary/BeneficiaryService');\nvar CompanyService = require('./components/company/CompanyService');\nvar UtilService = require('./components/common/UtilService');\nvar config = require('./config');\n\nvar moduleName = config.configBlock.namespace + '.services';\nvar servicesModule = ng.module(moduleName, [])\n    .factory('beneficiaryService', BeneficiaryService.service)\n    .factory('companyService', CompanyService.service)\n    .factory('utilService', UtilService.service);\n\nexports.servicesModule = servicesModule;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./components/beneficiary/BeneficiaryService\":11,\"./components/common/UtilService\":18,\"./components/company/CompanyService\":24,\"./config\":31}],4:[function(require,module,exports){\n(function (global){\n/** Main app **/\n\n'use strict';\n\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar config = require('./config');\nvar constants = require('./constants');\nvar services = require('./angularservices');\nvar controllers = require('./angularcontrollers');\nvar directives = require('./angulardirectives');\n\nvar animateModule = require('angular-animate');\nvar translateModule = require('angular-translate');\nvar sanitizeModule = require('angular-sanitize');\nvar blockUIModule = require('angular-block-ui');\nvar uiRouterModule = require('angular-ui-router');\n\nrequire('angular-block-ui/dist/angular-block-ui.min.css');\n\nvar moduleName = config.configBlock.namespace;\n\n// Declare app level module which depends on services, controllers and directives\nng.module(moduleName, [animateModule, translateModule, sanitizeModule, blockUIModule, uiRouterModule,\n    services.servicesModule.name, controllers.controllersModule.name, directives.directivesModule.name,\n    'inform', 'inform-exception'/*, 'inform-http-exception'*/\n]);\n\nng.module(moduleName)\n  .config(config.configBlock.settings)\n  .config(config.configBlock.states)\n  .config(config.configBlock.blockUI)\n  .config(config.configBlock.inform)\n  .config(config.configBlock.hrefSanitize);\n\nng.module(moduleName)\n  .constant('CONSTANTS', constants.constants);\n\nvar runBlock = function() {\n\n    // Add code that needs a run block to execute here.\n};\n\nng.module(moduleName)\n  .run(runBlock);\n  // .run(config.configBlock.modal);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./angularcontrollers\":1,\"./angulardirectives\":2,\"./angularservices\":3,\"./config\":31,\"./constants\":32,\"angular-animate\":34,\"angular-block-ui\":35,\"angular-block-ui/dist/angular-block-ui.min.css\":36,\"angular-sanitize\":38,\"angular-translate\":39,\"angular-ui-router\":40}],5:[function(require,module,exports){\n/**\r\n * Beneficiary Form Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryCreateView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],6:[function(require,module,exports){\n/**\r\n * Company Delete Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryDeleteView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],7:[function(require,module,exports){\n/**\r\n * Beneficiary Detail View Component Directive\r\n *\r\n * @param {$parse} Angular parser service\r\n * @param {$rootScope} Angular rootScope service\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function($parse, $compile, $rootScope, $timeout) {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryDetailView.html',\r\n        restrict: 'AE',\r\n        //replace: true,\r\n        //transclude: true,\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        link: function(scope, el, attrs) {\r\n            $rootScope.$on('disableBeneficiary', function(ev, data) {\r\n                for (var i = 0; i < data.beneficiaries.length; i++) {\r\n                    if (data.beneficiaries[i].id === data.beneficiaryId) {\r\n                        var inputEls = angular.element(el.find('input[type=text]'));\r\n                        for (var j = 0; j < inputEls.length; j++) {\r\n                            angular.element(inputEls[j]).attr('disabled', '');\r\n                            $timeout(function() {\r\n                                $compile(inputEls[j])(scope);\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                //$compile(el)(scope);\r\n            });\r\n        }\r\n    };\r\n};\r\ndirective.$inject = [\"$parse\", \"$compile\", \"$rootScope\", \"$timeout\"];\r\n\r\nexports.directive = directive;\r\n\n},{}],8:[function(require,module,exports){\n/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryListFragmentView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiaries: '=',\r\n            delref: '='\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],9:[function(require,module,exports){\n/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryListView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],10:[function(require,module,exports){\n/**\r\n * Company Search Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiarySearchView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],11:[function(require,module,exports){\n/**\r\n * This service helps to perform http requests (GET, POST, PUT, DELETE) for beneficiary tasks\r\n *\r\n * @param {$http} The AngularJS http service\r\n * @param {$timeout} The AngularJS timeout service\r\n *\r\n * @ngInject\r\n */\r\nvar service = function($http, $timeout) {\r\n    'use strict';\r\n\r\n    var serviceInstance = {};\r\n    serviceInstance.selectedBeneficiaryId = null;\r\n    serviceInstance.popOnDelete = null;\r\n    serviceInstance.beneficiary = null;\r\n    serviceInstance.beneficiaries = [];\r\n\r\n    serviceInstance.getBeneficiary = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'GET'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.createBeneficiary = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            data: data,\r\n            method: 'POST'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n    serviceInstance.updateBeneficiary = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'PUT',\r\n            data: data\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.deleteBeneficiary = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'DELETE'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$http\", \"$timeout\"];\r\n\r\nexports.service = service;\r\n\n},{}],12:[function(require,module,exports){\n/**\r\n * Beneficiary Form Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryUpdateView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],13:[function(require,module,exports){\n/**\r\n * Beneficiary View controller\r\n *\r\n * This controller is responsible for handing beneficiary form module related logic\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {$modal} Angular modal service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {utilService} Utility service\r\n * @param {blockUI} Block UI service\r\n * @param {inform} Inform provider service\r\n * @param {CONSTANTS} Project constants values\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function($rootScope, $scope, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, utilService, blockUI, inform, CONSTANTS) {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n    $scope.useExistingBeneficiary = false;\r\n    $scope.minimumValidBeneficiary = false;\r\n    $scope.beneficiaryId = null;\r\n    $scope.beneficiarySearched = false;\r\n    $scope.beneficiaryFound = false;\r\n    $scope.searchRequestSumbitted = false;\r\n    $scope.addRequestSubmitted = false;\r\n    $scope.addRequestAttempted = false;\r\n    $scope.updateRequestSubmitted = false;\r\n    $scope.updateRequestAttempted = false;\r\n    $scope.deleteRequestSubmitted = false;\r\n    $scope.deleteSuccessful = false;\r\n    $scope.serviceUrl = CONSTANTS.url.path;\r\n\r\n    $scope.initBeneficiary = {\r\n        \"firstName\": null,\r\n        \"lastName\": null\r\n    };\r\n    $scope.beneficiaries = beneficiaryService.beneficiaries; //.length > 0 ? beneficiaryService.beneficiaries : [];\r\n    $scope.beneficiary = beneficiaryService.beneficiary &&\r\n                         ($state.current.name === 'start.beneficiary.update' || $state.current.name === 'start.beneficiary.list.delete' || $state.current.name === 'start.beneficiary.search.delete') ?\r\n                         beneficiaryService.beneficiary : $scope.initBeneficiary;\r\n\r\n    $scope.resetBeneficiary = function() {\r\n        $timeout(function() {\r\n            $scope.beneficiary = $scope.initBeneficiary;\r\n            $scope.beneficiaries = [];\r\n        });\r\n    };\r\n\r\n    $scope.addBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.addRequestSubmitted = false;\r\n        beneficiaryService.beneficiary = $scope.beneficiary;\r\n        if (!utilService.isFormValid('beneficiaryDetailsForm')) {\r\n            $scope.addRequestAttempted = true;\r\n            $log.warn('form invalid');\r\n            inform.add('Invalid form. First name and Last name are required to create beneficiary', {\r\n                ttl: 3500,\r\n                type: 'danger'\r\n            });\r\n            // $scope.registerPopoverShow('#addBeneficiary');\r\n            return;\r\n        }\r\n\r\n        var beneficiaryCreateBlock = blockUI.instances.get('beneficiaryCreateBlock');\r\n        beneficiaryCreateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        beneficiaryService.createBeneficiary(url, $scope.beneficiary, function(result) {\r\n            $timeout(function() {\r\n                $scope.addRequestSubmitted = true;\r\n                if (result && result.data) {\r\n                    if (result.data.id > 0) {\r\n                        inform.add('beneficiary created successfully.', {\r\n                            ttl: 2500\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.beneficiary', {}, {reload:true});\r\n                        }, 2500);\r\n                    } else {\r\n                        inform.add('Request completed, however beneficiary couldn\\'t be created.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating beneficiary.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.addRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                beneficiaryCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelAddBeneficiary = function() {\r\n        $state.go('start.beneficiary');\r\n    };\r\n\r\n    $scope.updateBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.updateRequestSubmitted = false;\r\n        beneficiaryService.beneficiary = $scope.beneficiary;\r\n        if (!utilService.isFormValid('beneficiaryDetailsForm')) {\r\n            $scope.updateRequestAttempted = true;\r\n            $log.warn('ccform invalid');\r\n            inform.add('Invalid form. First name and Last name are required to create beneficiary', {\r\n                ttl: 3500,\r\n                type: 'danger'\r\n            });\r\n            return;\r\n        }\r\n\r\n        var beneficiaryUpdateBlock = blockUI.instances.get('beneficiaryUpdateBlock');\r\n        beneficiaryUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        beneficiaryService.updateBeneficiary(url, $scope.beneficiary, function(result) {\r\n            $timeout(function() {\r\n                $scope.updateRequestSubmitted = true;\r\n                if (result && result.data) {\r\n                    if (result.data.status === true) {\r\n                        inform.add('beneficiary updated successfully.', {\r\n                            ttl: 4000\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.beneficiary.list', {}, {reload: true});\r\n                        }, 4500);\r\n                    } else {\r\n                        inform.add('Request completed successfully, but no update performed on beneficiary.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'beneficiary couldn\\'t be updated.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.updateRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                beneficiaryUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseBeneficiaryUpdate = function() {\r\n        $state.go('start.beneficiary.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.deleteBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.beneficiary = beneficiaryService.beneficiary;\r\n        var beneficiaryDeleteBlock = blockUI.instances.get('beneficiaryDeleteBlock');\r\n        beneficiaryDeleteBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + $scope.beneficiary.id;\r\n        beneficiaryService.deleteBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.deleteRequestSubmitted = true;\r\n                if (result && result.data && result.data.status === true) {\r\n                    $scope.deleteSuccessful = true;\r\n                } else {\r\n                  $log.info(result);\r\n                }\r\n                beneficiaryDeleteBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseBeneficiaryDelete = function() {\r\n        $scope.$dismiss();\r\n        $state.go('start.beneficiary.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.fetchBeneficiary = function(id) {\r\n        $scope.beneficiaries.splice(0, $scope.beneficiaries.length);\r\n\r\n        var idSearch = !utilService.isBlank(id);\r\n        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        var url = idSearch ? baseUrl + '/' + id : baseUrl;\r\n        var beneficiaryListBlock = blockUI.instances.get('beneficiaryListBlock');\r\n        beneficiaryListBlock.start();\r\n        beneficiaryService.getBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.searchRequestSumbitted = true;\r\n                if (result && result.data) {\r\n                    if (idSearch) {\r\n                        $scope.beneficiaries.push(result.data);\r\n                    } else {\r\n                        $scope.beneficiaries = result.data;\r\n                    }\r\n                    beneficiaryService.beneficiaries = $scope.beneficiaries;\r\n                    $scope.beneficiaryFound = true;\r\n                }\r\n                beneficiaryListBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.searchBeneficiary = function(id, $event) {\r\n        $event.stopPropagation();\r\n        $timeout(function() {\r\n            if (!utilService.isValidId(id)) {\r\n                $scope.registerPopoverShow('#searchExistingBeneficiaryId');\r\n                return;\r\n            }\r\n            $scope.fetchBeneficiary(id);\r\n        });\r\n    };\r\n\r\n    $scope.mutateBeneficiaryOptions = function(beneficiary, $index, $event) {\r\n        $event.stopPropagation();\r\n        beneficiaryService.selectedBeneficiaryId = '#beneficiary' + $index;\r\n        beneficiaryService.beneficiary = beneficiary;\r\n        $scope.registerPopoverPrep(beneficiaryService.selectedBeneficiaryId);\r\n        $scope.registerPopoverShow(beneficiaryService.selectedBeneficiaryId);\r\n    };\r\n\r\n    /* initialize popover */\r\n\r\n    $scope.discardMessage = function($event) {\r\n        $event ? $event.stopPropagation() : '';\r\n        beneficiaryService.popOnDelete = \"delete\";\r\n        $scope.registerPopoverHide('[id*=popover]');\r\n    };\r\n\r\n    beneficiaryService.popOnDelete = \"delete\";\r\n\r\n    $scope.registerPopoverPrep = function(id) {\r\n        angular.element($document.find(id)).popover({\r\n            trigger: 'manual'\r\n        });\r\n    };\r\n\r\n    $scope.registerPopoverShow = function(id) {\r\n        if (beneficiaryService.popOnDelete !== \"popover\") {\r\n            beneficiaryService.popOnDelete = \"popover\";\r\n            angular.element($document.find(id)).popover('show');\r\n        }\r\n    };\r\n\r\n    $scope.registerPopoverHide = function(id) {\r\n        var el = angular.element($document.find(id));\r\n        el ? el.popover('hide') : '';\r\n    };\r\n\r\n    $scope.registerPopoverPrep('#removeBeneficiary');\r\n    $scope.registerPopoverPrep('#addBeneficiary');\r\n    $scope.registerPopoverPrep('#updateBeneficiary');\r\n    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');\r\n    $scope.registerPopoverHide('[id*=popover]');\r\n\r\n    // clear all informs\r\n    inform.clear();\r\n};\r\ncontroller.$inject = [\"$rootScope\", \"$scope\", \"$timeout\", \"$window\", \"$document\", \"$log\", \"$state\", \"$modal\", \"beneficiaryService\", \"utilService\", \"blockUI\", \"inform\", \"CONSTANTS\"];\r\n\r\nexports.controller = controller;\r\n\n},{}],14:[function(require,module,exports){\n/**\r\n * Main Beneficiary Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],15:[function(require,module,exports){\n/**\r\n * Main View controller\r\n *\r\n * This controller is responsible for handing request from main view\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function() {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n};\r\n\r\nexports.controller = controller;\r\n\n},{}],16:[function(require,module,exports){\n/**\r\n * Main Directive\r\n *\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/common/MainView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'MainViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],17:[function(require,module,exports){\nvar stateConfig = {\r\n    /**\r\n     * Default to <company-create-view />\r\n     */\r\n    main: {\r\n        url: '/',\r\n        views: {\r\n            'main': {\r\n                template: '<main-view></main-view>'\r\n            },\r\n            'mainItem@start': {\r\n                template: '<company-create-view></company-create-view>'\r\n            }\r\n        }\r\n    },\r\n    company: {\r\n        initial: {\r\n            url: 'company',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-view></company-view>'\r\n                }\r\n            }\r\n        },\r\n        list: {\r\n            url: '/list',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-list-view></company-list-view>'\r\n                }\r\n            }\r\n        },\r\n        search: {\r\n            url: '/search',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-search-view></company-search-view>'\r\n                }\r\n            }\r\n        },\r\n        update: {\r\n            url: '/update',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-update-view></company-update-view>'\r\n                }\r\n            }\r\n        },\r\n        delete: {\r\n            // would be used under start.company.list state, hence url resolves to: #/company/list/delete\r\n            url: '/delete',\r\n            /**\r\n             * On state enter event listener\r\n             * @param  {$modal} Modal service\r\n             * @ngInject\r\n             */\r\n            onEnter: [\"$modal\", function($modal) {\r\n                $modal.open({\r\n                    template: '<company-delete-view></company-delete-view>',\r\n                    backdrop: 'static',\r\n                    keyboard: false,\r\n                    windowClass: 'modal',\r\n                    controller: 'CompanyViewController'\r\n                });\r\n            }]\r\n        }\r\n    },\r\n    beneficiary: {\r\n        initial: {\r\n            url: 'beneficiary',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-view></beneficiary-view>'\r\n                }\r\n            }\r\n        },\r\n        list: {\r\n            url: '/list',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-list-view></beneficiary-list-view>'\r\n                }\r\n            }\r\n        },\r\n        search: {\r\n            url: '/search',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-search-view></beneficiary-seach-view>'\r\n                }\r\n            }\r\n        },\r\n        update: {\r\n            url: '/update',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-update-view></beneficiary-update-view>'\r\n                }\r\n            }\r\n        },\r\n        delete: {\r\n            /** would be used under start.beneficiary.list or start.beneficiary.search state,\r\n             *  hence url resolves to: #/beneficiary/list/delete or  #/beneficiary/search/delete\r\n             */\r\n            url: '/delete',\r\n            /**\r\n             * On state enter event listener\r\n             * @param  {$modal} Modal service\r\n             * @ngInject\r\n             */\r\n            onEnter: [\"$modal\", function($modal) {\r\n                $modal.open({\r\n                    template: '<beneficiary-delete-view></beneficiary-delete-view>',\r\n                    backdrop: 'static',\r\n                    keyboard: false,\r\n                    windowClass: 'modal',\r\n                    controller: 'BeneficiaryViewController'\r\n                });\r\n            }]\r\n        }\r\n    }\r\n};\r\n\r\nexports.stateConfig = stateConfig;\r\n\n},{}],18:[function(require,module,exports){\n/**\r\n * This service provide custom word lookup for case normalization if one is not provided by the service client\r\n *\r\n * @param {$window} The angular window service\r\n * @ngInject\r\n */\r\nvar service = function($window) {\r\n    'use strict';\r\n    var serviceInstance = {};\r\n\r\n    serviceInstance.isFormValid = function(formId) {\r\n        var isValid = true;\r\n        var formEl = $window.document.getElementById(formId);\r\n        if (!formEl || (formEl && formEl.className && formEl.className.indexOf('ng-invalid') > -1)) return false;\r\n        // otherwise, perform sanity check\r\n        var elements = $window.document.getElementById(formId).elements;\r\n        for (var i = 0, element = elements[i++]; i < elements.length; i++) {\r\n            if ((element.type === 'text' || element.type === 'checkbox' || element.type === 'radio' || element.type === 'date' || element.type === 'datetime-local' || element.type === 'email' || element.type === 'month' || element.type === 'number' || element.type === 'time' || element.type === 'url' || element.type === 'week' || element.type === 'textarea' || element.type === 'select') && (element.className.indexOf('ng-invalid') > -1)) {\r\n                isValid = false;\r\n                return isValid;\r\n            }\r\n        }\r\n\r\n        return isValid;\r\n    };\r\n\r\n    serviceInstance.isBlank = function(value) {\r\n        return angular.isUndefined(value) || value === null || value.length === 0;\r\n    };\r\n\r\n    serviceInstance.isValidId = function(id) {\r\n        return parseInt(id) >= 1;\r\n    }\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$window\"];\r\n\r\nexports.service = service;\r\n\n},{}],19:[function(require,module,exports){\n/**\r\n * Company Create Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyCreateView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],20:[function(require,module,exports){\n/**\r\n * Company Delete Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyDeleteView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],21:[function(require,module,exports){\n/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function() {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyListFragmentView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            companies: '=',\r\n            delref: '='\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],22:[function(require,module,exports){\n/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyListView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],23:[function(require,module,exports){\n/**\r\n * Company Search Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanySearchView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],24:[function(require,module,exports){\n/**\r\n * This service helps to perform http requests (GET, POST, PUT, DELETE) for company tasks\r\n *\r\n * @param {$http} The AngularJS http service\r\n * @param {$timeout} The AngularJS timeout service\r\n *\r\n * @ngInject\r\n */\r\nvar service = function($http, $timeout) {\r\n    'use strict';\r\n\r\n    var serviceInstance = {};\r\n    serviceInstance.selectedCompanyId = null;\r\n    serviceInstance.popOnDelete = null;\r\n    serviceInstance.company = null;\r\n    serviceInstance.companies = [];\r\n    serviceInstance.searchRequestSumbitted = false;\r\n\r\n    serviceInstance.getCompany = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'GET',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.createCompany = function(url, data, callback) {\r\n        console.log('here: ' + url);\r\n        //return;\r\n        $http({\r\n            url: url,\r\n            data: data,\r\n            method: 'POST',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n    serviceInstance.updateCompany = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'PUT',\r\n            data: data,\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.deleteCompany = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'DELETE',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$http\", \"$timeout\"];\r\n\r\nexports.service = service;\r\n\n},{}],25:[function(require,module,exports){\n/**\r\n * Company Update Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyUpdateView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],26:[function(require,module,exports){\n/**\r\n * Company View controller\r\n *\r\n * This controller is responsible for handing company form module related logic\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$q} Angular promise service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {$modal} Angular modal service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n * @param {utilService} Utility service\r\n * @param {blockUI} Block UI service\r\n * @param {inform} Inform provider service\r\n * @param {CONSTANTS} Project constants values\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function($rootScope, $scope, $q, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, companyService, utilService, blockUI, inform, CONSTANTS) {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n    $scope.useExistingBeneficiary = false;\r\n    $scope.minimumValidBeneficiary = false;\r\n    $scope.beneficiaryId = null;\r\n    $scope.beneficiarySearched = false;\r\n    $scope.beneficiaryFound = false;\r\n    $scope.companyFound = false;\r\n    $scope.searchRequestSumbitted = false;\r\n    $scope.addRequestSubmitted = false;\r\n    $scope.updateRequestSubmitted = false;\r\n    $scope.deleteRequestSubmitted = false;\r\n    $scope.deleteSuccessful = false;\r\n    $scope.serviceUrl = CONSTANTS.url.path;\r\n    $scope.initCompany = {\r\n        \"name\": null,\r\n        \"address\": null,\r\n        \"city\": null,\r\n        \"country\": null,\r\n        \"email\": null,\r\n        \"phoneNumber\": null,\r\n        \"beneficiaries\": [{\r\n            \"id\": -1,\r\n            \"firstName\": null,\r\n            \"lastName\": null\r\n        }]\r\n    };\r\n\r\n    $scope.companies = companyService.companies; //.length > 0 ? companyService.companies : [];\r\n    $scope.company = companyService.company &&\r\n                    ($state.current.name === 'start.company.update' || $state.current.name === 'start.company.list.delete' || $state.current.name === 'start.company.search.delete') ?\r\n                    companyService.company : $scope.initCompany;\r\n\r\n    $scope.verifyMinimumValidBeneficiary = function() {\r\n        for (var i = 0; i < $scope.company.beneficiaries.length; i++) {\r\n            $scope.minimumValidBeneficiary = $scope.company.beneficiaries[i].id !== -1 ||\r\n                                            (!utilService.isBlank($scope.company.beneficiaries[i].firstName) && !utilService.isBlank($scope.company.beneficiaries[i].lastName));\r\n            if ($scope.minimumValidBeneficiary) {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n\r\n    $scope.resetCompany = function() {\r\n        $timeout(function() {\r\n            $scope.company = $scope.initCompany;\r\n            $scope.companies = [];\r\n        });\r\n    };\r\n\r\n    $scope.addCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.addRequestSubmitted = false;\r\n        companyService.company = $scope.company;\r\n        if (utilService.isFormValid('companyDetailsForm')) {\r\n            $scope.verifyMinimumValidBeneficiary();\r\n            if (!$scope.minimumValidBeneficiary) {\r\n                $scope.registerPopoverShow('#addCompany');\r\n                return;\r\n            }\r\n            $log.info('form valid');\r\n        } else {\r\n            $log.warn('form invalid');\r\n            return;\r\n        }\r\n\r\n        var companyCreateBlock = blockUI.instances.get('companyCreateBlock');\r\n        companyCreateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n\r\n        companyService.createCompany(url, $scope.company, function(result) {\r\n            $timeout(function() {\r\n                $scope.addRequestSubmitted = true;\r\n                if (result && result.data) {\r\n                    if (result.data.id > 0) {\r\n                        inform.add('Company created successfully.', {\r\n                            ttl: 2500\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.company', {}, {reload:true});\r\n                        }, 2500);\r\n                    } else {\r\n                        inform.add('Request completed, however company couldn\\'t be created.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating company.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.addRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                companyCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelAddCompany = function() {\r\n        $state.go('start.company');\r\n    };\r\n\r\n    $scope.updateCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.updateRequestSubmitted = false;\r\n        companyService.company = $scope.company;\r\n        if (utilService.isFormValid('companyUpdateForm')) {\r\n            $scope.verifyMinimumValidBeneficiary();\r\n            if (!$scope.minimumValidBeneficiary) {\r\n                $scope.registerPopoverShow('#updateCompany');\r\n                return;\r\n            }\r\n        } else {\r\n            $log.warn('form invalid');\r\n            return;\r\n        }\r\n\r\n        var companyUpdateBlock = blockUI.instances.get('companyUpdateBlock');\r\n        companyUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        companyService.updateCompany(url, $scope.company, function(result) {\r\n            $timeout(function() {\r\n                $scope.updateRequestSubmitted = true;\r\n                if (result && result.data) {\r\n                    if (result.data.status === true) {\r\n                        inform.add('Company updated successfully.', {\r\n                            ttl: 4000\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.company.list', {}, {reload: true});\r\n                        }, 4500);\r\n                    } else {\r\n                        inform.add('Request completed successfully, but no update performed on company.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Company couldn\\'t be updated.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.updateRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                companyUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseCompanyUpdate = function() {\r\n        $state.go('start.company.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.deleteCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.company = companyService.company;\r\n        var companyDeleteBlock = blockUI.instances.get('companyDeleteBlock');\r\n        companyDeleteBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath + '/' + $scope.company.id;\r\n        companyService.deleteCompany(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.deleteRequestSubmitted = true;\r\n                if (result && result.data && result.data.status === true) {\r\n                    $scope.deleteSuccessful = true;\r\n                }\r\n                companyDeleteBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseCompanyDelete = function() {\r\n        $scope.$dismiss();\r\n        $state.go('start.company.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.fetchCompany = function(id) {\r\n        $scope.companies.splice(0, $scope.companies.length);\r\n\r\n        var idSearch = !utilService.isBlank(id);\r\n        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        var url = idSearch ? baseUrl + '/' + id : baseUrl;\r\n        var companyListBlock = blockUI.instances.get('companyListBlock');\r\n        companyListBlock.start();\r\n        companyService.getCompany(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.searchRequestSumbitted = true;\r\n                companyService.searchRequestSumbitted = $scope.searchRequestSumbitted;\r\n                if (result && result.data) {\r\n                    if (idSearch) {\r\n                        $scope.companies.push(result.data);\r\n                    } else {\r\n                        $scope.companies = result.data;\r\n                    }\r\n                    companyService.companies = $scope.companies;\r\n                    $scope.companyFound = true;\r\n                }\r\n                companyListBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.searchCompany = function(id, $event) {\r\n        $event.stopPropagation();\r\n        $timeout(function() {\r\n            if (!utilService.isValidId(id)) {\r\n                $scope.registerPopoverShow('#searchExistingCompanyId');\r\n                return;\r\n            }\r\n            $scope.fetchCompany(id);\r\n        });\r\n    };\r\n\r\n    $scope.searchBeneficiary = function(id, $event) {\r\n        $event.stopPropagation();\r\n\r\n        if (!utilService.isValidId(id)) {\r\n            $scope.registerPopoverShow('#searchExistingBeneficiaryId');\r\n            return;\r\n        }\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + id;\r\n\r\n        var companyCreateBlock = blockUI.instances.get('companyCreateBlock');\r\n        companyCreateBlock.start();\r\n        beneficiaryService.getBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.beneficiarySearched = true;\r\n                if (result && result.data) {\r\n                    $scope.verifyMinimumValidBeneficiary();\r\n                    // remove all empty forms\r\n                    if (!$scope.minimumValidBeneficiary) {\r\n                        $scope.company.beneficiaries.splice(0, $scope.company.beneficiaries.length);\r\n                    }\r\n                    if ($scope.company.beneficiaries.length > 0 ) {\r\n                        for (var i = 0; i < $scope.company.beneficiaries.length; i++) {\r\n                            if ($scope.company.beneficiaries[i].id != id) {\r\n                                $scope.company.beneficiaries.push(result.data);\r\n                                break;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        $scope.company.beneficiaries.push(result.data);\r\n                    }\r\n                    $scope.disableBeneficiary(result.data.id);\r\n                    $scope.minimumValidBeneficiary = true;\r\n                    $scope.beneficiaryFound = true;\r\n                    $scope.beneficiaryId = null;\r\n                }\r\n                companyCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.mutateCompanyOptions = function(company, $index, $event) {\r\n        $event.stopPropagation();\r\n        companyService.selectedCompanyId = '#company' + $index;\r\n        companyService.company = company;\r\n        $scope.registerPopoverPrep(companyService.selectedCompanyId);\r\n        $scope.registerPopoverShow(companyService.selectedCompanyId);\r\n    };\r\n\r\n    $scope.addBeneficiary = function() {\r\n        $scope.company.beneficiaries.push({\r\n            \"firstName\": \"\",\r\n            \"lastName\": \"\"\r\n        });\r\n    };\r\n\r\n    $scope.removeBeneficiary = function($event, beneficiary) {\r\n        $event.stopPropagation();\r\n        if ($scope.company.beneficiaries.indexOf(beneficiary) != -1) {\r\n            $timeout(function() {\r\n                if ($scope.company.beneficiaries.length === 1) {\r\n                    $scope.registerPopoverShow('#removeBeneficiary');\r\n                    return;\r\n                }\r\n                $scope.company.beneficiaries.splice($scope.company.beneficiaries.indexOf(beneficiary), 1);\r\n            });\r\n        }\r\n    };\r\n\r\n    $scope.disableBeneficiary = function(beneficiaryId) {\r\n        $rootScope.$emit('disableBeneficiary', {\r\n            beneficiaries: $scope.company.beneficiaries,\r\n            beneficiaryId: beneficiaryId\r\n        });\r\n    }\r\n\r\n    /* initialize popover */\r\n\r\n    $scope.discardMessage = function($event) {\r\n        $event ? $event.stopPropagation() : '';\r\n        companyService.popOnDelete = \"delete\";\r\n        $scope.registerPopoverHide('[id*=popover]');\r\n    };\r\n\r\n    companyService.popOnDelete = \"delete\";\r\n\r\n    $scope.registerPopoverPrep = function(id) {\r\n        angular.element($document.find(id)).popover({\r\n            trigger: 'manual'\r\n        });\r\n    };\r\n\r\n    $scope.registerPopoverShow = function(id) {\r\n        if (companyService.popOnDelete !== \"popover\") {\r\n            companyService.popOnDelete = \"popover\";\r\n            angular.element($document.find(id)).popover('show');\r\n        }\r\n    };\r\n\r\n    $scope.registerPopoverHide = function(id) {\r\n        var el = angular.element($document.find(id));\r\n        el ? el.popover('hide') : '';\r\n    };\r\n\r\n    $scope.registerPopoverPrep('#removeBeneficiary');\r\n    $scope.registerPopoverPrep('#addCompany');\r\n    $scope.registerPopoverPrep('#updateCompany');\r\n    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');\r\n    $scope.registerPopoverPrep('#searchExistingCompanyId');\r\n    $scope.registerPopoverHide('[id*=popover]');\r\n\r\n    // clear all informs\r\n    inform.clear();\r\n};\r\ncontroller.$inject = [\"$rootScope\", \"$scope\", \"$q\", \"$timeout\", \"$window\", \"$document\", \"$log\", \"$state\", \"$modal\", \"beneficiaryService\", \"companyService\", \"utilService\", \"blockUI\", \"inform\", \"CONSTANTS\"];\r\n\r\nexports.controller = controller;\r\n\n},{}],27:[function(require,module,exports){\n/**\r\n * Main Company Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyView.html',\r\n        restrict: 'AE',\r\n        scope: false\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],28:[function(require,module,exports){\n/**\r\n * Side Nav View controller\r\n *\r\n * This controller is responsible for handing request from side nav\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function() {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n};\r\n\r\nexports.controller = controller;\r\n\n},{}],29:[function(require,module,exports){\n/**\r\n * Side Nav Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/nav/SideNavView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'SideNavViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n\n},{}],30:[function(require,module,exports){\nvar translationsEN = {\n    \"BENEFICIARY\": {\n        \"ID\": \"Id\",\n        \"FIRST_NAME\": \"First name\",\n        \"LAST_NAME\": \"Last name\"\n    }\n};\n\nexports.translationsEN = translationsEN;\n\n},{}],31:[function(require,module,exports){\n'use strict';\r\n\r\nvar states = require('./components/common/States');\r\nvar configBlock = {\r\n    /**\r\n     * @param {$logProvider} The log provider service\r\n     * @param {$translateProvider} The angular translate service\r\n     * @ngInject\r\n     */\r\n    settings: [\"$logProvider\", \"$translateProvider\", function($logProvider, $translateProvider) {\r\n        $logProvider.debugEnabled(true); // Turns global logging with $log.debug on\r\n\r\n        var i18n_en = require('./components/nls/i18n-en');\r\n        $translateProvider.useSanitizeValueStrategy('sanitizeParameters');\r\n        $translateProvider.translations('en', i18n_en.translationsEN).useStaticFilesLoader({\r\n                files: [{\r\n                    prefix: './components/nls/i18n-',\r\n                    suffix: '.json'\r\n                }]\r\n            })\r\n            .preferredLanguage('en')\r\n            .fallbackLanguage('en');\r\n    }],\r\n    /**\r\n     * @param {$stateProvider} $stateProvider The UI router stateProvider service\r\n     * @param {$urlRouterProvider} The UI router urlRouterProvider service\r\n     * @param {$modalStateProvider} The custom modal state provider service\r\n     * @ngInject\r\n     */\r\n    states: [\"$stateProvider\", \"$urlRouterProvider\", function($stateProvider, $urlRouterProvider) {\r\n        $urlRouterProvider.otherwise('/');\r\n        $stateProvider\r\n            .state('start', states.stateConfig.main)\r\n            .state('start.company', states.stateConfig.company.initial)\r\n            .state('start.company.list', states.stateConfig.company.list)\r\n            .state('start.company.list.delete',  angular.copy(states.stateConfig.company.delete))\r\n            .state('start.company.search', states.stateConfig.company.search)\r\n            .state('start.company.search.delete', angular.copy(states.stateConfig.company.delete))\r\n            .state('start.company.update', states.stateConfig.company.update)\r\n            .state('start.beneficiary', states.stateConfig.beneficiary.initial)\r\n            .state('start.beneficiary.list', states.stateConfig.beneficiary.list)\r\n            .state('start.beneficiary.list.delete', angular.copy(states.stateConfig.beneficiary.delete))\r\n            .state('start.beneficiary.search', states.stateConfig.beneficiary.search)\r\n            .state('start.beneficiary.search.delete', angular.copy(states.stateConfig.beneficiary.delete))\r\n            .state('start.beneficiary.update', states.stateConfig.beneficiary.update)\r\n    }],\r\n\r\n    /**\r\n     * @param  {blockUIConfig} The block UI config service\r\n     * @ngInject\r\n     */\r\n    blockUI: [\"blockUIConfig\", function(blockUIConfig) {\r\n        blockUIConfig.delay = 100;\r\n        // blockUIConfig.autoBlock = false;\r\n        blockUIConfig.autoInjectBodyBlock = false;\r\n        blockUIConfig.template = '<div id=\"ui-overlay\"><img src=\"dist/images/ajax-loader.gif\" /></h1>';\r\n    }],\r\n\r\n    /**\r\n     * @param  {informProvider} The inform provider service\r\n     * @ngInject\r\n     */\r\n    inform: [\"informProvider\", function(informProvider) {\r\n        informProvider.defaults({\r\n            /**\r\n             * The time to live for the message in milliseconds.\r\n             * Default value is 5000. Specify <0 to make the message sticky.\r\n             */\r\n            ttl: -1,\r\n\r\n            /**\r\n             * The type of message to enable styling.\r\n             * Values can be 'default', 'primary', 'success', 'info', 'warning', 'danger' or any other custom required type.\r\n             * Default value is 'info'. If 'default' is specified as value, then 'info' is used\r\n             */\r\n            type: 'success',\r\n            /**\r\n             * Allow html formatting\r\n             * Default value is false\r\n             */\r\n            html: true\r\n        });\r\n    }],\r\n\r\n    /**\r\n     * Modal block\r\n     * @param  {$rootScope}  Angular root scope service\r\n     * @param  {$modalStack} Angular UI modal stack\r\n     * @ngInject\r\n     */\r\n    modal: [\"$rootScope\", \"$modalStack\", function($rootScope, $modalStack) {\r\n        $rootScope.$on('$stateChangeStart', function() {\r\n            var top = $modalStack.getTop();\r\n            if (top) {\r\n                $modalStack.dismiss(top.key);\r\n            }\r\n        });\r\n    }],\r\n\r\n    /**\r\n     * Href sanitization whitelist\r\n     * @param  {$compileProvide} Angular compile provider service\r\n     * @ngInject\r\n     */\r\n    hrefSanitize: [\"$compileProvider\", function($compileProvider) {\r\n        $compileProvider.aHrefSanitizationWhitelist(/^\\s*(https?|ftp|mailto|file|chrome-extension|blob:chrome-extension):/);\r\n    }],\r\n\r\n    namespace: 'com.companyregistry'\r\n};\r\n\r\nexports.configBlock = configBlock;\r\n\n},{\"./components/common/States\":17,\"./components/nls/i18n-en\":30}],32:[function(require,module,exports){\n'use strict';\r\n\r\nexports.constants = {\r\n    url: {\r\n\t\t\t\t// path: 'http://localhost:8080/companyregistry',\r\n\t\t\t\tpath: 'https://companyregistry.herokuapp.com',\r\n        companyContextPath: 'companies',\r\n        beneficiaryContextPath: 'beneficiaries'\r\n    }\r\n};\r\n\n},{}],33:[function(require,module,exports){\n/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* jshint ignore:start */\nvar noop        = angular.noop;\nvar extend      = angular.extend;\nvar jqLite      = angular.element;\nvar forEach     = angular.forEach;\nvar isArray     = angular.isArray;\nvar isString    = angular.isString;\nvar isObject    = angular.isObject;\nvar isUndefined = angular.isUndefined;\nvar isDefined   = angular.isDefined;\nvar isFunction  = angular.isFunction;\nvar isElement   = angular.isElement;\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar isPromiseLike = function(p) {\n  return p && p.then ? true : false;\n};\n\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return [];\n        break;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n        break;\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  }\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationOptions(element, target, newOptions) {\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof angular.element) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncancelled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\nvar $$AnimateChildrenDirective = [function() {\n  return function(scope, element, attrs) {\n    var val = attrs.ngAnimateChildren;\n    if (angular.isString(val) && val.length === 0) { //empty attribute\n      element.data(NG_ANIMATE_CHILDREN_DATA, true);\n    } else {\n      attrs.$observe('ngAnimateChildren', function(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      });\n    }\n  };\n}];\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and stlyes may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n * * `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occuring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a colapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for zegative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$animate',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $animate) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = \"$$ngAnimateParentKey\";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an interal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var cancelLastRAFRequest;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, options) {\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$animate.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle = parseFloat(options.delay);\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            value ? node.style.setProperty(prop, value)\n                  : node.style.removeProperty(prop);\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        var startTime, events = [];\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidently cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intential stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          element.on(events.join(' '), onAnimationProgress);\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n\n        function onAnimationProgress(event) {\n          event.stopPropagation();\n          var ev = event.originalEvent || event;\n          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();\n\n          /* Firefox (or possibly just Gecko) likes to not round values up\n           * when a ms measurement is used for the animation */\n          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n          /* $manualTimeStamp is a mocked timeStamp value which is set\n           * within browserTrigger(). This is only here so that tests can\n           * mock animations properly. Real events fallback to event.timeStamp,\n           * or, if they don't, then a timeStamp is automatically created for them.\n           * We're checking to see if the timeStamp surpasses the expected delay,\n           * but we're using elapsedTime instead of the timeStamp on the 2nd\n           * pre-condition since animations sometimes close off early */\n          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n            // we set this flag to ensure that if the transition is paused then, when resumed,\n            // the animation will automatically close itself since transitions cannot be paused.\n            animationCompleted = true;\n            close();\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragement case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coods object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      return {\n        start: function() {\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          var animationClosed = false;\n          var runner = new $$AnimateRunner({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            animationClosed = true;\n            applyOptions();\n            applyAnimationStyles(element, options);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(options, and) {\n    options = options || {};\n    var a = (options.addClass || '').length > 0;\n    var b = (options.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    var nO = newAnimation.options;\n    var cO = currentAnimation.options;\n\n    // if the exact same CSS class is added/removed then it's safe to cancel it\n    return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = {};\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationOptions(element, options) {\n      return mergeAnimationOptions(element, options, {});\n    }\n\n    function findCallbacks(element, event) {\n      var targetNode = getDomNode(element);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (entry.node.contains(targetNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    return {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n      },\n\n      off: function(event, container, callback) {\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n\n        function filterFromRegistry(list, matchContainer, matchCallback) {\n          var containerNode = extractElementNode(matchContainer);\n          return list.filter(function(entry) {\n            var isMatch = entry.node === containerNode &&\n                            (!matchCallback || entry.callback === matchCallback);\n            return !isMatch;\n          });\n        }\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n            var recordExists = disabledElementsLookup.get(node);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !recordExists;\n            } else {\n              // (element, bool) - Element setter\n              bool = !!bool;\n              if (!bool) {\n                disabledElementsLookup.put(node, true);\n              } else if (recordExists) {\n                disabledElementsLookup.remove(node);\n              }\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    function queueAnimation(element, event, options) {\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        close();\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationOptions(element, existingAnimation.options, options);\n            return existingAnimation.runner;\n          }\n        }\n\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationOptions(element, options);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationOptions(element, options);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation.options);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails.options));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n            });\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        switch (state) {\n          case RUNNING_STATE:\n            animationDetails.runner.end();\n            /* falls through */\n          case PRE_DIGEST_STATE:\n            if (animationDetails) {\n              activeAnimationsLookup.remove(child);\n            }\n            break;\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n\n      var parentHost = element.data(NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      while (parentElement && parentElement.length) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        var parentNode = parentElement[0];\n        if (parentNode.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentNode) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n          if (!rootElementDetected) {\n            parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);\n            if (parentHost) {\n              parentElement = parentHost;\n            }\n          }\n        }\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be apart of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        parentElement = parentElement.parent();\n      }\n\n      var allowAnimation = !parentAnimationDetected || animateChildren;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$AnimateAsyncRunFactory = ['$$rAF', function($$rAF) {\n  var waitQueue = [];\n\n  function waitForTick(fn) {\n    waitQueue.push(fn);\n    if (waitQueue.length > 1) return;\n    $$rAF(function() {\n      for (var i = 0; i < waitQueue.length; i++) {\n        waitQueue[i]();\n      }\n      waitQueue = [];\n    });\n  }\n\n  return function() {\n    var passed = false;\n    waitForTick(function() {\n      passed = true;\n    });\n    return function(callback) {\n      passed ? callback() : waitForTick(callback);\n    };\n  };\n}];\n\nvar $$AnimateRunnerFactory = ['$q', '$sniffer', '$$animateAsyncRun',\n                      function($q,   $sniffer,   $$animateAsyncRun) {\n\n  var INITIAL_STATE = 0;\n  var DONE_PENDING_STATE = 1;\n  var DONE_COMPLETE_STATE = 2;\n\n  AnimateRunner.chain = function(chain, callback) {\n    var index = 0;\n\n    next();\n    function next() {\n      if (index === chain.length) {\n        callback(true);\n        return;\n      }\n\n      chain[index](function(response) {\n        if (response === false) {\n          callback(false);\n          return;\n        }\n        index++;\n        next();\n      });\n    }\n  };\n\n  AnimateRunner.all = function(runners, callback) {\n    var count = 0;\n    var status = true;\n    forEach(runners, function(runner) {\n      runner.done(onProgress);\n    });\n\n    function onProgress(response) {\n      status = status && response;\n      if (++count === runners.length) {\n        callback(status);\n      }\n    }\n  };\n\n  function AnimateRunner(host) {\n    this.setHost(host);\n\n    this._doneCallbacks = [];\n    this._runInAnimationFrame = $$animateAsyncRun();\n    this._state = 0;\n  }\n\n  AnimateRunner.prototype = {\n    setHost: function(host) {\n      this.host = host || {};\n    },\n\n    done: function(fn) {\n      if (this._state === DONE_COMPLETE_STATE) {\n        fn();\n      } else {\n        this._doneCallbacks.push(fn);\n      }\n    },\n\n    progress: noop,\n\n    getPromise: function() {\n      if (!this.promise) {\n        var self = this;\n        this.promise = $q(function(resolve, reject) {\n          self.done(function(status) {\n            status === false ? reject() : resolve();\n          });\n        });\n      }\n      return this.promise;\n    },\n\n    then: function(resolveHandler, rejectHandler) {\n      return this.getPromise().then(resolveHandler, rejectHandler);\n    },\n\n    'catch': function(handler) {\n      return this.getPromise()['catch'](handler);\n    },\n\n    'finally': function(handler) {\n      return this.getPromise()['finally'](handler);\n    },\n\n    pause: function() {\n      if (this.host.pause) {\n        this.host.pause();\n      }\n    },\n\n    resume: function() {\n      if (this.host.resume) {\n        this.host.resume();\n      }\n    },\n\n    end: function() {\n      if (this.host.end) {\n        this.host.end();\n      }\n      this._resolve(true);\n    },\n\n    cancel: function() {\n      if (this.host.cancel) {\n        this.host.cancel();\n      }\n      this._resolve(false);\n    },\n\n    complete: function(response) {\n      var self = this;\n      if (self._state === INITIAL_STATE) {\n        self._state = DONE_PENDING_STATE;\n        self._runInAnimationFrame(function() {\n          self._resolve(response);\n        });\n      }\n    },\n\n    _resolve: function(response) {\n      if (this._state !== DONE_COMPLETE_STATE) {\n        forEach(this._doneCallbacks, function(fn) {\n          fn(response);\n        });\n        this._doneCallbacks.length = 0;\n        this._state = DONE_COMPLETE_STATE;\n      }\n    }\n  };\n\n  return AnimateRunner;\n}];\n\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effictively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check\n\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          getRunner(element).setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/* global angularAnimateModule: true,\n\n   $$AnimateAsyncRunFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateRunnerFactory,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,\n*/\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=true\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the ainmation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       }).start();\n*        runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       }).start();\n *\n *       runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n *\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix\n * will be evaluated for animation when any DOM changes occur in the application.\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [])\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .factory('$$AnimateRunner', $$AnimateRunnerFactory)\n  .factory('$$animateAsyncRun', $$AnimateAsyncRunFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n\n},{}],34:[function(require,module,exports){\nrequire('./angular-animate');\nmodule.exports = 'ngAnimate';\n\n},{\"./angular-animate\":33}],35:[function(require,module,exports){\n/*!\n   angular-block-ui v0.2.0\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\n   License: MIT\n*/\n(function(angular) {\n\nvar blkUI = angular.module('blockUI', []);\n\nblkUI.config([\"$provide\", \"$httpProvider\", function ($provide, $httpProvider) {\n\n  $provide.decorator('$exceptionHandler', ['$delegate', '$injector',\n    function ($delegate, $injector) {\n      var blockUI, blockUIConfig;\n\n      return function (exception, cause) {\n\n        blockUIConfig = blockUIConfig || $injector.get('blockUIConfig');\n\n        if (blockUIConfig.resetOnException) {\n          try {\n            blockUI = blockUI || $injector.get('blockUI');\n            blockUI.instances.reset();\n          } catch (ex) {\n            console.log('$exceptionHandler', exception);\n          }\n        }\n\n        $delegate(exception, cause);\n      };\n    }\n  ]);\n\n  $httpProvider.interceptors.push('blockUIHttpInterceptor');\n}]);\n\nblkUI.run([\"$document\", \"blockUIConfig\", \"$templateCache\", function ($document, blockUIConfig, $templateCache) {\n  if (blockUIConfig.autoInjectBodyBlock) {\n    $document.find('body').attr('block-ui', 'main');\n  }\n\n  if (blockUIConfig.template) {\n\n    // Swap the builtin template with the custom template.\n    // Create a magic cache key and place the template in the cache.\n\n    blockUIConfig.templateUrl = '$$block-ui-template$$';\n    $templateCache.put(blockUIConfig.templateUrl, blockUIConfig.template);\n  }\n}]);\n\nfunction moduleLoaded(name) {\n  try {\n    angular.module(name);\n  } catch(ex) {\n    return false;\n  }\n  return true;\n}\nblkUI.config([\"$provide\", function ($provide) {\n  $provide.decorator('$location', decorateLocation);\n}]);\n\nvar decorateLocation = [\n  '$delegate', 'blockUI', 'blockUIConfig',\n  function ($delegate, blockUI, blockUIConfig) {\n\n    if (blockUIConfig.blockBrowserNavigation) {\n\n      blockUI.$_blockLocationChange = true;\n\n      var overrides = ['url', 'path', 'search', 'hash', 'state'];\n\n      function hook(f) {\n        var s = $delegate[f];\n        $delegate[f] = function () {\n\n          //        console.log(f, Date.now(), arguments);\n\n          var result = s.apply($delegate, arguments);\n\n          // The call was a setter if the $location service is returned.\n\n          if (result === $delegate) {\n\n            // Mark the mainblock ui to allow the location change.\n\n            blockUI.$_blockLocationChange = false;\n          }\n\n          return result;\n        };\n      }\n\n      angular.forEach(overrides, hook);\n\n    }\n\n    return $delegate;\n}];\n\n// Called from block-ui-directive for the 'main' instance.\n\nfunction blockNavigation($scope, mainBlockUI, blockUIConfig) {\n\n  if (blockUIConfig.blockBrowserNavigation) {\n\n    function registerLocationChange() {\n\n      $scope.$on('$locationChangeStart', function (event) {\n\n        //        console.log('$locationChangeStart', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);\n\n        if (mainBlockUI.$_blockLocationChange && mainBlockUI.state().blockCount > 0) {\n          event.preventDefault();\n        }\n      });\n\n      $scope.$on('$locationChangeSuccess', function () {\n        mainBlockUI.$_blockLocationChange = blockUIConfig.blockBrowserNavigation;\n\n        //        console.log('$locationChangeSuccess', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);\n      });\n    }\n\n    if (moduleLoaded('ngRoute')) {\n\n      // After the initial content has been loaded we'll spy on any location\n      // changes and discard them when needed.\n\n      var fn = $scope.$on('$viewContentLoaded', function () {\n\n        // Unhook the view loaded and hook a function that will prevent\n        // location changes while the block is active.\n\n        fn();\n        registerLocationChange();\n\n      });\n\n    } else {\n      registerLocationChange();\n    }\n\n  }\n}\nblkUI.directive('blockUiContainer', [\"blockUIConfig\", \"blockUiContainerLinkFn\", function (blockUIConfig, blockUiContainerLinkFn) {\n  return {\n    scope: true,\n    restrict: 'A',\n    templateUrl: blockUIConfig.templateUrl,\n    compile: function($element) {\n      return blockUiContainerLinkFn;\n    }\n  };\n}]).factory('blockUiContainerLinkFn', [\"blockUI\", \"blockUIUtils\", function (blockUI, blockUIUtils) {\n\n  return function ($scope, $element, $attrs) {\n\n    var srvInstance = $element.inheritedData('block-ui');\n\n    if (!srvInstance) {\n      throw new Error('No parent block-ui service instance located.');\n    }\n\n    // Expose the state on the scope\n\n    $scope.state = srvInstance.state();\n\n//    $scope.$watch('state.blocking', function(value) {\n//      $element.toggleClass('block-ui-visible', !!value);\n//    });\n//\n//    $scope.$watch('state.blockCount > 0', function(value) {\n//      $element.toggleClass('block-ui-active', !!value);\n//    });\n  };\n}]);\nblkUI.directive('blockUi', [\"blockUiCompileFn\", function (blockUiCompileFn) {\n\n  return {\n    scope: true,\n    restrict: 'A',\n    compile: blockUiCompileFn\n  };\n\n}]).factory('blockUiCompileFn', [\"blockUiPreLinkFn\", function (blockUiPreLinkFn) {\n\n  return function ($element, $attrs) {\n\n    // Class should be added here to prevent an animation delay error.\n\n    $element.append('<div block-ui-container class=\"block-ui-container\"></div>');\n\n    return {\n      pre: blockUiPreLinkFn\n    };\n\n  };\n\n}]).factory('blockUiPreLinkFn', [\"blockUI\", \"blockUIUtils\", \"blockUIConfig\", function (blockUI, blockUIUtils, blockUIConfig) {\n\n  return function ($scope, $element, $attrs) {\n\n    // If the element does not have the class \"block-ui\" set, we set the\n    // default css classes from the config.\n\n    if (!$element.hasClass('block-ui')) {\n      $element.addClass(blockUIConfig.cssClass);\n    }\n\n    // Expose the blockUiMessageClass attribute value on the scope\n\n    $attrs.$observe('blockUiMessageClass', function (value) {\n      $scope.$_blockUiMessageClass = value;\n    });\n\n    // Create the blockUI instance\n    // Prefix underscore to prevent integers:\n    // https://github.com/McNull/angular-block-ui/pull/8\n\n    var instanceId = $attrs.blockUi || '_' + $scope.$id;\n    var srvInstance = blockUI.instances.get(instanceId);\n\n    // If this is the main (topmost) block element we'll also need to block any\n    // location changes while the block is active.\n\n    if (instanceId === 'main') {\n      blockNavigation($scope, srvInstance, blockUIConfig);\n    } else {\n      // Locate the parent blockUI instance\n      var parentInstance = $element.inheritedData('block-ui');\n\n      if (parentInstance) {\n        // TODO: assert if parent is already set to something else\n        srvInstance._parent = parentInstance;\n      }\n    }\n\n    // Ensure the instance is released when the scope is destroyed\n\n    $scope.$on('$destroy', function () {\n      srvInstance.release();\n    });\n\n    // Increase the reference count\n\n    srvInstance.addRef();\n\n    // Expose the state on the scope\n\n    $scope.$_blockUiState = srvInstance.state();\n\n    $scope.$watch('$_blockUiState.blocking', function (value) {\n      // Set the aria-busy attribute if needed\n      $element.attr('aria-busy', !!value);\n      $element.toggleClass('block-ui-visible', !!value);\n    });\n\n    $scope.$watch('$_blockUiState.blockCount > 0', function (value) {\n      $element.toggleClass('block-ui-active', !!value);\n    });\n\n    // If a pattern is provided assign it to the state\n\n    var pattern = $attrs.blockUiPattern;\n\n    if (pattern) {\n      var regExp = blockUIUtils.buildRegExp(pattern);\n      srvInstance.pattern(regExp);\n    }\n\n    // Store a reference to the service instance on the element\n\n    $element.data('block-ui', srvInstance);\n\n  };\n\n}]);\n//.factory('blockUiPostLinkFn', function(blockUIUtils) {\n//\n//  return function($scope, $element, $attrs) {\n//\n//    var $message;\n//\n//    $attrs.$observe('blockUiMessageClass', function(value) {\n//\n//      $message = $message || blockUIUtils.findElement($element, function($e) {\n//        return $e.hasClass('block-ui-message');\n//      });\n//\n//      $message.addClass(value);\n//\n//    });\n//  };\n//\n//});\nblkUI.constant('blockUIConfig', {\n    templateUrl: 'angular-block-ui/angular-block-ui.ng.html',\n    delay: 250,\n    message: \"Loading ...\",\n    autoBlock: true,\n    resetOnException: true,\n    requestFilter: angular.noop,\n    autoInjectBodyBlock: true,\n    cssClass: 'block-ui block-ui-anim-fade',\n    blockBrowserNavigation: false\n});\n\n\nblkUI.factory('blockUIHttpInterceptor', [\"$q\", \"$injector\", \"blockUIConfig\", \"$templateCache\", function($q, $injector, blockUIConfig, $templateCache) {\n\n  var blockUI;\n\n  function injectBlockUI() {\n    blockUI = blockUI || $injector.get('blockUI');\n  }\n\n  function stopBlockUI(config) {\n    if (blockUIConfig.autoBlock && (config && !config.$_noBlock && config.$_blocks)) {\n      injectBlockUI();\n      config.$_blocks.stop();\n    }\n  }\n\n  function error(rejection) {\n\n    try {\n      stopBlockUI(rejection.config);\n    } catch(ex) {\n      console.log('httpRequestError', ex);\n    }\n\n    return $q.reject(rejection);\n  }\n\n  return {\n    request: function(config) {\n\n      // Only block when autoBlock is enabled ...\n      // ... and the request doesn't match a cached template.\n\n      if (blockUIConfig.autoBlock &&\n        !(config.method == 'GET' && $templateCache.get(config.url))) {\n\n        // Don't block excluded requests\n\n        var result = blockUIConfig.requestFilter(config);\n\n        if (result === false) {\n          // Tag the config so we don't unblock this request\n          config.$_noBlock = true;\n        } else {\n\n          injectBlockUI();\n\n          config.$_blocks = blockUI.instances.locate(config);\n          config.$_blocks.start(result);\n        }\n      }\n\n      return config;\n    },\n\n    requestError: error,\n\n    response: function(response) {\n\n      // If the connection to the website goes down the response interceptor gets and error with \"cannot read property config of null\".\n      // https://github.com/McNull/angular-block-ui/issues/53\n\n      if(response) {\n        stopBlockUI(response.config);\n      }\n\n      return response;\n    },\n\n    responseError: error\n  };\n\n}]);\n\nblkUI.factory('blockUI', [\"blockUIConfig\", \"$timeout\", \"blockUIUtils\", \"$document\", function(blockUIConfig, $timeout, blockUIUtils, $document) {\n\n  var $body = $document.find('body');\n\n  function BlockUI(id) {\n\n    var self = this;\n\n    var state = {\n      id: id,\n      blockCount: 0,\n      message: blockUIConfig.message,\n      blocking: false\n    }, startPromise, doneCallbacks = [];\n\n    this._id = id;\n\n    this._refs = 0;\n\n    this.start = function(message) {\n\n      if(state.blockCount > 0) {\n        message = message || state.message || blockUIConfig.message;\n      } else {\n        message = message || blockUIConfig.message;\n      }\n\n      state.message = message;\n\n      state.blockCount++;\n\n      // Check if the focused element is part of the block scope\n\n      var $ae = angular.element($document[0].activeElement);\n\n      if($ae.length && blockUIUtils.isElementInBlockScope($ae, self)) {\n\n        // Let the active element lose focus and store a reference \n        // to restore focus when we're done (reset)\n\n        self._restoreFocus = $ae[0];\n\n        // https://github.com/McNull/angular-block-ui/issues/13\n        // http://stackoverflow.com/questions/22698058/apply-already-in-progress-error-when-using-typeahead-plugin-found-to-be-relate\n        // Queue the blur after any ng-blur expression.\n\n        $timeout(function() {\n          // Ensure we still need to blur\n          if(self._restoreFocus) {\n            self._restoreFocus.blur();\n          }\n        });\n      }\n\n      if (!startPromise) {\n        startPromise = $timeout(function() {\n          startPromise = null;\n          state.blocking = true;\n        }, blockUIConfig.delay);\n      }\n    };\n\n    this._cancelStartTimeout = function() {\n      if (startPromise) {\n        $timeout.cancel(startPromise);\n        startPromise = null;\n      }\n    };\n\n    this.stop = function() {\n      state.blockCount = Math.max(0, --state.blockCount);\n\n      if (state.blockCount === 0) {\n        self.reset(true);\n      }\n    };\n\n    this.message = function(value) {\n      state.message = value;\n    };\n\n    this.pattern = function(regexp) {\n      if (regexp !== undefined) {\n        self._pattern = regexp;\n      }\n\n      return self._pattern;\n    };\n\n    this.reset = function(executeCallbacks) {\n      \n      self._cancelStartTimeout();\n      state.blockCount = 0;\n      state.blocking = false;\n\n      // Restore the focus to the element that was active\n      // before the block start, but not if the user has \n      // focused something else while the block was active.\n\n      if(self._restoreFocus && \n         (!$document[0].activeElement || $document[0].activeElement === $body[0])) {\n        self._restoreFocus.focus();\n        self._restoreFocus = null;\n      }\n      \n      try {\n        if (executeCallbacks) {\n          angular.forEach(doneCallbacks, function(cb) {\n            cb();\n          });\n        }\n      } finally {\n        doneCallbacks.length = 0;\n      }\n    };\n\n    this.done = function(fn) {\n      doneCallbacks.push(fn);\n    };\n\n    this.state = function() {\n      return state;\n    };\n\n    this.addRef = function() {\n      self._refs += 1;\n    };\n\n    this.release = function() {\n      if(--self._refs <= 0) {\n        mainBlock.instances._destroy(self);\n      }\n    };\n  }\n\n  var instances = [];\n\n  instances.get = function(id) {\n\n    if(!isNaN(id)) {\n      throw new Error('BlockUI id cannot be a number');\n    }\n\n    var instance = instances[id];\n\n    if(!instance) {\n      // TODO: ensure no array instance trashing [xxx] -- current workaround: '_' + $scope.$id\n      instance = instances[id] = new BlockUI(id);\n      instances.push(instance);\n    }\n\n    return instance;\n  };\n\n  instances._destroy = function(idOrInstance) {\n    if (angular.isString(idOrInstance)) {\n      idOrInstance = instances[idOrInstance];\n    }\n\n    if (idOrInstance) {\n      idOrInstance.reset();\n\n      var i = blockUIUtils.indexOf(instances, idOrInstance);\n      instances.splice(i, 1);\n\n      delete instances[idOrInstance.state().id];\n    }\n  };\n  \n  instances.locate = function(request) {\n\n    var result = [];\n\n    // Add function wrappers that will be executed on every item\n    // in the array.\n    \n    blockUIUtils.forEachFnHook(result, 'start');\n    blockUIUtils.forEachFnHook(result, 'stop');\n\n    var i = instances.length;\n\n    while(i--) {\n      var instance = instances[i];\n      var pattern = instance._pattern;\n\n      if(pattern && pattern.test(request.url)) {\n        result.push(instance);\n      }\n    }\n\n    if(result.length === 0) {\n      result.push(mainBlock);\n    }\n\n    return result;\n  };\n\n  // Propagate the reset to all instances\n\n  blockUIUtils.forEachFnHook(instances, 'reset');\n\n  var mainBlock = instances.get('main');\n\n  mainBlock.addRef();\n  mainBlock.instances = instances;\n\n  return mainBlock;\n}]);\n\n\nblkUI.factory('blockUIUtils', function() {\n\n  var $ = angular.element;\n\n  var utils = {\n    buildRegExp: function(pattern) {\n      var match = pattern.match(/^\\/(.*)\\/([gim]*)$/), regExp;\n\n      if(match) {\n        regExp = new RegExp(match[1], match[2]);\n      } else {\n        throw Error('Incorrect regular expression format: ' + pattern);\n      }\n\n      return regExp;\n    },\n    forEachFn: function(arr, fnName, args) {\n      var i = arr.length;\n      while(i--) {\n        var t = arr[i];\n        t[fnName].apply(t, args);\n      }\n    },\n    forEachFnHook: function(arr, fnName) {\n      arr[fnName] = function() {\n        utils.forEachFn(this, fnName, arguments);\n      }\n    },\n    isElementInBlockScope: function($element, blockScope) {\n      var c = $element.inheritedData('block-ui');\n\n      while(c) {\n        if(c === blockScope) {\n          return true;\n        }\n\n        c = c._parent;\n      }\n\n      return false;\n    },\n    findElement: function ($element, predicateFn, traverse) {\n      var ret = null;\n\n      if (predicateFn($element)) {\n        ret = $element;\n      } else {\n\n        var $elements;\n\n        if (traverse) {\n          $elements = $element.parent();\n        } else {\n          $elements = $element.children();\n        }\n\n        var i = $elements.length;\n        while (!ret && i--) {\n          ret = utils.findElement($($elements[i]), predicateFn, traverse);\n        }\n      }\n\n      return ret;\n    },\n    indexOf: function(arr, obj, start) {\n//      if(Array.prototype.indexOf) {\n//        return arr.indexOf(obj, start);\n//      }\n\n      for (var i = (start || 0), j = arr.length; i < j; i++) {\n        if (arr[i] === obj) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  };\n\n  return utils;\n\n});\n// Automatically generated.\n// This file is already embedded in your main javascript output, there's no need to include this file\n// manually in the index.html. This file is only here for your debugging pleasures.\nangular.module('blockUI').run(['$templateCache', function($templateCache){\n  $templateCache.put('angular-block-ui/angular-block-ui.ng.html', '<div class=\\\"block-ui-overlay\\\"></div><div class=\\\"block-ui-message-container\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\"><div class=\\\"block-ui-message\\\" ng-class=\\\"$_blockUiMessageClass\\\">{{ state.message }}</div></div>');\n}]);\n})(angular);\nif (typeof module !== \"undefined\") module.exports = \"blockUI\";\n\n\n},{}],36:[function(require,module,exports){\nvar css = \"/*!\\n   angular-block-ui v0.2.0\\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\\n   License: MIT\\n*/\\n.block-ui {\\n  position: relative;\\n}\\nbody.block-ui {\\n  position: static;\\n}\\n.block-ui-main>.block-ui-container,\\nbody.block-ui>.block-ui-container {\\n  position: fixed;\\n}\\n.block-ui-container {\\n  position: absolute;\\n  z-index: 10000;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n  height: 0;\\n  overflow: hidden;\\n  opacity: 0;\\n  filter: alpha(opacity=00);\\n}\\n.block-ui-active>.block-ui-container {\\n  height: 100%;\\n  cursor: wait;\\n}\\n.block-ui-active .block-ui-active>.block-ui-container {\\n  height: 0;\\n}\\n.block-ui-visible>.block-ui-container {\\n  opacity: 1;\\n  filter: alpha(opacity=100);\\n}\\n.block-ui-overlay {\\n  width: 100%;\\n  height: 100%;\\n  opacity: .5;\\n  filter: alpha(opacity=50);\\n  background-color: #fff;\\n}\\n.block-ui-message-container {\\n  position: absolute;\\n  top: 35%;\\n  left: 0;\\n  right: 0;\\n  height: 0;\\n  text-align: center;\\n  z-index: 10001;\\n}\\n.block-ui-message {\\n  display: inline-block;\\n  text-align: left;\\n  background-color: #333;\\n  color: #f5f5f5;\\n  padding: 20px;\\n  border-radius: 4px;\\n  font-size: 20px;\\n  font-weight: 700;\\n  filter: alpha(opacity=100);\\n}\\n.block-ui-anim-fade>.block-ui-container {\\n  -webkit-transition: height 0s linear 200ms,opacity 200ms ease 0s;\\n  transition: height 0s linear 200ms,opacity 200ms ease 0s;\\n}\\n.block-ui-anim-fade.block-ui-active>.block-ui-container {\\n  -webkit-transition-delay: 0s;\\n  transition-delay: 0s;\\n}\\n\"; (require(\"browserify-css\").createStyle(css, { \"href\": \"node_modules\\\\angular-block-ui\\\\dist\\\\angular-block-ui.min.css\"})); module.exports = css;\n},{\"browserify-css\":41}],37:[function(require,module,exports){\n/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $sanitizeMinErr = angular.$$minErr('$sanitize');\n\n/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n\n/*\n * HTML Parser By Misko Hevery (misko@hevery.com)\n * based on:  HTML Parser By John Resig (ejohn.org)\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n *\n * // Use like so:\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n */\n\n\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string, however, since our parser is more strict than a typical browser\n *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a\n *   browser, won't make it through the sanitizer. The input may also contain SVG markup.\n *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and\n *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getInnerHtml()).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\nfunction $SanitizeProvider() {\n  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n    return function(html) {\n      var buf = [];\n      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n        return !/^unsafe/.test($$sanitizeUri(uri, isImage));\n      }));\n      return buf.join('');\n    };\n  }];\n}\n\nfunction sanitizeText(chars) {\n  var buf = [];\n  var writer = htmlSanitizeWriter(buf, angular.noop);\n  writer.chars(chars);\n  return buf.join('');\n}\n\n\n// Regular Expressions for parsing tags and attributes\nvar START_TAG_REGEXP =\n       /^<((?:[a-zA-Z])[\\w:-]*)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)\\s*(>?)/,\n  END_TAG_REGEXP = /^<\\/\\s*([\\w:-]+)[^>]*>/,\n  ATTR_REGEXP = /([\\w:-]+)(?:\\s*=\\s*(?:(?:\"((?:[^\"])*)\")|(?:'((?:[^'])*)')|([^>\\s]+)))?/g,\n  BEGIN_TAG_REGEXP = /^</,\n  BEGING_END_TAGE_REGEXP = /^<\\//,\n  COMMENT_REGEXP = /<!--(.*?)-->/g,\n  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,\n  CDATA_REGEXP = /<!\\[CDATA\\[(.*?)]]>/g,\n  SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n  // Match everything outside of normal chars and \" (quote character)\n  NON_ALPHANUMERIC_REGEXP = /([^\\#-~| |!])/g;\n\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\nvar voidElements = makeMap(\"area,br,col,hr,img,wbr\");\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\nvar optionalEndTagBlockElements = makeMap(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),\n    optionalEndTagInlineElements = makeMap(\"rp,rt\"),\n    optionalEndTagElements = angular.extend({},\n                                            optionalEndTagInlineElements,\n                                            optionalEndTagBlockElements);\n\n// Safe Block Elements - HTML5\nvar blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap(\"address,article,\" +\n        \"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,\" +\n        \"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul\"));\n\n// Inline Elements - HTML5\nvar inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap(\"a,abbr,acronym,b,\" +\n        \"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,\" +\n        \"samp,small,span,strike,strong,sub,sup,time,tt,u,var\"));\n\n// SVG Elements\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n// They can potentially allow for arbitrary javascript to be executed. See #11290\nvar svgElements = makeMap(\"circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,\" +\n        \"hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,\" +\n        \"radialGradient,rect,stop,svg,switch,text,title,tspan,use\");\n\n// Special Elements (can contain anything)\nvar specialElements = makeMap(\"script,style\");\n\nvar validElements = angular.extend({},\n                                   voidElements,\n                                   blockElements,\n                                   inlineElements,\n                                   optionalEndTagElements,\n                                   svgElements);\n\n//Attributes that have href and hence need to be sanitized\nvar uriAttrs = makeMap(\"background,cite,href,longdesc,src,usemap,xlink:href\");\n\nvar htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n    'valign,value,vspace,width');\n\n// SVG attributes (without \"id\" and \"name\" attributes)\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\nvar svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +\n    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\nvar validAttrs = angular.extend({},\n                                uriAttrs,\n                                svgAttrs,\n                                htmlAttrs);\n\nfunction makeMap(str, lowercaseKeys) {\n  var obj = {}, items = str.split(','), i;\n  for (i = 0; i < items.length; i++) {\n    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;\n  }\n  return obj;\n}\n\n\n/**\n * @example\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n * @param {string} html string\n * @param {object} handler\n */\nfunction htmlParser(html, handler) {\n  if (typeof html !== 'string') {\n    if (html === null || typeof html === 'undefined') {\n      html = '';\n    } else {\n      html = '' + html;\n    }\n  }\n  var index, chars, match, stack = [], last = html, text;\n  stack.last = function() { return stack[stack.length - 1]; };\n\n  while (html) {\n    text = '';\n    chars = true;\n\n    // Make sure we're not in a script or style element\n    if (!stack.last() || !specialElements[stack.last()]) {\n\n      // Comment\n      if (html.indexOf(\"<!--\") === 0) {\n        // comments containing -- are not allowed unless they terminate the comment\n        index = html.indexOf(\"--\", 4);\n\n        if (index >= 0 && html.lastIndexOf(\"-->\", index) === index) {\n          if (handler.comment) handler.comment(html.substring(4, index));\n          html = html.substring(index + 3);\n          chars = false;\n        }\n      // DOCTYPE\n      } else if (DOCTYPE_REGEXP.test(html)) {\n        match = html.match(DOCTYPE_REGEXP);\n\n        if (match) {\n          html = html.replace(match[0], '');\n          chars = false;\n        }\n      // end tag\n      } else if (BEGING_END_TAGE_REGEXP.test(html)) {\n        match = html.match(END_TAG_REGEXP);\n\n        if (match) {\n          html = html.substring(match[0].length);\n          match[0].replace(END_TAG_REGEXP, parseEndTag);\n          chars = false;\n        }\n\n      // start tag\n      } else if (BEGIN_TAG_REGEXP.test(html)) {\n        match = html.match(START_TAG_REGEXP);\n\n        if (match) {\n          // We only have a valid start-tag if there is a '>'.\n          if (match[4]) {\n            html = html.substring(match[0].length);\n            match[0].replace(START_TAG_REGEXP, parseStartTag);\n          }\n          chars = false;\n        } else {\n          // no ending tag found --- this piece should be encoded as an entity.\n          text += '<';\n          html = html.substring(1);\n        }\n      }\n\n      if (chars) {\n        index = html.indexOf(\"<\");\n\n        text += index < 0 ? html : html.substring(0, index);\n        html = index < 0 ? \"\" : html.substring(index);\n\n        if (handler.chars) handler.chars(decodeEntities(text));\n      }\n\n    } else {\n      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\\W\\w].\n      html = html.replace(new RegExp(\"([\\\\W\\\\w]*)<\\\\s*\\\\/\\\\s*\" + stack.last() + \"[^>]*>\", 'i'),\n        function(all, text) {\n          text = text.replace(COMMENT_REGEXP, \"$1\").replace(CDATA_REGEXP, \"$1\");\n\n          if (handler.chars) handler.chars(decodeEntities(text));\n\n          return \"\";\n      });\n\n      parseEndTag(\"\", stack.last());\n    }\n\n    if (html == last) {\n      throw $sanitizeMinErr('badparse', \"The sanitizer was unable to parse the following block \" +\n                                        \"of html: {0}\", html);\n    }\n    last = html;\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function parseStartTag(tag, tagName, rest, unary) {\n    tagName = angular.lowercase(tagName);\n    if (blockElements[tagName]) {\n      while (stack.last() && inlineElements[stack.last()]) {\n        parseEndTag(\"\", stack.last());\n      }\n    }\n\n    if (optionalEndTagElements[tagName] && stack.last() == tagName) {\n      parseEndTag(\"\", tagName);\n    }\n\n    unary = voidElements[tagName] || !!unary;\n\n    if (!unary) {\n      stack.push(tagName);\n    }\n\n    var attrs = {};\n\n    rest.replace(ATTR_REGEXP,\n      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {\n        var value = doubleQuotedValue\n          || singleQuotedValue\n          || unquotedValue\n          || '';\n\n        attrs[name] = decodeEntities(value);\n    });\n    if (handler.start) handler.start(tagName, attrs, unary);\n  }\n\n  function parseEndTag(tag, tagName) {\n    var pos = 0, i;\n    tagName = angular.lowercase(tagName);\n    if (tagName) {\n      // Find the closest opened tag of the same type\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos] == tagName) break;\n      }\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (i = stack.length - 1; i >= pos; i--)\n        if (handler.end) handler.end(stack[i]);\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n    }\n  }\n}\n\nvar hiddenPre=document.createElement(\"pre\");\n/**\n * decodes all entities into regular string\n * @param value\n * @returns {string} A string with decoded entities.\n */\nfunction decodeEntities(value) {\n  if (!value) { return ''; }\n\n  hiddenPre.innerHTML = value.replace(/</g,\"&lt;\");\n  // innerText depends on styling as it doesn't display hidden elements.\n  // Therefore, it's better to use textContent not to cause unnecessary reflows.\n  return hiddenPre.textContent;\n}\n\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n * @returns {string} escaped text\n */\nfunction encodeEntities(value) {\n  return value.\n    replace(/&/g, '&amp;').\n    replace(SURROGATE_PAIR_REGEXP, function(value) {\n      var hi = value.charCodeAt(0);\n      var low = value.charCodeAt(1);\n      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n    }).\n    replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n      return '&#' + value.charCodeAt(0) + ';';\n    }).\n    replace(/</g, '&lt;').\n    replace(/>/g, '&gt;');\n}\n\n/**\n * create an HTML/XML writer which writes to buffer\n * @param {Array} buf use buf.jain('') to get out sanitized html string\n * @returns {object} in the form of {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * }\n */\nfunction htmlSanitizeWriter(buf, uriValidator) {\n  var ignore = false;\n  var out = angular.bind(buf, buf.push);\n  return {\n    start: function(tag, attrs, unary) {\n      tag = angular.lowercase(tag);\n      if (!ignore && specialElements[tag]) {\n        ignore = tag;\n      }\n      if (!ignore && validElements[tag] === true) {\n        out('<');\n        out(tag);\n        angular.forEach(attrs, function(value, key) {\n          var lkey=angular.lowercase(key);\n          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n          if (validAttrs[lkey] === true &&\n            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n            out(' ');\n            out(key);\n            out('=\"');\n            out(encodeEntities(value));\n            out('\"');\n          }\n        });\n        out(unary ? '/>' : '>');\n      }\n    },\n    end: function(tag) {\n        tag = angular.lowercase(tag);\n        if (!ignore && validElements[tag] === true) {\n          out('</');\n          out(tag);\n          out('>');\n        }\n        if (tag == ignore) {\n          ignore = false;\n        }\n      },\n    chars: function(chars) {\n        if (!ignore) {\n          out(encodeEntities(chars));\n        }\n      }\n  };\n}\n\n\n// define ngSanitize module and register $sanitize service\nangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n/* global sanitizeText: false */\n\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.\n * @returns {string} Html-linkified text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n       <script>\n         angular.module('linkyExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', function($scope) {\n             $scope.snippet =\n               'Pretty text with some links:\\n'+\n               'http://angularjs.org/,\\n'+\n               'mailto:us@somewhere.org,\\n'+\n               'another@somewhere.org,\\n'+\n               'and one more: ftp://127.0.0.1/.';\n             $scope.snippetWithTarget = 'http://angularjs.org/';\n           }]);\n       </script>\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Filter</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithTarget | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n     </file>\n   </example>\n */\nangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n  var LINKY_URL_REGEXP =\n        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n      MAILTO_REGEXP = /^mailto:/i;\n\n  return function(text, target) {\n    if (!text) return text;\n    var match;\n    var raw = text;\n    var html = [];\n    var url;\n    var i;\n    while ((match = raw.match(LINKY_URL_REGEXP))) {\n      // We can not end in these as they are sometimes found at the end of the sentence\n      url = match[0];\n      // if we did not match ftp/http/www/mailto then assume mailto\n      if (!match[2] && !match[4]) {\n        url = (match[3] ? 'http://' : 'mailto:') + url;\n      }\n      i = match.index;\n      addText(raw.substr(0, i));\n      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n      raw = raw.substring(i + match[0].length);\n    }\n    addText(raw);\n    return $sanitize(html.join(''));\n\n    function addText(text) {\n      if (!text) {\n        return;\n      }\n      html.push(sanitizeText(text));\n    }\n\n    function addLink(url, text) {\n      html.push('<a ');\n      if (angular.isDefined(target)) {\n        html.push('target=\"',\n                  target,\n                  '\" ');\n      }\n      html.push('href=\"',\n                url.replace(/\"/g, '&quot;'),\n                '\">');\n      addText(text);\n      html.push('</a>');\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n\n},{}],38:[function(require,module,exports){\nrequire('./angular-sanitize');\nmodule.exports = 'ngSanitize';\n\n},{\"./angular-sanitize\":37}],39:[function(require,module,exports){\n/*!\n * angular-translate - v2.10.0 - 2016-02-28\n * \n * Copyright (c) 2016 The angular-translate team, Pascal Precht; Licensed MIT\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define([], function () {\n      return (factory());\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    factory();\n  }\n}(this, function () {\n\n/**\n * @ngdoc overview\n * @name pascalprecht.translate\n *\n * @description\n * The main module which holds everything together.\n */\nangular.module('pascalprecht.translate', ['ng'])\n  .run(runTranslate);\n\nfunction runTranslate($translate) {\n\n  'use strict';\n\n  var key = $translate.storageKey(),\n    storage = $translate.storage();\n\n  var fallbackFromIncorrectStorageValue = function () {\n    var preferred = $translate.preferredLanguage();\n    if (angular.isString(preferred)) {\n      $translate.use(preferred);\n      // $translate.use() will also remember the language.\n      // So, we don't need to call storage.put() here.\n    } else {\n      storage.put(key, $translate.use());\n    }\n  };\n\n  fallbackFromIncorrectStorageValue.displayName = 'fallbackFromIncorrectStorageValue';\n\n  if (storage) {\n    if (!storage.get(key)) {\n      fallbackFromIncorrectStorageValue();\n    } else {\n      $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);\n    }\n  } else if (angular.isString($translate.preferredLanguage())) {\n    $translate.use($translate.preferredLanguage());\n  }\n}\nrunTranslate.$inject = ['$translate'];\n\nrunTranslate.displayName = 'runTranslate';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateSanitizationProvider\n *\n * @description\n *\n * Configurations for $translateSanitization\n */\nangular.module('pascalprecht.translate').provider('$translateSanitization', $translateSanitizationProvider);\n\nfunction $translateSanitizationProvider () {\n\n  'use strict';\n\n  var $sanitize,\n      currentStrategy = null, // TODO change to either 'sanitize', 'escape' or ['sanitize', 'escapeParameters'] in 3.0.\n      hasConfiguredStrategy = false,\n      hasShownNoStrategyConfiguredWarning = false,\n      strategies;\n\n  /**\n   * Definition of a sanitization strategy function\n   * @callback StrategyFunction\n   * @param {string|object} value - value to be sanitized (either a string or an interpolated value map)\n   * @param {string} mode - either 'text' for a string (translation) or 'params' for the interpolated params\n   * @return {string|object}\n   */\n\n  /**\n   * @ngdoc property\n   * @name strategies\n   * @propertyOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Following strategies are built-in:\n   * <dl>\n   *   <dt>sanitize</dt>\n   *   <dd>Sanitizes HTML in the translation text using $sanitize</dd>\n   *   <dt>escape</dt>\n   *   <dd>Escapes HTML in the translation</dd>\n   *   <dt>sanitizeParameters</dt>\n   *   <dd>Sanitizes HTML in the values of the interpolation parameters using $sanitize</dd>\n   *   <dt>escapeParameters</dt>\n   *   <dd>Escapes HTML in the values of the interpolation parameters</dd>\n   *   <dt>escaped</dt>\n   *   <dd>Support legacy strategy name 'escaped' for backwards compatibility (will be removed in 3.0)</dd>\n   * </dl>\n   *\n   */\n\n  strategies = {\n    sanitize: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlSanitizeValue(value);\n      }\n      return value;\n    },\n    escape: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlEscapeValue(value);\n      }\n      return value;\n    },\n    sanitizeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlSanitizeValue);\n      }\n      return value;\n    },\n    escapeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlEscapeValue);\n      }\n      return value;\n    }\n  };\n  // Support legacy strategy name 'escaped' for backwards compatibility.\n  // TODO should be removed in 3.0\n  strategies.escaped = strategies.escapeParameters;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#addStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Adds a sanitization strategy to the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @param {StrategyFunction} strategyFunction - strategy function\n   * @returns {object} this\n   */\n  this.addStrategy = function (strategyName, strategyFunction) {\n    strategies[strategyName] = strategyFunction;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#removeStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Removes a sanitization strategy from the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @returns {object} this\n   */\n  this.removeStrategy = function (strategyName) {\n    delete strategies[strategyName];\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#useStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n   *\n   * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n   * @returns {object} this\n   */\n  this.useStrategy = function (strategy) {\n    hasConfiguredStrategy = true;\n    currentStrategy = strategy;\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translateSanitization\n   * @requires $injector\n   * @requires $log\n   *\n   * @description\n   * Sanitizes interpolation parameters and translated texts.\n   *\n   */\n  this.$get = ['$injector', '$log', function ($injector, $log) {\n\n    var cachedStrategyMap = {};\n\n    var applyStrategies = function (value, mode, selectedStrategies) {\n      angular.forEach(selectedStrategies, function (selectedStrategy) {\n        if (angular.isFunction(selectedStrategy)) {\n          value = selectedStrategy(value, mode);\n        } else if (angular.isFunction(strategies[selectedStrategy])) {\n          value = strategies[selectedStrategy](value, mode);\n        } else if (angular.isString(strategies[selectedStrategy])) {\n          if (!cachedStrategyMap[strategies[selectedStrategy]]) {\n            try {\n              cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);\n            } catch (e) {\n              cachedStrategyMap[strategies[selectedStrategy]] = function() {};\n              throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n            }\n          }\n          value = cachedStrategyMap[strategies[selectedStrategy]](value, mode);\n        } else {\n          throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n        }\n      });\n      return value;\n    };\n\n    // TODO: should be removed in 3.0\n    var showNoStrategyConfiguredWarning = function () {\n      if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {\n        $log.warn('pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.');\n        hasShownNoStrategyConfiguredWarning = true;\n      }\n    };\n\n    if ($injector.has('$sanitize')) {\n      $sanitize = $injector.get('$sanitize');\n    }\n\n    return {\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#useStrategy\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n       *\n       * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n       */\n      useStrategy: (function (self) {\n        return function (strategy) {\n          self.useStrategy(strategy);\n        };\n      })(this),\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#sanitize\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Sanitizes a value.\n       *\n       * @param {string|object} value The value which should be sanitized.\n       * @param {string} mode The current sanitization mode, either 'params' or 'text'.\n       * @param {string|StrategyFunction|array} [strategy] Optional custom strategy which should be used instead of the currently selected strategy.\n       * @returns {string|object} sanitized value\n       */\n      sanitize: function (value, mode, strategy) {\n        if (!currentStrategy) {\n          showNoStrategyConfiguredWarning();\n        }\n\n        if (arguments.length < 3) {\n          strategy = currentStrategy;\n        }\n\n        if (!strategy) {\n          return value;\n        }\n\n        var selectedStrategies = angular.isArray(strategy) ? strategy : [strategy];\n        return applyStrategies(value, mode, selectedStrategies);\n      }\n    };\n  }];\n\n  var htmlEscapeValue = function (value) {\n    var element = angular.element('<div></div>');\n    element.text(value); // not chainable, see #1044\n    return element.html();\n  };\n\n  var htmlSanitizeValue = function (value) {\n    if (!$sanitize) {\n      throw new Error('pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as \\'escape\\'.');\n    }\n    return $sanitize(value);\n  };\n\n  var mapInterpolationParameters = function (value, iteratee, stack) {\n    if (angular.isObject(value)) {\n      var result = angular.isArray(value) ? [] : {};\n\n      if (!stack) {\n        stack = [];\n      } else {\n        if (stack.indexOf(value) > -1) {\n          throw new Error('pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object');\n        }\n      }\n\n      stack.push(value);\n      angular.forEach(value, function (propertyValue, propertyKey) {\n        result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack);\n      });\n      stack.splice(-1, 1); // remove last\n\n      return result;\n    } else if (angular.isNumber(value)) {\n      return value;\n    } else {\n      return iteratee(value);\n    }\n  };\n}\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateProvider\n * @description\n *\n * $translateProvider allows developers to register translation-tables, asynchronous loaders\n * and similar to configure translation behavior directly inside of a module.\n *\n */\nangular.module('pascalprecht.translate')\n.constant('pascalprechtTranslateOverrider', {})\n.provider('$translate', $translate);\n\nfunction $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {\n\n  'use strict';\n\n  var $translationTable = {},\n      $preferredLanguage,\n      $availableLanguageKeys = [],\n      $languageKeyAliases,\n      $fallbackLanguage,\n      $fallbackWasString,\n      $uses,\n      $nextLang,\n      $storageFactory,\n      $storageKey = $STORAGE_KEY,\n      $storagePrefix,\n      $missingTranslationHandlerFactory,\n      $interpolationFactory,\n      $interpolatorFactories = [],\n      $loaderFactory,\n      $cloakClassName = 'translate-cloak',\n      $loaderOptions,\n      $notFoundIndicatorLeft,\n      $notFoundIndicatorRight,\n      $postCompilingEnabled = false,\n      $forceAsyncReloadEnabled = false,\n      $nestedObjectDelimeter = '.',\n      $isReady = false,\n      loaderCache,\n      directivePriority = 0,\n      statefulFilter = true,\n      uniformLanguageTagResolver = 'default',\n      languageTagResolver = {\n        'default': function (tag) {\n          return (tag || '').split('-').join('_');\n        },\n        java: function (tag) {\n          var temp = (tag || '').split('-').join('_');\n          var parts = temp.split('_');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '_' + parts[1].toUpperCase()) : temp;\n        },\n        bcp47: function (tag) {\n          var temp = (tag || '').split('_').join('-');\n          var parts = temp.split('-');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '-' + parts[1].toUpperCase()) : temp;\n        }\n      };\n\n  var version = '2.10.0';\n\n  // tries to determine the browsers language\n  var getFirstBrowserLanguage = function () {\n\n    // internal purpose only\n    if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {\n      return pascalprechtTranslateOverrider.getLocale();\n    }\n\n    var nav = $windowProvider.$get().navigator,\n        browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],\n        i,\n        language;\n\n    // support for HTML 5.1 \"navigator.languages\"\n    if (angular.isArray(nav.languages)) {\n      for (i = 0; i < nav.languages.length; i++) {\n        language = nav.languages[i];\n        if (language && language.length) {\n          return language;\n        }\n      }\n    }\n\n    // support for other well known properties in browsers\n    for (i = 0; i < browserLanguagePropertyKeys.length; i++) {\n      language = nav[browserLanguagePropertyKeys[i]];\n      if (language && language.length) {\n        return language;\n      }\n    }\n\n    return null;\n  };\n  getFirstBrowserLanguage.displayName = 'angular-translate/service: getFirstBrowserLanguage';\n\n  // tries to determine the browsers locale\n  var getLocale = function () {\n    var locale = getFirstBrowserLanguage() || '';\n    if (languageTagResolver[uniformLanguageTagResolver]) {\n      locale = languageTagResolver[uniformLanguageTagResolver](locale);\n    }\n    return locale;\n  };\n  getLocale.displayName = 'angular-translate/service: getLocale';\n\n  /**\n   * @name indexOf\n   * @private\n   *\n   * @description\n   * indexOf polyfill. Kinda sorta.\n   *\n   * @param {array} array Array to search in.\n   * @param {string} searchElement Element to search for.\n   *\n   * @returns {int} Index of search element.\n   */\n  var indexOf = function(array, searchElement) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === searchElement) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  var negotiateLocale = function (preferred) {\n    if(!preferred) {\n      return;\n    }\n\n    var avail = [],\n        locale = angular.lowercase(preferred),\n        i = 0,\n        n = $availableLanguageKeys.length;\n\n    for (; i < n; i++) {\n      avail.push(angular.lowercase($availableLanguageKeys[i]));\n    }\n\n    // Check for an exact match in our list of available keys\n    if (indexOf(avail, locale) > -1) {\n      return preferred;\n    }\n\n    if ($languageKeyAliases) {\n      var alias;\n      for (var langKeyAlias in $languageKeyAliases) {\n        var hasWildcardKey = false;\n        var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) &&\n          angular.lowercase(langKeyAlias) === angular.lowercase(preferred);\n\n        if (langKeyAlias.slice(-1) === '*') {\n          hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length-1);\n        }\n        if (hasExactKey || hasWildcardKey) {\n          alias = $languageKeyAliases[langKeyAlias];\n          if (indexOf(avail, angular.lowercase(alias)) > -1) {\n            return alias;\n          }\n        }\n      }\n    }\n\n    // Check for a language code without region\n    var parts = preferred.split('_');\n\n    if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {\n      return parts[0];\n    }\n\n    // If everything fails, return undefined.\n    return;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translations\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a new translation table for specific language key.\n   *\n   * To register a translation table for specific language, pass a defined language\n   * key as first parameter.\n   *\n   * <pre>\n   *  // register translation table for language: 'de_DE'\n   *  $translateProvider.translations('de_DE', {\n   *    'GREETING': 'Hallo Welt!'\n   *  });\n   *\n   *  // register another one\n   *  $translateProvider.translations('en_US', {\n   *    'GREETING': 'Hello world!'\n   *  });\n   * </pre>\n   *\n   * When registering multiple translation tables for for the same language key,\n   * the actual translation table gets extended. This allows you to define module\n   * specific translation which only get added, once a specific module is loaded in\n   * your app.\n   *\n   * Invoking this method with no arguments returns the translation table which was\n   * registered with no language key. Invoking it with a language key returns the\n   * related translation table.\n   *\n   * @param {string} key A language key.\n   * @param {object} translationTable A plain old JavaScript object that represents a translation table.\n   *\n   */\n  var translations = function (langKey, translationTable) {\n\n    if (!langKey && !translationTable) {\n      return $translationTable;\n    }\n\n    if (langKey && !translationTable) {\n      if (angular.isString(langKey)) {\n        return $translationTable[langKey];\n      }\n    } else {\n      if (!angular.isObject($translationTable[langKey])) {\n        $translationTable[langKey] = {};\n      }\n      angular.extend($translationTable[langKey], flatObject(translationTable));\n    }\n    return this;\n  };\n\n  this.translations = translations;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#cloakClassName\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the class name for `translate-cloak` directive.\n   * Default class name is `translate-cloak`.\n   *\n   * @param {string} name translate-cloak class name\n   */\n  this.cloakClassName = function (name) {\n    if (!name) {\n      return $cloakClassName;\n    }\n    $cloakClassName = name;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#nestedObjectDelimeter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the delimiter for namespaced translations.\n   * Default delimiter is `.`.\n   *\n   * @param {string} delimiter namespace separator\n   */\n  this.nestedObjectDelimeter = function (delimiter) {\n    if (!delimiter) {\n      return $nestedObjectDelimeter;\n    }\n    $nestedObjectDelimeter = delimiter;\n    return this;\n  };\n\n  /**\n   * @name flatObject\n   * @private\n   *\n   * @description\n   * Flats an object. This function is used to flatten given translation data with\n   * namespaces, so they are later accessible via dot notation.\n   */\n  var flatObject = function (data, path, result, prevKey) {\n    var key, keyWithPath, keyWithShortPath, val;\n\n    if (!path) {\n      path = [];\n    }\n    if (!result) {\n      result = {};\n    }\n    for (key in data) {\n      if (!Object.prototype.hasOwnProperty.call(data, key)) {\n        continue;\n      }\n      val = data[key];\n      if (angular.isObject(val)) {\n        flatObject(val, path.concat(key), result, key);\n      } else {\n        keyWithPath = path.length ? ('' + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key) : key;\n        if(path.length && key === prevKey){\n          // Create shortcut path (foo.bar == foo.bar.bar)\n          keyWithShortPath = '' + path.join($nestedObjectDelimeter);\n          // Link it to original path\n          result[keyWithShortPath] = '@:' + keyWithPath;\n        }\n        result[keyWithPath] = val;\n      }\n    }\n    return result;\n  };\n  flatObject.displayName = 'flatObject';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#addInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Adds interpolation services to angular-translate, so it can manage them.\n   *\n   * @param {object} factory Interpolation service factory\n   */\n  this.addInterpolation = function (factory) {\n    $interpolatorFactories.push(factory);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMessageFormatInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use interpolation functionality of messageformat.js.\n   * This is useful when having high level pluralization and gender selection.\n   */\n  this.useMessageFormatInterpolation = function () {\n    return this.useInterpolation('$translateMessageFormatInterpolation');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which interpolation style to use as default, application-wide.\n   * Simply pass a factory/service name. The interpolation service has to implement\n   * the correct interface.\n   *\n   * @param {string} factory Interpolation service name.\n   */\n  this.useInterpolation = function (factory) {\n    $interpolationFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useSanitizeStrategy\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Simply sets a sanitation strategy type.\n   *\n   * @param {string} value Strategy type.\n   */\n  this.useSanitizeValueStrategy = function (value) {\n    $translateSanitizationProvider.useStrategy(value);\n    return this;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#preferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use for translation\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **prefer**.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.preferredLanguage = function(langKey) {\n    if (langKey) {\n      setupPreferredLanguage(langKey);\n      return this;\n    }\n    return $preferredLanguage;\n  };\n  var setupPreferredLanguage = function (langKey) {\n    if (langKey) {\n      $preferredLanguage = langKey;\n    }\n    return $preferredLanguage;\n  };\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicator\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found. E.g. when\n   * setting the indicator as 'X' and one tries to translate a translation id\n   * called `NOT_FOUND`, this will result in `X NOT_FOUND X`.\n   *\n   * Internally this methods sets a left indicator and a right indicator using\n   * `$translateProvider.translationNotFoundIndicatorLeft()` and\n   * `$translateProvider.translationNotFoundIndicatorRight()`.\n   *\n   * **Note**: These methods automatically add a whitespace between the indicators\n   * and the translation id.\n   *\n   * @param {string} indicator An indicator, could be any string.\n   */\n  this.translationNotFoundIndicator = function (indicator) {\n    this.translationNotFoundIndicatorLeft(indicator);\n    this.translationNotFoundIndicatorRight(indicator);\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found left to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorLeft = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorLeft;\n    }\n    $notFoundIndicatorLeft = indicator;\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found right to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorRight = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorRight;\n    }\n    $notFoundIndicatorRight = indicator;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#fallbackLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use when missing translations\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **fallback**.\n   *\n   * @param {string||array} langKey A language key.\n   *\n   */\n  this.fallbackLanguage = function (langKey) {\n    fallbackStack(langKey);\n    return this;\n  };\n\n  var fallbackStack = function (langKey) {\n    if (langKey) {\n      if (angular.isString(langKey)) {\n        $fallbackWasString = true;\n        $fallbackLanguage = [ langKey ];\n      } else if (angular.isArray(langKey)) {\n        $fallbackWasString = false;\n        $fallbackLanguage = langKey;\n      }\n      if (angular.isString($preferredLanguage)  && indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n        $fallbackLanguage.push($preferredLanguage);\n      }\n\n      return this;\n    } else {\n      if ($fallbackWasString) {\n        return $fallbackLanguage[0];\n      } else {\n        return $fallbackLanguage;\n      }\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#use\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Set which translation table to use for translation by given language key. When\n   * trying to 'use' a language which isn't provided, it'll throw an error.\n   *\n   * You actually don't have to use this method since `$translateProvider#preferredLanguage`\n   * does the job too.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.use = function (langKey) {\n    if (langKey) {\n      if (!$translationTable[langKey] && (!$loaderFactory)) {\n        // only throw an error, when not loading translation data asynchronously\n        throw new Error('$translateProvider couldn\\'t find translationTable for langKey: \\'' + langKey + '\\'');\n      }\n      $uses = langKey;\n      return this;\n    }\n    return $uses;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storageKey\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which key must represent the choosed language by a user in the storage.\n   *\n   * @param {string} key A key for the storage.\n   */\n  var storageKey = function(key) {\n    if (!key) {\n      if ($storagePrefix) {\n        return $storagePrefix + $storageKey;\n      }\n      return $storageKey;\n    }\n    $storageKey = key;\n    return this;\n  };\n\n  this.storageKey = storageKey;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useUrlLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateUrlLoader` extension service as loader.\n   *\n   * @param {string} url Url\n   * @param {Object=} options Optional configuration object\n   */\n  this.useUrlLoader = function (url, options) {\n    return this.useLoader('$translateUrlLoader', angular.extend({ url: url }, options));\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStaticFilesLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateStaticFilesLoader` extension service as loader.\n   *\n   * @param {Object=} options Optional configuration object\n   */\n  this.useStaticFilesLoader = function (options) {\n    return this.useLoader('$translateStaticFilesLoader', options);\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use any other service as loader.\n   *\n   * @param {string} loaderFactory Factory name to use\n   * @param {Object=} options Optional configuration object\n   */\n  this.useLoader = function (loaderFactory, options) {\n    $loaderFactory = loaderFactory;\n    $loaderOptions = options || {};\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLocalStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateLocalStorage` service as storage layer.\n   *\n   */\n  this.useLocalStorage = function () {\n    return this.useStorage('$translateLocalStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useCookieStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateCookieStorage` service as storage layer.\n   */\n  this.useCookieStorage = function () {\n    return this.useStorage('$translateCookieStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use custom service as storage layer.\n   */\n  this.useStorage = function (storageFactory) {\n    $storageFactory = storageFactory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storagePrefix\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets prefix for storage key.\n   *\n   * @param {string} prefix Storage key prefix\n   */\n  this.storagePrefix = function (prefix) {\n    if (!prefix) {\n      return prefix;\n    }\n    $storagePrefix = prefix;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandlerLog\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use built-in log handler when trying to translate\n   * a translation Id which doesn't exist.\n   *\n   * This is actually a shortcut method for `useMissingTranslationHandler()`.\n   *\n   */\n  this.useMissingTranslationHandlerLog = function () {\n    return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandler\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Expects a factory name which later gets instantiated with `$injector`.\n   * This method can be used to tell angular-translate to use a custom\n   * missingTranslationHandler. Just build a factory which returns a function\n   * and expects a translation id as argument.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.useMissingTranslationHandler('customHandler');\n   *  });\n   *\n   *  app.factory('customHandler', function (dep1, dep2) {\n   *    return function (translationId) {\n   *      // something with translationId and dep1 and dep2\n   *    };\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.useMissingTranslationHandler = function (factory) {\n    $missingTranslationHandlerFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#usePostCompiling\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If post compiling is enabled, all translated values will be processed\n   * again with AngularJS' $compile.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.usePostCompiling(true);\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.usePostCompiling = function (value) {\n    $postCompilingEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#forceAsyncReload\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If force async reload is enabled, async loader will always be called\n   * even if $translationTable already contains the language key, adding\n   * possible new entries to the $translationTable.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.forceAsyncReload(true);\n   *  });\n   * </pre>\n   *\n   * @param {boolean} value - valid values are true or false\n   */\n  this.forceAsyncReload = function (value) {\n    $forceAsyncReloadEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#uniformLanguageTag\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which language tag should be used as a result when determining\n   * the current browser language.\n   *\n   * This setting must be set before invoking {@link pascalprecht.translate.$translateProvider#methods_determinePreferredLanguage determinePreferredLanguage()}.\n   *\n   * <pre>\n   * $translateProvider\n   *   .uniformLanguageTag('bcp47')\n   *   .determinePreferredLanguage()\n   * </pre>\n   *\n   * The resolver currently supports:\n   * * default\n   *     (traditionally: hyphens will be converted into underscores, i.e. en-US => en_US)\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_us\n   * * java\n   *     like default, but the second part will be always in uppercase\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_US\n   * * BCP 47 (RFC 4646 & 4647)\n   *     en-US => en-US\n   *     en_US => en-US\n   *     en-us => en-US\n   *\n   * See also:\n   * * http://en.wikipedia.org/wiki/IETF_language_tag\n   * * http://www.w3.org/International/core/langtags/\n   * * http://tools.ietf.org/html/bcp47\n   *\n   * @param {string|object} options - options (or standard)\n   * @param {string} options.standard - valid values are 'default', 'bcp47', 'java'\n   */\n  this.uniformLanguageTag = function (options) {\n\n    if (!options) {\n      options = {};\n    } else if (angular.isString(options)) {\n      options = {\n        standard: options\n      };\n    }\n\n    uniformLanguageTagResolver = options.standard;\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#determinePreferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to try to determine on its own which language key\n   * to set as preferred language. When `fn` is given, angular-translate uses it\n   * to determine a language key, otherwise it uses the built-in `getLocale()`\n   * method.\n   *\n   * The `getLocale()` returns a language key in the format `[lang]_[country]` or\n   * `[lang]` depending on what the browser provides.\n   *\n   * Use this method at your own risk, since not all browsers return a valid\n   * locale (see {@link pascalprecht.translate.$translateProvider#methods_uniformLanguageTag uniformLanguageTag()}).\n   *\n   * @param {Function=} fn Function to determine a browser's locale\n   */\n  this.determinePreferredLanguage = function (fn) {\n\n    var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();\n\n    if (!$availableLanguageKeys.length) {\n      $preferredLanguage = locale;\n    } else {\n      $preferredLanguage = negotiateLocale(locale) || locale;\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#registerAvailableLanguageKeys\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a set of language keys the app will work with. Use this method in\n   * combination with\n   * {@link pascalprecht.translate.$translateProvider#determinePreferredLanguage determinePreferredLanguage}.\n   * When available languages keys are registered, angular-translate\n   * tries to find the best fitting language key depending on the browsers locale,\n   * considering your language key convention.\n   *\n   * @param {object} languageKeys Array of language keys the your app will use\n   * @param {object=} aliases Alias map.\n   */\n  this.registerAvailableLanguageKeys = function (languageKeys, aliases) {\n    if (languageKeys) {\n      $availableLanguageKeys = languageKeys;\n      if (aliases) {\n        $languageKeyAliases = aliases;\n      }\n      return this;\n    }\n    return $availableLanguageKeys;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoaderCache\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a cache for internal $http based loaders.\n   * {@link pascalprecht.translate.$translationCache $translationCache}.\n   * When false the cache will be disabled (default). When true or undefined\n   * the cache will be a default (see $cacheFactory). When an object it will\n   * be treat as a cache object itself: the usage is $http({cache: cache})\n   *\n   * @param {object} cache boolean, string or cache-object\n   */\n  this.useLoaderCache = function (cache) {\n    if (cache === false) {\n      // disable cache\n      loaderCache = undefined;\n    } else if (cache === true) {\n      // enable cache using AJS defaults\n      loaderCache = true;\n    } else if (typeof(cache) === 'undefined') {\n      // enable cache using default\n      loaderCache = '$translationCache';\n    } else if (cache) {\n      // enable cache using given one (see $cacheFactory)\n      loaderCache = cache;\n    }\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#directivePriority\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets the default priority of the translate directive. The standard value is `0`.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {number} priority for the translate-directive\n   */\n  this.directivePriority = function (priority) {\n    if (priority === undefined) {\n      // getter\n      return directivePriority;\n    } else {\n      // setter with chaining\n      directivePriority = priority;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#statefulFilter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Since AngularJS 1.3, filters which are not stateless (depending at the scope)\n   * have to explicit define this behavior.\n   * Sets whether the translate filter should be stateful or stateless. The standard value is `true`\n   * meaning being stateful.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {boolean} state - defines the state of the filter\n   */\n  this.statefulFilter = function (state) {\n    if (state === undefined) {\n      // getter\n      return statefulFilter;\n    } else {\n      // setter with chaining\n      statefulFilter = state;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translate\n   * @requires $interpolate\n   * @requires $log\n   * @requires $rootScope\n   * @requires $q\n   *\n   * @description\n   * The `$translate` service is the actual core of angular-translate. It expects a translation id\n   * and optional interpolate parameters to translate contents.\n   *\n   * <pre>\n   *  $translate('HEADLINE_TEXT').then(function (translation) {\n   *    $scope.translatedText = translation;\n   *  });\n   * </pre>\n   *\n   * @param {string|array} translationId A token which represents a translation id\n   *                                     This can be optionally an array of translation ids which\n   *                                     results that the function returns an object where each key\n   *                                     is the translation id and the value the translation.\n   * @param {object=} interpolateParams An object hash for dynamic values\n   * @param {string} interpolationId The id of the interpolation to use\n   * @param {string} forceLanguage A language to be used instead of the current language\n   * @returns {object} promise\n   */\n  this.$get = [\n    '$log',\n    '$injector',\n    '$rootScope',\n    '$q',\n    function ($log, $injector, $rootScope, $q) {\n\n      var Storage,\n          defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),\n          pendingLoader = false,\n          interpolatorHashMap = {},\n          langPromises = {},\n          fallbackIndex,\n          startFallbackIteration;\n\n      var $translate = function (translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage) {\n\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          // Inspired by Q.allSettled by Kris Kowal\n          // https://github.com/kriskowal/q/blob/b0fa72980717dc202ffc3cbf03b936e10ebbb9d7/q.js#L1553-1563\n          // This transforms all promises regardless resolved or rejected\n          var translateAll = function (translationIds) {\n            var results = {}; // storing the actual results\n            var promises = []; // promises to wait for\n            // Wraps the promise a) being always resolved and b) storing the link id->value\n            var translate = function (translationId) {\n              var deferred = $q.defer();\n              var regardless = function (value) {\n                results[translationId] = value;\n                deferred.resolve([translationId, value]);\n              };\n              // we don't care whether the promise was resolved or rejected; just store the values\n              $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage).then(regardless, regardless);\n              return deferred.promise;\n            };\n            for (var i = 0, c = translationIds.length; i < c; i++) {\n              promises.push(translate(translationIds[i]));\n            }\n            // wait for all (including storing to results)\n            return $q.all(promises).then(function () {\n              // return the results\n              return results;\n            });\n          };\n          return translateAll(translationId);\n        }\n\n        var deferred = $q.defer();\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var promiseToWaitFor = (function () {\n          var promise = $preferredLanguage ?\n            langPromises[$preferredLanguage] :\n            langPromises[uses];\n\n          fallbackIndex = 0;\n\n          if ($storageFactory && !promise) {\n            // looks like there's no pending promise for $preferredLanguage or\n            // $uses. Maybe there's one pending for a language that comes from\n            // storage.\n            var langKey = Storage.get($storageKey);\n            promise = langPromises[langKey];\n\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n                var index = indexOf($fallbackLanguage, langKey);\n                // maybe the language from storage is also defined as fallback language\n                // we increase the fallback language index to not search in that language\n                // as fallback, since it's probably the first used language\n                // in that case the index starts after the first element\n                fallbackIndex = (index === 0) ? 1 : 0;\n\n                // but we can make sure to ALWAYS fallback to preferred language at least\n                if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n                  $fallbackLanguage.push($preferredLanguage);\n                }\n            }\n          }\n          return promise;\n        }());\n\n        if (!promiseToWaitFor) {\n          // no promise to wait for? okay. Then there's no loader registered\n          // nor is a one pending for language that comes from storage.\n          // We can just translate.\n          determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n        } else {\n          var promiseResolved = function () {\n            // $uses may have changed while waiting\n            if (!forceLanguage) {\n              uses = $uses;\n            }\n            determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n          };\n          promiseResolved.displayName = 'promiseResolved';\n\n          promiseToWaitFor['finally'](promiseResolved);\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name applyNotFoundIndicators\n       * @private\n       *\n       * @description\n       * Applies not fount indicators to given translation id, if needed.\n       * This function gets only executed, if a translation id doesn't exist,\n       * which is why a translation id is expected as argument.\n       *\n       * @param {string} translationId Translation id.\n       * @returns {string} Same as given translation id but applied with not found\n       * indicators.\n       */\n      var applyNotFoundIndicators = function (translationId) {\n        // applying notFoundIndicators\n        if ($notFoundIndicatorLeft) {\n          translationId = [$notFoundIndicatorLeft, translationId].join(' ');\n        }\n        if ($notFoundIndicatorRight) {\n          translationId = [translationId, $notFoundIndicatorRight].join(' ');\n        }\n        return translationId;\n      };\n\n      /**\n       * @name useLanguage\n       * @private\n       *\n       * @description\n       * Makes actual use of a language by setting a given language key as used\n       * language and informs registered interpolators to also use the given\n       * key as locale.\n       *\n       * @param {key} Locale key.\n       */\n      var useLanguage = function (key) {\n        $uses = key;\n\n        // make sure to store new language key before triggering success event\n        if ($storageFactory) {\n          Storage.put($translate.storageKey(), $uses);\n        }\n\n        $rootScope.$emit('$translateChangeSuccess', {language: key});\n\n        // inform default interpolator\n        defaultInterpolator.setLocale($uses);\n\n        var eachInterpolator = function (interpolator, id) {\n          interpolatorHashMap[id].setLocale($uses);\n        };\n        eachInterpolator.displayName = 'eachInterpolatorLocaleSetter';\n\n        // inform all others too!\n        angular.forEach(interpolatorHashMap, eachInterpolator);\n        $rootScope.$emit('$translateChangeEnd', {language: key});\n      };\n\n      /**\n       * @name loadAsync\n       * @private\n       *\n       * @description\n       * Kicks of registered async loader using `$injector` and applies existing\n       * loader options. When resolved, it updates translation tables accordingly\n       * or rejects with given language key.\n       *\n       * @param {string} key Language key.\n       * @return {Promise} A promise.\n       */\n      var loadAsync = function (key) {\n        if (!key) {\n          throw 'No language key specified for loading.';\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateLoadingStart', {language: key});\n        pendingLoader = true;\n\n        var cache = loaderCache;\n        if (typeof(cache) === 'string') {\n          // getting on-demand instance of loader\n          cache = $injector.get(cache);\n        }\n\n        var loaderOptions = angular.extend({}, $loaderOptions, {\n          key: key,\n          $http: angular.extend({}, {\n            cache: cache\n          }, $loaderOptions.$http)\n        });\n\n        var onLoaderSuccess = function (data) {\n          var translationTable = {};\n          $rootScope.$emit('$translateLoadingSuccess', {language: key});\n\n          if (angular.isArray(data)) {\n            angular.forEach(data, function (table) {\n              angular.extend(translationTable, flatObject(table));\n            });\n          } else {\n            angular.extend(translationTable, flatObject(data));\n          }\n          pendingLoader = false;\n          deferred.resolve({\n            key: key,\n            table: translationTable\n          });\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderSuccess.displayName = 'onLoaderSuccess';\n\n        var onLoaderError = function (key) {\n          $rootScope.$emit('$translateLoadingError', {language: key});\n          deferred.reject(key);\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderError.displayName = 'onLoaderError';\n\n        $injector.get($loaderFactory)(loaderOptions)\n          .then(onLoaderSuccess, onLoaderError);\n\n        return deferred.promise;\n      };\n\n      if ($storageFactory) {\n        Storage = $injector.get($storageFactory);\n\n        if (!Storage.get || !Storage.put) {\n          throw new Error('Couldn\\'t use storage \\'' + $storageFactory + '\\', missing get() or put() method!');\n        }\n      }\n\n      // if we have additional interpolations that were added via\n      // $translateProvider.addInterpolation(), we have to map'em\n      if ($interpolatorFactories.length) {\n        var eachInterpolationFactory = function (interpolatorFactory) {\n          var interpolator = $injector.get(interpolatorFactory);\n          // setting initial locale for each interpolation service\n          interpolator.setLocale($preferredLanguage || $uses);\n          // make'em recognizable through id\n          interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;\n        };\n        eachInterpolationFactory.displayName = 'interpolationFactoryAdder';\n\n        angular.forEach($interpolatorFactories, eachInterpolationFactory);\n      }\n\n      /**\n       * @name getTranslationTable\n       * @private\n       *\n       * @description\n       * Returns a promise that resolves to the translation table\n       * or is rejected if an error occurred.\n       *\n       * @param langKey\n       * @returns {Q.promise}\n       */\n      var getTranslationTable = function (langKey) {\n        var deferred = $q.defer();\n        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {\n          deferred.resolve($translationTable[langKey]);\n        } else if (langPromises[langKey]) {\n          var onResolve = function (data) {\n            translations(data.key, data.table);\n            deferred.resolve(data.table);\n          };\n          onResolve.displayName = 'translationTableResolver';\n          langPromises[langKey].then(onResolve, deferred.reject);\n        } else {\n          deferred.reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslation\n       * @private\n       *\n       * @description\n       * Returns a promise that will resolve to the translation\n       * or be rejected if no translation was found for the language.\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise}\n       */\n      var getFallbackTranslation = function (langKey, translationId, interpolateParams, Interpolator) {\n        var deferred = $q.defer();\n\n        var onResolve = function (translationTable) {\n          if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n            Interpolator.setLocale(langKey);\n            var translation = translationTable[translationId];\n            if (translation.substr(0, 2) === '@:') {\n              getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator)\n                .then(deferred.resolve, deferred.reject);\n            } else {\n              deferred.resolve(Interpolator.interpolate(translationTable[translationId], interpolateParams));\n            }\n            Interpolator.setLocale($uses);\n          } else {\n            deferred.reject();\n          }\n        };\n        onResolve.displayName = 'fallbackTranslationResolver';\n\n        getTranslationTable(langKey).then(onResolve, deferred.reject);\n\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslationInstant\n       * @private\n       *\n       * @description\n       * Returns a translation\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var getFallbackTranslationInstant = function (langKey, translationId, interpolateParams, Interpolator) {\n        var result, translationTable = $translationTable[langKey];\n\n        if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n          Interpolator.setLocale(langKey);\n          result = Interpolator.interpolate(translationTable[translationId], interpolateParams);\n          if (result.substr(0, 2) === '@:') {\n            return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);\n          }\n          Interpolator.setLocale($uses);\n        }\n\n        return result;\n      };\n\n\n      /**\n       * @name translateByHandler\n       * @private\n       *\n       * Translate by missing translation handler.\n       *\n       * @param translationId\n       * @returns translation created by $missingTranslationHandler or translationId is $missingTranslationHandler is\n       * absent\n       */\n      var translateByHandler = function (translationId, interpolateParams) {\n        // If we have a handler factory - we might also call it here to determine if it provides\n        // a default text for a translationid that can't be found anywhere in our tables\n        if ($missingTranslationHandlerFactory) {\n          var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams);\n          if (resultString !== undefined) {\n            return resultString;\n          } else {\n            return translationId;\n          }\n        } else {\n          return translationId;\n        }\n      };\n\n      /**\n       * @name resolveForFallbackLanguage\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise that will resolve to the translation.\n       */\n      var resolveForFallbackLanguage = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        var deferred = $q.defer();\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(\n            deferred.resolve,\n            function () {\n              // Look in the next fallback language for a translation.\n              // It delays the resolving by passing another promise to resolve.\n              resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve);\n            }\n          );\n        } else {\n          // No translation found in any fallback language\n          // if a default translation text is set in the directive, then return this as a result\n          if (defaultTranslationText) {\n            deferred.resolve(defaultTranslationText);\n          } else {\n            // if no default translation is set and an error handler is defined, send it to the handler\n            // and then return the result\n            deferred.resolve(translateByHandler(translationId, interpolateParams));\n          }\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name resolveForFallbackLanguageInstant\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var resolveForFallbackLanguageInstant = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {\n        var result;\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);\n          if (!result) {\n            result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);\n          }\n        }\n        return result;\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise, that resolves to the translation.\n       */\n      var fallbackTranslation = function (translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguage((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText);\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {String} translation\n       */\n      var fallbackTranslationInstant = function (translationId, interpolateParams, Interpolator) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguageInstant((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator);\n      };\n\n      var determineTranslation = function (translationId, interpolateParams, interpolationId, defaultTranslationText, uses) {\n\n        var deferred = $q.defer();\n\n        var table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n\n            $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses)\n              .then(deferred.resolve, deferred.reject);\n          } else {\n            deferred.resolve(Interpolator.interpolate(translation, interpolateParams));\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText)\n                .then(function (translation) {\n                  deferred.resolve(translation);\n                }, function (_translationId) {\n                  deferred.reject(applyNotFoundIndicators(_translationId));\n                });\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n              } else {\n                deferred.resolve(missingTranslationHandlerTranslation);\n              }\n          } else {\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n            } else {\n              deferred.reject(applyNotFoundIndicators(translationId));\n            }\n          }\n        }\n        return deferred.promise;\n      };\n\n      var determineTranslationInstant = function (translationId, interpolateParams, interpolationId, uses) {\n\n        var result, table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = defaultInterpolator;\n\n        // if the interpolation id exists use custom interpolator\n        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {\n          Interpolator = interpolatorHashMap[interpolationId];\n        }\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n            result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses);\n          } else {\n            result = Interpolator.interpolate(translation, interpolateParams);\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackIndex = 0;\n            result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            result = missingTranslationHandlerTranslation;\n          } else {\n            result = applyNotFoundIndicators(translationId);\n          }\n        }\n\n        return result;\n      };\n\n      var clearNextLangAndPromise = function(key) {\n        if ($nextLang === key) {\n          $nextLang = undefined;\n        }\n        langPromises[key] = undefined;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#preferredLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the preferred language.\n       *\n       * @param {string} langKey language String or Array to be used as preferredLanguage (changing at runtime)\n       *\n       * @return {string} preferred language key\n       */\n      $translate.preferredLanguage = function (langKey) {\n        if(langKey) {\n          setupPreferredLanguage(langKey);\n        }\n        return $preferredLanguage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#cloakClassName\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured class name for `translate-cloak` directive.\n       *\n       * @return {string} cloakClassName\n       */\n      $translate.cloakClassName = function () {\n        return $cloakClassName;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#nestedObjectDelimeter\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured delimiter for nested namespaces.\n       *\n       * @return {string} nestedObjectDelimeter\n       */\n      $translate.nestedObjectDelimeter = function () {\n        return $nestedObjectDelimeter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#fallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the fallback languages or sets a new fallback stack.\n       *\n       * @param {string=} langKey language String or Array of fallback languages to be used (to change stack at runtime)\n       *\n       * @return {string||array} fallback language key\n       */\n      $translate.fallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          fallbackStack(langKey);\n\n          // as we might have an async loader initiated and a new translation language might have been defined\n          // we need to add the promise to the stack also. So - iterate.\n          if ($loaderFactory) {\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n              for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n                if (!langPromises[$fallbackLanguage[i]]) {\n                  langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);\n                }\n              }\n            }\n          }\n          $translate.use($translate.use());\n        }\n        if ($fallbackWasString) {\n          return $fallbackLanguage[0];\n        } else {\n          return $fallbackLanguage;\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#useFallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Sets the first key of the fallback language stack to be used for translation.\n       * Therefore all languages in the fallback array BEFORE this key will be skipped!\n       *\n       * @param {string=} langKey Contains the langKey the iteration shall start with. Set to false if you want to\n       * get back to the whole stack\n       */\n      $translate.useFallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          if (!langKey) {\n            startFallbackIteration = 0;\n          } else {\n            var langKeyPosition = indexOf($fallbackLanguage, langKey);\n            if (langKeyPosition > -1) {\n              startFallbackIteration = langKeyPosition;\n            }\n          }\n\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#proposedLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key of language that is currently loaded asynchronously.\n       *\n       * @return {string} language key\n       */\n      $translate.proposedLanguage = function () {\n        return $nextLang;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns registered storage.\n       *\n       * @return {object} Storage\n       */\n      $translate.storage = function () {\n        return Storage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#negotiateLocale\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a language key based on available languages and language aliases. If a\n       * language key cannot be resolved, returns undefined.\n       *\n       * If no or a falsy key is given, returns undefined.\n       *\n       * @param {string} [key] Language key\n       * @return {string|undefined} Language key or undefined if no language key is found.\n       */\n      $translate.negotiateLocale = negotiateLocale;\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#use\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Tells angular-translate which language to use by given language key. This method is\n       * used to change language at runtime. It also takes care of storing the language\n       * key in a configured store to let your app remember the choosed language.\n       *\n       * When trying to 'use' a language which isn't available it tries to load it\n       * asynchronously with registered loaders.\n       *\n       * Returns promise object with loaded language file data or string of the currently used language.\n       *\n       * If no or a falsy key is given it returns the currently used language key.\n       * The returned string will be ```undefined``` if setting up $translate hasn't finished.\n       * @example\n       * $translate.use(\"en_US\").then(function(data){\n       *   $scope.text = $translate(\"HELLO\");\n       * });\n       *\n       * @param {string} [key] Language key\n       * @return {object|string} Promise with loaded language data or the language key if a falsy param was given.\n       */\n      $translate.use = function (key) {\n        if (!key) {\n          return $uses;\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateChangeStart', {language: key});\n\n        // Try to get the aliased language key\n        var aliasedKey = negotiateLocale(key);\n        if (aliasedKey) {\n          key = aliasedKey;\n        }\n\n        // if there isn't a translation table for the language we've requested,\n        // we load it asynchronously\n        $nextLang = key;\n        if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {\n          langPromises[key] = loadAsync(key).then(function (translation) {\n            translations(translation.key, translation.table);\n            deferred.resolve(translation.key);\n            if ($nextLang === key) {\n              useLanguage(translation.key);\n            }\n            return translation;\n          }, function (key) {\n            $rootScope.$emit('$translateChangeError', {language: key});\n            deferred.reject(key);\n            $rootScope.$emit('$translateChangeEnd', {language: key});\n            return $q.reject(key);\n          });\n          langPromises[key]['finally'](function () {\n            clearNextLangAndPromise(key);\n          });\n        } else if (langPromises[key]) {\n          // we are already loading this asynchronously\n          // resolve our new deferred when the old langPromise is resolved\n          langPromises[key].then(function (translation) {\n            if ($nextLang === translation.key) {\n              useLanguage(translation.key);\n            }\n            deferred.resolve(translation.key);\n            return translation;\n          }, function (key) {\n            // find first available fallback language if that request has failed\n            if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0) {\n              return $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);\n            } else {\n              return deferred.reject(key);\n            }\n          });\n        } else {\n          deferred.resolve(key);\n          useLanguage(key);\n        }\n\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storageKey\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the key for the storage.\n       *\n       * @return {string} storage key\n       */\n      $translate.storageKey = function () {\n        return storageKey();\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isPostCompilingEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether post compiling is enabled or not\n       *\n       * @return {bool} storage key\n       */\n      $translate.isPostCompilingEnabled = function () {\n        return $postCompilingEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isForceAsyncReloadEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether force async reload is enabled or not\n       *\n       * @return {boolean} forceAsyncReload value\n       */\n      $translate.isForceAsyncReloadEnabled = function () {\n        return $forceAsyncReloadEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#refresh\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Refreshes a translation table pointed by the given langKey. If langKey is not specified,\n       * the module will drop all existent translation tables and load new version of those which\n       * are currently in use.\n       *\n       * Refresh means that the module will drop target translation table and try to load it again.\n       *\n       * In case there are no loaders registered the refresh() method will throw an Error.\n       *\n       * If the module is able to refresh translation tables refresh() method will broadcast\n       * $translateRefreshStart and $translateRefreshEnd events.\n       *\n       * @example\n       * // this will drop all currently existent translation tables and reload those which are\n       * // currently in use\n       * $translate.refresh();\n       * // this will refresh a translation table for the en_US language\n       * $translate.refresh('en_US');\n       *\n       * @param {string} langKey A language key of the table, which has to be refreshed\n       *\n       * @return {promise} Promise, which will be resolved in case a translation tables refreshing\n       * process is finished successfully, and reject if not.\n       */\n      $translate.refresh = function (langKey) {\n        if (!$loaderFactory) {\n          throw new Error('Couldn\\'t refresh translation table, no loader registered!');\n        }\n\n        var deferred = $q.defer();\n\n        function resolve() {\n          deferred.resolve();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        function reject() {\n          deferred.reject();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        $rootScope.$emit('$translateRefreshStart', {language: langKey});\n\n        if (!langKey) {\n          // if there's no language key specified we refresh ALL THE THINGS!\n          var tables = [], loadingKeys = {};\n\n          // reload registered fallback languages\n          if ($fallbackLanguage && $fallbackLanguage.length) {\n            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n              tables.push(loadAsync($fallbackLanguage[i]));\n              loadingKeys[$fallbackLanguage[i]] = true;\n            }\n          }\n\n          // reload currently used language\n          if ($uses && !loadingKeys[$uses]) {\n            tables.push(loadAsync($uses));\n          }\n\n          var allTranslationsLoaded = function (tableData) {\n            $translationTable = {};\n            angular.forEach(tableData, function (data) {\n              translations(data.key, data.table);\n            });\n            if ($uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          allTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          $q.all(tables).then(allTranslationsLoaded, reject);\n\n        } else if ($translationTable[langKey]) {\n\n          var oneTranslationsLoaded = function (data) {\n            translations(data.key, data.table);\n            if (langKey === $uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          oneTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          loadAsync(langKey).then(oneTranslationsLoaded, reject);\n\n        } else {\n          reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#instant\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a translation instantly from the internal state of loaded translation. All rules\n       * regarding the current language, the preferred language of even fallback languages will be\n       * used except any promise handling. If a language was not found, an asynchronous loading\n       * will be invoked in the background.\n       *\n       * @param {string|array} translationId A token which represents a translation id\n       *                                     This can be optionally an array of translation ids which\n       *                                     results that the function's promise returns an object where\n       *                                     each key is the translation id and the value the translation.\n       * @param {object} interpolateParams Params\n       * @param {string} interpolationId The id of the interpolation to use\n       * @param {string} forceLanguage A language to be used instead of the current language\n       *\n       * @return {string|object} translation\n       */\n      $translate.instant = function (translationId, interpolateParams, interpolationId, forceLanguage) {\n\n        // we don't want to re-negotiate $uses\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Detect undefined and null values to shorten the execution and prevent exceptions\n        if (translationId === null || angular.isUndefined(translationId)) {\n          return translationId;\n        }\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          var results = {};\n          for (var i = 0, c = translationId.length; i < c; i++) {\n            results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage);\n          }\n          return results;\n        }\n\n        // We discarded unacceptable values. So we just need to verify if translationId is empty String\n        if (angular.isString(translationId) && translationId.length < 1) {\n          return translationId;\n        }\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var result, possibleLangKeys = [];\n        if ($preferredLanguage) {\n          possibleLangKeys.push($preferredLanguage);\n        }\n        if (uses) {\n          possibleLangKeys.push(uses);\n        }\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);\n        }\n        for (var j = 0, d = possibleLangKeys.length; j < d; j++) {\n          var possibleLangKey = possibleLangKeys[j];\n          if ($translationTable[possibleLangKey]) {\n            if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {\n              result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses);\n            }\n          }\n          if (typeof result !== 'undefined') {\n            break;\n          }\n        }\n\n        if (!result && result !== '') {\n          if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {\n            result = applyNotFoundIndicators(translationId);\n          } else {\n            // Return translation of default interpolator if not found anything.\n            result = defaultInterpolator.interpolate(translationId, interpolateParams);\n            if ($missingTranslationHandlerFactory && !pendingLoader) {\n              result = translateByHandler(translationId, interpolateParams);\n            }\n          }\n        }\n\n        return result;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#versionInfo\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the current version information for the angular-translate library\n       *\n       * @return {string} angular-translate version\n       */\n      $translate.versionInfo = function () {\n        return version;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#loaderCache\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the defined loaderCache.\n       *\n       * @return {boolean|string|object} current value of loaderCache\n       */\n      $translate.loaderCache = function () {\n        return loaderCache;\n      };\n\n      // internal purpose only\n      $translate.directivePriority = function () {\n        return directivePriority;\n      };\n\n      // internal purpose only\n      $translate.statefulFilter = function () {\n        return statefulFilter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_onReady onReady()}.\n       *\n       * @return {boolean} current value of ready\n       */\n      $translate.isReady = function () {\n        return $isReady;\n      };\n\n      var $onReadyDeferred = $q.defer();\n      $onReadyDeferred.promise.then(function () {\n        $isReady = true;\n      });\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#onReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_isReady isReady()}.\n       *\n       * @param {Function=} fn Function to invoke when service is ready\n       * @return {object} Promise resolved when service is ready\n       */\n      $translate.onReady = function (fn) {\n        var deferred = $q.defer();\n        if (angular.isFunction(fn)) {\n          deferred.promise.then(fn);\n        }\n        if ($isReady) {\n          deferred.resolve();\n        } else {\n          $onReadyDeferred.promise.then(deferred.resolve);\n        }\n        return deferred.promise;\n      };\n\n      // Whenever $translateReady is being fired, this will ensure the state of $isReady\n      var globalOnReadyListener = $rootScope.$on('$translateReady', function () {\n        $onReadyDeferred.resolve();\n        globalOnReadyListener(); // one time only\n        globalOnReadyListener = null;\n      });\n      var globalOnChangeListener = $rootScope.$on('$translateChangeEnd', function () {\n        $onReadyDeferred.resolve();\n        globalOnChangeListener(); // one time only\n        globalOnChangeListener = null;\n      });\n\n      if ($loaderFactory) {\n\n        // If at least one async loader is defined and there are no\n        // (default) translations available we should try to load them.\n        if (angular.equals($translationTable, {})) {\n          if ($translate.use()) {\n            $translate.use($translate.use());\n          }\n        }\n\n        // Also, if there are any fallback language registered, we start\n        // loading them asynchronously as soon as we can.\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          var processAsyncResult = function (translation) {\n            translations(translation.key, translation.table);\n            $rootScope.$emit('$translateChangeEnd', { language: translation.key });\n            return translation;\n          };\n          for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n            var fallbackLanguageId = $fallbackLanguage[i];\n            if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {\n              langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);\n            }\n          }\n        }\n      } else {\n        $rootScope.$emit('$translateReady', { language: $translate.use() });\n      }\n\n      return $translate;\n    }\n  ];\n}\n$translate.$inject = ['$STORAGE_KEY', '$windowProvider', '$translateSanitizationProvider', 'pascalprechtTranslateOverrider'];\n\n$translate.displayName = 'displayName';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateDefaultInterpolation\n * @requires $interpolate\n *\n * @description\n * Uses angular's `$interpolate` services to interpolate strings against some values.\n *\n * Be aware to configure a proper sanitization strategy.\n *\n * See also:\n * * {@link pascalprecht.translate.$translateSanitization}\n *\n * @return {object} $translateDefaultInterpolation Interpolator service\n */\nangular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', $translateDefaultInterpolation);\n\nfunction $translateDefaultInterpolation ($interpolate, $translateSanitization) {\n\n  'use strict';\n\n  var $translateInterpolator = {},\n      $locale,\n      $identifier = 'default';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#setLocale\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Sets current locale (this is currently not use in this interpolation).\n   *\n   * @param {string} locale Language key or locale.\n   */\n  $translateInterpolator.setLocale = function (locale) {\n    $locale = locale;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#getInterpolationIdentifier\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Returns an identifier for this interpolation service.\n   *\n   * @returns {string} $identifier\n   */\n  $translateInterpolator.getInterpolationIdentifier = function () {\n    return $identifier;\n  };\n\n  /**\n   * @deprecated will be removed in 3.0\n   * @see {@link pascalprecht.translate.$translateSanitization}\n   */\n  $translateInterpolator.useSanitizeValueStrategy = function (value) {\n    $translateSanitization.useStrategy(value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#interpolate\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Interpolates given string agains given interpolate params using angulars\n   * `$interpolate` service.\n   *\n   * @returns {string} interpolated string.\n   */\n  $translateInterpolator.interpolate = function (string, interpolationParams) {\n    interpolationParams = interpolationParams || {};\n    interpolationParams = $translateSanitization.sanitize(interpolationParams, 'params');\n\n    var interpolatedText = $interpolate(string)(interpolationParams);\n    interpolatedText = $translateSanitization.sanitize(interpolatedText, 'text');\n\n    return interpolatedText;\n  };\n\n  return $translateInterpolator;\n}\n$translateDefaultInterpolation.$inject = ['$interpolate', '$translateSanitization'];\n\n$translateDefaultInterpolation.displayName = '$translateDefaultInterpolation';\n\nangular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translate\n * @requires $compile\n * @requires $filter\n * @requires $interpolate\n * @restrict AE\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate Translation id which could be either string or interpolated string.\n * @param {string=} translate-values Values to pass into translation id. Can be passed as object literal string or interpolated object.\n * @param {string=} translate-attr-ATTR translate Translation id and put it into ATTR attribute.\n * @param {string=} translate-default will be used unless translation was successful\n * @param {boolean=} translate-compile (default true if present) defines locally activation of {@link pascalprecht.translate.$translateProvider#methods_usePostCompiling}\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre translate=\"TRANSLATION_ID\"></pre>\n        <pre translate>TRANSLATION_ID</pre>\n        <pre translate translate-attr-title=\"TRANSLATION_ID\"></pre>\n        <pre translate=\"{{translationId}}\"></pre>\n        <pre translate>{{translationId}}</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{value: 5}\"></pre>\n        <pre translate translate-values=\"{value: 5}\">WITH_VALUES</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n        <pre translate translate-values=\"{{values}}\">WITH_VALUES</pre>\n        <pre translate translate-attr-title=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        }).preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n    <file name=\"scenario.js\">\n      it('should translate', function () {\n        inject(function ($rootScope, $compile) {\n          $rootScope.translationId = 'TRANSLATION_ID';\n\n          element = $compile('<p translate=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate=\"{{translationId}}\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>TRANSLATION_ID</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>{{translationId}}</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate translate-attr-title=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.attr('title')).toBe('Hello there!');\n        });\n      });\n    </file>\n   </example>\n */\n.directive('translate', translateDirective);\nfunction translateDirective($translate, $q, $interpolate, $compile, $parse, $rootScope) {\n\n  'use strict';\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  return {\n    restrict: 'AE',\n    scope: true,\n    priority: $translate.directivePriority(),\n    compile: function (tElement, tAttr) {\n\n      var translateValuesExist = (tAttr.translateValues) ?\n        tAttr.translateValues : undefined;\n\n      var translateInterpolation = (tAttr.translateInterpolation) ?\n        tAttr.translateInterpolation : undefined;\n\n      var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);\n\n      var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',\n          watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';\n\n      return function linkFn(scope, iElement, iAttr) {\n\n        scope.interpolateParams = {};\n        scope.preText = '';\n        scope.postText = '';\n        scope.translateNamespace = getTranslateNamespace(scope);\n        var translationIds = {};\n\n        var initInterpolationParams = function (interpolateParams, iAttr, tAttr) {\n          // initial setup\n          if (iAttr.translateValues) {\n            angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));\n          }\n          // initially fetch all attributes if existing and fill the params\n          if (translateValueExist) {\n            for (var attr in tAttr) {\n              if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n                var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);\n                interpolateParams[attributeName] = tAttr[attr];\n              }\n            }\n          }\n        };\n\n        // Ensures any change of the attribute \"translate\" containing the id will\n        // be re-stored to the scope's \"translationId\".\n        // If the attribute has no content, the element's text value (white spaces trimmed off) will be used.\n        var observeElementTranslation = function (translationId) {\n\n          // Remove any old watcher\n          if (angular.isFunction(observeElementTranslation._unwatchOld)) {\n            observeElementTranslation._unwatchOld();\n            observeElementTranslation._unwatchOld = undefined;\n          }\n\n          if (angular.equals(translationId , '') || !angular.isDefined(translationId)) {\n            var iElementText = trim.apply(iElement.text());\n\n            // Resolve translation id by inner html if required\n            var interpolateMatches = iElementText.match(interpolateRegExp);\n            // Interpolate translation id if required\n            if (angular.isArray(interpolateMatches)) {\n              scope.preText = interpolateMatches[1];\n              scope.postText = interpolateMatches[3];\n              translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);\n              var watcherMatches = iElementText.match(watcherRegExp);\n              if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {\n                observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function (newValue) {\n                  translationIds.translate = newValue;\n                  updateTranslations();\n                });\n              }\n            } else {\n              // do not assigne the translation id if it is empty.\n              translationIds.translate = !iElementText ? undefined : iElementText;\n            }\n          } else {\n            translationIds.translate = translationId;\n          }\n          updateTranslations();\n        };\n\n        var observeAttributeTranslation = function (translateAttr) {\n          iAttr.$observe(translateAttr, function (translationId) {\n            translationIds[translateAttr] = translationId;\n            updateTranslations();\n          });\n        };\n\n        // initial setup with values\n        initInterpolationParams(scope.interpolateParams, iAttr, tAttr);\n\n        var firstAttributeChangedEvent = true;\n        iAttr.$observe('translate', function (translationId) {\n          if (typeof translationId === 'undefined') {\n            // case of element \"<translate>xyz</translate>\"\n            observeElementTranslation('');\n          } else {\n            // case of regular attribute\n            if (translationId !== '' || !firstAttributeChangedEvent) {\n              translationIds.translate = translationId;\n              updateTranslations();\n            }\n          }\n          firstAttributeChangedEvent = false;\n        });\n\n        for (var translateAttr in iAttr) {\n          if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr') {\n            observeAttributeTranslation(translateAttr);\n          }\n        }\n\n        iAttr.$observe('translateDefault', function (value) {\n          scope.defaultText = value;\n          updateTranslations();\n        });\n\n        if (translateValuesExist) {\n          iAttr.$observe('translateValues', function (interpolateParams) {\n            if (interpolateParams) {\n              scope.$parent.$watch(function () {\n                angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));\n              });\n            }\n          });\n        }\n\n        if (translateValueExist) {\n          var observeValueAttribute = function (attrName) {\n            iAttr.$observe(attrName, function (value) {\n              var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);\n              scope.interpolateParams[attributeName] = value;\n            });\n          };\n          for (var attr in iAttr) {\n            if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n              observeValueAttribute(attr);\n            }\n          }\n        }\n\n        // Master update function\n        var updateTranslations = function () {\n          for (var key in translationIds) {\n\n            if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {\n              updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);\n            }\n          }\n        };\n\n        // Put translation processing function outside loop\n        var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {\n          if (translationId) {\n            // if translation id starts with '.' and translateNamespace given, prepend namespace\n            if (translateNamespace && translationId.charAt(0) === '.') {\n              translationId = translateNamespace + translationId;\n            }\n\n            $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage)\n              .then(function (translation) {\n                applyTranslation(translation, scope, true, translateAttr);\n              }, function (translationId) {\n                applyTranslation(translationId, scope, false, translateAttr);\n              });\n          } else {\n            // as an empty string cannot be translated, we can solve this using successful=false\n            applyTranslation(translationId, scope, false, translateAttr);\n          }\n        };\n\n        var applyTranslation = function (value, scope, successful, translateAttr) {\n          if (translateAttr === 'translate') {\n            // default translate into innerHTML\n            if (!successful && typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n            iElement.empty().append(scope.preText + value + scope.postText);\n            var globallyEnabled = $translate.isPostCompilingEnabled();\n            var locallyDefined = typeof tAttr.translateCompile !== 'undefined';\n            var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';\n            if ((globallyEnabled && !locallyDefined) || locallyEnabled) {\n              $compile(iElement.contents())(scope);\n            }\n          } else {\n            // translate attribute\n            if (!successful && typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n            var attributeName = iAttr.$attr[translateAttr];\n            if (attributeName.substr(0, 5) === 'data-') {\n              // ensure html5 data prefix is stripped\n              attributeName = attributeName.substr(5);\n            }\n            attributeName = attributeName.substr(15);\n            iElement.attr(attributeName, value);\n          }\n        };\n\n        if (translateValuesExist || translateValueExist || iAttr.translateDefault) {\n          scope.$watch('interpolateParams', updateTranslations, true);\n        }\n        scope.$watch('translateLanguage', updateTranslations);\n\n        // Ensures the text will be refreshed after the current language was changed\n        // w/ $translate.use(...)\n        var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);\n\n        // ensure translation will be looked up at least one\n        if (iElement.text().length) {\n          if (iAttr.translate) {\n            observeElementTranslation(iAttr.translate);\n          } else {\n            observeElementTranslation('');\n          }\n        } else if (iAttr.translate) {\n          // ensure attribute will be not skipped\n          observeElementTranslation(iAttr.translate);\n        }\n        updateTranslations();\n        scope.$on('$destroy', unbind);\n      };\n    }\n  };\n}\ntranslateDirective.$inject = ['$translate', '$q', '$interpolate', '$compile', '$parse', '$rootScope'];\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateDirective.displayName = 'translateDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateCloak\n * @requires $rootScope\n * @requires $translate\n * @restrict A\n *\n * $description\n * Adds a `translate-cloak` class name to the given element where this directive\n * is applied initially and removes it, once a loader has finished loading.\n *\n * This directive can be used to prevent initial flickering when loading translation\n * data asynchronously.\n *\n * The class name is defined in\n * {@link pascalprecht.translate.$translateProvider#cloakClassName $translate.cloakClassName()}.\n *\n * @param {string=} translate-cloak If a translationId is provided, it will be used for showing\n *                                  or hiding the cloak. Basically it relies on the translation\n *                                  resolve.\n */\n.directive('translateCloak', translateCloakDirective);\n\nfunction translateCloakDirective($translate, $rootScope) {\n\n  'use strict';\n\n  return {\n    compile: function (tElement) {\n      var applyCloak = function () {\n        tElement.addClass($translate.cloakClassName());\n      },\n      removeCloak = function () {\n        tElement.removeClass($translate.cloakClassName());\n      };\n      $translate.onReady(function () {\n        removeCloak();\n      });\n      applyCloak();\n\n      return function linkFn(scope, iElement, iAttr) {\n        if (iAttr.translateCloak && iAttr.translateCloak.length) {\n          // Register a watcher for the defined translation allowing a fine tuned cloak\n          iAttr.$observe('translateCloak', function (translationId) {\n            $translate(translationId).then(removeCloak, applyCloak);\n          });\n          // Register for change events as this is being another indicicator revalidating the cloak)\n          $rootScope.$on('$translateChangeSuccess', function () {\n            $translate(iAttr.translateCloak).then(removeCloak, applyCloak);\n          });\n        }\n      };\n    }\n  };\n}\ntranslateCloakDirective.$inject = ['$translate', '$rootScope'];\n\ntranslateCloakDirective.displayName = 'translateCloakDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateNamespace\n * @restrict A\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate namespace name which could be either string or interpolated string.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div translate-namespace=\"CONTENT\">\n\n        <div>\n            <h1 translate>.HEADERS.TITLE</h1>\n            <h1 translate>.HEADERS.WELCOME</h1>\n        </div>\n\n        <div translate-namespace=\".HEADERS\">\n            <h1 translate>.TITLE</h1>\n            <h1 translate>.WELCOME</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'CONTENT': {\n            'HEADERS': {\n                TITLE: 'Title'\n            }\n          },\n          'CONTENT.HEADERS.WELCOME': 'Welcome'\n        }).preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateNamespace', translateNamespaceDirective);\n\nfunction translateNamespaceDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return {\n        pre: function (scope, iElement, iAttrs) {\n          scope.translateNamespace = getTranslateNamespace(scope);\n\n          if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === '.') {\n            scope.translateNamespace += iAttrs.translateNamespace;\n          } else {\n            scope.translateNamespace = iAttrs.translateNamespace;\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateNamespaceDirective.displayName = 'translateNamespaceDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateLanguage\n * @restrict A\n *\n * @description\n * Forces the language to the directives in the underlying scope.\n *\n * @param {string=} translate language that will be negotiated.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div>\n\n        <div>\n            <h1 translate>HELLO</h1>\n        </div>\n\n        <div translate-language=\"de\">\n            <h1 translate>HELLO</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider\n          .translations('en',{\n            'HELLO': 'Hello world!'\n          })\n          .translations('de',{\n            'HELLO': 'Hallo Welt!'\n          })\n          .translations(.preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateLanguage', translateLanguageDirective);\n\nfunction translateLanguageDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return function linkFn(scope, iElement, iAttrs) {\n        iAttrs.$observe('translateLanguage', function (newTranslateLanguage) {\n          scope.translateLanguage = newTranslateLanguage;\n        });\n      };\n    }\n  };\n}\n\ntranslateLanguageDirective.displayName = 'translateLanguageDirective';\n\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc filter\n * @name pascalprecht.translate.filter:translate\n * @requires $parse\n * @requires pascalprecht.translate.$translate\n * @function\n *\n * @description\n * Uses `$translate` service to translate contents. Accepts interpolate parameters\n * to pass dynamized values though translation.\n *\n * @param {string} translationId A translation id to be translated.\n * @param {*=} interpolateParams Optional object literal (as hash or string) to pass values into translation.\n *\n * @returns {string} Translated text.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre>{{ 'TRANSLATION_ID' | translate }}</pre>\n        <pre>{{ translationId | translate }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:'{value: 5}' }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:values }}</pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en', {\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        });\n        $translateProvider.preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n   </example>\n */\n.filter('translate', translateFilterFactory);\n\nfunction translateFilterFactory($parse, $translate) {\n\n  'use strict';\n\n  var translateFilter = function (translationId, interpolateParams, interpolation, forceLanguage) {\n\n    if (!angular.isObject(interpolateParams)) {\n      interpolateParams = $parse(interpolateParams)(this);\n    }\n\n    return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);\n  };\n\n  if ($translate.statefulFilter()) {\n    translateFilter.$stateful = true;\n  }\n\n  return translateFilter;\n}\ntranslateFilterFactory.$inject = ['$parse', '$translate'];\n\ntranslateFilterFactory.displayName = 'translateFilterFactory';\n\nangular.module('pascalprecht.translate')\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translationCache\n * @requires $cacheFactory\n *\n * @description\n * The first time a translation table is used, it is loaded in the translation cache for quick retrieval. You\n * can load translation tables directly into the cache by consuming the\n * `$translationCache` service directly.\n *\n * @return {object} $cacheFactory object.\n */\n  .factory('$translationCache', $translationCache);\n\nfunction $translationCache($cacheFactory) {\n\n  'use strict';\n\n  return $cacheFactory('translations');\n}\n$translationCache.$inject = ['$cacheFactory'];\n\n$translationCache.displayName = '$translationCache';\nreturn 'pascalprecht.translate';\n\n}));\n\n},{}],40:[function(require,module,exports){\n/**\n * State-based routing for AngularJS\n * @version v0.2.18\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    toJson = angular.toJson;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i] || !parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:\n        result = result.replace(/\\/$/, '');\n        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  var param, paramVal;\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    param = this.params[paramName];\n    paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n    param = this.params[paramName];\n    paramVal = searchParams[paramName];\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validates\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      var isFinalPathParam = i + 1 === nPath;\n\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n\n      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      if (encoded.length === 0) continue;\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        if (isArray(val) && val.length === 0) return val;\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  // Use tildes to pre-encode slashes.\n  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n  // and bidirectional encoding/decoding fails.\n  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    \"string\": {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    \"int\": {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    \"bool\": {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    \"date\": {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    \"json\": {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    \"any\": { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\n      if (angular.isString(config.type))\n        return $types[config.type];\n      if (config.type instanceof Type)\n        return config.type;\n      return new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {function} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|function} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. \n   * \n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|function} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n\n        isHtml5 = isHtml5 && $sniffer.history;\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. Only parameters specified in the state definition can be overridden, new \n     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n     *    have changed.  It will reload the resolves and views of the current state and parent states.\n     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n     *    the transition reloads the resolves and views for that matched state, and all its children states.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n      \n      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n      if (hash) toParams['#'] = hash;\n      \n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n          if ($state.transition == null) $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .factory('$stateParams', function () { return {}; })\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\nvar ngMajorVer = angular.version.major;\nvar ngMinorVer = angular.version.minor;\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations\n * will be applied to the ui-view)\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = {\n      enter: function (element, target, cb) { target.after(element); cb(); },\n      leave: function (element, cb) { element.remove(); cb(); }\n    };\n\n    if (!!attrs.noanimation) return statics;\n\n    function animEnabled(element) {\n      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);\n      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();\n      return (!!$animator);\n    }\n\n    // ng 1.2+\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          if (!animEnabled(element)) {\n            statics.enter(element, target, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function(element, cb) {\n          if (!animEnabled(element)) {\n            statics.leave(element, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        }\n      };\n    }\n\n    // ng 1.1.5\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics;\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          var _previousEl = previousEl;\n          var _currentScope = currentScope;\n\n          if (_currentScope) {\n            _currentScope._willBeDestroyed = true;\n          }\n\n          function cleanOld() {\n            if (_previousEl) {\n              _previousEl.remove();\n            }\n\n            if (_currentScope) {\n              _currentScope.$destroy();\n            }\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              cleanOld();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n          } else {\n            cleanOld();\n            previousEl = null;\n          }\n\n          currentEl = null;\n          currentScope = null;\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          currentScope.$emit('$viewContentLoaded', name);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var inherited = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\nfunction clickHook(el, $state, $timeout, type, current) {\n  return function(e) {\n    var button = e.which || e.button, target = current();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function() {\n        $state.go(target.state, target.params, target.options);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\n      e.preventDefault = function() {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\nfunction defaultOpts(el, $state) {\n  return { relative: stateContext(el) || $state.$current, inherit: true };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n * URL, the directive will automatically generate & update the `href` attribute via\n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n * the link will trigger a state transition with optional parameters.\n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative\n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the\n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n *\n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n      var def    = { state: ref.state, href: null, params: null };\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n\n      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\n      var update = function(val) {\n        if (val) def.params = angular.copy(val);\n        def.href = $state.href(ref.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(ref.state, def.params);\n        if (def.href !== null) attrs.$set(type.attr, def.href);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n        def.params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-state\n *\n * @requires ui.router.state.uiSref\n *\n * @restrict A\n *\n * @description\n * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n * params and override options.\n *\n * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}\n * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDynamicDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n      var def    = { state: null, params: null, options: null, href: null };\n\n      function runStateRefLink (group) {\n        def.state = group[0]; def.params = group[1]; def.options = group[2];\n        def.href = $state.href(def.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(def.state, def.params);\n        if (def.href) attrs.$set(type.attr, def.href);\n      }\n\n      scope.$watch(watch, runStateRefLink, true);\n      runStateRefLink(scope.$eval(watch));\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * It is also possible to pass ui-sref-active an expression that evaluates\n * to an object hash, whose keys represent active class names and whose\n * values represent the respective state names/globs.\n * ui-sref-active will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * @Example\n * Given the following template, with \"admin\" being an abstract state:\n * <pre>\n * <div ui-sref-active=\"{'active': 'admin.*'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * </pre>\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied\n * to both the <div> and <a> elements. It is important to note that the state\n * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n      try {\n        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n      } catch (e) {\n        // Do nothing. uiSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n      if (isObject(uiSrefActive)) {\n        forEach(uiSrefActive, function(stateOrName, activeClass) {\n          if (isString(stateOrName)) {\n            var ref = parseStateRef(stateOrName, $state.current.name);\n            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n          }\n        });\n      }\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ui-sref-active, so we\n        // shadow the one that comes from ui-sref\n        if (isObject(uiSrefActive) && states.length > 0) {\n          return;\n        }\n        addState(newState, newParams, uiSrefActive);\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      function addState(stateName, stateParams, activeClass) {\n        var state = $state.get(stateName, stateContext($element));\n        var stateHash = createStateHash(stateName, stateParams);\n\n        states.push({\n          state: state || { name: stateName },\n          params: stateParams,\n          hash: stateHash\n        });\n\n        activeClasses[stateHash] = activeClass;\n      }\n\n      /**\n       * @param {string} state\n       * @param {Object|string} [params]\n       * @return {string}\n       */\n      function createStateHash(state, params) {\n        if (!isString(state)) {\n          throw new Error('state should be a string');\n        }\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        params = $scope.$eval(params);\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        return state;\n      }\n\n      // Update route state\n      function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }\n\n      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n      function removeClass(el, className) { el.removeClass(className); }\n      function anyMatch(state, params) { return $state.includes(state.name, params); }\n      function exactMatch(state, params) { return $state.is(state.name, params); }\n\n      update();\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n  .directive('uiState', $StateRefDynamicDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state, params) {\n    return $state.is(state, params);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state, params, options) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n},{}],41:[function(require,module,exports){\n'use strict';\n// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.\n\nmodule.exports = {\n    // Create a <link> tag with optional data attributes\n    createLink: function(href, attributes) {\n        var head = document.head || document.getElementsByTagName('head')[0];\n        var link = document.createElement('link');\n\n        link.href = href;\n        link.rel = 'stylesheet';\n\n        for (var key in attributes) {\n            if ( ! attributes.hasOwnProperty(key)) {\n                continue;\n            }\n            var value = attributes[key];\n            link.setAttribute('data-' + key, value);\n        }\n\n        head.appendChild(link);\n    },\n    // Create a <style> tag with optional data attributes\n    createStyle: function(cssText, attributes) {\n        var head = document.head || document.getElementsByTagName('head')[0],\n            style = document.createElement('style');\n\n        style.type = 'text/css';\n\n        for (var key in attributes) {\n            if ( ! attributes.hasOwnProperty(key)) {\n                continue;\n            }\n            var value = attributes[key];\n            style.setAttribute('data-' + key, value);\n        }\n        \n        if (style.sheet) { // for jsdom and IE9+\n            style.innerHTML = cssText;\n            style.sheet.cssText = cssText;\n            head.appendChild(style);\n        } else if (style.styleSheet) { // for IE8 and below\n            head.appendChild(style);\n            style.styleSheet.cssText = cssText;\n        } else { // for Chrome, Firefox, and Safari\n            style.appendChild(document.createTextNode(cssText));\n            head.appendChild(style);\n        }\n    }\n};\n\n},{}]},{},[4])\n\n","var ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\r\nvar MainViewController = require('./components/common/MainViewController');\r\nvar SideNavViewController = require('./components/nav/SideNavViewController');\r\nvar BeneficiaryViewController = require('./components/beneficiary/BeneficiaryViewController');\r\nvar CompanyViewController = require('./components/company/CompanyViewController');\r\nvar config = require('./config');\r\n\r\nvar moduleName = config.configBlock.namespace + '.controllers';\r\nvar controllersModule = ng.module(moduleName, [])\r\n    .controller('MainViewController', MainViewController.controller)\r\n    .controller('SideNavViewController', SideNavViewController.controller)\r\n    .controller('BeneficiaryViewController', BeneficiaryViewController.controller)\r\n    .controller('CompanyViewController', CompanyViewController.controller);\r\n\r\nexports.controllersModule = controllersModule;\r\n","var ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar MainViewDirective = require('./components/common/MainViewDirective');\nvar SideNavViewDirective = require('./components/nav/SideNavViewDirective');\nvar BeneficiaryViewDirective = require('./components/beneficiary/BeneficiaryViewDirective');\nvar BeneficiaryCreateViewDirective = require('./components/beneficiary/BeneficiaryCreateViewDirective');\nvar BeneficiaryUpdateViewDirective = require('./components/beneficiary/BeneficiaryUpdateViewDirective');\nvar BeneficiaryDeleteViewDirective = require('./components/beneficiary/BeneficiaryDeleteViewDirective');\nvar BeneficiaryListViewDirective = require('./components/beneficiary/BeneficiaryListViewDirective');\nvar BeneficiaryListFragmentViewDirective = require('./components/beneficiary/BeneficiaryListFragmentViewDirective');\nvar BeneficiaryDetailViewDirective = require('./components/beneficiary/BeneficiaryDetailViewDirective');\nvar BeneficiarySearchViewDirective = require('./components/beneficiary/BeneficiarySearchViewDirective');\nvar CompanyViewDirective = require('./components/company/CompanyViewDirective');\nvar CompanyCreateViewDirective = require('./components/company/CompanyCreateViewDirective');\nvar CompanyUpdateViewDirective = require('./components/company/CompanyUpdateViewDirective');\nvar CompanyDeleteViewDirective = require('./components/company/CompanyDeleteViewDirective');\nvar CompanyListViewDirective = require('./components/company/CompanyListViewDirective');\nvar CompanyListFragmentViewDirective = require('./components/company/CompanyListFragmentViewDirective');\nvar CompanySearchViewDirective = require('./components/company/CompanySearchViewDirective');\nvar config = require('./config');\n\nvar moduleName = config.configBlock.namespace + '.directives';\n\nvar directivesModule = ng.module(moduleName, [])\n    .directive('mainView', MainViewDirective.directive)\n    .directive('sideNavView', SideNavViewDirective.directive)\n    .directive('beneficiaryView', BeneficiaryViewDirective.directive)\n    .directive('beneficiaryCreateView', BeneficiaryCreateViewDirective.directive)\n    .directive('beneficiaryUpdateView', BeneficiaryUpdateViewDirective.directive)\n    .directive('beneficiaryDeleteView', BeneficiaryDeleteViewDirective.directive)\n    .directive('beneficiaryDetailView', BeneficiaryDetailViewDirective.directive)\n    .directive('beneficiarySearchView', BeneficiarySearchViewDirective.directive)\n    .directive('beneficiaryListView', BeneficiaryListViewDirective.directive)\n    .directive('beneficiaryListDetailView', BeneficiaryListViewDirective.directive)\n    .directive('beneficiaryListFragmentView', BeneficiaryListFragmentViewDirective.directive)\n    .directive('companyView', CompanyViewDirective.directive)\n    .directive('companyCreateView', CompanyCreateViewDirective.directive)\n    .directive('companyUpdateView', CompanyUpdateViewDirective.directive)\n    .directive('companyDeleteView', CompanyDeleteViewDirective.directive)\n    .directive('companySearchView', CompanySearchViewDirective.directive)\n    .directive('companyListView', CompanyListViewDirective.directive)\n    .directive('companyListFragmentView', CompanyListFragmentViewDirective.directive)\n\nexports.directivesModule = directivesModule;\n","var ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar BeneficiaryService = require('./components/beneficiary/BeneficiaryService');\nvar CompanyService = require('./components/company/CompanyService');\nvar UtilService = require('./components/common/UtilService');\nvar config = require('./config');\n\nvar moduleName = config.configBlock.namespace + '.services';\nvar servicesModule = ng.module(moduleName, [])\n    .factory('beneficiaryService', BeneficiaryService.service)\n    .factory('companyService', CompanyService.service)\n    .factory('utilService', UtilService.service);\n\nexports.servicesModule = servicesModule;\n","/** Main app **/\n\n'use strict';\n\nvar ng = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\nvar config = require('./config');\nvar constants = require('./constants');\nvar services = require('./angularservices');\nvar controllers = require('./angularcontrollers');\nvar directives = require('./angulardirectives');\n\nvar animateModule = require('angular-animate');\nvar translateModule = require('angular-translate');\nvar sanitizeModule = require('angular-sanitize');\nvar blockUIModule = require('angular-block-ui');\nvar uiRouterModule = require('angular-ui-router');\n\nrequire('angular-block-ui/dist/angular-block-ui.min.css');\n\nvar moduleName = config.configBlock.namespace;\n\n// Declare app level module which depends on services, controllers and directives\nng.module(moduleName, [animateModule, translateModule, sanitizeModule, blockUIModule, uiRouterModule,\n    services.servicesModule.name, controllers.controllersModule.name, directives.directivesModule.name,\n    'inform', 'inform-exception'/*, 'inform-http-exception'*/\n]);\n\nng.module(moduleName)\n  .config(config.configBlock.settings)\n  .config(config.configBlock.states)\n  .config(config.configBlock.blockUI)\n  .config(config.configBlock.inform)\n  .config(config.configBlock.hrefSanitize);\n\nng.module(moduleName)\n  .constant('CONSTANTS', constants.constants);\n\nvar runBlock = function() {\n\n    // Add code that needs a run block to execute here.\n};\n\nng.module(moduleName)\n  .run(runBlock);\n  // .run(config.configBlock.modal);\n","/**\r\n * Beneficiary Form Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryCreateView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Delete Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryDeleteView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Beneficiary Detail View Component Directive\r\n *\r\n * @param {$parse} Angular parser service\r\n * @param {$rootScope} Angular rootScope service\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function($parse, $compile, $rootScope, $timeout) {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryDetailView.html',\r\n        restrict: 'AE',\r\n        //replace: true,\r\n        //transclude: true,\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        link: function(scope, el, attrs) {\r\n            $rootScope.$on('disableBeneficiary', function(ev, data) {\r\n                for (var i = 0; i < data.beneficiaries.length; i++) {\r\n                    if (data.beneficiaries[i].id === data.beneficiaryId) {\r\n                        var inputEls = angular.element(el.find('input[type=text]'));\r\n                        for (var j = 0; j < inputEls.length; j++) {\r\n                            angular.element(inputEls[j]).attr('disabled', '');\r\n                            $timeout(function() {\r\n                                $compile(inputEls[j])(scope);\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                //$compile(el)(scope);\r\n            });\r\n        }\r\n    };\r\n};\r\ndirective.$inject = [\"$parse\", \"$compile\", \"$rootScope\", \"$timeout\"];\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryListFragmentView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiaries: '=',\r\n            delref: '='\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryListView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Search Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiarySearchView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * This service helps to perform http requests (GET, POST, PUT, DELETE) for beneficiary tasks\r\n *\r\n * @param {$http} The AngularJS http service\r\n * @param {$timeout} The AngularJS timeout service\r\n *\r\n * @ngInject\r\n */\r\nvar service = function($http, $timeout) {\r\n    'use strict';\r\n\r\n    var serviceInstance = {};\r\n    serviceInstance.selectedBeneficiaryId = null;\r\n    serviceInstance.popOnDelete = null;\r\n    serviceInstance.beneficiary = null;\r\n    serviceInstance.beneficiaries = [];\r\n\r\n    serviceInstance.getBeneficiary = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'GET'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.createBeneficiary = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            data: data,\r\n            method: 'POST'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n    serviceInstance.updateBeneficiary = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'PUT',\r\n            data: data\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.deleteBeneficiary = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'DELETE'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$http\", \"$timeout\"];\r\n\r\nexports.service = service;\r\n","/**\r\n * Beneficiary Form Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryUpdateView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            beneficiary: '=beneficiaryDetails'\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Beneficiary View controller\r\n *\r\n * This controller is responsible for handing beneficiary form module related logic\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {$modal} Angular modal service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {utilService} Utility service\r\n * @param {blockUI} Block UI service\r\n * @param {inform} Inform provider service\r\n * @param {CONSTANTS} Project constants values\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function($rootScope, $scope, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, utilService, blockUI, inform, CONSTANTS) {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n    $scope.useExistingBeneficiary = false;\r\n    $scope.minimumValidBeneficiary = false;\r\n    $scope.beneficiaryId = null;\r\n    $scope.beneficiarySearched = false;\r\n    $scope.beneficiaryFound = false;\r\n    $scope.searchRequestSumbitted = false;\r\n    $scope.addRequestSubmitted = false;\r\n    $scope.addRequestAttempted = false;\r\n    $scope.updateRequestSubmitted = false;\r\n    $scope.updateRequestAttempted = false;\r\n    $scope.deleteRequestSubmitted = false;\r\n    $scope.deleteSuccessful = false;\r\n    $scope.serviceUrl = CONSTANTS.url.path;\r\n\r\n    $scope.initBeneficiary = {\r\n        \"firstName\": null,\r\n        \"lastName\": null\r\n    };\r\n    $scope.beneficiaries = beneficiaryService.beneficiaries; //.length > 0 ? beneficiaryService.beneficiaries : [];\r\n    $scope.beneficiary = beneficiaryService.beneficiary &&\r\n                         ($state.current.name === 'start.beneficiary.update' || $state.current.name === 'start.beneficiary.list.delete' || $state.current.name === 'start.beneficiary.search.delete') ?\r\n                         beneficiaryService.beneficiary : $scope.initBeneficiary;\r\n\r\n    $scope.resetBeneficiary = function() {\r\n        $timeout(function() {\r\n            $scope.beneficiary = $scope.initBeneficiary;\r\n            $scope.beneficiaries = [];\r\n        });\r\n    };\r\n\r\n    $scope.addBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.addRequestSubmitted = false;\r\n        beneficiaryService.beneficiary = $scope.beneficiary;\r\n        if (!utilService.isFormValid('beneficiaryDetailsForm')) {\r\n            $scope.addRequestAttempted = true;\r\n            $log.warn('form invalid');\r\n            inform.add('Invalid form. First name and Last name are required to create beneficiary', {\r\n                ttl: 3500,\r\n                type: 'danger'\r\n            });\r\n            // $scope.registerPopoverShow('#addBeneficiary');\r\n            return;\r\n        }\r\n\r\n        var beneficiaryCreateBlock = blockUI.instances.get('beneficiaryCreateBlock');\r\n        beneficiaryCreateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        beneficiaryService.createBeneficiary(url, $scope.beneficiary, function(result) {\r\n            $timeout(function() {\r\n                $scope.addRequestSubmitted = true;\r\n                if (result && result.data) {\r\n                    if (result.data.id > 0) {\r\n                        inform.add('beneficiary created successfully.', {\r\n                            ttl: 2500\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.beneficiary', {}, {reload:true});\r\n                        }, 2500);\r\n                    } else {\r\n                        inform.add('Request completed, however beneficiary couldn\\'t be created.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating beneficiary.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.addRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                beneficiaryCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelAddBeneficiary = function() {\r\n        $state.go('start.beneficiary');\r\n    };\r\n\r\n    $scope.updateBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.updateRequestSubmitted = false;\r\n        beneficiaryService.beneficiary = $scope.beneficiary;\r\n        if (!utilService.isFormValid('beneficiaryDetailsForm')) {\r\n            $scope.updateRequestAttempted = true;\r\n            $log.warn('ccform invalid');\r\n            inform.add('Invalid form. First name and Last name are required to create beneficiary', {\r\n                ttl: 3500,\r\n                type: 'danger'\r\n            });\r\n            return;\r\n        }\r\n\r\n        var beneficiaryUpdateBlock = blockUI.instances.get('beneficiaryUpdateBlock');\r\n        beneficiaryUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        beneficiaryService.updateBeneficiary(url, $scope.beneficiary, function(result) {\r\n            $timeout(function() {\r\n                $scope.updateRequestSubmitted = true;\r\n                if (result && result.data) {\r\n                    if (result.data.status === true) {\r\n                        inform.add('beneficiary updated successfully.', {\r\n                            ttl: 4000\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.beneficiary.list', {}, {reload: true});\r\n                        }, 4500);\r\n                    } else {\r\n                        inform.add('Request completed successfully, but no update performed on beneficiary.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'beneficiary couldn\\'t be updated.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.updateRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                beneficiaryUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseBeneficiaryUpdate = function() {\r\n        $state.go('start.beneficiary.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.deleteBeneficiary = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.beneficiary = beneficiaryService.beneficiary;\r\n        var beneficiaryDeleteBlock = blockUI.instances.get('beneficiaryDeleteBlock');\r\n        beneficiaryDeleteBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + $scope.beneficiary.id;\r\n        beneficiaryService.deleteBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.deleteRequestSubmitted = true;\r\n                if (result && result.data && result.data.status === true) {\r\n                    $scope.deleteSuccessful = true;\r\n                } else {\r\n                  $log.info(result);\r\n                }\r\n                beneficiaryDeleteBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseBeneficiaryDelete = function() {\r\n        $scope.$dismiss();\r\n        $state.go('start.beneficiary.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.fetchBeneficiary = function(id) {\r\n        $scope.beneficiaries.splice(0, $scope.beneficiaries.length);\r\n\r\n        var idSearch = !utilService.isBlank(id);\r\n        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;\r\n        var url = idSearch ? baseUrl + '/' + id : baseUrl;\r\n        var beneficiaryListBlock = blockUI.instances.get('beneficiaryListBlock');\r\n        beneficiaryListBlock.start();\r\n        beneficiaryService.getBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.searchRequestSumbitted = true;\r\n                if (result && result.data) {\r\n                    if (idSearch) {\r\n                        $scope.beneficiaries.push(result.data);\r\n                    } else {\r\n                        $scope.beneficiaries = result.data;\r\n                    }\r\n                    beneficiaryService.beneficiaries = $scope.beneficiaries;\r\n                    $scope.beneficiaryFound = true;\r\n                }\r\n                beneficiaryListBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.searchBeneficiary = function(id, $event) {\r\n        $event.stopPropagation();\r\n        $timeout(function() {\r\n            if (!utilService.isValidId(id)) {\r\n                $scope.registerPopoverShow('#searchExistingBeneficiaryId');\r\n                return;\r\n            }\r\n            $scope.fetchBeneficiary(id);\r\n        });\r\n    };\r\n\r\n    $scope.mutateBeneficiaryOptions = function(beneficiary, $index, $event) {\r\n        $event.stopPropagation();\r\n        beneficiaryService.selectedBeneficiaryId = '#beneficiary' + $index;\r\n        beneficiaryService.beneficiary = beneficiary;\r\n        $scope.registerPopoverPrep(beneficiaryService.selectedBeneficiaryId);\r\n        $scope.registerPopoverShow(beneficiaryService.selectedBeneficiaryId);\r\n    };\r\n\r\n    /* initialize popover */\r\n\r\n    $scope.discardMessage = function($event) {\r\n        $event ? $event.stopPropagation() : '';\r\n        beneficiaryService.popOnDelete = \"delete\";\r\n        $scope.registerPopoverHide('[id*=popover]');\r\n    };\r\n\r\n    beneficiaryService.popOnDelete = \"delete\";\r\n\r\n    $scope.registerPopoverPrep = function(id) {\r\n        angular.element($document.find(id)).popover({\r\n            trigger: 'manual'\r\n        });\r\n    };\r\n\r\n    $scope.registerPopoverShow = function(id) {\r\n        if (beneficiaryService.popOnDelete !== \"popover\") {\r\n            beneficiaryService.popOnDelete = \"popover\";\r\n            angular.element($document.find(id)).popover('show');\r\n        }\r\n    };\r\n\r\n    $scope.registerPopoverHide = function(id) {\r\n        var el = angular.element($document.find(id));\r\n        el ? el.popover('hide') : '';\r\n    };\r\n\r\n    $scope.registerPopoverPrep('#removeBeneficiary');\r\n    $scope.registerPopoverPrep('#addBeneficiary');\r\n    $scope.registerPopoverPrep('#updateBeneficiary');\r\n    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');\r\n    $scope.registerPopoverHide('[id*=popover]');\r\n\r\n    // clear all informs\r\n    inform.clear();\r\n};\r\ncontroller.$inject = [\"$rootScope\", \"$scope\", \"$timeout\", \"$window\", \"$document\", \"$log\", \"$state\", \"$modal\", \"beneficiaryService\", \"utilService\", \"blockUI\", \"inform\", \"CONSTANTS\"];\r\n\r\nexports.controller = controller;\r\n","/**\r\n * Main Beneficiary Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/beneficiary/BeneficiaryView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'BeneficiaryViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Main View controller\r\n *\r\n * This controller is responsible for handing request from main view\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function() {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n};\r\n\r\nexports.controller = controller;\r\n","/**\r\n * Main Directive\r\n *\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/common/MainView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'MainViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","var stateConfig = {\r\n    /**\r\n     * Default to <company-create-view />\r\n     */\r\n    main: {\r\n        url: '/',\r\n        views: {\r\n            'main': {\r\n                template: '<main-view></main-view>'\r\n            },\r\n            'mainItem@start': {\r\n                template: '<company-create-view></company-create-view>'\r\n            }\r\n        }\r\n    },\r\n    company: {\r\n        initial: {\r\n            url: 'company',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-view></company-view>'\r\n                }\r\n            }\r\n        },\r\n        list: {\r\n            url: '/list',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-list-view></company-list-view>'\r\n                }\r\n            }\r\n        },\r\n        search: {\r\n            url: '/search',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-search-view></company-search-view>'\r\n                }\r\n            }\r\n        },\r\n        update: {\r\n            url: '/update',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<company-update-view></company-update-view>'\r\n                }\r\n            }\r\n        },\r\n        delete: {\r\n            // would be used under start.company.list state, hence url resolves to: #/company/list/delete\r\n            url: '/delete',\r\n            /**\r\n             * On state enter event listener\r\n             * @param  {$modal} Modal service\r\n             * @ngInject\r\n             */\r\n            onEnter: [\"$modal\", function($modal) {\r\n                $modal.open({\r\n                    template: '<company-delete-view></company-delete-view>',\r\n                    backdrop: 'static',\r\n                    keyboard: false,\r\n                    windowClass: 'modal',\r\n                    controller: 'CompanyViewController'\r\n                });\r\n            }]\r\n        }\r\n    },\r\n    beneficiary: {\r\n        initial: {\r\n            url: 'beneficiary',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-view></beneficiary-view>'\r\n                }\r\n            }\r\n        },\r\n        list: {\r\n            url: '/list',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-list-view></beneficiary-list-view>'\r\n                }\r\n            }\r\n        },\r\n        search: {\r\n            url: '/search',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-search-view></beneficiary-seach-view>'\r\n                }\r\n            }\r\n        },\r\n        update: {\r\n            url: '/update',\r\n            views: {\r\n                'mainItem@start': {\r\n                    template: '<beneficiary-update-view></beneficiary-update-view>'\r\n                }\r\n            }\r\n        },\r\n        delete: {\r\n            /** would be used under start.beneficiary.list or start.beneficiary.search state,\r\n             *  hence url resolves to: #/beneficiary/list/delete or  #/beneficiary/search/delete\r\n             */\r\n            url: '/delete',\r\n            /**\r\n             * On state enter event listener\r\n             * @param  {$modal} Modal service\r\n             * @ngInject\r\n             */\r\n            onEnter: [\"$modal\", function($modal) {\r\n                $modal.open({\r\n                    template: '<beneficiary-delete-view></beneficiary-delete-view>',\r\n                    backdrop: 'static',\r\n                    keyboard: false,\r\n                    windowClass: 'modal',\r\n                    controller: 'BeneficiaryViewController'\r\n                });\r\n            }]\r\n        }\r\n    }\r\n};\r\n\r\nexports.stateConfig = stateConfig;\r\n","/**\r\n * This service provide custom word lookup for case normalization if one is not provided by the service client\r\n *\r\n * @param {$window} The angular window service\r\n * @ngInject\r\n */\r\nvar service = function($window) {\r\n    'use strict';\r\n    var serviceInstance = {};\r\n\r\n    serviceInstance.isFormValid = function(formId) {\r\n        var isValid = true;\r\n        var formEl = $window.document.getElementById(formId);\r\n        if (!formEl || (formEl && formEl.className && formEl.className.indexOf('ng-invalid') > -1)) return false;\r\n        // otherwise, perform sanity check\r\n        var elements = $window.document.getElementById(formId).elements;\r\n        for (var i = 0, element = elements[i++]; i < elements.length; i++) {\r\n            if ((element.type === 'text' || element.type === 'checkbox' || element.type === 'radio' || element.type === 'date' || element.type === 'datetime-local' || element.type === 'email' || element.type === 'month' || element.type === 'number' || element.type === 'time' || element.type === 'url' || element.type === 'week' || element.type === 'textarea' || element.type === 'select') && (element.className.indexOf('ng-invalid') > -1)) {\r\n                isValid = false;\r\n                return isValid;\r\n            }\r\n        }\r\n\r\n        return isValid;\r\n    };\r\n\r\n    serviceInstance.isBlank = function(value) {\r\n        return angular.isUndefined(value) || value === null || value.length === 0;\r\n    };\r\n\r\n    serviceInstance.isValidId = function(id) {\r\n        return parseInt(id) >= 1;\r\n    }\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$window\"];\r\n\r\nexports.service = service;\r\n","/**\r\n * Company Create Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyCreateView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Delete Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyDeleteView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function() {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyListFragmentView.html',\r\n        restrict: 'AE',\r\n        scope: {\r\n            companies: '=',\r\n            delref: '='\r\n        },\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Table List Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyListView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company Search Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanySearchView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * This service helps to perform http requests (GET, POST, PUT, DELETE) for company tasks\r\n *\r\n * @param {$http} The AngularJS http service\r\n * @param {$timeout} The AngularJS timeout service\r\n *\r\n * @ngInject\r\n */\r\nvar service = function($http, $timeout) {\r\n    'use strict';\r\n\r\n    var serviceInstance = {};\r\n    serviceInstance.selectedCompanyId = null;\r\n    serviceInstance.popOnDelete = null;\r\n    serviceInstance.company = null;\r\n    serviceInstance.companies = [];\r\n    serviceInstance.searchRequestSumbitted = false;\r\n\r\n    serviceInstance.getCompany = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'GET',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.createCompany = function(url, data, callback) {\r\n        console.log('here: ' + url);\r\n        //return;\r\n        $http({\r\n            url: url,\r\n            data: data,\r\n            method: 'POST',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n    serviceInstance.updateCompany = function(url, data, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'PUT',\r\n            data: data,\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n    serviceInstance.deleteCompany = function(url, callback) {\r\n        $http({\r\n            url: url,\r\n            method: 'DELETE',\r\n            dataType: 'jsonp'\r\n        }).then(function(results) {\r\n            callback(results);\r\n        }, function(error) {\r\n            var errorData = {\r\n                status: error.status ? error.status : 500,\r\n                message: error.data ? error.data : 'Error occured while retrieving company details'\r\n            };\r\n            callback(errorData);\r\n        });\r\n    };\r\n\r\n\r\n    return serviceInstance;\r\n};\r\nservice.$inject = [\"$http\", \"$timeout\"];\r\n\r\nexports.service = service;\r\n","/**\r\n * Company Update Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyUpdateView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'CompanyViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Company View controller\r\n *\r\n * This controller is responsible for handing company form module related logic\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$q} Angular promise service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {$modal} Angular modal service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n * @param {utilService} Utility service\r\n * @param {blockUI} Block UI service\r\n * @param {inform} Inform provider service\r\n * @param {CONSTANTS} Project constants values\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function($rootScope, $scope, $q, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, companyService, utilService, blockUI, inform, CONSTANTS) {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n    $scope.useExistingBeneficiary = false;\r\n    $scope.minimumValidBeneficiary = false;\r\n    $scope.beneficiaryId = null;\r\n    $scope.beneficiarySearched = false;\r\n    $scope.beneficiaryFound = false;\r\n    $scope.companyFound = false;\r\n    $scope.searchRequestSumbitted = false;\r\n    $scope.addRequestSubmitted = false;\r\n    $scope.updateRequestSubmitted = false;\r\n    $scope.deleteRequestSubmitted = false;\r\n    $scope.deleteSuccessful = false;\r\n    $scope.serviceUrl = CONSTANTS.url.path;\r\n    $scope.initCompany = {\r\n        \"name\": null,\r\n        \"address\": null,\r\n        \"city\": null,\r\n        \"country\": null,\r\n        \"email\": null,\r\n        \"phoneNumber\": null,\r\n        \"beneficiaries\": [{\r\n            \"id\": -1,\r\n            \"firstName\": null,\r\n            \"lastName\": null\r\n        }]\r\n    };\r\n\r\n    $scope.companies = companyService.companies; //.length > 0 ? companyService.companies : [];\r\n    $scope.company = companyService.company &&\r\n                    ($state.current.name === 'start.company.update' || $state.current.name === 'start.company.list.delete' || $state.current.name === 'start.company.search.delete') ?\r\n                    companyService.company : $scope.initCompany;\r\n\r\n    $scope.verifyMinimumValidBeneficiary = function() {\r\n        for (var i = 0; i < $scope.company.beneficiaries.length; i++) {\r\n            $scope.minimumValidBeneficiary = $scope.company.beneficiaries[i].id !== -1 ||\r\n                                            (!utilService.isBlank($scope.company.beneficiaries[i].firstName) && !utilService.isBlank($scope.company.beneficiaries[i].lastName));\r\n            if ($scope.minimumValidBeneficiary) {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n\r\n    $scope.resetCompany = function() {\r\n        $timeout(function() {\r\n            $scope.company = $scope.initCompany;\r\n            $scope.companies = [];\r\n        });\r\n    };\r\n\r\n    $scope.addCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.addRequestSubmitted = false;\r\n        companyService.company = $scope.company;\r\n        if (utilService.isFormValid('companyDetailsForm')) {\r\n            $scope.verifyMinimumValidBeneficiary();\r\n            if (!$scope.minimumValidBeneficiary) {\r\n                $scope.registerPopoverShow('#addCompany');\r\n                return;\r\n            }\r\n            $log.info('form valid');\r\n        } else {\r\n            $log.warn('form invalid');\r\n            return;\r\n        }\r\n\r\n        var companyCreateBlock = blockUI.instances.get('companyCreateBlock');\r\n        companyCreateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n\r\n        companyService.createCompany(url, $scope.company, function(result) {\r\n            $timeout(function() {\r\n                $scope.addRequestSubmitted = true;\r\n                if (result && result.data) {\r\n                    if (result.data.id > 0) {\r\n                        inform.add('Company created successfully.', {\r\n                            ttl: 2500\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.company', {}, {reload:true});\r\n                        }, 2500);\r\n                    } else {\r\n                        inform.add('Request completed, however company couldn\\'t be created.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating company.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.addRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                companyCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelAddCompany = function() {\r\n        $state.go('start.company');\r\n    };\r\n\r\n    $scope.updateCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.updateRequestSubmitted = false;\r\n        companyService.company = $scope.company;\r\n        if (utilService.isFormValid('companyUpdateForm')) {\r\n            $scope.verifyMinimumValidBeneficiary();\r\n            if (!$scope.minimumValidBeneficiary) {\r\n                $scope.registerPopoverShow('#updateCompany');\r\n                return;\r\n            }\r\n        } else {\r\n            $log.warn('form invalid');\r\n            return;\r\n        }\r\n\r\n        var companyUpdateBlock = blockUI.instances.get('companyUpdateBlock');\r\n        companyUpdateBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        companyService.updateCompany(url, $scope.company, function(result) {\r\n            $timeout(function() {\r\n                $scope.updateRequestSubmitted = true;\r\n                if (result && result.data) {\r\n                    if (result.data.status === true) {\r\n                        inform.add('Company updated successfully.', {\r\n                            ttl: 4000\r\n                        });\r\n                        $timeout(function() {\r\n                            $state.go('start.company.list', {}, {reload: true});\r\n                        }, 4500);\r\n                    } else {\r\n                        inform.add('Request completed successfully, but no update performed on company.', {\r\n                            ttl: 5000,\r\n                            type: 'warning'\r\n                        });\r\n                    }\r\n                } else {\r\n                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Company couldn\\'t be updated.', {\r\n                        ttl: 5000,\r\n                        type: 'danger'\r\n                    });\r\n                    $timeout(function() {\r\n                        $scope.updateRequestSubmitted = false;\r\n                    }, 5000);\r\n                }\r\n                companyUpdateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseCompanyUpdate = function() {\r\n        $state.go('start.company.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.deleteCompany = function($event) {\r\n        $event.stopPropagation();\r\n        $scope.company = companyService.company;\r\n        var companyDeleteBlock = blockUI.instances.get('companyDeleteBlock');\r\n        companyDeleteBlock.start();\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath + '/' + $scope.company.id;\r\n        companyService.deleteCompany(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.deleteRequestSubmitted = true;\r\n                if (result && result.data && result.data.status === true) {\r\n                    $scope.deleteSuccessful = true;\r\n                }\r\n                companyDeleteBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.cancelOrCloseCompanyDelete = function() {\r\n        $scope.$dismiss();\r\n        $state.go('start.company.list', {}, {reload: true});\r\n    };\r\n\r\n    $scope.fetchCompany = function(id) {\r\n        $scope.companies.splice(0, $scope.companies.length);\r\n\r\n        var idSearch = !utilService.isBlank(id);\r\n        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;\r\n        var url = idSearch ? baseUrl + '/' + id : baseUrl;\r\n        var companyListBlock = blockUI.instances.get('companyListBlock');\r\n        companyListBlock.start();\r\n        companyService.getCompany(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.searchRequestSumbitted = true;\r\n                companyService.searchRequestSumbitted = $scope.searchRequestSumbitted;\r\n                if (result && result.data) {\r\n                    if (idSearch) {\r\n                        $scope.companies.push(result.data);\r\n                    } else {\r\n                        $scope.companies = result.data;\r\n                    }\r\n                    companyService.companies = $scope.companies;\r\n                    $scope.companyFound = true;\r\n                }\r\n                companyListBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.searchCompany = function(id, $event) {\r\n        $event.stopPropagation();\r\n        $timeout(function() {\r\n            if (!utilService.isValidId(id)) {\r\n                $scope.registerPopoverShow('#searchExistingCompanyId');\r\n                return;\r\n            }\r\n            $scope.fetchCompany(id);\r\n        });\r\n    };\r\n\r\n    $scope.searchBeneficiary = function(id, $event) {\r\n        $event.stopPropagation();\r\n\r\n        if (!utilService.isValidId(id)) {\r\n            $scope.registerPopoverShow('#searchExistingBeneficiaryId');\r\n            return;\r\n        }\r\n        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + id;\r\n\r\n        var companyCreateBlock = blockUI.instances.get('companyCreateBlock');\r\n        companyCreateBlock.start();\r\n        beneficiaryService.getBeneficiary(url, function(result) {\r\n            $timeout(function() {\r\n                $scope.beneficiarySearched = true;\r\n                if (result && result.data) {\r\n                    $scope.verifyMinimumValidBeneficiary();\r\n                    // remove all empty forms\r\n                    if (!$scope.minimumValidBeneficiary) {\r\n                        $scope.company.beneficiaries.splice(0, $scope.company.beneficiaries.length);\r\n                    }\r\n                    if ($scope.company.beneficiaries.length > 0 ) {\r\n                        for (var i = 0; i < $scope.company.beneficiaries.length; i++) {\r\n                            if ($scope.company.beneficiaries[i].id != id) {\r\n                                $scope.company.beneficiaries.push(result.data);\r\n                                break;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        $scope.company.beneficiaries.push(result.data);\r\n                    }\r\n                    $scope.disableBeneficiary(result.data.id);\r\n                    $scope.minimumValidBeneficiary = true;\r\n                    $scope.beneficiaryFound = true;\r\n                    $scope.beneficiaryId = null;\r\n                }\r\n                companyCreateBlock.stop();\r\n            });\r\n        });\r\n    };\r\n\r\n    $scope.mutateCompanyOptions = function(company, $index, $event) {\r\n        $event.stopPropagation();\r\n        companyService.selectedCompanyId = '#company' + $index;\r\n        companyService.company = company;\r\n        $scope.registerPopoverPrep(companyService.selectedCompanyId);\r\n        $scope.registerPopoverShow(companyService.selectedCompanyId);\r\n    };\r\n\r\n    $scope.addBeneficiary = function() {\r\n        $scope.company.beneficiaries.push({\r\n            \"firstName\": \"\",\r\n            \"lastName\": \"\"\r\n        });\r\n    };\r\n\r\n    $scope.removeBeneficiary = function($event, beneficiary) {\r\n        $event.stopPropagation();\r\n        if ($scope.company.beneficiaries.indexOf(beneficiary) != -1) {\r\n            $timeout(function() {\r\n                if ($scope.company.beneficiaries.length === 1) {\r\n                    $scope.registerPopoverShow('#removeBeneficiary');\r\n                    return;\r\n                }\r\n                $scope.company.beneficiaries.splice($scope.company.beneficiaries.indexOf(beneficiary), 1);\r\n            });\r\n        }\r\n    };\r\n\r\n    $scope.disableBeneficiary = function(beneficiaryId) {\r\n        $rootScope.$emit('disableBeneficiary', {\r\n            beneficiaries: $scope.company.beneficiaries,\r\n            beneficiaryId: beneficiaryId\r\n        });\r\n    }\r\n\r\n    /* initialize popover */\r\n\r\n    $scope.discardMessage = function($event) {\r\n        $event ? $event.stopPropagation() : '';\r\n        companyService.popOnDelete = \"delete\";\r\n        $scope.registerPopoverHide('[id*=popover]');\r\n    };\r\n\r\n    companyService.popOnDelete = \"delete\";\r\n\r\n    $scope.registerPopoverPrep = function(id) {\r\n        angular.element($document.find(id)).popover({\r\n            trigger: 'manual'\r\n        });\r\n    };\r\n\r\n    $scope.registerPopoverShow = function(id) {\r\n        if (companyService.popOnDelete !== \"popover\") {\r\n            companyService.popOnDelete = \"popover\";\r\n            angular.element($document.find(id)).popover('show');\r\n        }\r\n    };\r\n\r\n    $scope.registerPopoverHide = function(id) {\r\n        var el = angular.element($document.find(id));\r\n        el ? el.popover('hide') : '';\r\n    };\r\n\r\n    $scope.registerPopoverPrep('#removeBeneficiary');\r\n    $scope.registerPopoverPrep('#addCompany');\r\n    $scope.registerPopoverPrep('#updateCompany');\r\n    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');\r\n    $scope.registerPopoverPrep('#searchExistingCompanyId');\r\n    $scope.registerPopoverHide('[id*=popover]');\r\n\r\n    // clear all informs\r\n    inform.clear();\r\n};\r\ncontroller.$inject = [\"$rootScope\", \"$scope\", \"$q\", \"$timeout\", \"$window\", \"$document\", \"$log\", \"$state\", \"$modal\", \"beneficiaryService\", \"companyService\", \"utilService\", \"blockUI\", \"inform\", \"CONSTANTS\"];\r\n\r\nexports.controller = controller;\r\n","/**\r\n * Main Company Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/company/CompanyView.html',\r\n        restrict: 'AE',\r\n        scope: false\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","/**\r\n * Side Nav View controller\r\n *\r\n * This controller is responsible for handing request from side nav\r\n *\r\n * @param {$rootScope} Angular root scope service\r\n * @param {$scope} Angular scope service\r\n * @param {$timeout} Angular timeout service\r\n * @param {$window} Angular window service\r\n * @param {$document} Angular document service\r\n * @param {$log} Angular logger service\r\n * @param {beneficiaryService} Beneficiary service\r\n * @param {companyService} Company service\r\n *\r\n * @ngInject\r\n *\r\n */\r\nvar controller = function() {\r\n    'use strict';\r\n    var ctrl = this;\r\n\r\n};\r\n\r\nexports.controller = controller;\r\n","/**\r\n * Side Nav Component Directive\r\n *\r\n * @ngInject\r\n */\r\nvar directive = function () {\r\n    'use strict';\r\n    return {\r\n        templateUrl: 'app/components/nav/SideNavView.html',\r\n        restrict: 'AE',\r\n        scope: false,\r\n        controllerAs: 'ctrl',\r\n        controller: 'SideNavViewController'\r\n    };\r\n};\r\n\r\nexports.directive = directive;\r\n","var translationsEN = {\n    \"BENEFICIARY\": {\n        \"ID\": \"Id\",\n        \"FIRST_NAME\": \"First name\",\n        \"LAST_NAME\": \"Last name\"\n    }\n};\n\nexports.translationsEN = translationsEN;\n","'use strict';\r\n\r\nvar states = require('./components/common/States');\r\nvar configBlock = {\r\n    /**\r\n     * @param {$logProvider} The log provider service\r\n     * @param {$translateProvider} The angular translate service\r\n     * @ngInject\r\n     */\r\n    settings: [\"$logProvider\", \"$translateProvider\", function($logProvider, $translateProvider) {\r\n        $logProvider.debugEnabled(true); // Turns global logging with $log.debug on\r\n\r\n        var i18n_en = require('./components/nls/i18n-en');\r\n        $translateProvider.useSanitizeValueStrategy('sanitizeParameters');\r\n        $translateProvider.translations('en', i18n_en.translationsEN).useStaticFilesLoader({\r\n                files: [{\r\n                    prefix: './components/nls/i18n-',\r\n                    suffix: '.json'\r\n                }]\r\n            })\r\n            .preferredLanguage('en')\r\n            .fallbackLanguage('en');\r\n    }],\r\n    /**\r\n     * @param {$stateProvider} $stateProvider The UI router stateProvider service\r\n     * @param {$urlRouterProvider} The UI router urlRouterProvider service\r\n     * @param {$modalStateProvider} The custom modal state provider service\r\n     * @ngInject\r\n     */\r\n    states: [\"$stateProvider\", \"$urlRouterProvider\", function($stateProvider, $urlRouterProvider) {\r\n        $urlRouterProvider.otherwise('/');\r\n        $stateProvider\r\n            .state('start', states.stateConfig.main)\r\n            .state('start.company', states.stateConfig.company.initial)\r\n            .state('start.company.list', states.stateConfig.company.list)\r\n            .state('start.company.list.delete',  angular.copy(states.stateConfig.company.delete))\r\n            .state('start.company.search', states.stateConfig.company.search)\r\n            .state('start.company.search.delete', angular.copy(states.stateConfig.company.delete))\r\n            .state('start.company.update', states.stateConfig.company.update)\r\n            .state('start.beneficiary', states.stateConfig.beneficiary.initial)\r\n            .state('start.beneficiary.list', states.stateConfig.beneficiary.list)\r\n            .state('start.beneficiary.list.delete', angular.copy(states.stateConfig.beneficiary.delete))\r\n            .state('start.beneficiary.search', states.stateConfig.beneficiary.search)\r\n            .state('start.beneficiary.search.delete', angular.copy(states.stateConfig.beneficiary.delete))\r\n            .state('start.beneficiary.update', states.stateConfig.beneficiary.update)\r\n    }],\r\n\r\n    /**\r\n     * @param  {blockUIConfig} The block UI config service\r\n     * @ngInject\r\n     */\r\n    blockUI: [\"blockUIConfig\", function(blockUIConfig) {\r\n        blockUIConfig.delay = 100;\r\n        // blockUIConfig.autoBlock = false;\r\n        blockUIConfig.autoInjectBodyBlock = false;\r\n        blockUIConfig.template = '<div id=\"ui-overlay\"><img src=\"dist/images/ajax-loader.gif\" /></h1>';\r\n    }],\r\n\r\n    /**\r\n     * @param  {informProvider} The inform provider service\r\n     * @ngInject\r\n     */\r\n    inform: [\"informProvider\", function(informProvider) {\r\n        informProvider.defaults({\r\n            /**\r\n             * The time to live for the message in milliseconds.\r\n             * Default value is 5000. Specify <0 to make the message sticky.\r\n             */\r\n            ttl: -1,\r\n\r\n            /**\r\n             * The type of message to enable styling.\r\n             * Values can be 'default', 'primary', 'success', 'info', 'warning', 'danger' or any other custom required type.\r\n             * Default value is 'info'. If 'default' is specified as value, then 'info' is used\r\n             */\r\n            type: 'success',\r\n            /**\r\n             * Allow html formatting\r\n             * Default value is false\r\n             */\r\n            html: true\r\n        });\r\n    }],\r\n\r\n    /**\r\n     * Modal block\r\n     * @param  {$rootScope}  Angular root scope service\r\n     * @param  {$modalStack} Angular UI modal stack\r\n     * @ngInject\r\n     */\r\n    modal: [\"$rootScope\", \"$modalStack\", function($rootScope, $modalStack) {\r\n        $rootScope.$on('$stateChangeStart', function() {\r\n            var top = $modalStack.getTop();\r\n            if (top) {\r\n                $modalStack.dismiss(top.key);\r\n            }\r\n        });\r\n    }],\r\n\r\n    /**\r\n     * Href sanitization whitelist\r\n     * @param  {$compileProvide} Angular compile provider service\r\n     * @ngInject\r\n     */\r\n    hrefSanitize: [\"$compileProvider\", function($compileProvider) {\r\n        $compileProvider.aHrefSanitizationWhitelist(/^\\s*(https?|ftp|mailto|file|chrome-extension|blob:chrome-extension):/);\r\n    }],\r\n\r\n    namespace: 'com.companyregistry'\r\n};\r\n\r\nexports.configBlock = configBlock;\r\n","'use strict';\r\n\r\nexports.constants = {\r\n    url: {\r\n\t\t\t\t// path: 'http://localhost:8080/companyregistry',\r\n\t\t\t\tpath: 'https://companyregistry.herokuapp.com',\r\n        companyContextPath: 'companies',\r\n        beneficiaryContextPath: 'beneficiaries'\r\n    }\r\n};\r\n","/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* jshint ignore:start */\nvar noop        = angular.noop;\nvar extend      = angular.extend;\nvar jqLite      = angular.element;\nvar forEach     = angular.forEach;\nvar isArray     = angular.isArray;\nvar isString    = angular.isString;\nvar isObject    = angular.isObject;\nvar isUndefined = angular.isUndefined;\nvar isDefined   = angular.isDefined;\nvar isFunction  = angular.isFunction;\nvar isElement   = angular.isElement;\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar isPromiseLike = function(p) {\n  return p && p.then ? true : false;\n};\n\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return [];\n        break;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n        break;\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType == ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  }\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationOptions(element, target, newOptions) {\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof angular.element) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncancelled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\nvar $$AnimateChildrenDirective = [function() {\n  return function(scope, element, attrs) {\n    var val = attrs.ngAnimateChildren;\n    if (angular.isString(val) && val.length === 0) { //empty attribute\n      element.data(NG_ANIMATE_CHILDREN_DATA, true);\n    } else {\n      attrs.$observe('ngAnimateChildren', function(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      });\n    }\n  };\n}];\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and stlyes may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n * * `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occuring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a colapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\nvar BASE_TEN = 10;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for zegative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) == 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$animate',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $animate) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = \"$$ngAnimateParentKey\";\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an interal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var cancelLastRAFRequest;\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, options) {\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$animate.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle = parseFloat(options.delay);\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) { // jshint ignore:line\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            value ? node.style.setProperty(prop, value)\n                  : node.style.removeProperty(prop);\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        var startTime, events = [];\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              animationPaused\n                  ? temporaryStyles.push(value)\n                  : removeFromArray(temporaryStyles, value);\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidently cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intential stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.className + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== \"boolean\" && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          element.on(events.join(' '), onAnimationProgress);\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n\n        function onAnimationProgress(event) {\n          event.stopPropagation();\n          var ev = event.originalEvent || event;\n          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();\n\n          /* Firefox (or possibly just Gecko) likes to not round values up\n           * when a ms measurement is used for the animation */\n          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n          /* $manualTimeStamp is a mocked timeStamp value which is set\n           * within browserTrigger(). This is only here so that tests can\n           * mock animations properly. Real events fallback to event.timeStamp,\n           * or, if they don't, then a timeStamp is automatically created for them.\n           * We're checking to see if the timeStamp surpasses the expected delay,\n           * but we're using elapsedTime instead of the timeStamp on the 2nd\n           * pre-condition since animations sometimes close off early */\n          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n            // we set this flag to ensure that if the transition is paused then, when resumed,\n            // the animation will automatically close itself since transitions cannot be paused.\n            animationCompleted = true;\n            close();\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragement case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coods object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event == 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      return {\n        start: function() {\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          var animationClosed = false;\n          var runner = new $$AnimateRunner({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            animationClosed = true;\n            applyOptions();\n            applyAnimationStyles(element, options);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a,b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          runners.length ? $$AnimateRunner.all(runners, callback) : callback();\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              reject ? runner.cancel() : runner.end();\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i=0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(element, currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(options, and) {\n    options = options || {};\n    var a = (options.addClass || '').length > 0;\n    var b = (options.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(element, newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event == 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(element, newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(element, newAnimation, currentAnimation) {\n    var nO = newAnimation.options;\n    var cO = currentAnimation.options;\n\n    // if the exact same CSS class is added/removed then it's safe to cancel it\n    return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {\n\n    var activeAnimationsLookup = new $$HashMap();\n    var disabledElementsLookup = new $$HashMap();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = {};\n\n    // remember that the classNameFilter is set during the provider/config\n    // stage therefore we can optimize here and setup a helper function\n    var classNameFilter = $animateProvider.classNameFilter();\n    var isAnimatableClassName = !classNameFilter\n              ? function() { return true; }\n              : function(className) {\n                return classNameFilter.test(className);\n              };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationOptions(element, options) {\n      return mergeAnimationOptions(element, options, {});\n    }\n\n    function findCallbacks(element, event) {\n      var targetNode = getDomNode(element);\n\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (entry.node.contains(targetNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    return {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n      },\n\n      off: function(event, container, callback) {\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n\n        function filterFromRegistry(list, matchContainer, matchCallback) {\n          var containerNode = extractElementNode(matchContainer);\n          return list.filter(function(entry) {\n            var isMatch = entry.node === containerNode &&\n                            (!matchCallback || entry.callback === matchCallback);\n            return !isMatch;\n          });\n        }\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n            var recordExists = disabledElementsLookup.get(node);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !recordExists;\n            } else {\n              // (element, bool) - Element setter\n              bool = !!bool;\n              if (!bool) {\n                disabledElementsLookup.put(node, true);\n              } else if (recordExists) {\n                disabledElementsLookup.remove(node);\n              }\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    function queueAnimation(element, event, options) {\n      var node, parent;\n      element = stripCommentsFromElement(element);\n      if (element) {\n        node = getDomNode(element);\n        parent = element.parent();\n      }\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // there are situations where a directive issues an animation for\n      // a jqLite wrapper that contains only comment nodes... If this\n      // happens then there is no way we can perform an animation\n      if (!node) {\n        close();\n        return runner;\n      }\n\n      var className = [node.className, options.addClass, options.removeClass].join(' ');\n      if (!isAnimatableClassName(className)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // this is a hard disable of all animations for the application or on\n      // the element itself, therefore  there is no need to continue further\n      // past this point if not enabled\n      var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(element, parent, event);\n      }\n\n      if (skipAnimations) {\n        close();\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(element);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationOptions(element, existingAnimation.options, options);\n            return existingAnimation.runner;\n          }\n        }\n\n        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationOptions(element, options);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationOptions(element, options);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation.options);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(element);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails.options));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(element);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(element, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(getDomNode(element));\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(element, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n            });\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) { // jshint ignore:line\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(element) {\n      var node = getDomNode(element);\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));\n        var animationDetails = activeAnimationsLookup.get(child);\n        switch (state) {\n          case RUNNING_STATE:\n            animationDetails.runner.end();\n            /* falls through */\n          case PRE_DIGEST_STATE:\n            if (animationDetails) {\n              activeAnimationsLookup.remove(child);\n            }\n            break;\n        }\n      });\n    }\n\n    function clearElementAnimationState(element) {\n      var node = getDomNode(element);\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.remove(node);\n    }\n\n    function isMatchingElement(nodeOrElmA, nodeOrElmB) {\n      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);\n    }\n\n    function areAnimationsAllowed(element, parentElement, event) {\n      var bodyElement = jqLite($document[0].body);\n      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';\n      var rootElementDetected = isMatchingElement(element, $rootElement);\n      var parentAnimationDetected = false;\n      var animateChildren;\n\n      var parentHost = element.data(NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentElement = parentHost;\n      }\n\n      while (parentElement && parentElement.length) {\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n        }\n\n        var parentNode = parentElement[0];\n        if (parentNode.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentNode) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!rootElementDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootElementDetected = isMatchingElement(parentElement, $rootElement);\n          if (!rootElementDetected) {\n            parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);\n            if (parentHost) {\n              parentElement = parentHost;\n            }\n          }\n        }\n\n        if (!bodyElementDetected) {\n          // we also need to ensure that the element is or will be apart of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyElementDetected = isMatchingElement(parentElement, bodyElement);\n        }\n\n        parentElement = parentElement.parent();\n      }\n\n      var allowAnimation = !parentAnimationDetected || animateChildren;\n      return allowAnimation && rootElementDetected && bodyElementDetected;\n    }\n\n    function markElementAnimationState(element, state, details) {\n      details = details || {};\n      details.state = state;\n\n      var node = getDomNode(element);\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.put(node, newValue);\n    }\n  }];\n}];\n\nvar $$AnimateAsyncRunFactory = ['$$rAF', function($$rAF) {\n  var waitQueue = [];\n\n  function waitForTick(fn) {\n    waitQueue.push(fn);\n    if (waitQueue.length > 1) return;\n    $$rAF(function() {\n      for (var i = 0; i < waitQueue.length; i++) {\n        waitQueue[i]();\n      }\n      waitQueue = [];\n    });\n  }\n\n  return function() {\n    var passed = false;\n    waitForTick(function() {\n      passed = true;\n    });\n    return function(callback) {\n      passed ? callback() : waitForTick(callback);\n    };\n  };\n}];\n\nvar $$AnimateRunnerFactory = ['$q', '$sniffer', '$$animateAsyncRun',\n                      function($q,   $sniffer,   $$animateAsyncRun) {\n\n  var INITIAL_STATE = 0;\n  var DONE_PENDING_STATE = 1;\n  var DONE_COMPLETE_STATE = 2;\n\n  AnimateRunner.chain = function(chain, callback) {\n    var index = 0;\n\n    next();\n    function next() {\n      if (index === chain.length) {\n        callback(true);\n        return;\n      }\n\n      chain[index](function(response) {\n        if (response === false) {\n          callback(false);\n          return;\n        }\n        index++;\n        next();\n      });\n    }\n  };\n\n  AnimateRunner.all = function(runners, callback) {\n    var count = 0;\n    var status = true;\n    forEach(runners, function(runner) {\n      runner.done(onProgress);\n    });\n\n    function onProgress(response) {\n      status = status && response;\n      if (++count === runners.length) {\n        callback(status);\n      }\n    }\n  };\n\n  function AnimateRunner(host) {\n    this.setHost(host);\n\n    this._doneCallbacks = [];\n    this._runInAnimationFrame = $$animateAsyncRun();\n    this._state = 0;\n  }\n\n  AnimateRunner.prototype = {\n    setHost: function(host) {\n      this.host = host || {};\n    },\n\n    done: function(fn) {\n      if (this._state === DONE_COMPLETE_STATE) {\n        fn();\n      } else {\n        this._doneCallbacks.push(fn);\n      }\n    },\n\n    progress: noop,\n\n    getPromise: function() {\n      if (!this.promise) {\n        var self = this;\n        this.promise = $q(function(resolve, reject) {\n          self.done(function(status) {\n            status === false ? reject() : resolve();\n          });\n        });\n      }\n      return this.promise;\n    },\n\n    then: function(resolveHandler, rejectHandler) {\n      return this.getPromise().then(resolveHandler, rejectHandler);\n    },\n\n    'catch': function(handler) {\n      return this.getPromise()['catch'](handler);\n    },\n\n    'finally': function(handler) {\n      return this.getPromise()['finally'](handler);\n    },\n\n    pause: function() {\n      if (this.host.pause) {\n        this.host.pause();\n      }\n    },\n\n    resume: function() {\n      if (this.host.resume) {\n        this.host.resume();\n      }\n    },\n\n    end: function() {\n      if (this.host.end) {\n        this.host.end();\n      }\n      this._resolve(true);\n    },\n\n    cancel: function() {\n      if (this.host.cancel) {\n        this.host.cancel();\n      }\n      this._resolve(false);\n    },\n\n    complete: function(response) {\n      var self = this;\n      if (self._state === INITIAL_STATE) {\n        self._state = DONE_PENDING_STATE;\n        self._runInAnimationFrame(function() {\n          self._resolve(response);\n        });\n      }\n    },\n\n    _resolve: function(response) {\n      if (this._state !== DONE_COMPLETE_STATE) {\n        forEach(this._doneCallbacks, function(fn) {\n          fn(response);\n        });\n        this._doneCallbacks.length = 0;\n        this._state = DONE_COMPLETE_STATE;\n      }\n    }\n  };\n\n  return AnimateRunner;\n}];\n\nvar $$AnimationProvider = ['$animateProvider', function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$HashMap();\n\n      // this is done first beforehand so that the hashmap\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.put(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.put(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effictively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check\n\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          getRunner(element).setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) { // jshint ignore:line\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/* global angularAnimateModule: true,\n\n   $$AnimateAsyncRunFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateRunnerFactory,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,\n*/\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=true\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the ainmation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       }).start();\n*        runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var runner = $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       }).start();\n *\n *       runner.done(doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n *\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix\n * will be evaluated for animation when any DOM changes occur in the application.\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [])\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .factory('$$AnimateRunner', $$AnimateRunnerFactory)\n  .factory('$$animateAsyncRun', $$AnimateAsyncRunFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n","require('./angular-animate');\nmodule.exports = 'ngAnimate';\n","/*!\n   angular-block-ui v0.2.0\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\n   License: MIT\n*/\n(function(angular) {\n\nvar blkUI = angular.module('blockUI', []);\n\nblkUI.config([\"$provide\", \"$httpProvider\", function ($provide, $httpProvider) {\n\n  $provide.decorator('$exceptionHandler', ['$delegate', '$injector',\n    function ($delegate, $injector) {\n      var blockUI, blockUIConfig;\n\n      return function (exception, cause) {\n\n        blockUIConfig = blockUIConfig || $injector.get('blockUIConfig');\n\n        if (blockUIConfig.resetOnException) {\n          try {\n            blockUI = blockUI || $injector.get('blockUI');\n            blockUI.instances.reset();\n          } catch (ex) {\n            console.log('$exceptionHandler', exception);\n          }\n        }\n\n        $delegate(exception, cause);\n      };\n    }\n  ]);\n\n  $httpProvider.interceptors.push('blockUIHttpInterceptor');\n}]);\n\nblkUI.run([\"$document\", \"blockUIConfig\", \"$templateCache\", function ($document, blockUIConfig, $templateCache) {\n  if (blockUIConfig.autoInjectBodyBlock) {\n    $document.find('body').attr('block-ui', 'main');\n  }\n\n  if (blockUIConfig.template) {\n\n    // Swap the builtin template with the custom template.\n    // Create a magic cache key and place the template in the cache.\n\n    blockUIConfig.templateUrl = '$$block-ui-template$$';\n    $templateCache.put(blockUIConfig.templateUrl, blockUIConfig.template);\n  }\n}]);\n\nfunction moduleLoaded(name) {\n  try {\n    angular.module(name);\n  } catch(ex) {\n    return false;\n  }\n  return true;\n}\nblkUI.config([\"$provide\", function ($provide) {\n  $provide.decorator('$location', decorateLocation);\n}]);\n\nvar decorateLocation = [\n  '$delegate', 'blockUI', 'blockUIConfig',\n  function ($delegate, blockUI, blockUIConfig) {\n\n    if (blockUIConfig.blockBrowserNavigation) {\n\n      blockUI.$_blockLocationChange = true;\n\n      var overrides = ['url', 'path', 'search', 'hash', 'state'];\n\n      function hook(f) {\n        var s = $delegate[f];\n        $delegate[f] = function () {\n\n          //        console.log(f, Date.now(), arguments);\n\n          var result = s.apply($delegate, arguments);\n\n          // The call was a setter if the $location service is returned.\n\n          if (result === $delegate) {\n\n            // Mark the mainblock ui to allow the location change.\n\n            blockUI.$_blockLocationChange = false;\n          }\n\n          return result;\n        };\n      }\n\n      angular.forEach(overrides, hook);\n\n    }\n\n    return $delegate;\n}];\n\n// Called from block-ui-directive for the 'main' instance.\n\nfunction blockNavigation($scope, mainBlockUI, blockUIConfig) {\n\n  if (blockUIConfig.blockBrowserNavigation) {\n\n    function registerLocationChange() {\n\n      $scope.$on('$locationChangeStart', function (event) {\n\n        //        console.log('$locationChangeStart', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);\n\n        if (mainBlockUI.$_blockLocationChange && mainBlockUI.state().blockCount > 0) {\n          event.preventDefault();\n        }\n      });\n\n      $scope.$on('$locationChangeSuccess', function () {\n        mainBlockUI.$_blockLocationChange = blockUIConfig.blockBrowserNavigation;\n\n        //        console.log('$locationChangeSuccess', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);\n      });\n    }\n\n    if (moduleLoaded('ngRoute')) {\n\n      // After the initial content has been loaded we'll spy on any location\n      // changes and discard them when needed.\n\n      var fn = $scope.$on('$viewContentLoaded', function () {\n\n        // Unhook the view loaded and hook a function that will prevent\n        // location changes while the block is active.\n\n        fn();\n        registerLocationChange();\n\n      });\n\n    } else {\n      registerLocationChange();\n    }\n\n  }\n}\nblkUI.directive('blockUiContainer', [\"blockUIConfig\", \"blockUiContainerLinkFn\", function (blockUIConfig, blockUiContainerLinkFn) {\n  return {\n    scope: true,\n    restrict: 'A',\n    templateUrl: blockUIConfig.templateUrl,\n    compile: function($element) {\n      return blockUiContainerLinkFn;\n    }\n  };\n}]).factory('blockUiContainerLinkFn', [\"blockUI\", \"blockUIUtils\", function (blockUI, blockUIUtils) {\n\n  return function ($scope, $element, $attrs) {\n\n    var srvInstance = $element.inheritedData('block-ui');\n\n    if (!srvInstance) {\n      throw new Error('No parent block-ui service instance located.');\n    }\n\n    // Expose the state on the scope\n\n    $scope.state = srvInstance.state();\n\n//    $scope.$watch('state.blocking', function(value) {\n//      $element.toggleClass('block-ui-visible', !!value);\n//    });\n//\n//    $scope.$watch('state.blockCount > 0', function(value) {\n//      $element.toggleClass('block-ui-active', !!value);\n//    });\n  };\n}]);\nblkUI.directive('blockUi', [\"blockUiCompileFn\", function (blockUiCompileFn) {\n\n  return {\n    scope: true,\n    restrict: 'A',\n    compile: blockUiCompileFn\n  };\n\n}]).factory('blockUiCompileFn', [\"blockUiPreLinkFn\", function (blockUiPreLinkFn) {\n\n  return function ($element, $attrs) {\n\n    // Class should be added here to prevent an animation delay error.\n\n    $element.append('<div block-ui-container class=\"block-ui-container\"></div>');\n\n    return {\n      pre: blockUiPreLinkFn\n    };\n\n  };\n\n}]).factory('blockUiPreLinkFn', [\"blockUI\", \"blockUIUtils\", \"blockUIConfig\", function (blockUI, blockUIUtils, blockUIConfig) {\n\n  return function ($scope, $element, $attrs) {\n\n    // If the element does not have the class \"block-ui\" set, we set the\n    // default css classes from the config.\n\n    if (!$element.hasClass('block-ui')) {\n      $element.addClass(blockUIConfig.cssClass);\n    }\n\n    // Expose the blockUiMessageClass attribute value on the scope\n\n    $attrs.$observe('blockUiMessageClass', function (value) {\n      $scope.$_blockUiMessageClass = value;\n    });\n\n    // Create the blockUI instance\n    // Prefix underscore to prevent integers:\n    // https://github.com/McNull/angular-block-ui/pull/8\n\n    var instanceId = $attrs.blockUi || '_' + $scope.$id;\n    var srvInstance = blockUI.instances.get(instanceId);\n\n    // If this is the main (topmost) block element we'll also need to block any\n    // location changes while the block is active.\n\n    if (instanceId === 'main') {\n      blockNavigation($scope, srvInstance, blockUIConfig);\n    } else {\n      // Locate the parent blockUI instance\n      var parentInstance = $element.inheritedData('block-ui');\n\n      if (parentInstance) {\n        // TODO: assert if parent is already set to something else\n        srvInstance._parent = parentInstance;\n      }\n    }\n\n    // Ensure the instance is released when the scope is destroyed\n\n    $scope.$on('$destroy', function () {\n      srvInstance.release();\n    });\n\n    // Increase the reference count\n\n    srvInstance.addRef();\n\n    // Expose the state on the scope\n\n    $scope.$_blockUiState = srvInstance.state();\n\n    $scope.$watch('$_blockUiState.blocking', function (value) {\n      // Set the aria-busy attribute if needed\n      $element.attr('aria-busy', !!value);\n      $element.toggleClass('block-ui-visible', !!value);\n    });\n\n    $scope.$watch('$_blockUiState.blockCount > 0', function (value) {\n      $element.toggleClass('block-ui-active', !!value);\n    });\n\n    // If a pattern is provided assign it to the state\n\n    var pattern = $attrs.blockUiPattern;\n\n    if (pattern) {\n      var regExp = blockUIUtils.buildRegExp(pattern);\n      srvInstance.pattern(regExp);\n    }\n\n    // Store a reference to the service instance on the element\n\n    $element.data('block-ui', srvInstance);\n\n  };\n\n}]);\n//.factory('blockUiPostLinkFn', function(blockUIUtils) {\n//\n//  return function($scope, $element, $attrs) {\n//\n//    var $message;\n//\n//    $attrs.$observe('blockUiMessageClass', function(value) {\n//\n//      $message = $message || blockUIUtils.findElement($element, function($e) {\n//        return $e.hasClass('block-ui-message');\n//      });\n//\n//      $message.addClass(value);\n//\n//    });\n//  };\n//\n//});\nblkUI.constant('blockUIConfig', {\n    templateUrl: 'angular-block-ui/angular-block-ui.ng.html',\n    delay: 250,\n    message: \"Loading ...\",\n    autoBlock: true,\n    resetOnException: true,\n    requestFilter: angular.noop,\n    autoInjectBodyBlock: true,\n    cssClass: 'block-ui block-ui-anim-fade',\n    blockBrowserNavigation: false\n});\n\n\nblkUI.factory('blockUIHttpInterceptor', [\"$q\", \"$injector\", \"blockUIConfig\", \"$templateCache\", function($q, $injector, blockUIConfig, $templateCache) {\n\n  var blockUI;\n\n  function injectBlockUI() {\n    blockUI = blockUI || $injector.get('blockUI');\n  }\n\n  function stopBlockUI(config) {\n    if (blockUIConfig.autoBlock && (config && !config.$_noBlock && config.$_blocks)) {\n      injectBlockUI();\n      config.$_blocks.stop();\n    }\n  }\n\n  function error(rejection) {\n\n    try {\n      stopBlockUI(rejection.config);\n    } catch(ex) {\n      console.log('httpRequestError', ex);\n    }\n\n    return $q.reject(rejection);\n  }\n\n  return {\n    request: function(config) {\n\n      // Only block when autoBlock is enabled ...\n      // ... and the request doesn't match a cached template.\n\n      if (blockUIConfig.autoBlock &&\n        !(config.method == 'GET' && $templateCache.get(config.url))) {\n\n        // Don't block excluded requests\n\n        var result = blockUIConfig.requestFilter(config);\n\n        if (result === false) {\n          // Tag the config so we don't unblock this request\n          config.$_noBlock = true;\n        } else {\n\n          injectBlockUI();\n\n          config.$_blocks = blockUI.instances.locate(config);\n          config.$_blocks.start(result);\n        }\n      }\n\n      return config;\n    },\n\n    requestError: error,\n\n    response: function(response) {\n\n      // If the connection to the website goes down the response interceptor gets and error with \"cannot read property config of null\".\n      // https://github.com/McNull/angular-block-ui/issues/53\n\n      if(response) {\n        stopBlockUI(response.config);\n      }\n\n      return response;\n    },\n\n    responseError: error\n  };\n\n}]);\n\nblkUI.factory('blockUI', [\"blockUIConfig\", \"$timeout\", \"blockUIUtils\", \"$document\", function(blockUIConfig, $timeout, blockUIUtils, $document) {\n\n  var $body = $document.find('body');\n\n  function BlockUI(id) {\n\n    var self = this;\n\n    var state = {\n      id: id,\n      blockCount: 0,\n      message: blockUIConfig.message,\n      blocking: false\n    }, startPromise, doneCallbacks = [];\n\n    this._id = id;\n\n    this._refs = 0;\n\n    this.start = function(message) {\n\n      if(state.blockCount > 0) {\n        message = message || state.message || blockUIConfig.message;\n      } else {\n        message = message || blockUIConfig.message;\n      }\n\n      state.message = message;\n\n      state.blockCount++;\n\n      // Check if the focused element is part of the block scope\n\n      var $ae = angular.element($document[0].activeElement);\n\n      if($ae.length && blockUIUtils.isElementInBlockScope($ae, self)) {\n\n        // Let the active element lose focus and store a reference \n        // to restore focus when we're done (reset)\n\n        self._restoreFocus = $ae[0];\n\n        // https://github.com/McNull/angular-block-ui/issues/13\n        // http://stackoverflow.com/questions/22698058/apply-already-in-progress-error-when-using-typeahead-plugin-found-to-be-relate\n        // Queue the blur after any ng-blur expression.\n\n        $timeout(function() {\n          // Ensure we still need to blur\n          if(self._restoreFocus) {\n            self._restoreFocus.blur();\n          }\n        });\n      }\n\n      if (!startPromise) {\n        startPromise = $timeout(function() {\n          startPromise = null;\n          state.blocking = true;\n        }, blockUIConfig.delay);\n      }\n    };\n\n    this._cancelStartTimeout = function() {\n      if (startPromise) {\n        $timeout.cancel(startPromise);\n        startPromise = null;\n      }\n    };\n\n    this.stop = function() {\n      state.blockCount = Math.max(0, --state.blockCount);\n\n      if (state.blockCount === 0) {\n        self.reset(true);\n      }\n    };\n\n    this.message = function(value) {\n      state.message = value;\n    };\n\n    this.pattern = function(regexp) {\n      if (regexp !== undefined) {\n        self._pattern = regexp;\n      }\n\n      return self._pattern;\n    };\n\n    this.reset = function(executeCallbacks) {\n      \n      self._cancelStartTimeout();\n      state.blockCount = 0;\n      state.blocking = false;\n\n      // Restore the focus to the element that was active\n      // before the block start, but not if the user has \n      // focused something else while the block was active.\n\n      if(self._restoreFocus && \n         (!$document[0].activeElement || $document[0].activeElement === $body[0])) {\n        self._restoreFocus.focus();\n        self._restoreFocus = null;\n      }\n      \n      try {\n        if (executeCallbacks) {\n          angular.forEach(doneCallbacks, function(cb) {\n            cb();\n          });\n        }\n      } finally {\n        doneCallbacks.length = 0;\n      }\n    };\n\n    this.done = function(fn) {\n      doneCallbacks.push(fn);\n    };\n\n    this.state = function() {\n      return state;\n    };\n\n    this.addRef = function() {\n      self._refs += 1;\n    };\n\n    this.release = function() {\n      if(--self._refs <= 0) {\n        mainBlock.instances._destroy(self);\n      }\n    };\n  }\n\n  var instances = [];\n\n  instances.get = function(id) {\n\n    if(!isNaN(id)) {\n      throw new Error('BlockUI id cannot be a number');\n    }\n\n    var instance = instances[id];\n\n    if(!instance) {\n      // TODO: ensure no array instance trashing [xxx] -- current workaround: '_' + $scope.$id\n      instance = instances[id] = new BlockUI(id);\n      instances.push(instance);\n    }\n\n    return instance;\n  };\n\n  instances._destroy = function(idOrInstance) {\n    if (angular.isString(idOrInstance)) {\n      idOrInstance = instances[idOrInstance];\n    }\n\n    if (idOrInstance) {\n      idOrInstance.reset();\n\n      var i = blockUIUtils.indexOf(instances, idOrInstance);\n      instances.splice(i, 1);\n\n      delete instances[idOrInstance.state().id];\n    }\n  };\n  \n  instances.locate = function(request) {\n\n    var result = [];\n\n    // Add function wrappers that will be executed on every item\n    // in the array.\n    \n    blockUIUtils.forEachFnHook(result, 'start');\n    blockUIUtils.forEachFnHook(result, 'stop');\n\n    var i = instances.length;\n\n    while(i--) {\n      var instance = instances[i];\n      var pattern = instance._pattern;\n\n      if(pattern && pattern.test(request.url)) {\n        result.push(instance);\n      }\n    }\n\n    if(result.length === 0) {\n      result.push(mainBlock);\n    }\n\n    return result;\n  };\n\n  // Propagate the reset to all instances\n\n  blockUIUtils.forEachFnHook(instances, 'reset');\n\n  var mainBlock = instances.get('main');\n\n  mainBlock.addRef();\n  mainBlock.instances = instances;\n\n  return mainBlock;\n}]);\n\n\nblkUI.factory('blockUIUtils', function() {\n\n  var $ = angular.element;\n\n  var utils = {\n    buildRegExp: function(pattern) {\n      var match = pattern.match(/^\\/(.*)\\/([gim]*)$/), regExp;\n\n      if(match) {\n        regExp = new RegExp(match[1], match[2]);\n      } else {\n        throw Error('Incorrect regular expression format: ' + pattern);\n      }\n\n      return regExp;\n    },\n    forEachFn: function(arr, fnName, args) {\n      var i = arr.length;\n      while(i--) {\n        var t = arr[i];\n        t[fnName].apply(t, args);\n      }\n    },\n    forEachFnHook: function(arr, fnName) {\n      arr[fnName] = function() {\n        utils.forEachFn(this, fnName, arguments);\n      }\n    },\n    isElementInBlockScope: function($element, blockScope) {\n      var c = $element.inheritedData('block-ui');\n\n      while(c) {\n        if(c === blockScope) {\n          return true;\n        }\n\n        c = c._parent;\n      }\n\n      return false;\n    },\n    findElement: function ($element, predicateFn, traverse) {\n      var ret = null;\n\n      if (predicateFn($element)) {\n        ret = $element;\n      } else {\n\n        var $elements;\n\n        if (traverse) {\n          $elements = $element.parent();\n        } else {\n          $elements = $element.children();\n        }\n\n        var i = $elements.length;\n        while (!ret && i--) {\n          ret = utils.findElement($($elements[i]), predicateFn, traverse);\n        }\n      }\n\n      return ret;\n    },\n    indexOf: function(arr, obj, start) {\n//      if(Array.prototype.indexOf) {\n//        return arr.indexOf(obj, start);\n//      }\n\n      for (var i = (start || 0), j = arr.length; i < j; i++) {\n        if (arr[i] === obj) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  };\n\n  return utils;\n\n});\n// Automatically generated.\n// This file is already embedded in your main javascript output, there's no need to include this file\n// manually in the index.html. This file is only here for your debugging pleasures.\nangular.module('blockUI').run(['$templateCache', function($templateCache){\n  $templateCache.put('angular-block-ui/angular-block-ui.ng.html', '<div class=\\\"block-ui-overlay\\\"></div><div class=\\\"block-ui-message-container\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\"><div class=\\\"block-ui-message\\\" ng-class=\\\"$_blockUiMessageClass\\\">{{ state.message }}</div></div>');\n}]);\n})(angular);\nif (typeof module !== \"undefined\") module.exports = \"blockUI\";\n//# sourceMappingURL=angular-block-ui.js.map\n","var css = \"/*!\\n   angular-block-ui v0.2.0\\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\\n   License: MIT\\n*/\\n.block-ui {\\n  position: relative;\\n}\\nbody.block-ui {\\n  position: static;\\n}\\n.block-ui-main>.block-ui-container,\\nbody.block-ui>.block-ui-container {\\n  position: fixed;\\n}\\n.block-ui-container {\\n  position: absolute;\\n  z-index: 10000;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  left: 0;\\n  height: 0;\\n  overflow: hidden;\\n  opacity: 0;\\n  filter: alpha(opacity=00);\\n}\\n.block-ui-active>.block-ui-container {\\n  height: 100%;\\n  cursor: wait;\\n}\\n.block-ui-active .block-ui-active>.block-ui-container {\\n  height: 0;\\n}\\n.block-ui-visible>.block-ui-container {\\n  opacity: 1;\\n  filter: alpha(opacity=100);\\n}\\n.block-ui-overlay {\\n  width: 100%;\\n  height: 100%;\\n  opacity: .5;\\n  filter: alpha(opacity=50);\\n  background-color: #fff;\\n}\\n.block-ui-message-container {\\n  position: absolute;\\n  top: 35%;\\n  left: 0;\\n  right: 0;\\n  height: 0;\\n  text-align: center;\\n  z-index: 10001;\\n}\\n.block-ui-message {\\n  display: inline-block;\\n  text-align: left;\\n  background-color: #333;\\n  color: #f5f5f5;\\n  padding: 20px;\\n  border-radius: 4px;\\n  font-size: 20px;\\n  font-weight: 700;\\n  filter: alpha(opacity=100);\\n}\\n.block-ui-anim-fade>.block-ui-container {\\n  -webkit-transition: height 0s linear 200ms,opacity 200ms ease 0s;\\n  transition: height 0s linear 200ms,opacity 200ms ease 0s;\\n}\\n.block-ui-anim-fade.block-ui-active>.block-ui-container {\\n  -webkit-transition-delay: 0s;\\n  transition-delay: 0s;\\n}\\n\"; (require(\"browserify-css\").createStyle(css, { \"href\": \"node_modules\\\\angular-block-ui\\\\dist\\\\angular-block-ui.min.css\"})); module.exports = css;","/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $sanitizeMinErr = angular.$$minErr('$sanitize');\n\n/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n\n/*\n * HTML Parser By Misko Hevery (misko@hevery.com)\n * based on:  HTML Parser By John Resig (ejohn.org)\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n *\n * // Use like so:\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n */\n\n\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string, however, since our parser is more strict than a typical browser\n *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a\n *   browser, won't make it through the sanitizer. The input may also contain SVG markup.\n *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and\n *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getInnerHtml()).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\nfunction $SanitizeProvider() {\n  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n    return function(html) {\n      var buf = [];\n      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n        return !/^unsafe/.test($$sanitizeUri(uri, isImage));\n      }));\n      return buf.join('');\n    };\n  }];\n}\n\nfunction sanitizeText(chars) {\n  var buf = [];\n  var writer = htmlSanitizeWriter(buf, angular.noop);\n  writer.chars(chars);\n  return buf.join('');\n}\n\n\n// Regular Expressions for parsing tags and attributes\nvar START_TAG_REGEXP =\n       /^<((?:[a-zA-Z])[\\w:-]*)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)\\s*(>?)/,\n  END_TAG_REGEXP = /^<\\/\\s*([\\w:-]+)[^>]*>/,\n  ATTR_REGEXP = /([\\w:-]+)(?:\\s*=\\s*(?:(?:\"((?:[^\"])*)\")|(?:'((?:[^'])*)')|([^>\\s]+)))?/g,\n  BEGIN_TAG_REGEXP = /^</,\n  BEGING_END_TAGE_REGEXP = /^<\\//,\n  COMMENT_REGEXP = /<!--(.*?)-->/g,\n  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,\n  CDATA_REGEXP = /<!\\[CDATA\\[(.*?)]]>/g,\n  SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n  // Match everything outside of normal chars and \" (quote character)\n  NON_ALPHANUMERIC_REGEXP = /([^\\#-~| |!])/g;\n\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\nvar voidElements = makeMap(\"area,br,col,hr,img,wbr\");\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\nvar optionalEndTagBlockElements = makeMap(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),\n    optionalEndTagInlineElements = makeMap(\"rp,rt\"),\n    optionalEndTagElements = angular.extend({},\n                                            optionalEndTagInlineElements,\n                                            optionalEndTagBlockElements);\n\n// Safe Block Elements - HTML5\nvar blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap(\"address,article,\" +\n        \"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,\" +\n        \"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul\"));\n\n// Inline Elements - HTML5\nvar inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap(\"a,abbr,acronym,b,\" +\n        \"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,\" +\n        \"samp,small,span,strike,strong,sub,sup,time,tt,u,var\"));\n\n// SVG Elements\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n// They can potentially allow for arbitrary javascript to be executed. See #11290\nvar svgElements = makeMap(\"circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,\" +\n        \"hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,\" +\n        \"radialGradient,rect,stop,svg,switch,text,title,tspan,use\");\n\n// Special Elements (can contain anything)\nvar specialElements = makeMap(\"script,style\");\n\nvar validElements = angular.extend({},\n                                   voidElements,\n                                   blockElements,\n                                   inlineElements,\n                                   optionalEndTagElements,\n                                   svgElements);\n\n//Attributes that have href and hence need to be sanitized\nvar uriAttrs = makeMap(\"background,cite,href,longdesc,src,usemap,xlink:href\");\n\nvar htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n    'valign,value,vspace,width');\n\n// SVG attributes (without \"id\" and \"name\" attributes)\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\nvar svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +\n    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\nvar validAttrs = angular.extend({},\n                                uriAttrs,\n                                svgAttrs,\n                                htmlAttrs);\n\nfunction makeMap(str, lowercaseKeys) {\n  var obj = {}, items = str.split(','), i;\n  for (i = 0; i < items.length; i++) {\n    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;\n  }\n  return obj;\n}\n\n\n/**\n * @example\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n * @param {string} html string\n * @param {object} handler\n */\nfunction htmlParser(html, handler) {\n  if (typeof html !== 'string') {\n    if (html === null || typeof html === 'undefined') {\n      html = '';\n    } else {\n      html = '' + html;\n    }\n  }\n  var index, chars, match, stack = [], last = html, text;\n  stack.last = function() { return stack[stack.length - 1]; };\n\n  while (html) {\n    text = '';\n    chars = true;\n\n    // Make sure we're not in a script or style element\n    if (!stack.last() || !specialElements[stack.last()]) {\n\n      // Comment\n      if (html.indexOf(\"<!--\") === 0) {\n        // comments containing -- are not allowed unless they terminate the comment\n        index = html.indexOf(\"--\", 4);\n\n        if (index >= 0 && html.lastIndexOf(\"-->\", index) === index) {\n          if (handler.comment) handler.comment(html.substring(4, index));\n          html = html.substring(index + 3);\n          chars = false;\n        }\n      // DOCTYPE\n      } else if (DOCTYPE_REGEXP.test(html)) {\n        match = html.match(DOCTYPE_REGEXP);\n\n        if (match) {\n          html = html.replace(match[0], '');\n          chars = false;\n        }\n      // end tag\n      } else if (BEGING_END_TAGE_REGEXP.test(html)) {\n        match = html.match(END_TAG_REGEXP);\n\n        if (match) {\n          html = html.substring(match[0].length);\n          match[0].replace(END_TAG_REGEXP, parseEndTag);\n          chars = false;\n        }\n\n      // start tag\n      } else if (BEGIN_TAG_REGEXP.test(html)) {\n        match = html.match(START_TAG_REGEXP);\n\n        if (match) {\n          // We only have a valid start-tag if there is a '>'.\n          if (match[4]) {\n            html = html.substring(match[0].length);\n            match[0].replace(START_TAG_REGEXP, parseStartTag);\n          }\n          chars = false;\n        } else {\n          // no ending tag found --- this piece should be encoded as an entity.\n          text += '<';\n          html = html.substring(1);\n        }\n      }\n\n      if (chars) {\n        index = html.indexOf(\"<\");\n\n        text += index < 0 ? html : html.substring(0, index);\n        html = index < 0 ? \"\" : html.substring(index);\n\n        if (handler.chars) handler.chars(decodeEntities(text));\n      }\n\n    } else {\n      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\\W\\w].\n      html = html.replace(new RegExp(\"([\\\\W\\\\w]*)<\\\\s*\\\\/\\\\s*\" + stack.last() + \"[^>]*>\", 'i'),\n        function(all, text) {\n          text = text.replace(COMMENT_REGEXP, \"$1\").replace(CDATA_REGEXP, \"$1\");\n\n          if (handler.chars) handler.chars(decodeEntities(text));\n\n          return \"\";\n      });\n\n      parseEndTag(\"\", stack.last());\n    }\n\n    if (html == last) {\n      throw $sanitizeMinErr('badparse', \"The sanitizer was unable to parse the following block \" +\n                                        \"of html: {0}\", html);\n    }\n    last = html;\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function parseStartTag(tag, tagName, rest, unary) {\n    tagName = angular.lowercase(tagName);\n    if (blockElements[tagName]) {\n      while (stack.last() && inlineElements[stack.last()]) {\n        parseEndTag(\"\", stack.last());\n      }\n    }\n\n    if (optionalEndTagElements[tagName] && stack.last() == tagName) {\n      parseEndTag(\"\", tagName);\n    }\n\n    unary = voidElements[tagName] || !!unary;\n\n    if (!unary) {\n      stack.push(tagName);\n    }\n\n    var attrs = {};\n\n    rest.replace(ATTR_REGEXP,\n      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {\n        var value = doubleQuotedValue\n          || singleQuotedValue\n          || unquotedValue\n          || '';\n\n        attrs[name] = decodeEntities(value);\n    });\n    if (handler.start) handler.start(tagName, attrs, unary);\n  }\n\n  function parseEndTag(tag, tagName) {\n    var pos = 0, i;\n    tagName = angular.lowercase(tagName);\n    if (tagName) {\n      // Find the closest opened tag of the same type\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos] == tagName) break;\n      }\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (i = stack.length - 1; i >= pos; i--)\n        if (handler.end) handler.end(stack[i]);\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n    }\n  }\n}\n\nvar hiddenPre=document.createElement(\"pre\");\n/**\n * decodes all entities into regular string\n * @param value\n * @returns {string} A string with decoded entities.\n */\nfunction decodeEntities(value) {\n  if (!value) { return ''; }\n\n  hiddenPre.innerHTML = value.replace(/</g,\"&lt;\");\n  // innerText depends on styling as it doesn't display hidden elements.\n  // Therefore, it's better to use textContent not to cause unnecessary reflows.\n  return hiddenPre.textContent;\n}\n\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n * @returns {string} escaped text\n */\nfunction encodeEntities(value) {\n  return value.\n    replace(/&/g, '&amp;').\n    replace(SURROGATE_PAIR_REGEXP, function(value) {\n      var hi = value.charCodeAt(0);\n      var low = value.charCodeAt(1);\n      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n    }).\n    replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n      return '&#' + value.charCodeAt(0) + ';';\n    }).\n    replace(/</g, '&lt;').\n    replace(/>/g, '&gt;');\n}\n\n/**\n * create an HTML/XML writer which writes to buffer\n * @param {Array} buf use buf.jain('') to get out sanitized html string\n * @returns {object} in the form of {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * }\n */\nfunction htmlSanitizeWriter(buf, uriValidator) {\n  var ignore = false;\n  var out = angular.bind(buf, buf.push);\n  return {\n    start: function(tag, attrs, unary) {\n      tag = angular.lowercase(tag);\n      if (!ignore && specialElements[tag]) {\n        ignore = tag;\n      }\n      if (!ignore && validElements[tag] === true) {\n        out('<');\n        out(tag);\n        angular.forEach(attrs, function(value, key) {\n          var lkey=angular.lowercase(key);\n          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n          if (validAttrs[lkey] === true &&\n            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n            out(' ');\n            out(key);\n            out('=\"');\n            out(encodeEntities(value));\n            out('\"');\n          }\n        });\n        out(unary ? '/>' : '>');\n      }\n    },\n    end: function(tag) {\n        tag = angular.lowercase(tag);\n        if (!ignore && validElements[tag] === true) {\n          out('</');\n          out(tag);\n          out('>');\n        }\n        if (tag == ignore) {\n          ignore = false;\n        }\n      },\n    chars: function(chars) {\n        if (!ignore) {\n          out(encodeEntities(chars));\n        }\n      }\n  };\n}\n\n\n// define ngSanitize module and register $sanitize service\nangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n/* global sanitizeText: false */\n\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.\n * @returns {string} Html-linkified text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n       <script>\n         angular.module('linkyExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', function($scope) {\n             $scope.snippet =\n               'Pretty text with some links:\\n'+\n               'http://angularjs.org/,\\n'+\n               'mailto:us@somewhere.org,\\n'+\n               'another@somewhere.org,\\n'+\n               'and one more: ftp://127.0.0.1/.';\n             $scope.snippetWithTarget = 'http://angularjs.org/';\n           }]);\n       </script>\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Filter</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithTarget | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n     </file>\n   </example>\n */\nangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n  var LINKY_URL_REGEXP =\n        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n      MAILTO_REGEXP = /^mailto:/i;\n\n  return function(text, target) {\n    if (!text) return text;\n    var match;\n    var raw = text;\n    var html = [];\n    var url;\n    var i;\n    while ((match = raw.match(LINKY_URL_REGEXP))) {\n      // We can not end in these as they are sometimes found at the end of the sentence\n      url = match[0];\n      // if we did not match ftp/http/www/mailto then assume mailto\n      if (!match[2] && !match[4]) {\n        url = (match[3] ? 'http://' : 'mailto:') + url;\n      }\n      i = match.index;\n      addText(raw.substr(0, i));\n      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n      raw = raw.substring(i + match[0].length);\n    }\n    addText(raw);\n    return $sanitize(html.join(''));\n\n    function addText(text) {\n      if (!text) {\n        return;\n      }\n      html.push(sanitizeText(text));\n    }\n\n    function addLink(url, text) {\n      html.push('<a ');\n      if (angular.isDefined(target)) {\n        html.push('target=\"',\n                  target,\n                  '\" ');\n      }\n      html.push('href=\"',\n                url.replace(/\"/g, '&quot;'),\n                '\">');\n      addText(text);\n      html.push('</a>');\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n","require('./angular-sanitize');\nmodule.exports = 'ngSanitize';\n","/*!\n * angular-translate - v2.10.0 - 2016-02-28\n * \n * Copyright (c) 2016 The angular-translate team, Pascal Precht; Licensed MIT\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define([], function () {\n      return (factory());\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    factory();\n  }\n}(this, function () {\n\n/**\n * @ngdoc overview\n * @name pascalprecht.translate\n *\n * @description\n * The main module which holds everything together.\n */\nangular.module('pascalprecht.translate', ['ng'])\n  .run(runTranslate);\n\nfunction runTranslate($translate) {\n\n  'use strict';\n\n  var key = $translate.storageKey(),\n    storage = $translate.storage();\n\n  var fallbackFromIncorrectStorageValue = function () {\n    var preferred = $translate.preferredLanguage();\n    if (angular.isString(preferred)) {\n      $translate.use(preferred);\n      // $translate.use() will also remember the language.\n      // So, we don't need to call storage.put() here.\n    } else {\n      storage.put(key, $translate.use());\n    }\n  };\n\n  fallbackFromIncorrectStorageValue.displayName = 'fallbackFromIncorrectStorageValue';\n\n  if (storage) {\n    if (!storage.get(key)) {\n      fallbackFromIncorrectStorageValue();\n    } else {\n      $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);\n    }\n  } else if (angular.isString($translate.preferredLanguage())) {\n    $translate.use($translate.preferredLanguage());\n  }\n}\nrunTranslate.$inject = ['$translate'];\n\nrunTranslate.displayName = 'runTranslate';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateSanitizationProvider\n *\n * @description\n *\n * Configurations for $translateSanitization\n */\nangular.module('pascalprecht.translate').provider('$translateSanitization', $translateSanitizationProvider);\n\nfunction $translateSanitizationProvider () {\n\n  'use strict';\n\n  var $sanitize,\n      currentStrategy = null, // TODO change to either 'sanitize', 'escape' or ['sanitize', 'escapeParameters'] in 3.0.\n      hasConfiguredStrategy = false,\n      hasShownNoStrategyConfiguredWarning = false,\n      strategies;\n\n  /**\n   * Definition of a sanitization strategy function\n   * @callback StrategyFunction\n   * @param {string|object} value - value to be sanitized (either a string or an interpolated value map)\n   * @param {string} mode - either 'text' for a string (translation) or 'params' for the interpolated params\n   * @return {string|object}\n   */\n\n  /**\n   * @ngdoc property\n   * @name strategies\n   * @propertyOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Following strategies are built-in:\n   * <dl>\n   *   <dt>sanitize</dt>\n   *   <dd>Sanitizes HTML in the translation text using $sanitize</dd>\n   *   <dt>escape</dt>\n   *   <dd>Escapes HTML in the translation</dd>\n   *   <dt>sanitizeParameters</dt>\n   *   <dd>Sanitizes HTML in the values of the interpolation parameters using $sanitize</dd>\n   *   <dt>escapeParameters</dt>\n   *   <dd>Escapes HTML in the values of the interpolation parameters</dd>\n   *   <dt>escaped</dt>\n   *   <dd>Support legacy strategy name 'escaped' for backwards compatibility (will be removed in 3.0)</dd>\n   * </dl>\n   *\n   */\n\n  strategies = {\n    sanitize: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlSanitizeValue(value);\n      }\n      return value;\n    },\n    escape: function (value, mode) {\n      if (mode === 'text') {\n        value = htmlEscapeValue(value);\n      }\n      return value;\n    },\n    sanitizeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlSanitizeValue);\n      }\n      return value;\n    },\n    escapeParameters: function (value, mode) {\n      if (mode === 'params') {\n        value = mapInterpolationParameters(value, htmlEscapeValue);\n      }\n      return value;\n    }\n  };\n  // Support legacy strategy name 'escaped' for backwards compatibility.\n  // TODO should be removed in 3.0\n  strategies.escaped = strategies.escapeParameters;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#addStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Adds a sanitization strategy to the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @param {StrategyFunction} strategyFunction - strategy function\n   * @returns {object} this\n   */\n  this.addStrategy = function (strategyName, strategyFunction) {\n    strategies[strategyName] = strategyFunction;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#removeStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Removes a sanitization strategy from the list of known strategies.\n   *\n   * @param {string} strategyName - unique key for a strategy\n   * @returns {object} this\n   */\n  this.removeStrategy = function (strategyName) {\n    delete strategies[strategyName];\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateSanitizationProvider#useStrategy\n   * @methodOf pascalprecht.translate.$translateSanitizationProvider\n   *\n   * @description\n   * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n   *\n   * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n   * @returns {object} this\n   */\n  this.useStrategy = function (strategy) {\n    hasConfiguredStrategy = true;\n    currentStrategy = strategy;\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translateSanitization\n   * @requires $injector\n   * @requires $log\n   *\n   * @description\n   * Sanitizes interpolation parameters and translated texts.\n   *\n   */\n  this.$get = ['$injector', '$log', function ($injector, $log) {\n\n    var cachedStrategyMap = {};\n\n    var applyStrategies = function (value, mode, selectedStrategies) {\n      angular.forEach(selectedStrategies, function (selectedStrategy) {\n        if (angular.isFunction(selectedStrategy)) {\n          value = selectedStrategy(value, mode);\n        } else if (angular.isFunction(strategies[selectedStrategy])) {\n          value = strategies[selectedStrategy](value, mode);\n        } else if (angular.isString(strategies[selectedStrategy])) {\n          if (!cachedStrategyMap[strategies[selectedStrategy]]) {\n            try {\n              cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);\n            } catch (e) {\n              cachedStrategyMap[strategies[selectedStrategy]] = function() {};\n              throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n            }\n          }\n          value = cachedStrategyMap[strategies[selectedStrategy]](value, mode);\n        } else {\n          throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \\'' + selectedStrategy + '\\'');\n        }\n      });\n      return value;\n    };\n\n    // TODO: should be removed in 3.0\n    var showNoStrategyConfiguredWarning = function () {\n      if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {\n        $log.warn('pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.');\n        hasShownNoStrategyConfiguredWarning = true;\n      }\n    };\n\n    if ($injector.has('$sanitize')) {\n      $sanitize = $injector.get('$sanitize');\n    }\n\n    return {\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#useStrategy\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.\n       *\n       * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.\n       */\n      useStrategy: (function (self) {\n        return function (strategy) {\n          self.useStrategy(strategy);\n        };\n      })(this),\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translateSanitization#sanitize\n       * @methodOf pascalprecht.translate.$translateSanitization\n       *\n       * @description\n       * Sanitizes a value.\n       *\n       * @param {string|object} value The value which should be sanitized.\n       * @param {string} mode The current sanitization mode, either 'params' or 'text'.\n       * @param {string|StrategyFunction|array} [strategy] Optional custom strategy which should be used instead of the currently selected strategy.\n       * @returns {string|object} sanitized value\n       */\n      sanitize: function (value, mode, strategy) {\n        if (!currentStrategy) {\n          showNoStrategyConfiguredWarning();\n        }\n\n        if (arguments.length < 3) {\n          strategy = currentStrategy;\n        }\n\n        if (!strategy) {\n          return value;\n        }\n\n        var selectedStrategies = angular.isArray(strategy) ? strategy : [strategy];\n        return applyStrategies(value, mode, selectedStrategies);\n      }\n    };\n  }];\n\n  var htmlEscapeValue = function (value) {\n    var element = angular.element('<div></div>');\n    element.text(value); // not chainable, see #1044\n    return element.html();\n  };\n\n  var htmlSanitizeValue = function (value) {\n    if (!$sanitize) {\n      throw new Error('pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as \\'escape\\'.');\n    }\n    return $sanitize(value);\n  };\n\n  var mapInterpolationParameters = function (value, iteratee, stack) {\n    if (angular.isObject(value)) {\n      var result = angular.isArray(value) ? [] : {};\n\n      if (!stack) {\n        stack = [];\n      } else {\n        if (stack.indexOf(value) > -1) {\n          throw new Error('pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object');\n        }\n      }\n\n      stack.push(value);\n      angular.forEach(value, function (propertyValue, propertyKey) {\n        result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack);\n      });\n      stack.splice(-1, 1); // remove last\n\n      return result;\n    } else if (angular.isNumber(value)) {\n      return value;\n    } else {\n      return iteratee(value);\n    }\n  };\n}\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateProvider\n * @description\n *\n * $translateProvider allows developers to register translation-tables, asynchronous loaders\n * and similar to configure translation behavior directly inside of a module.\n *\n */\nangular.module('pascalprecht.translate')\n.constant('pascalprechtTranslateOverrider', {})\n.provider('$translate', $translate);\n\nfunction $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {\n\n  'use strict';\n\n  var $translationTable = {},\n      $preferredLanguage,\n      $availableLanguageKeys = [],\n      $languageKeyAliases,\n      $fallbackLanguage,\n      $fallbackWasString,\n      $uses,\n      $nextLang,\n      $storageFactory,\n      $storageKey = $STORAGE_KEY,\n      $storagePrefix,\n      $missingTranslationHandlerFactory,\n      $interpolationFactory,\n      $interpolatorFactories = [],\n      $loaderFactory,\n      $cloakClassName = 'translate-cloak',\n      $loaderOptions,\n      $notFoundIndicatorLeft,\n      $notFoundIndicatorRight,\n      $postCompilingEnabled = false,\n      $forceAsyncReloadEnabled = false,\n      $nestedObjectDelimeter = '.',\n      $isReady = false,\n      loaderCache,\n      directivePriority = 0,\n      statefulFilter = true,\n      uniformLanguageTagResolver = 'default',\n      languageTagResolver = {\n        'default': function (tag) {\n          return (tag || '').split('-').join('_');\n        },\n        java: function (tag) {\n          var temp = (tag || '').split('-').join('_');\n          var parts = temp.split('_');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '_' + parts[1].toUpperCase()) : temp;\n        },\n        bcp47: function (tag) {\n          var temp = (tag || '').split('_').join('-');\n          var parts = temp.split('-');\n          return parts.length > 1 ? (parts[0].toLowerCase() + '-' + parts[1].toUpperCase()) : temp;\n        }\n      };\n\n  var version = '2.10.0';\n\n  // tries to determine the browsers language\n  var getFirstBrowserLanguage = function () {\n\n    // internal purpose only\n    if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {\n      return pascalprechtTranslateOverrider.getLocale();\n    }\n\n    var nav = $windowProvider.$get().navigator,\n        browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],\n        i,\n        language;\n\n    // support for HTML 5.1 \"navigator.languages\"\n    if (angular.isArray(nav.languages)) {\n      for (i = 0; i < nav.languages.length; i++) {\n        language = nav.languages[i];\n        if (language && language.length) {\n          return language;\n        }\n      }\n    }\n\n    // support for other well known properties in browsers\n    for (i = 0; i < browserLanguagePropertyKeys.length; i++) {\n      language = nav[browserLanguagePropertyKeys[i]];\n      if (language && language.length) {\n        return language;\n      }\n    }\n\n    return null;\n  };\n  getFirstBrowserLanguage.displayName = 'angular-translate/service: getFirstBrowserLanguage';\n\n  // tries to determine the browsers locale\n  var getLocale = function () {\n    var locale = getFirstBrowserLanguage() || '';\n    if (languageTagResolver[uniformLanguageTagResolver]) {\n      locale = languageTagResolver[uniformLanguageTagResolver](locale);\n    }\n    return locale;\n  };\n  getLocale.displayName = 'angular-translate/service: getLocale';\n\n  /**\n   * @name indexOf\n   * @private\n   *\n   * @description\n   * indexOf polyfill. Kinda sorta.\n   *\n   * @param {array} array Array to search in.\n   * @param {string} searchElement Element to search for.\n   *\n   * @returns {int} Index of search element.\n   */\n  var indexOf = function(array, searchElement) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === searchElement) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  var negotiateLocale = function (preferred) {\n    if(!preferred) {\n      return;\n    }\n\n    var avail = [],\n        locale = angular.lowercase(preferred),\n        i = 0,\n        n = $availableLanguageKeys.length;\n\n    for (; i < n; i++) {\n      avail.push(angular.lowercase($availableLanguageKeys[i]));\n    }\n\n    // Check for an exact match in our list of available keys\n    if (indexOf(avail, locale) > -1) {\n      return preferred;\n    }\n\n    if ($languageKeyAliases) {\n      var alias;\n      for (var langKeyAlias in $languageKeyAliases) {\n        var hasWildcardKey = false;\n        var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) &&\n          angular.lowercase(langKeyAlias) === angular.lowercase(preferred);\n\n        if (langKeyAlias.slice(-1) === '*') {\n          hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length-1);\n        }\n        if (hasExactKey || hasWildcardKey) {\n          alias = $languageKeyAliases[langKeyAlias];\n          if (indexOf(avail, angular.lowercase(alias)) > -1) {\n            return alias;\n          }\n        }\n      }\n    }\n\n    // Check for a language code without region\n    var parts = preferred.split('_');\n\n    if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {\n      return parts[0];\n    }\n\n    // If everything fails, return undefined.\n    return;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translations\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a new translation table for specific language key.\n   *\n   * To register a translation table for specific language, pass a defined language\n   * key as first parameter.\n   *\n   * <pre>\n   *  // register translation table for language: 'de_DE'\n   *  $translateProvider.translations('de_DE', {\n   *    'GREETING': 'Hallo Welt!'\n   *  });\n   *\n   *  // register another one\n   *  $translateProvider.translations('en_US', {\n   *    'GREETING': 'Hello world!'\n   *  });\n   * </pre>\n   *\n   * When registering multiple translation tables for for the same language key,\n   * the actual translation table gets extended. This allows you to define module\n   * specific translation which only get added, once a specific module is loaded in\n   * your app.\n   *\n   * Invoking this method with no arguments returns the translation table which was\n   * registered with no language key. Invoking it with a language key returns the\n   * related translation table.\n   *\n   * @param {string} key A language key.\n   * @param {object} translationTable A plain old JavaScript object that represents a translation table.\n   *\n   */\n  var translations = function (langKey, translationTable) {\n\n    if (!langKey && !translationTable) {\n      return $translationTable;\n    }\n\n    if (langKey && !translationTable) {\n      if (angular.isString(langKey)) {\n        return $translationTable[langKey];\n      }\n    } else {\n      if (!angular.isObject($translationTable[langKey])) {\n        $translationTable[langKey] = {};\n      }\n      angular.extend($translationTable[langKey], flatObject(translationTable));\n    }\n    return this;\n  };\n\n  this.translations = translations;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#cloakClassName\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the class name for `translate-cloak` directive.\n   * Default class name is `translate-cloak`.\n   *\n   * @param {string} name translate-cloak class name\n   */\n  this.cloakClassName = function (name) {\n    if (!name) {\n      return $cloakClassName;\n    }\n    $cloakClassName = name;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#nestedObjectDelimeter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   *\n   * Let's you change the delimiter for namespaced translations.\n   * Default delimiter is `.`.\n   *\n   * @param {string} delimiter namespace separator\n   */\n  this.nestedObjectDelimeter = function (delimiter) {\n    if (!delimiter) {\n      return $nestedObjectDelimeter;\n    }\n    $nestedObjectDelimeter = delimiter;\n    return this;\n  };\n\n  /**\n   * @name flatObject\n   * @private\n   *\n   * @description\n   * Flats an object. This function is used to flatten given translation data with\n   * namespaces, so they are later accessible via dot notation.\n   */\n  var flatObject = function (data, path, result, prevKey) {\n    var key, keyWithPath, keyWithShortPath, val;\n\n    if (!path) {\n      path = [];\n    }\n    if (!result) {\n      result = {};\n    }\n    for (key in data) {\n      if (!Object.prototype.hasOwnProperty.call(data, key)) {\n        continue;\n      }\n      val = data[key];\n      if (angular.isObject(val)) {\n        flatObject(val, path.concat(key), result, key);\n      } else {\n        keyWithPath = path.length ? ('' + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key) : key;\n        if(path.length && key === prevKey){\n          // Create shortcut path (foo.bar == foo.bar.bar)\n          keyWithShortPath = '' + path.join($nestedObjectDelimeter);\n          // Link it to original path\n          result[keyWithShortPath] = '@:' + keyWithPath;\n        }\n        result[keyWithPath] = val;\n      }\n    }\n    return result;\n  };\n  flatObject.displayName = 'flatObject';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#addInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Adds interpolation services to angular-translate, so it can manage them.\n   *\n   * @param {object} factory Interpolation service factory\n   */\n  this.addInterpolation = function (factory) {\n    $interpolatorFactories.push(factory);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMessageFormatInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use interpolation functionality of messageformat.js.\n   * This is useful when having high level pluralization and gender selection.\n   */\n  this.useMessageFormatInterpolation = function () {\n    return this.useInterpolation('$translateMessageFormatInterpolation');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useInterpolation\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which interpolation style to use as default, application-wide.\n   * Simply pass a factory/service name. The interpolation service has to implement\n   * the correct interface.\n   *\n   * @param {string} factory Interpolation service name.\n   */\n  this.useInterpolation = function (factory) {\n    $interpolationFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useSanitizeStrategy\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Simply sets a sanitation strategy type.\n   *\n   * @param {string} value Strategy type.\n   */\n  this.useSanitizeValueStrategy = function (value) {\n    $translateSanitizationProvider.useStrategy(value);\n    return this;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#preferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use for translation\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **prefer**.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.preferredLanguage = function(langKey) {\n    if (langKey) {\n      setupPreferredLanguage(langKey);\n      return this;\n    }\n    return $preferredLanguage;\n  };\n  var setupPreferredLanguage = function (langKey) {\n    if (langKey) {\n      $preferredLanguage = langKey;\n    }\n    return $preferredLanguage;\n  };\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicator\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found. E.g. when\n   * setting the indicator as 'X' and one tries to translate a translation id\n   * called `NOT_FOUND`, this will result in `X NOT_FOUND X`.\n   *\n   * Internally this methods sets a left indicator and a right indicator using\n   * `$translateProvider.translationNotFoundIndicatorLeft()` and\n   * `$translateProvider.translationNotFoundIndicatorRight()`.\n   *\n   * **Note**: These methods automatically add a whitespace between the indicators\n   * and the translation id.\n   *\n   * @param {string} indicator An indicator, could be any string.\n   */\n  this.translationNotFoundIndicator = function (indicator) {\n    this.translationNotFoundIndicatorLeft(indicator);\n    this.translationNotFoundIndicatorRight(indicator);\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found left to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorLeft = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorLeft;\n    }\n    $notFoundIndicatorLeft = indicator;\n    return this;\n  };\n\n  /**\n   * ngdoc function\n   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets an indicator which is used when a translation isn't found right to the\n   * translation id.\n   *\n   * @param {string} indicator An indicator.\n   */\n  this.translationNotFoundIndicatorRight = function (indicator) {\n    if (!indicator) {\n      return $notFoundIndicatorRight;\n    }\n    $notFoundIndicatorRight = indicator;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#fallbackLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which of the registered translation tables to use when missing translations\n   * at initial startup by passing a language key. Similar to `$translateProvider#use`\n   * only that it says which language to **fallback**.\n   *\n   * @param {string||array} langKey A language key.\n   *\n   */\n  this.fallbackLanguage = function (langKey) {\n    fallbackStack(langKey);\n    return this;\n  };\n\n  var fallbackStack = function (langKey) {\n    if (langKey) {\n      if (angular.isString(langKey)) {\n        $fallbackWasString = true;\n        $fallbackLanguage = [ langKey ];\n      } else if (angular.isArray(langKey)) {\n        $fallbackWasString = false;\n        $fallbackLanguage = langKey;\n      }\n      if (angular.isString($preferredLanguage)  && indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n        $fallbackLanguage.push($preferredLanguage);\n      }\n\n      return this;\n    } else {\n      if ($fallbackWasString) {\n        return $fallbackLanguage[0];\n      } else {\n        return $fallbackLanguage;\n      }\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#use\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Set which translation table to use for translation by given language key. When\n   * trying to 'use' a language which isn't provided, it'll throw an error.\n   *\n   * You actually don't have to use this method since `$translateProvider#preferredLanguage`\n   * does the job too.\n   *\n   * @param {string} langKey A language key.\n   */\n  this.use = function (langKey) {\n    if (langKey) {\n      if (!$translationTable[langKey] && (!$loaderFactory)) {\n        // only throw an error, when not loading translation data asynchronously\n        throw new Error('$translateProvider couldn\\'t find translationTable for langKey: \\'' + langKey + '\\'');\n      }\n      $uses = langKey;\n      return this;\n    }\n    return $uses;\n  };\n\n /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storageKey\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells the module which key must represent the choosed language by a user in the storage.\n   *\n   * @param {string} key A key for the storage.\n   */\n  var storageKey = function(key) {\n    if (!key) {\n      if ($storagePrefix) {\n        return $storagePrefix + $storageKey;\n      }\n      return $storageKey;\n    }\n    $storageKey = key;\n    return this;\n  };\n\n  this.storageKey = storageKey;\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useUrlLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateUrlLoader` extension service as loader.\n   *\n   * @param {string} url Url\n   * @param {Object=} options Optional configuration object\n   */\n  this.useUrlLoader = function (url, options) {\n    return this.useLoader('$translateUrlLoader', angular.extend({ url: url }, options));\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStaticFilesLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateStaticFilesLoader` extension service as loader.\n   *\n   * @param {Object=} options Optional configuration object\n   */\n  this.useStaticFilesLoader = function (options) {\n    return this.useLoader('$translateStaticFilesLoader', options);\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoader\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use any other service as loader.\n   *\n   * @param {string} loaderFactory Factory name to use\n   * @param {Object=} options Optional configuration object\n   */\n  this.useLoader = function (loaderFactory, options) {\n    $loaderFactory = loaderFactory;\n    $loaderOptions = options || {};\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLocalStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateLocalStorage` service as storage layer.\n   *\n   */\n  this.useLocalStorage = function () {\n    return this.useStorage('$translateLocalStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useCookieStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use `$translateCookieStorage` service as storage layer.\n   */\n  this.useCookieStorage = function () {\n    return this.useStorage('$translateCookieStorage');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useStorage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use custom service as storage layer.\n   */\n  this.useStorage = function (storageFactory) {\n    $storageFactory = storageFactory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#storagePrefix\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets prefix for storage key.\n   *\n   * @param {string} prefix Storage key prefix\n   */\n  this.storagePrefix = function (prefix) {\n    if (!prefix) {\n      return prefix;\n    }\n    $storagePrefix = prefix;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandlerLog\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to use built-in log handler when trying to translate\n   * a translation Id which doesn't exist.\n   *\n   * This is actually a shortcut method for `useMissingTranslationHandler()`.\n   *\n   */\n  this.useMissingTranslationHandlerLog = function () {\n    return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandler\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Expects a factory name which later gets instantiated with `$injector`.\n   * This method can be used to tell angular-translate to use a custom\n   * missingTranslationHandler. Just build a factory which returns a function\n   * and expects a translation id as argument.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.useMissingTranslationHandler('customHandler');\n   *  });\n   *\n   *  app.factory('customHandler', function (dep1, dep2) {\n   *    return function (translationId) {\n   *      // something with translationId and dep1 and dep2\n   *    };\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.useMissingTranslationHandler = function (factory) {\n    $missingTranslationHandlerFactory = factory;\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#usePostCompiling\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If post compiling is enabled, all translated values will be processed\n   * again with AngularJS' $compile.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.usePostCompiling(true);\n   *  });\n   * </pre>\n   *\n   * @param {string} factory Factory name\n   */\n  this.usePostCompiling = function (value) {\n    $postCompilingEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#forceAsyncReload\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * If force async reload is enabled, async loader will always be called\n   * even if $translationTable already contains the language key, adding\n   * possible new entries to the $translationTable.\n   *\n   * Example:\n   * <pre>\n   *  app.config(function ($translateProvider) {\n   *    $translateProvider.forceAsyncReload(true);\n   *  });\n   * </pre>\n   *\n   * @param {boolean} value - valid values are true or false\n   */\n  this.forceAsyncReload = function (value) {\n    $forceAsyncReloadEnabled = !(!value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#uniformLanguageTag\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate which language tag should be used as a result when determining\n   * the current browser language.\n   *\n   * This setting must be set before invoking {@link pascalprecht.translate.$translateProvider#methods_determinePreferredLanguage determinePreferredLanguage()}.\n   *\n   * <pre>\n   * $translateProvider\n   *   .uniformLanguageTag('bcp47')\n   *   .determinePreferredLanguage()\n   * </pre>\n   *\n   * The resolver currently supports:\n   * * default\n   *     (traditionally: hyphens will be converted into underscores, i.e. en-US => en_US)\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_us\n   * * java\n   *     like default, but the second part will be always in uppercase\n   *     en-US => en_US\n   *     en_US => en_US\n   *     en-us => en_US\n   * * BCP 47 (RFC 4646 & 4647)\n   *     en-US => en-US\n   *     en_US => en-US\n   *     en-us => en-US\n   *\n   * See also:\n   * * http://en.wikipedia.org/wiki/IETF_language_tag\n   * * http://www.w3.org/International/core/langtags/\n   * * http://tools.ietf.org/html/bcp47\n   *\n   * @param {string|object} options - options (or standard)\n   * @param {string} options.standard - valid values are 'default', 'bcp47', 'java'\n   */\n  this.uniformLanguageTag = function (options) {\n\n    if (!options) {\n      options = {};\n    } else if (angular.isString(options)) {\n      options = {\n        standard: options\n      };\n    }\n\n    uniformLanguageTagResolver = options.standard;\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#determinePreferredLanguage\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Tells angular-translate to try to determine on its own which language key\n   * to set as preferred language. When `fn` is given, angular-translate uses it\n   * to determine a language key, otherwise it uses the built-in `getLocale()`\n   * method.\n   *\n   * The `getLocale()` returns a language key in the format `[lang]_[country]` or\n   * `[lang]` depending on what the browser provides.\n   *\n   * Use this method at your own risk, since not all browsers return a valid\n   * locale (see {@link pascalprecht.translate.$translateProvider#methods_uniformLanguageTag uniformLanguageTag()}).\n   *\n   * @param {Function=} fn Function to determine a browser's locale\n   */\n  this.determinePreferredLanguage = function (fn) {\n\n    var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();\n\n    if (!$availableLanguageKeys.length) {\n      $preferredLanguage = locale;\n    } else {\n      $preferredLanguage = negotiateLocale(locale) || locale;\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#registerAvailableLanguageKeys\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a set of language keys the app will work with. Use this method in\n   * combination with\n   * {@link pascalprecht.translate.$translateProvider#determinePreferredLanguage determinePreferredLanguage}.\n   * When available languages keys are registered, angular-translate\n   * tries to find the best fitting language key depending on the browsers locale,\n   * considering your language key convention.\n   *\n   * @param {object} languageKeys Array of language keys the your app will use\n   * @param {object=} aliases Alias map.\n   */\n  this.registerAvailableLanguageKeys = function (languageKeys, aliases) {\n    if (languageKeys) {\n      $availableLanguageKeys = languageKeys;\n      if (aliases) {\n        $languageKeyAliases = aliases;\n      }\n      return this;\n    }\n    return $availableLanguageKeys;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#useLoaderCache\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Registers a cache for internal $http based loaders.\n   * {@link pascalprecht.translate.$translationCache $translationCache}.\n   * When false the cache will be disabled (default). When true or undefined\n   * the cache will be a default (see $cacheFactory). When an object it will\n   * be treat as a cache object itself: the usage is $http({cache: cache})\n   *\n   * @param {object} cache boolean, string or cache-object\n   */\n  this.useLoaderCache = function (cache) {\n    if (cache === false) {\n      // disable cache\n      loaderCache = undefined;\n    } else if (cache === true) {\n      // enable cache using AJS defaults\n      loaderCache = true;\n    } else if (typeof(cache) === 'undefined') {\n      // enable cache using default\n      loaderCache = '$translationCache';\n    } else if (cache) {\n      // enable cache using given one (see $cacheFactory)\n      loaderCache = cache;\n    }\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#directivePriority\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Sets the default priority of the translate directive. The standard value is `0`.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {number} priority for the translate-directive\n   */\n  this.directivePriority = function (priority) {\n    if (priority === undefined) {\n      // getter\n      return directivePriority;\n    } else {\n      // setter with chaining\n      directivePriority = priority;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateProvider#statefulFilter\n   * @methodOf pascalprecht.translate.$translateProvider\n   *\n   * @description\n   * Since AngularJS 1.3, filters which are not stateless (depending at the scope)\n   * have to explicit define this behavior.\n   * Sets whether the translate filter should be stateful or stateless. The standard value is `true`\n   * meaning being stateful.\n   * Calling this function without an argument will return the current value.\n   *\n   * @param {boolean} state - defines the state of the filter\n   */\n  this.statefulFilter = function (state) {\n    if (state === undefined) {\n      // getter\n      return statefulFilter;\n    } else {\n      // setter with chaining\n      statefulFilter = state;\n      return this;\n    }\n  };\n\n  /**\n   * @ngdoc object\n   * @name pascalprecht.translate.$translate\n   * @requires $interpolate\n   * @requires $log\n   * @requires $rootScope\n   * @requires $q\n   *\n   * @description\n   * The `$translate` service is the actual core of angular-translate. It expects a translation id\n   * and optional interpolate parameters to translate contents.\n   *\n   * <pre>\n   *  $translate('HEADLINE_TEXT').then(function (translation) {\n   *    $scope.translatedText = translation;\n   *  });\n   * </pre>\n   *\n   * @param {string|array} translationId A token which represents a translation id\n   *                                     This can be optionally an array of translation ids which\n   *                                     results that the function returns an object where each key\n   *                                     is the translation id and the value the translation.\n   * @param {object=} interpolateParams An object hash for dynamic values\n   * @param {string} interpolationId The id of the interpolation to use\n   * @param {string} forceLanguage A language to be used instead of the current language\n   * @returns {object} promise\n   */\n  this.$get = [\n    '$log',\n    '$injector',\n    '$rootScope',\n    '$q',\n    function ($log, $injector, $rootScope, $q) {\n\n      var Storage,\n          defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),\n          pendingLoader = false,\n          interpolatorHashMap = {},\n          langPromises = {},\n          fallbackIndex,\n          startFallbackIteration;\n\n      var $translate = function (translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage) {\n\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          // Inspired by Q.allSettled by Kris Kowal\n          // https://github.com/kriskowal/q/blob/b0fa72980717dc202ffc3cbf03b936e10ebbb9d7/q.js#L1553-1563\n          // This transforms all promises regardless resolved or rejected\n          var translateAll = function (translationIds) {\n            var results = {}; // storing the actual results\n            var promises = []; // promises to wait for\n            // Wraps the promise a) being always resolved and b) storing the link id->value\n            var translate = function (translationId) {\n              var deferred = $q.defer();\n              var regardless = function (value) {\n                results[translationId] = value;\n                deferred.resolve([translationId, value]);\n              };\n              // we don't care whether the promise was resolved or rejected; just store the values\n              $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage).then(regardless, regardless);\n              return deferred.promise;\n            };\n            for (var i = 0, c = translationIds.length; i < c; i++) {\n              promises.push(translate(translationIds[i]));\n            }\n            // wait for all (including storing to results)\n            return $q.all(promises).then(function () {\n              // return the results\n              return results;\n            });\n          };\n          return translateAll(translationId);\n        }\n\n        var deferred = $q.defer();\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var promiseToWaitFor = (function () {\n          var promise = $preferredLanguage ?\n            langPromises[$preferredLanguage] :\n            langPromises[uses];\n\n          fallbackIndex = 0;\n\n          if ($storageFactory && !promise) {\n            // looks like there's no pending promise for $preferredLanguage or\n            // $uses. Maybe there's one pending for a language that comes from\n            // storage.\n            var langKey = Storage.get($storageKey);\n            promise = langPromises[langKey];\n\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n                var index = indexOf($fallbackLanguage, langKey);\n                // maybe the language from storage is also defined as fallback language\n                // we increase the fallback language index to not search in that language\n                // as fallback, since it's probably the first used language\n                // in that case the index starts after the first element\n                fallbackIndex = (index === 0) ? 1 : 0;\n\n                // but we can make sure to ALWAYS fallback to preferred language at least\n                if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {\n                  $fallbackLanguage.push($preferredLanguage);\n                }\n            }\n          }\n          return promise;\n        }());\n\n        if (!promiseToWaitFor) {\n          // no promise to wait for? okay. Then there's no loader registered\n          // nor is a one pending for language that comes from storage.\n          // We can just translate.\n          determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n        } else {\n          var promiseResolved = function () {\n            // $uses may have changed while waiting\n            if (!forceLanguage) {\n              uses = $uses;\n            }\n            determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);\n          };\n          promiseResolved.displayName = 'promiseResolved';\n\n          promiseToWaitFor['finally'](promiseResolved);\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name applyNotFoundIndicators\n       * @private\n       *\n       * @description\n       * Applies not fount indicators to given translation id, if needed.\n       * This function gets only executed, if a translation id doesn't exist,\n       * which is why a translation id is expected as argument.\n       *\n       * @param {string} translationId Translation id.\n       * @returns {string} Same as given translation id but applied with not found\n       * indicators.\n       */\n      var applyNotFoundIndicators = function (translationId) {\n        // applying notFoundIndicators\n        if ($notFoundIndicatorLeft) {\n          translationId = [$notFoundIndicatorLeft, translationId].join(' ');\n        }\n        if ($notFoundIndicatorRight) {\n          translationId = [translationId, $notFoundIndicatorRight].join(' ');\n        }\n        return translationId;\n      };\n\n      /**\n       * @name useLanguage\n       * @private\n       *\n       * @description\n       * Makes actual use of a language by setting a given language key as used\n       * language and informs registered interpolators to also use the given\n       * key as locale.\n       *\n       * @param {key} Locale key.\n       */\n      var useLanguage = function (key) {\n        $uses = key;\n\n        // make sure to store new language key before triggering success event\n        if ($storageFactory) {\n          Storage.put($translate.storageKey(), $uses);\n        }\n\n        $rootScope.$emit('$translateChangeSuccess', {language: key});\n\n        // inform default interpolator\n        defaultInterpolator.setLocale($uses);\n\n        var eachInterpolator = function (interpolator, id) {\n          interpolatorHashMap[id].setLocale($uses);\n        };\n        eachInterpolator.displayName = 'eachInterpolatorLocaleSetter';\n\n        // inform all others too!\n        angular.forEach(interpolatorHashMap, eachInterpolator);\n        $rootScope.$emit('$translateChangeEnd', {language: key});\n      };\n\n      /**\n       * @name loadAsync\n       * @private\n       *\n       * @description\n       * Kicks of registered async loader using `$injector` and applies existing\n       * loader options. When resolved, it updates translation tables accordingly\n       * or rejects with given language key.\n       *\n       * @param {string} key Language key.\n       * @return {Promise} A promise.\n       */\n      var loadAsync = function (key) {\n        if (!key) {\n          throw 'No language key specified for loading.';\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateLoadingStart', {language: key});\n        pendingLoader = true;\n\n        var cache = loaderCache;\n        if (typeof(cache) === 'string') {\n          // getting on-demand instance of loader\n          cache = $injector.get(cache);\n        }\n\n        var loaderOptions = angular.extend({}, $loaderOptions, {\n          key: key,\n          $http: angular.extend({}, {\n            cache: cache\n          }, $loaderOptions.$http)\n        });\n\n        var onLoaderSuccess = function (data) {\n          var translationTable = {};\n          $rootScope.$emit('$translateLoadingSuccess', {language: key});\n\n          if (angular.isArray(data)) {\n            angular.forEach(data, function (table) {\n              angular.extend(translationTable, flatObject(table));\n            });\n          } else {\n            angular.extend(translationTable, flatObject(data));\n          }\n          pendingLoader = false;\n          deferred.resolve({\n            key: key,\n            table: translationTable\n          });\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderSuccess.displayName = 'onLoaderSuccess';\n\n        var onLoaderError = function (key) {\n          $rootScope.$emit('$translateLoadingError', {language: key});\n          deferred.reject(key);\n          $rootScope.$emit('$translateLoadingEnd', {language: key});\n        };\n        onLoaderError.displayName = 'onLoaderError';\n\n        $injector.get($loaderFactory)(loaderOptions)\n          .then(onLoaderSuccess, onLoaderError);\n\n        return deferred.promise;\n      };\n\n      if ($storageFactory) {\n        Storage = $injector.get($storageFactory);\n\n        if (!Storage.get || !Storage.put) {\n          throw new Error('Couldn\\'t use storage \\'' + $storageFactory + '\\', missing get() or put() method!');\n        }\n      }\n\n      // if we have additional interpolations that were added via\n      // $translateProvider.addInterpolation(), we have to map'em\n      if ($interpolatorFactories.length) {\n        var eachInterpolationFactory = function (interpolatorFactory) {\n          var interpolator = $injector.get(interpolatorFactory);\n          // setting initial locale for each interpolation service\n          interpolator.setLocale($preferredLanguage || $uses);\n          // make'em recognizable through id\n          interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;\n        };\n        eachInterpolationFactory.displayName = 'interpolationFactoryAdder';\n\n        angular.forEach($interpolatorFactories, eachInterpolationFactory);\n      }\n\n      /**\n       * @name getTranslationTable\n       * @private\n       *\n       * @description\n       * Returns a promise that resolves to the translation table\n       * or is rejected if an error occurred.\n       *\n       * @param langKey\n       * @returns {Q.promise}\n       */\n      var getTranslationTable = function (langKey) {\n        var deferred = $q.defer();\n        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {\n          deferred.resolve($translationTable[langKey]);\n        } else if (langPromises[langKey]) {\n          var onResolve = function (data) {\n            translations(data.key, data.table);\n            deferred.resolve(data.table);\n          };\n          onResolve.displayName = 'translationTableResolver';\n          langPromises[langKey].then(onResolve, deferred.reject);\n        } else {\n          deferred.reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslation\n       * @private\n       *\n       * @description\n       * Returns a promise that will resolve to the translation\n       * or be rejected if no translation was found for the language.\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise}\n       */\n      var getFallbackTranslation = function (langKey, translationId, interpolateParams, Interpolator) {\n        var deferred = $q.defer();\n\n        var onResolve = function (translationTable) {\n          if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n            Interpolator.setLocale(langKey);\n            var translation = translationTable[translationId];\n            if (translation.substr(0, 2) === '@:') {\n              getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator)\n                .then(deferred.resolve, deferred.reject);\n            } else {\n              deferred.resolve(Interpolator.interpolate(translationTable[translationId], interpolateParams));\n            }\n            Interpolator.setLocale($uses);\n          } else {\n            deferred.reject();\n          }\n        };\n        onResolve.displayName = 'fallbackTranslationResolver';\n\n        getTranslationTable(langKey).then(onResolve, deferred.reject);\n\n        return deferred.promise;\n      };\n\n      /**\n       * @name getFallbackTranslationInstant\n       * @private\n       *\n       * @description\n       * Returns a translation\n       * This function is currently only used for fallback language translation.\n       *\n       * @param langKey The language to translate to.\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var getFallbackTranslationInstant = function (langKey, translationId, interpolateParams, Interpolator) {\n        var result, translationTable = $translationTable[langKey];\n\n        if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {\n          Interpolator.setLocale(langKey);\n          result = Interpolator.interpolate(translationTable[translationId], interpolateParams);\n          if (result.substr(0, 2) === '@:') {\n            return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);\n          }\n          Interpolator.setLocale($uses);\n        }\n\n        return result;\n      };\n\n\n      /**\n       * @name translateByHandler\n       * @private\n       *\n       * Translate by missing translation handler.\n       *\n       * @param translationId\n       * @returns translation created by $missingTranslationHandler or translationId is $missingTranslationHandler is\n       * absent\n       */\n      var translateByHandler = function (translationId, interpolateParams) {\n        // If we have a handler factory - we might also call it here to determine if it provides\n        // a default text for a translationid that can't be found anywhere in our tables\n        if ($missingTranslationHandlerFactory) {\n          var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams);\n          if (resultString !== undefined) {\n            return resultString;\n          } else {\n            return translationId;\n          }\n        } else {\n          return translationId;\n        }\n      };\n\n      /**\n       * @name resolveForFallbackLanguage\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise that will resolve to the translation.\n       */\n      var resolveForFallbackLanguage = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        var deferred = $q.defer();\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(\n            deferred.resolve,\n            function () {\n              // Look in the next fallback language for a translation.\n              // It delays the resolving by passing another promise to resolve.\n              resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve);\n            }\n          );\n        } else {\n          // No translation found in any fallback language\n          // if a default translation text is set in the directive, then return this as a result\n          if (defaultTranslationText) {\n            deferred.resolve(defaultTranslationText);\n          } else {\n            // if no default translation is set and an error handler is defined, send it to the handler\n            // and then return the result\n            deferred.resolve(translateByHandler(translationId, interpolateParams));\n          }\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @name resolveForFallbackLanguageInstant\n       * @private\n       *\n       * Recursive helper function for fallbackTranslation that will sequentially look\n       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.\n       *\n       * @param fallbackLanguageIndex\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {string} translation\n       */\n      var resolveForFallbackLanguageInstant = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {\n        var result;\n\n        if (fallbackLanguageIndex < $fallbackLanguage.length) {\n          var langKey = $fallbackLanguage[fallbackLanguageIndex];\n          result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);\n          if (!result) {\n            result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);\n          }\n        }\n        return result;\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {Q.promise} Promise, that resolves to the translation.\n       */\n      var fallbackTranslation = function (translationId, interpolateParams, Interpolator, defaultTranslationText) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguage((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText);\n      };\n\n      /**\n       * Translates with the usage of the fallback languages.\n       *\n       * @param translationId\n       * @param interpolateParams\n       * @param Interpolator\n       * @returns {String} translation\n       */\n      var fallbackTranslationInstant = function (translationId, interpolateParams, Interpolator) {\n        // Start with the fallbackLanguage with index 0\n        return resolveForFallbackLanguageInstant((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator);\n      };\n\n      var determineTranslation = function (translationId, interpolateParams, interpolationId, defaultTranslationText, uses) {\n\n        var deferred = $q.defer();\n\n        var table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n\n            $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses)\n              .then(deferred.resolve, deferred.reject);\n          } else {\n            deferred.resolve(Interpolator.interpolate(translation, interpolateParams));\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText)\n                .then(function (translation) {\n                  deferred.resolve(translation);\n                }, function (_translationId) {\n                  deferred.reject(applyNotFoundIndicators(_translationId));\n                });\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n              } else {\n                deferred.resolve(missingTranslationHandlerTranslation);\n              }\n          } else {\n            if (defaultTranslationText) {\n              deferred.resolve(defaultTranslationText);\n            } else {\n              deferred.reject(applyNotFoundIndicators(translationId));\n            }\n          }\n        }\n        return deferred.promise;\n      };\n\n      var determineTranslationInstant = function (translationId, interpolateParams, interpolationId, uses) {\n\n        var result, table = uses ? $translationTable[uses] : $translationTable,\n            Interpolator = defaultInterpolator;\n\n        // if the interpolation id exists use custom interpolator\n        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {\n          Interpolator = interpolatorHashMap[interpolationId];\n        }\n\n        // if the translation id exists, we can just interpolate it\n        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {\n          var translation = table[translationId];\n\n          // If using link, rerun $translate with linked translationId and return it\n          if (translation.substr(0, 2) === '@:') {\n            result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses);\n          } else {\n            result = Interpolator.interpolate(translation, interpolateParams);\n          }\n        } else {\n          var missingTranslationHandlerTranslation;\n          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise\n          if ($missingTranslationHandlerFactory && !pendingLoader) {\n            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);\n          }\n\n          // since we couldn't translate the inital requested translation id,\n          // we try it now with one or more fallback languages, if fallback language(s) is\n          // configured.\n          if (uses && $fallbackLanguage && $fallbackLanguage.length) {\n            fallbackIndex = 0;\n            result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);\n          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {\n            // looks like the requested translation id doesn't exists.\n            // Now, if there is a registered handler for missing translations and no\n            // asyncLoader is pending, we execute the handler\n            result = missingTranslationHandlerTranslation;\n          } else {\n            result = applyNotFoundIndicators(translationId);\n          }\n        }\n\n        return result;\n      };\n\n      var clearNextLangAndPromise = function(key) {\n        if ($nextLang === key) {\n          $nextLang = undefined;\n        }\n        langPromises[key] = undefined;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#preferredLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the preferred language.\n       *\n       * @param {string} langKey language String or Array to be used as preferredLanguage (changing at runtime)\n       *\n       * @return {string} preferred language key\n       */\n      $translate.preferredLanguage = function (langKey) {\n        if(langKey) {\n          setupPreferredLanguage(langKey);\n        }\n        return $preferredLanguage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#cloakClassName\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured class name for `translate-cloak` directive.\n       *\n       * @return {string} cloakClassName\n       */\n      $translate.cloakClassName = function () {\n        return $cloakClassName;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#nestedObjectDelimeter\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the configured delimiter for nested namespaces.\n       *\n       * @return {string} nestedObjectDelimeter\n       */\n      $translate.nestedObjectDelimeter = function () {\n        return $nestedObjectDelimeter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#fallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key for the fallback languages or sets a new fallback stack.\n       *\n       * @param {string=} langKey language String or Array of fallback languages to be used (to change stack at runtime)\n       *\n       * @return {string||array} fallback language key\n       */\n      $translate.fallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          fallbackStack(langKey);\n\n          // as we might have an async loader initiated and a new translation language might have been defined\n          // we need to add the promise to the stack also. So - iterate.\n          if ($loaderFactory) {\n            if ($fallbackLanguage && $fallbackLanguage.length) {\n              for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n                if (!langPromises[$fallbackLanguage[i]]) {\n                  langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);\n                }\n              }\n            }\n          }\n          $translate.use($translate.use());\n        }\n        if ($fallbackWasString) {\n          return $fallbackLanguage[0];\n        } else {\n          return $fallbackLanguage;\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#useFallbackLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Sets the first key of the fallback language stack to be used for translation.\n       * Therefore all languages in the fallback array BEFORE this key will be skipped!\n       *\n       * @param {string=} langKey Contains the langKey the iteration shall start with. Set to false if you want to\n       * get back to the whole stack\n       */\n      $translate.useFallbackLanguage = function (langKey) {\n        if (langKey !== undefined && langKey !== null) {\n          if (!langKey) {\n            startFallbackIteration = 0;\n          } else {\n            var langKeyPosition = indexOf($fallbackLanguage, langKey);\n            if (langKeyPosition > -1) {\n              startFallbackIteration = langKeyPosition;\n            }\n          }\n\n        }\n\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#proposedLanguage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the language key of language that is currently loaded asynchronously.\n       *\n       * @return {string} language key\n       */\n      $translate.proposedLanguage = function () {\n        return $nextLang;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storage\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns registered storage.\n       *\n       * @return {object} Storage\n       */\n      $translate.storage = function () {\n        return Storage;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#negotiateLocale\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a language key based on available languages and language aliases. If a\n       * language key cannot be resolved, returns undefined.\n       *\n       * If no or a falsy key is given, returns undefined.\n       *\n       * @param {string} [key] Language key\n       * @return {string|undefined} Language key or undefined if no language key is found.\n       */\n      $translate.negotiateLocale = negotiateLocale;\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#use\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Tells angular-translate which language to use by given language key. This method is\n       * used to change language at runtime. It also takes care of storing the language\n       * key in a configured store to let your app remember the choosed language.\n       *\n       * When trying to 'use' a language which isn't available it tries to load it\n       * asynchronously with registered loaders.\n       *\n       * Returns promise object with loaded language file data or string of the currently used language.\n       *\n       * If no or a falsy key is given it returns the currently used language key.\n       * The returned string will be ```undefined``` if setting up $translate hasn't finished.\n       * @example\n       * $translate.use(\"en_US\").then(function(data){\n       *   $scope.text = $translate(\"HELLO\");\n       * });\n       *\n       * @param {string} [key] Language key\n       * @return {object|string} Promise with loaded language data or the language key if a falsy param was given.\n       */\n      $translate.use = function (key) {\n        if (!key) {\n          return $uses;\n        }\n\n        var deferred = $q.defer();\n\n        $rootScope.$emit('$translateChangeStart', {language: key});\n\n        // Try to get the aliased language key\n        var aliasedKey = negotiateLocale(key);\n        if (aliasedKey) {\n          key = aliasedKey;\n        }\n\n        // if there isn't a translation table for the language we've requested,\n        // we load it asynchronously\n        $nextLang = key;\n        if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {\n          langPromises[key] = loadAsync(key).then(function (translation) {\n            translations(translation.key, translation.table);\n            deferred.resolve(translation.key);\n            if ($nextLang === key) {\n              useLanguage(translation.key);\n            }\n            return translation;\n          }, function (key) {\n            $rootScope.$emit('$translateChangeError', {language: key});\n            deferred.reject(key);\n            $rootScope.$emit('$translateChangeEnd', {language: key});\n            return $q.reject(key);\n          });\n          langPromises[key]['finally'](function () {\n            clearNextLangAndPromise(key);\n          });\n        } else if (langPromises[key]) {\n          // we are already loading this asynchronously\n          // resolve our new deferred when the old langPromise is resolved\n          langPromises[key].then(function (translation) {\n            if ($nextLang === translation.key) {\n              useLanguage(translation.key);\n            }\n            deferred.resolve(translation.key);\n            return translation;\n          }, function (key) {\n            // find first available fallback language if that request has failed\n            if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0) {\n              return $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);\n            } else {\n              return deferred.reject(key);\n            }\n          });\n        } else {\n          deferred.resolve(key);\n          useLanguage(key);\n        }\n\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#storageKey\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the key for the storage.\n       *\n       * @return {string} storage key\n       */\n      $translate.storageKey = function () {\n        return storageKey();\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isPostCompilingEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether post compiling is enabled or not\n       *\n       * @return {bool} storage key\n       */\n      $translate.isPostCompilingEnabled = function () {\n        return $postCompilingEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isForceAsyncReloadEnabled\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether force async reload is enabled or not\n       *\n       * @return {boolean} forceAsyncReload value\n       */\n      $translate.isForceAsyncReloadEnabled = function () {\n        return $forceAsyncReloadEnabled;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#refresh\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Refreshes a translation table pointed by the given langKey. If langKey is not specified,\n       * the module will drop all existent translation tables and load new version of those which\n       * are currently in use.\n       *\n       * Refresh means that the module will drop target translation table and try to load it again.\n       *\n       * In case there are no loaders registered the refresh() method will throw an Error.\n       *\n       * If the module is able to refresh translation tables refresh() method will broadcast\n       * $translateRefreshStart and $translateRefreshEnd events.\n       *\n       * @example\n       * // this will drop all currently existent translation tables and reload those which are\n       * // currently in use\n       * $translate.refresh();\n       * // this will refresh a translation table for the en_US language\n       * $translate.refresh('en_US');\n       *\n       * @param {string} langKey A language key of the table, which has to be refreshed\n       *\n       * @return {promise} Promise, which will be resolved in case a translation tables refreshing\n       * process is finished successfully, and reject if not.\n       */\n      $translate.refresh = function (langKey) {\n        if (!$loaderFactory) {\n          throw new Error('Couldn\\'t refresh translation table, no loader registered!');\n        }\n\n        var deferred = $q.defer();\n\n        function resolve() {\n          deferred.resolve();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        function reject() {\n          deferred.reject();\n          $rootScope.$emit('$translateRefreshEnd', {language: langKey});\n        }\n\n        $rootScope.$emit('$translateRefreshStart', {language: langKey});\n\n        if (!langKey) {\n          // if there's no language key specified we refresh ALL THE THINGS!\n          var tables = [], loadingKeys = {};\n\n          // reload registered fallback languages\n          if ($fallbackLanguage && $fallbackLanguage.length) {\n            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n              tables.push(loadAsync($fallbackLanguage[i]));\n              loadingKeys[$fallbackLanguage[i]] = true;\n            }\n          }\n\n          // reload currently used language\n          if ($uses && !loadingKeys[$uses]) {\n            tables.push(loadAsync($uses));\n          }\n\n          var allTranslationsLoaded = function (tableData) {\n            $translationTable = {};\n            angular.forEach(tableData, function (data) {\n              translations(data.key, data.table);\n            });\n            if ($uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          allTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          $q.all(tables).then(allTranslationsLoaded, reject);\n\n        } else if ($translationTable[langKey]) {\n\n          var oneTranslationsLoaded = function (data) {\n            translations(data.key, data.table);\n            if (langKey === $uses) {\n              useLanguage($uses);\n            }\n            resolve();\n          };\n          oneTranslationsLoaded.displayName = 'refreshPostProcessor';\n\n          loadAsync(langKey).then(oneTranslationsLoaded, reject);\n\n        } else {\n          reject();\n        }\n        return deferred.promise;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#instant\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns a translation instantly from the internal state of loaded translation. All rules\n       * regarding the current language, the preferred language of even fallback languages will be\n       * used except any promise handling. If a language was not found, an asynchronous loading\n       * will be invoked in the background.\n       *\n       * @param {string|array} translationId A token which represents a translation id\n       *                                     This can be optionally an array of translation ids which\n       *                                     results that the function's promise returns an object where\n       *                                     each key is the translation id and the value the translation.\n       * @param {object} interpolateParams Params\n       * @param {string} interpolationId The id of the interpolation to use\n       * @param {string} forceLanguage A language to be used instead of the current language\n       *\n       * @return {string|object} translation\n       */\n      $translate.instant = function (translationId, interpolateParams, interpolationId, forceLanguage) {\n\n        // we don't want to re-negotiate $uses\n        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses\n              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;\n\n        // Detect undefined and null values to shorten the execution and prevent exceptions\n        if (translationId === null || angular.isUndefined(translationId)) {\n          return translationId;\n        }\n\n        // Duck detection: If the first argument is an array, a bunch of translations was requested.\n        // The result is an object.\n        if (angular.isArray(translationId)) {\n          var results = {};\n          for (var i = 0, c = translationId.length; i < c; i++) {\n            results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage);\n          }\n          return results;\n        }\n\n        // We discarded unacceptable values. So we just need to verify if translationId is empty String\n        if (angular.isString(translationId) && translationId.length < 1) {\n          return translationId;\n        }\n\n        // trim off any whitespace\n        if (translationId) {\n          translationId = trim.apply(translationId);\n        }\n\n        var result, possibleLangKeys = [];\n        if ($preferredLanguage) {\n          possibleLangKeys.push($preferredLanguage);\n        }\n        if (uses) {\n          possibleLangKeys.push(uses);\n        }\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);\n        }\n        for (var j = 0, d = possibleLangKeys.length; j < d; j++) {\n          var possibleLangKey = possibleLangKeys[j];\n          if ($translationTable[possibleLangKey]) {\n            if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {\n              result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses);\n            }\n          }\n          if (typeof result !== 'undefined') {\n            break;\n          }\n        }\n\n        if (!result && result !== '') {\n          if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {\n            result = applyNotFoundIndicators(translationId);\n          } else {\n            // Return translation of default interpolator if not found anything.\n            result = defaultInterpolator.interpolate(translationId, interpolateParams);\n            if ($missingTranslationHandlerFactory && !pendingLoader) {\n              result = translateByHandler(translationId, interpolateParams);\n            }\n          }\n        }\n\n        return result;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#versionInfo\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the current version information for the angular-translate library\n       *\n       * @return {string} angular-translate version\n       */\n      $translate.versionInfo = function () {\n        return version;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#loaderCache\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns the defined loaderCache.\n       *\n       * @return {boolean|string|object} current value of loaderCache\n       */\n      $translate.loaderCache = function () {\n        return loaderCache;\n      };\n\n      // internal purpose only\n      $translate.directivePriority = function () {\n        return directivePriority;\n      };\n\n      // internal purpose only\n      $translate.statefulFilter = function () {\n        return statefulFilter;\n      };\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#isReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_onReady onReady()}.\n       *\n       * @return {boolean} current value of ready\n       */\n      $translate.isReady = function () {\n        return $isReady;\n      };\n\n      var $onReadyDeferred = $q.defer();\n      $onReadyDeferred.promise.then(function () {\n        $isReady = true;\n      });\n\n      /**\n       * @ngdoc function\n       * @name pascalprecht.translate.$translate#onReady\n       * @methodOf pascalprecht.translate.$translate\n       *\n       * @description\n       * Returns whether the service is \"ready\" to translate (i.e. loading 1st language).\n       *\n       * See also {@link pascalprecht.translate.$translate#methods_isReady isReady()}.\n       *\n       * @param {Function=} fn Function to invoke when service is ready\n       * @return {object} Promise resolved when service is ready\n       */\n      $translate.onReady = function (fn) {\n        var deferred = $q.defer();\n        if (angular.isFunction(fn)) {\n          deferred.promise.then(fn);\n        }\n        if ($isReady) {\n          deferred.resolve();\n        } else {\n          $onReadyDeferred.promise.then(deferred.resolve);\n        }\n        return deferred.promise;\n      };\n\n      // Whenever $translateReady is being fired, this will ensure the state of $isReady\n      var globalOnReadyListener = $rootScope.$on('$translateReady', function () {\n        $onReadyDeferred.resolve();\n        globalOnReadyListener(); // one time only\n        globalOnReadyListener = null;\n      });\n      var globalOnChangeListener = $rootScope.$on('$translateChangeEnd', function () {\n        $onReadyDeferred.resolve();\n        globalOnChangeListener(); // one time only\n        globalOnChangeListener = null;\n      });\n\n      if ($loaderFactory) {\n\n        // If at least one async loader is defined and there are no\n        // (default) translations available we should try to load them.\n        if (angular.equals($translationTable, {})) {\n          if ($translate.use()) {\n            $translate.use($translate.use());\n          }\n        }\n\n        // Also, if there are any fallback language registered, we start\n        // loading them asynchronously as soon as we can.\n        if ($fallbackLanguage && $fallbackLanguage.length) {\n          var processAsyncResult = function (translation) {\n            translations(translation.key, translation.table);\n            $rootScope.$emit('$translateChangeEnd', { language: translation.key });\n            return translation;\n          };\n          for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {\n            var fallbackLanguageId = $fallbackLanguage[i];\n            if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {\n              langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);\n            }\n          }\n        }\n      } else {\n        $rootScope.$emit('$translateReady', { language: $translate.use() });\n      }\n\n      return $translate;\n    }\n  ];\n}\n$translate.$inject = ['$STORAGE_KEY', '$windowProvider', '$translateSanitizationProvider', 'pascalprechtTranslateOverrider'];\n\n$translate.displayName = 'displayName';\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translateDefaultInterpolation\n * @requires $interpolate\n *\n * @description\n * Uses angular's `$interpolate` services to interpolate strings against some values.\n *\n * Be aware to configure a proper sanitization strategy.\n *\n * See also:\n * * {@link pascalprecht.translate.$translateSanitization}\n *\n * @return {object} $translateDefaultInterpolation Interpolator service\n */\nangular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', $translateDefaultInterpolation);\n\nfunction $translateDefaultInterpolation ($interpolate, $translateSanitization) {\n\n  'use strict';\n\n  var $translateInterpolator = {},\n      $locale,\n      $identifier = 'default';\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#setLocale\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Sets current locale (this is currently not use in this interpolation).\n   *\n   * @param {string} locale Language key or locale.\n   */\n  $translateInterpolator.setLocale = function (locale) {\n    $locale = locale;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#getInterpolationIdentifier\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Returns an identifier for this interpolation service.\n   *\n   * @returns {string} $identifier\n   */\n  $translateInterpolator.getInterpolationIdentifier = function () {\n    return $identifier;\n  };\n\n  /**\n   * @deprecated will be removed in 3.0\n   * @see {@link pascalprecht.translate.$translateSanitization}\n   */\n  $translateInterpolator.useSanitizeValueStrategy = function (value) {\n    $translateSanitization.useStrategy(value);\n    return this;\n  };\n\n  /**\n   * @ngdoc function\n   * @name pascalprecht.translate.$translateDefaultInterpolation#interpolate\n   * @methodOf pascalprecht.translate.$translateDefaultInterpolation\n   *\n   * @description\n   * Interpolates given string agains given interpolate params using angulars\n   * `$interpolate` service.\n   *\n   * @returns {string} interpolated string.\n   */\n  $translateInterpolator.interpolate = function (string, interpolationParams) {\n    interpolationParams = interpolationParams || {};\n    interpolationParams = $translateSanitization.sanitize(interpolationParams, 'params');\n\n    var interpolatedText = $interpolate(string)(interpolationParams);\n    interpolatedText = $translateSanitization.sanitize(interpolatedText, 'text');\n\n    return interpolatedText;\n  };\n\n  return $translateInterpolator;\n}\n$translateDefaultInterpolation.$inject = ['$interpolate', '$translateSanitization'];\n\n$translateDefaultInterpolation.displayName = '$translateDefaultInterpolation';\n\nangular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translate\n * @requires $compile\n * @requires $filter\n * @requires $interpolate\n * @restrict AE\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate Translation id which could be either string or interpolated string.\n * @param {string=} translate-values Values to pass into translation id. Can be passed as object literal string or interpolated object.\n * @param {string=} translate-attr-ATTR translate Translation id and put it into ATTR attribute.\n * @param {string=} translate-default will be used unless translation was successful\n * @param {boolean=} translate-compile (default true if present) defines locally activation of {@link pascalprecht.translate.$translateProvider#methods_usePostCompiling}\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre translate=\"TRANSLATION_ID\"></pre>\n        <pre translate>TRANSLATION_ID</pre>\n        <pre translate translate-attr-title=\"TRANSLATION_ID\"></pre>\n        <pre translate=\"{{translationId}}\"></pre>\n        <pre translate>{{translationId}}</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{value: 5}\"></pre>\n        <pre translate translate-values=\"{value: 5}\">WITH_VALUES</pre>\n        <pre translate=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n        <pre translate translate-values=\"{{values}}\">WITH_VALUES</pre>\n        <pre translate translate-attr-title=\"WITH_VALUES\" translate-values=\"{{values}}\"></pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        }).preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n    <file name=\"scenario.js\">\n      it('should translate', function () {\n        inject(function ($rootScope, $compile) {\n          $rootScope.translationId = 'TRANSLATION_ID';\n\n          element = $compile('<p translate=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate=\"{{translationId}}\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>TRANSLATION_ID</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate>{{translationId}}</p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.text()).toBe('Hello there!');\n\n          element = $compile('<p translate translate-attr-title=\"TRANSLATION_ID\"></p>')($rootScope);\n          $rootScope.$digest();\n          expect(element.attr('title')).toBe('Hello there!');\n        });\n      });\n    </file>\n   </example>\n */\n.directive('translate', translateDirective);\nfunction translateDirective($translate, $q, $interpolate, $compile, $parse, $rootScope) {\n\n  'use strict';\n\n  /**\n   * @name trim\n   * @private\n   *\n   * @description\n   * trim polyfill\n   *\n   * @returns {string} The string stripped of whitespace from both ends\n   */\n  var trim = function() {\n    return this.toString().replace(/^\\s+|\\s+$/g, '');\n  };\n\n  return {\n    restrict: 'AE',\n    scope: true,\n    priority: $translate.directivePriority(),\n    compile: function (tElement, tAttr) {\n\n      var translateValuesExist = (tAttr.translateValues) ?\n        tAttr.translateValues : undefined;\n\n      var translateInterpolation = (tAttr.translateInterpolation) ?\n        tAttr.translateInterpolation : undefined;\n\n      var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);\n\n      var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',\n          watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';\n\n      return function linkFn(scope, iElement, iAttr) {\n\n        scope.interpolateParams = {};\n        scope.preText = '';\n        scope.postText = '';\n        scope.translateNamespace = getTranslateNamespace(scope);\n        var translationIds = {};\n\n        var initInterpolationParams = function (interpolateParams, iAttr, tAttr) {\n          // initial setup\n          if (iAttr.translateValues) {\n            angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));\n          }\n          // initially fetch all attributes if existing and fill the params\n          if (translateValueExist) {\n            for (var attr in tAttr) {\n              if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n                var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);\n                interpolateParams[attributeName] = tAttr[attr];\n              }\n            }\n          }\n        };\n\n        // Ensures any change of the attribute \"translate\" containing the id will\n        // be re-stored to the scope's \"translationId\".\n        // If the attribute has no content, the element's text value (white spaces trimmed off) will be used.\n        var observeElementTranslation = function (translationId) {\n\n          // Remove any old watcher\n          if (angular.isFunction(observeElementTranslation._unwatchOld)) {\n            observeElementTranslation._unwatchOld();\n            observeElementTranslation._unwatchOld = undefined;\n          }\n\n          if (angular.equals(translationId , '') || !angular.isDefined(translationId)) {\n            var iElementText = trim.apply(iElement.text());\n\n            // Resolve translation id by inner html if required\n            var interpolateMatches = iElementText.match(interpolateRegExp);\n            // Interpolate translation id if required\n            if (angular.isArray(interpolateMatches)) {\n              scope.preText = interpolateMatches[1];\n              scope.postText = interpolateMatches[3];\n              translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);\n              var watcherMatches = iElementText.match(watcherRegExp);\n              if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {\n                observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function (newValue) {\n                  translationIds.translate = newValue;\n                  updateTranslations();\n                });\n              }\n            } else {\n              // do not assigne the translation id if it is empty.\n              translationIds.translate = !iElementText ? undefined : iElementText;\n            }\n          } else {\n            translationIds.translate = translationId;\n          }\n          updateTranslations();\n        };\n\n        var observeAttributeTranslation = function (translateAttr) {\n          iAttr.$observe(translateAttr, function (translationId) {\n            translationIds[translateAttr] = translationId;\n            updateTranslations();\n          });\n        };\n\n        // initial setup with values\n        initInterpolationParams(scope.interpolateParams, iAttr, tAttr);\n\n        var firstAttributeChangedEvent = true;\n        iAttr.$observe('translate', function (translationId) {\n          if (typeof translationId === 'undefined') {\n            // case of element \"<translate>xyz</translate>\"\n            observeElementTranslation('');\n          } else {\n            // case of regular attribute\n            if (translationId !== '' || !firstAttributeChangedEvent) {\n              translationIds.translate = translationId;\n              updateTranslations();\n            }\n          }\n          firstAttributeChangedEvent = false;\n        });\n\n        for (var translateAttr in iAttr) {\n          if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr') {\n            observeAttributeTranslation(translateAttr);\n          }\n        }\n\n        iAttr.$observe('translateDefault', function (value) {\n          scope.defaultText = value;\n          updateTranslations();\n        });\n\n        if (translateValuesExist) {\n          iAttr.$observe('translateValues', function (interpolateParams) {\n            if (interpolateParams) {\n              scope.$parent.$watch(function () {\n                angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));\n              });\n            }\n          });\n        }\n\n        if (translateValueExist) {\n          var observeValueAttribute = function (attrName) {\n            iAttr.$observe(attrName, function (value) {\n              var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);\n              scope.interpolateParams[attributeName] = value;\n            });\n          };\n          for (var attr in iAttr) {\n            if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {\n              observeValueAttribute(attr);\n            }\n          }\n        }\n\n        // Master update function\n        var updateTranslations = function () {\n          for (var key in translationIds) {\n\n            if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {\n              updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);\n            }\n          }\n        };\n\n        // Put translation processing function outside loop\n        var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {\n          if (translationId) {\n            // if translation id starts with '.' and translateNamespace given, prepend namespace\n            if (translateNamespace && translationId.charAt(0) === '.') {\n              translationId = translateNamespace + translationId;\n            }\n\n            $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage)\n              .then(function (translation) {\n                applyTranslation(translation, scope, true, translateAttr);\n              }, function (translationId) {\n                applyTranslation(translationId, scope, false, translateAttr);\n              });\n          } else {\n            // as an empty string cannot be translated, we can solve this using successful=false\n            applyTranslation(translationId, scope, false, translateAttr);\n          }\n        };\n\n        var applyTranslation = function (value, scope, successful, translateAttr) {\n          if (translateAttr === 'translate') {\n            // default translate into innerHTML\n            if (!successful && typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n            iElement.empty().append(scope.preText + value + scope.postText);\n            var globallyEnabled = $translate.isPostCompilingEnabled();\n            var locallyDefined = typeof tAttr.translateCompile !== 'undefined';\n            var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';\n            if ((globallyEnabled && !locallyDefined) || locallyEnabled) {\n              $compile(iElement.contents())(scope);\n            }\n          } else {\n            // translate attribute\n            if (!successful && typeof scope.defaultText !== 'undefined') {\n              value = scope.defaultText;\n            }\n            var attributeName = iAttr.$attr[translateAttr];\n            if (attributeName.substr(0, 5) === 'data-') {\n              // ensure html5 data prefix is stripped\n              attributeName = attributeName.substr(5);\n            }\n            attributeName = attributeName.substr(15);\n            iElement.attr(attributeName, value);\n          }\n        };\n\n        if (translateValuesExist || translateValueExist || iAttr.translateDefault) {\n          scope.$watch('interpolateParams', updateTranslations, true);\n        }\n        scope.$watch('translateLanguage', updateTranslations);\n\n        // Ensures the text will be refreshed after the current language was changed\n        // w/ $translate.use(...)\n        var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);\n\n        // ensure translation will be looked up at least one\n        if (iElement.text().length) {\n          if (iAttr.translate) {\n            observeElementTranslation(iAttr.translate);\n          } else {\n            observeElementTranslation('');\n          }\n        } else if (iAttr.translate) {\n          // ensure attribute will be not skipped\n          observeElementTranslation(iAttr.translate);\n        }\n        updateTranslations();\n        scope.$on('$destroy', unbind);\n      };\n    }\n  };\n}\ntranslateDirective.$inject = ['$translate', '$q', '$interpolate', '$compile', '$parse', '$rootScope'];\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateDirective.displayName = 'translateDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateCloak\n * @requires $rootScope\n * @requires $translate\n * @restrict A\n *\n * $description\n * Adds a `translate-cloak` class name to the given element where this directive\n * is applied initially and removes it, once a loader has finished loading.\n *\n * This directive can be used to prevent initial flickering when loading translation\n * data asynchronously.\n *\n * The class name is defined in\n * {@link pascalprecht.translate.$translateProvider#cloakClassName $translate.cloakClassName()}.\n *\n * @param {string=} translate-cloak If a translationId is provided, it will be used for showing\n *                                  or hiding the cloak. Basically it relies on the translation\n *                                  resolve.\n */\n.directive('translateCloak', translateCloakDirective);\n\nfunction translateCloakDirective($translate, $rootScope) {\n\n  'use strict';\n\n  return {\n    compile: function (tElement) {\n      var applyCloak = function () {\n        tElement.addClass($translate.cloakClassName());\n      },\n      removeCloak = function () {\n        tElement.removeClass($translate.cloakClassName());\n      };\n      $translate.onReady(function () {\n        removeCloak();\n      });\n      applyCloak();\n\n      return function linkFn(scope, iElement, iAttr) {\n        if (iAttr.translateCloak && iAttr.translateCloak.length) {\n          // Register a watcher for the defined translation allowing a fine tuned cloak\n          iAttr.$observe('translateCloak', function (translationId) {\n            $translate(translationId).then(removeCloak, applyCloak);\n          });\n          // Register for change events as this is being another indicicator revalidating the cloak)\n          $rootScope.$on('$translateChangeSuccess', function () {\n            $translate(iAttr.translateCloak).then(removeCloak, applyCloak);\n          });\n        }\n      };\n    }\n  };\n}\ntranslateCloakDirective.$inject = ['$translate', '$rootScope'];\n\ntranslateCloakDirective.displayName = 'translateCloakDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateNamespace\n * @restrict A\n *\n * @description\n * Translates given translation id either through attribute or DOM content.\n * Internally it uses `translate` filter to translate translation id. It possible to\n * pass an optional `translate-values` object literal as string into translation id.\n *\n * @param {string=} translate namespace name which could be either string or interpolated string.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div translate-namespace=\"CONTENT\">\n\n        <div>\n            <h1 translate>.HEADERS.TITLE</h1>\n            <h1 translate>.HEADERS.WELCOME</h1>\n        </div>\n\n        <div translate-namespace=\".HEADERS\">\n            <h1 translate>.TITLE</h1>\n            <h1 translate>.WELCOME</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en',{\n          'TRANSLATION_ID': 'Hello there!',\n          'CONTENT': {\n            'HEADERS': {\n                TITLE: 'Title'\n            }\n          },\n          'CONTENT.HEADERS.WELCOME': 'Welcome'\n        }).preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateNamespace', translateNamespaceDirective);\n\nfunction translateNamespaceDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return {\n        pre: function (scope, iElement, iAttrs) {\n          scope.translateNamespace = getTranslateNamespace(scope);\n\n          if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === '.') {\n            scope.translateNamespace += iAttrs.translateNamespace;\n          } else {\n            scope.translateNamespace = iAttrs.translateNamespace;\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * Returns the scope's namespace.\n * @private\n * @param scope\n * @returns {string}\n */\nfunction getTranslateNamespace(scope) {\n  'use strict';\n  if (scope.translateNamespace) {\n    return scope.translateNamespace;\n  }\n  if (scope.$parent) {\n    return getTranslateNamespace(scope.$parent);\n  }\n}\n\ntranslateNamespaceDirective.displayName = 'translateNamespaceDirective';\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc directive\n * @name pascalprecht.translate.directive:translateLanguage\n * @restrict A\n *\n * @description\n * Forces the language to the directives in the underlying scope.\n *\n * @param {string=} translate language that will be negotiated.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div>\n\n        <div>\n            <h1 translate>HELLO</h1>\n        </div>\n\n        <div translate-language=\"de\">\n            <h1 translate>HELLO</h1>\n        </div>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider\n          .translations('en',{\n            'HELLO': 'Hello world!'\n          })\n          .translations('de',{\n            'HELLO': 'Hallo Welt!'\n          })\n          .translations(.preferredLanguage('en');\n\n      });\n\n    </file>\n   </example>\n */\n.directive('translateLanguage', translateLanguageDirective);\n\nfunction translateLanguageDirective() {\n\n  'use strict';\n\n  return {\n    restrict: 'A',\n    scope: true,\n    compile: function () {\n      return function linkFn(scope, iElement, iAttrs) {\n        iAttrs.$observe('translateLanguage', function (newTranslateLanguage) {\n          scope.translateLanguage = newTranslateLanguage;\n        });\n      };\n    }\n  };\n}\n\ntranslateLanguageDirective.displayName = 'translateLanguageDirective';\n\n\nangular.module('pascalprecht.translate')\n/**\n * @ngdoc filter\n * @name pascalprecht.translate.filter:translate\n * @requires $parse\n * @requires pascalprecht.translate.$translate\n * @function\n *\n * @description\n * Uses `$translate` service to translate contents. Accepts interpolate parameters\n * to pass dynamized values though translation.\n *\n * @param {string} translationId A translation id to be translated.\n * @param {*=} interpolateParams Optional object literal (as hash or string) to pass values into translation.\n *\n * @returns {string} Translated text.\n *\n * @example\n   <example module=\"ngView\">\n    <file name=\"index.html\">\n      <div ng-controller=\"TranslateCtrl\">\n\n        <pre>{{ 'TRANSLATION_ID' | translate }}</pre>\n        <pre>{{ translationId | translate }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:'{value: 5}' }}</pre>\n        <pre>{{ 'WITH_VALUES' | translate:values }}</pre>\n\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngView', ['pascalprecht.translate'])\n\n      .config(function ($translateProvider) {\n\n        $translateProvider.translations('en', {\n          'TRANSLATION_ID': 'Hello there!',\n          'WITH_VALUES': 'The following value is dynamic: {{value}}'\n        });\n        $translateProvider.preferredLanguage('en');\n\n      });\n\n      angular.module('ngView').controller('TranslateCtrl', function ($scope) {\n        $scope.translationId = 'TRANSLATION_ID';\n\n        $scope.values = {\n          value: 78\n        };\n      });\n    </file>\n   </example>\n */\n.filter('translate', translateFilterFactory);\n\nfunction translateFilterFactory($parse, $translate) {\n\n  'use strict';\n\n  var translateFilter = function (translationId, interpolateParams, interpolation, forceLanguage) {\n\n    if (!angular.isObject(interpolateParams)) {\n      interpolateParams = $parse(interpolateParams)(this);\n    }\n\n    return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);\n  };\n\n  if ($translate.statefulFilter()) {\n    translateFilter.$stateful = true;\n  }\n\n  return translateFilter;\n}\ntranslateFilterFactory.$inject = ['$parse', '$translate'];\n\ntranslateFilterFactory.displayName = 'translateFilterFactory';\n\nangular.module('pascalprecht.translate')\n\n/**\n * @ngdoc object\n * @name pascalprecht.translate.$translationCache\n * @requires $cacheFactory\n *\n * @description\n * The first time a translation table is used, it is loaded in the translation cache for quick retrieval. You\n * can load translation tables directly into the cache by consuming the\n * `$translationCache` service directly.\n *\n * @return {object} $cacheFactory object.\n */\n  .factory('$translationCache', $translationCache);\n\nfunction $translationCache($cacheFactory) {\n\n  'use strict';\n\n  return $cacheFactory('translations');\n}\n$translationCache.$inject = ['$cacheFactory'];\n\n$translationCache.displayName = '$translationCache';\nreturn 'pascalprecht.translate';\n\n}));\n","/**\n * State-based routing for AngularJS\n * @version v0.2.18\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    toJson = angular.toJson;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i] || !parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:\n        result = result.replace(/\\/$/, '');\n        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  var param, paramVal;\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    param = this.params[paramName];\n    paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n    param = this.params[paramName];\n    paramVal = searchParams[paramName];\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validates\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      var isFinalPathParam = i + 1 === nPath;\n\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n\n      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      if (encoded.length === 0) continue;\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        if (isArray(val) && val.length === 0) return val;\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  // Use tildes to pre-encode slashes.\n  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n  // and bidirectional encoding/decoding fails.\n  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    \"string\": {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    \"int\": {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    \"bool\": {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    \"date\": {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    \"json\": {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    \"any\": { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\n      if (angular.isString(config.type))\n        return $types[config.type];\n      if (config.type instanceof Type)\n        return config.type;\n      return new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {function} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|function} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. \n   * \n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|function} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n\n        isHtml5 = isHtml5 && $sniffer.history;\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. Only parameters specified in the state definition can be overridden, new \n     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n     *    have changed.  It will reload the resolves and views of the current state and parent states.\n     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n     *    the transition reloads the resolves and views for that matched state, and all its children states.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n      \n      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n      if (hash) toParams['#'] = hash;\n      \n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n          if ($state.transition == null) $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .factory('$stateParams', function () { return {}; })\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\nvar ngMajorVer = angular.version.major;\nvar ngMinorVer = angular.version.minor;\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations\n * will be applied to the ui-view)\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = {\n      enter: function (element, target, cb) { target.after(element); cb(); },\n      leave: function (element, cb) { element.remove(); cb(); }\n    };\n\n    if (!!attrs.noanimation) return statics;\n\n    function animEnabled(element) {\n      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);\n      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();\n      return (!!$animator);\n    }\n\n    // ng 1.2+\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          if (!animEnabled(element)) {\n            statics.enter(element, target, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function(element, cb) {\n          if (!animEnabled(element)) {\n            statics.leave(element, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        }\n      };\n    }\n\n    // ng 1.1.5\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics;\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          var _previousEl = previousEl;\n          var _currentScope = currentScope;\n\n          if (_currentScope) {\n            _currentScope._willBeDestroyed = true;\n          }\n\n          function cleanOld() {\n            if (_previousEl) {\n              _previousEl.remove();\n            }\n\n            if (_currentScope) {\n              _currentScope.$destroy();\n            }\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              cleanOld();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n          } else {\n            cleanOld();\n            previousEl = null;\n          }\n\n          currentEl = null;\n          currentScope = null;\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          currentScope.$emit('$viewContentLoaded', name);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var inherited = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\nfunction clickHook(el, $state, $timeout, type, current) {\n  return function(e) {\n    var button = e.which || e.button, target = current();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function() {\n        $state.go(target.state, target.params, target.options);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\n      e.preventDefault = function() {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\nfunction defaultOpts(el, $state) {\n  return { relative: stateContext(el) || $state.$current, inherit: true };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n * URL, the directive will automatically generate & update the `href` attribute via\n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n * the link will trigger a state transition with optional parameters.\n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative\n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the\n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n *\n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n      var def    = { state: ref.state, href: null, params: null };\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n\n      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\n      var update = function(val) {\n        if (val) def.params = angular.copy(val);\n        def.href = $state.href(ref.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(ref.state, def.params);\n        if (def.href !== null) attrs.$set(type.attr, def.href);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n        def.params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-state\n *\n * @requires ui.router.state.uiSref\n *\n * @restrict A\n *\n * @description\n * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n * params and override options.\n *\n * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}\n * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDynamicDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n      var def    = { state: null, params: null, options: null, href: null };\n\n      function runStateRefLink (group) {\n        def.state = group[0]; def.params = group[1]; def.options = group[2];\n        def.href = $state.href(def.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(def.state, def.params);\n        if (def.href) attrs.$set(type.attr, def.href);\n      }\n\n      scope.$watch(watch, runStateRefLink, true);\n      runStateRefLink(scope.$eval(watch));\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * It is also possible to pass ui-sref-active an expression that evaluates\n * to an object hash, whose keys represent active class names and whose\n * values represent the respective state names/globs.\n * ui-sref-active will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * @Example\n * Given the following template, with \"admin\" being an abstract state:\n * <pre>\n * <div ui-sref-active=\"{'active': 'admin.*'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * </pre>\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied\n * to both the <div> and <a> elements. It is important to note that the state\n * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n      try {\n        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n      } catch (e) {\n        // Do nothing. uiSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n      if (isObject(uiSrefActive)) {\n        forEach(uiSrefActive, function(stateOrName, activeClass) {\n          if (isString(stateOrName)) {\n            var ref = parseStateRef(stateOrName, $state.current.name);\n            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n          }\n        });\n      }\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ui-sref-active, so we\n        // shadow the one that comes from ui-sref\n        if (isObject(uiSrefActive) && states.length > 0) {\n          return;\n        }\n        addState(newState, newParams, uiSrefActive);\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      function addState(stateName, stateParams, activeClass) {\n        var state = $state.get(stateName, stateContext($element));\n        var stateHash = createStateHash(stateName, stateParams);\n\n        states.push({\n          state: state || { name: stateName },\n          params: stateParams,\n          hash: stateHash\n        });\n\n        activeClasses[stateHash] = activeClass;\n      }\n\n      /**\n       * @param {string} state\n       * @param {Object|string} [params]\n       * @return {string}\n       */\n      function createStateHash(state, params) {\n        if (!isString(state)) {\n          throw new Error('state should be a string');\n        }\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        params = $scope.$eval(params);\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        return state;\n      }\n\n      // Update route state\n      function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }\n\n      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n      function removeClass(el, className) { el.removeClass(className); }\n      function anyMatch(state, params) { return $state.includes(state.name, params); }\n      function exactMatch(state, params) { return $state.is(state.name, params); }\n\n      update();\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n  .directive('uiState', $StateRefDynamicDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state, params) {\n    return $state.is(state, params);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state, params, options) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);","'use strict';\n// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.\n\nmodule.exports = {\n    // Create a <link> tag with optional data attributes\n    createLink: function(href, attributes) {\n        var head = document.head || document.getElementsByTagName('head')[0];\n        var link = document.createElement('link');\n\n        link.href = href;\n        link.rel = 'stylesheet';\n\n        for (var key in attributes) {\n            if ( ! attributes.hasOwnProperty(key)) {\n                continue;\n            }\n            var value = attributes[key];\n            link.setAttribute('data-' + key, value);\n        }\n\n        head.appendChild(link);\n    },\n    // Create a <style> tag with optional data attributes\n    createStyle: function(cssText, attributes) {\n        var head = document.head || document.getElementsByTagName('head')[0],\n            style = document.createElement('style');\n\n        style.type = 'text/css';\n\n        for (var key in attributes) {\n            if ( ! attributes.hasOwnProperty(key)) {\n                continue;\n            }\n            var value = attributes[key];\n            style.setAttribute('data-' + key, value);\n        }\n        \n        if (style.sheet) { // for jsdom and IE9+\n            style.innerHTML = cssText;\n            style.sheet.cssText = cssText;\n            head.appendChild(style);\n        } else if (style.styleSheet) { // for IE8 and below\n            head.appendChild(style);\n            style.styleSheet.cssText = cssText;\n        } else { // for Chrome, Firefox, and Safari\n            style.appendChild(document.createTextNode(cssText));\n            head.appendChild(style);\n        }\n    }\n};\n"],"sourceRoot":"/source/"}