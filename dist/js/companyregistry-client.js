(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
var ng = (typeof window !== "undefined" ? window['angular'] : typeof global !== "undefined" ? global['angular'] : null);
var MainViewController = require('./components/common/MainViewController');
var SideNavViewController = require('./components/nav/SideNavViewController');
var BeneficiaryViewController = require('./components/beneficiary/BeneficiaryViewController');
var CompanyViewController = require('./components/company/CompanyViewController');
var config = require('./config');

var moduleName = config.configBlock.namespace + '.controllers';
var controllersModule = ng.module(moduleName, [])
    .controller('MainViewController', MainViewController.controller)
    .controller('SideNavViewController', SideNavViewController.controller)
    .controller('BeneficiaryViewController', BeneficiaryViewController.controller)
    .controller('CompanyViewController', CompanyViewController.controller);

exports.controllersModule = controllersModule;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./components/beneficiary/BeneficiaryViewController":13,"./components/common/MainViewController":15,"./components/company/CompanyViewController":26,"./components/nav/SideNavViewController":28,"./config":31}],2:[function(require,module,exports){
(function (global){
var ng = (typeof window !== "undefined" ? window['angular'] : typeof global !== "undefined" ? global['angular'] : null);
var MainViewDirective = require('./components/common/MainViewDirective');
var SideNavViewDirective = require('./components/nav/SideNavViewDirective');
var BeneficiaryViewDirective = require('./components/beneficiary/BeneficiaryViewDirective');
var BeneficiaryCreateViewDirective = require('./components/beneficiary/BeneficiaryCreateViewDirective');
var BeneficiaryUpdateViewDirective = require('./components/beneficiary/BeneficiaryUpdateViewDirective');
var BeneficiaryDeleteViewDirective = require('./components/beneficiary/BeneficiaryDeleteViewDirective');
var BeneficiaryListViewDirective = require('./components/beneficiary/BeneficiaryListViewDirective');
var BeneficiaryListFragmentViewDirective = require('./components/beneficiary/BeneficiaryListFragmentViewDirective');
var BeneficiaryDetailViewDirective = require('./components/beneficiary/BeneficiaryDetailViewDirective');
var BeneficiarySearchViewDirective = require('./components/beneficiary/BeneficiarySearchViewDirective');
var CompanyViewDirective = require('./components/company/CompanyViewDirective');
var CompanyCreateViewDirective = require('./components/company/CompanyCreateViewDirective');
var CompanyUpdateViewDirective = require('./components/company/CompanyUpdateViewDirective');
var CompanyDeleteViewDirective = require('./components/company/CompanyDeleteViewDirective');
var CompanyListViewDirective = require('./components/company/CompanyListViewDirective');
var CompanyListFragmentViewDirective = require('./components/company/CompanyListFragmentViewDirective');
var CompanySearchViewDirective = require('./components/company/CompanySearchViewDirective');
var config = require('./config');

var moduleName = config.configBlock.namespace + '.directives';

var directivesModule = ng.module(moduleName, [])
    .directive('mainView', MainViewDirective.directive)
    .directive('sideNavView', SideNavViewDirective.directive)
    .directive('beneficiaryView', BeneficiaryViewDirective.directive)
    .directive('beneficiaryCreateView', BeneficiaryCreateViewDirective.directive)
    .directive('beneficiaryUpdateView', BeneficiaryUpdateViewDirective.directive)
    .directive('beneficiaryDeleteView', BeneficiaryDeleteViewDirective.directive)
    .directive('beneficiaryDetailView', BeneficiaryDetailViewDirective.directive)
    .directive('beneficiarySearchView', BeneficiarySearchViewDirective.directive)
    .directive('beneficiaryListView', BeneficiaryListViewDirective.directive)
    .directive('beneficiaryListDetailView', BeneficiaryListViewDirective.directive)
    .directive('beneficiaryListFragmentView', BeneficiaryListFragmentViewDirective.directive)
    .directive('companyView', CompanyViewDirective.directive)
    .directive('companyCreateView', CompanyCreateViewDirective.directive)
    .directive('companyUpdateView', CompanyUpdateViewDirective.directive)
    .directive('companyDeleteView', CompanyDeleteViewDirective.directive)
    .directive('companySearchView', CompanySearchViewDirective.directive)
    .directive('companyListView', CompanyListViewDirective.directive)
    .directive('companyListFragmentView', CompanyListFragmentViewDirective.directive)

exports.directivesModule = directivesModule;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./components/beneficiary/BeneficiaryCreateViewDirective":5,"./components/beneficiary/BeneficiaryDeleteViewDirective":6,"./components/beneficiary/BeneficiaryDetailViewDirective":7,"./components/beneficiary/BeneficiaryListFragmentViewDirective":8,"./components/beneficiary/BeneficiaryListViewDirective":9,"./components/beneficiary/BeneficiarySearchViewDirective":10,"./components/beneficiary/BeneficiaryUpdateViewDirective":12,"./components/beneficiary/BeneficiaryViewDirective":14,"./components/common/MainViewDirective":16,"./components/company/CompanyCreateViewDirective":19,"./components/company/CompanyDeleteViewDirective":20,"./components/company/CompanyListFragmentViewDirective":21,"./components/company/CompanyListViewDirective":22,"./components/company/CompanySearchViewDirective":23,"./components/company/CompanyUpdateViewDirective":25,"./components/company/CompanyViewDirective":27,"./components/nav/SideNavViewDirective":29,"./config":31}],3:[function(require,module,exports){
(function (global){
var ng = (typeof window !== "undefined" ? window['angular'] : typeof global !== "undefined" ? global['angular'] : null);
var BeneficiaryService = require('./components/beneficiary/BeneficiaryService');
var CompanyService = require('./components/company/CompanyService');
var UtilService = require('./components/common/UtilService');
var config = require('./config');

var moduleName = config.configBlock.namespace + '.services';
var servicesModule = ng.module(moduleName, [])
    .factory('beneficiaryService', BeneficiaryService.service)
    .factory('companyService', CompanyService.service)
    .factory('utilService', UtilService.service);

exports.servicesModule = servicesModule;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./components/beneficiary/BeneficiaryService":11,"./components/common/UtilService":18,"./components/company/CompanyService":24,"./config":31}],4:[function(require,module,exports){
(function (global){
/** Main app **/

'use strict';

var ng = (typeof window !== "undefined" ? window['angular'] : typeof global !== "undefined" ? global['angular'] : null);
var config = require('./config');
var constants = require('./constants');
var services = require('./angularservices');
var controllers = require('./angularcontrollers');
var directives = require('./angulardirectives');

var animateModule = require('angular-animate');
var translateModule = require('angular-translate');
var sanitizeModule = require('angular-sanitize');
var blockUIModule = require('angular-block-ui');
var uiRouterModule = require('angular-ui-router');

require('angular-block-ui/dist/angular-block-ui.min.css');

var moduleName = config.configBlock.namespace;

// Declare app level module which depends on services, controllers and directives
ng.module(moduleName, [animateModule, translateModule, sanitizeModule, blockUIModule, uiRouterModule,
    services.servicesModule.name, controllers.controllersModule.name, directives.directivesModule.name,
    'inform', 'inform-exception'/*, 'inform-http-exception'*/
]);

ng.module(moduleName)
  .config(config.configBlock.settings)
  .config(config.configBlock.states)
  .config(config.configBlock.blockUI)
  .config(config.configBlock.inform)
  .config(config.configBlock.hrefSanitize);

ng.module(moduleName)
  .constant('CONSTANTS', constants.constants);

var runBlock = function() {

    // Add code that needs a run block to execute here.
};

ng.module(moduleName)
  .run(runBlock);
  // .run(config.configBlock.modal);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./angularcontrollers":1,"./angulardirectives":2,"./angularservices":3,"./config":31,"./constants":32,"angular-animate":34,"angular-block-ui":35,"angular-block-ui/dist/angular-block-ui.min.css":36,"angular-sanitize":38,"angular-translate":39,"angular-ui-router":40}],5:[function(require,module,exports){
/**
 * Beneficiary Form Component Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/beneficiary/BeneficiaryCreateView.html',
        restrict: 'AE',
        scope: {
            beneficiary: '=beneficiaryDetails'
        },
        controllerAs: 'ctrl',
        controller: 'BeneficiaryViewController'
    };
};

exports.directive = directive;

},{}],6:[function(require,module,exports){
/**
 * Company Delete Component Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/beneficiary/BeneficiaryDeleteView.html',
        restrict: 'AE',
        scope: false,
        controllerAs: 'ctrl',
        controller: 'BeneficiaryViewController'
    };
};

exports.directive = directive;

},{}],7:[function(require,module,exports){
/**
 * Beneficiary Detail View Component Directive
 *
 * @param {$parse} Angular parser service
 * @param {$rootScope} Angular rootScope service
 *
 * @ngInject
 */
var directive = function($parse, $compile, $rootScope, $timeout) {
    'use strict';
    return {
        templateUrl: 'app/components/beneficiary/BeneficiaryDetailView.html',
        restrict: 'AE',
        //replace: true,
        //transclude: true,
        scope: {
            beneficiary: '=beneficiaryDetails'
        },
        link: function(scope, el, attrs) {
            $rootScope.$on('disableBeneficiary', function(ev, data) {
                for (var i = 0; i < data.beneficiaries.length; i++) {
                    if (data.beneficiaries[i].id === data.beneficiaryId) {
                        var inputEls = angular.element(el.find('input[type=text]'));
                        for (var j = 0; j < inputEls.length; j++) {
                            angular.element(inputEls[j]).attr('disabled', '');
                            $timeout(function() {
                                $compile(inputEls[j])(scope);
                            });
                        }
                        break;
                    }
                }
                //$compile(el)(scope);
            });
        }
    };
};
directive.$inject = ["$parse", "$compile", "$rootScope", "$timeout"];

exports.directive = directive;

},{}],8:[function(require,module,exports){
/**
 * Company Table List Component Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/beneficiary/BeneficiaryListFragmentView.html',
        restrict: 'AE',
        scope: {
            beneficiaries: '=',
            delref: '=',
            searchRequestSumbitted: '='
        },
        controllerAs: 'ctrl',
        controller: 'BeneficiaryViewController'
    };
};

exports.directive = directive;

},{}],9:[function(require,module,exports){
/**
 * Company Table List Component Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/beneficiary/BeneficiaryListView.html',
        restrict: 'AE',
        scope: false,
        controllerAs: 'ctrl',
        controller: 'BeneficiaryViewController'
    };
};

exports.directive = directive;

},{}],10:[function(require,module,exports){
/**
 * Company Search Component Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/beneficiary/BeneficiarySearchView.html',
        restrict: 'AE',
        scope: false,
        controllerAs: 'ctrl',
        controller: 'BeneficiaryViewController'
    };
};

exports.directive = directive;

},{}],11:[function(require,module,exports){
/**
 * This service helps to perform http requests (GET, POST, PUT, DELETE) for beneficiary tasks
 *
 * @param {$http} The AngularJS http service
 * @param {$timeout} The AngularJS timeout service
 *
 * @ngInject
 */
var service = function($http, $timeout) {
    'use strict';

    var serviceInstance = {};
    serviceInstance.selectedBeneficiaryId = null;
    serviceInstance.popOnDelete = null;
    serviceInstance.beneficiary = null;
    serviceInstance.beneficiaries = [];

    serviceInstance.getBeneficiary = function(url, callback) {
        $http({
            url: url,
            method: 'GET',
            dataType: 'jsonp'
        }).then(function(results) {
            callback(results);
        }, function(error) {
            var errorData = {
                status: error.status ? error.status : 500,
                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'
            };
            callback(errorData);
        });
    };

    serviceInstance.createBeneficiary = function(url, data, callback) {
        $http({
            url: url,
            data: data,
            method: 'POST',
            dataType: 'jsonp'
        }).then(function(results) {
            callback(results);
        }, function(error) {
            var errorData = {
                status: error.status ? error.status : 500,
                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'
            };
            callback(errorData);
        });
    };
    serviceInstance.updateBeneficiary = function(url, data, callback) {
        $http({
            url: url,
            method: 'PUT',
            data: data,
            dataType: 'jsonp'
        }).then(function(results) {
            callback(results);
        }, function(error) {
            var errorData = {
                status: error.status ? error.status : 500,
                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'
            };
            callback(errorData);
        });
    };

    serviceInstance.deleteBeneficiary = function(url, callback) {
        $http({
            url: url,
            method: 'DELETE',
            dataType: 'jsonp'
        }).then(function(results) {
            callback(results);
        }, function(error) {
            var errorData = {
                status: error.status ? error.status : 500,
                message: error.data ? error.data : 'Error occured while retrieving beneficiary details'
            };
            callback(errorData);
        });
    };

    return serviceInstance;
};
service.$inject = ["$http", "$timeout"];

exports.service = service;

},{}],12:[function(require,module,exports){
/**
 * Beneficiary Form Component Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/beneficiary/BeneficiaryUpdateView.html',
        restrict: 'AE',
        scope: {
            beneficiary: '=beneficiaryDetails'
        },
        controllerAs: 'ctrl',
        controller: 'BeneficiaryViewController'
    };
};

exports.directive = directive;

},{}],13:[function(require,module,exports){
/**
 * Beneficiary View controller
 *
 * This controller is responsible for handing beneficiary form module related logic
 *
 * @param {$rootScope} Angular root scope service
 * @param {$scope} Angular scope service
 * @param {$timeout} Angular timeout service
 * @param {$window} Angular window service
 * @param {$document} Angular document service
 * @param {$log} Angular logger service
 * @param {$modal} Angular modal service
 * @param {beneficiaryService} Beneficiary service
 * @param {utilService} Utility service
 * @param {blockUI} Block UI service
 * @param {inform} Inform provider service
 * @param {CONSTANTS} Project constants values
 *
 * @ngInject
 *
 */
var controller = function($rootScope, $scope, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, utilService, blockUI, inform, CONSTANTS) {
    'use strict';
    var ctrl = this;

    $scope.useExistingBeneficiary = false;
    $scope.minimumValidBeneficiary = false;
    $scope.beneficiaryId = null;
    $scope.beneficiarySearched = false;
    $scope.beneficiaryFound = false;
    $scope.searchRequestSumbitted = false;
    $scope.addRequestSubmitted = false;
    $scope.addRequestAttempted = false;
    $scope.updateRequestSubmitted = false;
    $scope.updateRequestAttempted = false;
    $scope.deleteRequestSubmitted = false;
    $scope.deleteSuccessful = false;
    $scope.serviceUrl = CONSTANTS.url.path;

    $scope.initBeneficiary = {
        "firstName": null,
        "lastName": null
    };

    $scope.beneficiaries = beneficiaryService.beneficiaries.length > 0 ? beneficiaryService.beneficiaries : [];
    $scope.beneficiary = beneficiaryService.beneficiary &&
                         ($state.current.name === 'start.beneficiary.update' || $state.current.name === 'start.beneficiary.list.delete' || $state.current.name === 'start.beneficiary.search.delete') ?
                         beneficiaryService.beneficiary : $scope.initBeneficiary;

    $scope.resetBeneficiary = function() {
        $timeout(function() {
            $scope.beneficiary = $scope.initBeneficiary;
            $scope.beneficiaries = [];
        });
    };

    $scope.addBeneficiary = function($event) {
        $event.stopPropagation();
        $scope.addRequestSubmitted = false;
        beneficiaryService.beneficiary = $scope.beneficiary;
        if (!utilService.isFormValid('beneficiaryDetailsForm')) {
            $scope.addRequestAttempted = true;
            $log.warn('form invalid');
            inform.add('Invalid form. First name and Last name are required to create beneficiary', {
                ttl: 3500,
                type: 'danger'
            });
            // $scope.registerPopoverShow('#addBeneficiary');
            return;
        }

        var beneficiaryCreateBlock = blockUI.instances.get('beneficiaryCreateBlock');
        // beneficiaryCreateBlock.start();
        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;
        beneficiaryService.createBeneficiary(url, $scope.beneficiary, function(result) {
            $timeout(function() {
                $scope.addRequestSubmitted = true;
                if (result && result.data) {
                    if (result.data.id > 0) {
                        inform.add('beneficiary created successfully.', {
                            ttl: 2500
                        });
                        $timeout(function() {
                            $state.go('start.beneficiary', {}, {reload:true});
                        }, 2500);
                    } else {
                        inform.add('Request completed, however beneficiary couldn\'t be created.', {
                            ttl: 5000,
                            type: 'warning'
                        });
                    }
                } else {
                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating beneficiary.', {
                        ttl: 5000,
                        type: 'danger'
                    });
                    $timeout(function() {
                        $scope.addRequestSubmitted = false;
                    }, 5000);
                }
                // beneficiaryCreateBlock.stop();
            });
        });
    };

    $scope.cancelAddBeneficiary = function() {
        $state.go('start.beneficiary');
    };

    $scope.updateBeneficiary = function($event) {
        $event.stopPropagation();
        $scope.updateRequestSubmitted = false;
        beneficiaryService.beneficiary = $scope.beneficiary;
        if (!utilService.isFormValid('beneficiaryDetailsForm')) {
            $scope.updateRequestAttempted = true;
            $log.warn('ccform invalid');
            inform.add('Invalid form. First name and Last name are required to create beneficiary', {
                ttl: 3500,
                type: 'danger'
            });
            return;
        }

        // var beneficiaryUpdateBlock = blockUI.instances.get('beneficiaryUpdateBlock');
        // beneficiaryUpdateBlock.start();
        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;
        beneficiaryService.updateBeneficiary(url, $scope.beneficiary, function(result) {
            $timeout(function() {
                $scope.updateRequestSubmitted = true;
                if (result && result.data) {
                    if (result.data.status === true) {
                        inform.add('beneficiary updated successfully.', {
                            ttl: 4000
                        });
                        $timeout(function() {
                            $state.go('start.beneficiary.list', {}, {reload: true});
                        }, 4500);
                    } else {
                        inform.add('Request completed successfully, but no update performed on beneficiary.', {
                            ttl: 5000,
                            type: 'warning'
                        });
                    }
                } else {
                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'beneficiary couldn\'t be updated.', {
                        ttl: 5000,
                        type: 'danger'
                    });
                    $timeout(function() {
                        $scope.updateRequestSubmitted = false;
                    }, 5000);
                }
                // beneficiaryUpdateBlock.stop();
            });
        });
    };

    $scope.cancelOrCloseBeneficiaryUpdate = function() {
        $state.go('start.beneficiary.list', {}, {reload: true});
    };

    $scope.deleteBeneficiary = function($event) {
        $event.stopPropagation();
        $scope.beneficiary = beneficiaryService.beneficiary;
        // var beneficiaryUpdateBlock = blockUI.instances.get('beneficiaryUpdateBlock');
        // beneficiaryUpdateBlock.start();
        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + $scope.beneficiary.id;
        beneficiaryService.deleteBeneficiary(url, function(result) {
            $timeout(function() {
                $scope.deleteRequestSubmitted = true;
                if (result && result.data && result.data.status === true) {
                    $scope.deleteSuccessful = true;
                } else {
                  $log.info(result);
                }
                // beneficiaryUpdateBlock.stop();
            });
        });
    };

    $scope.cancelOrCloseBeneficiaryDelete = function() {
        $scope.$dismiss();
        $state.go('start.beneficiary.list', {}, {reload: true});
    };

    $scope.fetchBeneficiary = function(id) {
        $scope.beneficiaries.splice(0, $scope.beneficiaries.length);

        var idSearch = !utilService.isBlank(id);
        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath;
        var url = idSearch ? baseUrl + '/' + id : baseUrl;
        //var beneficiaryListBlock = blockUI.instances.get('beneficiaryListBlock');
        //beneficiaryListBlock.start();
        beneficiaryService.getBeneficiary(url, function(result) {
            $timeout(function() {
                $scope.searchRequestSumbitted = true;
                if (result && result.data) {
                    if (idSearch) {
                        $scope.beneficiaries.push(result.data);
                    } else {
                        $scope.beneficiaries = result.data;
                    }
                    beneficiaryService.beneficiaries = $scope.beneficiaries;
                    $scope.beneficiaryFound = true;
                }
                //beneficiaryListBlock.stop();
            });
        });
    };

    $scope.searchBeneficiary = function(id, $event) {
        $event.stopPropagation();
        $timeout(function() {
            if (!utilService.isValidId(id)) {
                $scope.registerPopoverShow('#searchExistingBeneficiaryId');
                return;
            }
            $scope.fetchBeneficiary(id);
        });
    };

    $scope.mutateBeneficiaryOptions = function(beneficiary, $index, $event) {
        $event.stopPropagation();
        beneficiaryService.selectedBeneficiaryId = '#beneficiary' + $index;
        beneficiaryService.beneficiary = beneficiary;
        $scope.registerPopoverPrep(beneficiaryService.selectedBeneficiaryId);
        $scope.registerPopoverShow(beneficiaryService.selectedBeneficiaryId);
    };

    /* initialize popover */

    $scope.discardMessage = function($event) {
        $event ? $event.stopPropagation() : '';
        beneficiaryService.popOnDelete = "delete";
        $scope.registerPopoverHide('[id*=popover]');
    };

    beneficiaryService.popOnDelete = "delete";

    $scope.registerPopoverPrep = function(id) {
        angular.element($document.find(id)).popover({
            trigger: 'manual'
        });
    };

    $scope.registerPopoverShow = function(id) {
        if (beneficiaryService.popOnDelete !== "popover") {
            beneficiaryService.popOnDelete = "popover";
            angular.element($document.find(id)).popover('show');
        }
    };

    $scope.registerPopoverHide = function(id) {
        var el = angular.element($document.find(id));
        el ? el.popover('hide') : '';
    };

    $scope.registerPopoverPrep('#removeBeneficiary');
    $scope.registerPopoverPrep('#addBeneficiary');
    $scope.registerPopoverPrep('#updateBeneficiary');
    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');
    $scope.registerPopoverHide('[id*=popover]');

    // clear all informs
    inform.clear();
};
controller.$inject = ["$rootScope", "$scope", "$timeout", "$window", "$document", "$log", "$state", "$modal", "beneficiaryService", "utilService", "blockUI", "inform", "CONSTANTS"];

exports.controller = controller;

},{}],14:[function(require,module,exports){
/**
 * Main Beneficiary Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/beneficiary/BeneficiaryView.html',
        restrict: 'AE',
        scope: false,
        controllerAs: 'ctrl',
        controller: 'BeneficiaryViewController'
    };
};

exports.directive = directive;

},{}],15:[function(require,module,exports){
/**
 * Main View controller
 *
 * This controller is responsible for handing request from main view
 *
 * @param {$rootScope} Angular root scope service
 * @param {$scope} Angular scope service
 * @param {$timeout} Angular timeout service
 * @param {$window} Angular window service
 * @param {$document} Angular document service
 * @param {$log} Angular logger service
 * @param {beneficiaryService} Beneficiary service
 * @param {companyService} Company service
 *
 * @ngInject
 *
 */
var controller = function() {
    'use strict';
    var ctrl = this;

};

exports.controller = controller;

},{}],16:[function(require,module,exports){
/**
 * Main Directive
 *
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/common/MainView.html',
        restrict: 'AE',
        scope: false,
        controllerAs: 'ctrl',
        controller: 'MainViewController'
    };
};

exports.directive = directive;

},{}],17:[function(require,module,exports){
var stateConfig = {
    /**
     * Default to <company-create-view />
     */
    main: {
        url: '/',
        views: {
            'main': {
                template: '<main-view></main-view>'
            },
            'mainItem@start': {
                template: '<company-create-view></company-create-view>'
            }
        }
    },
    company: {
        initial: {
            url: 'company',
            views: {
                'mainItem@start': {
                    template: '<company-view></company-view>'
                }
            }
        },
        list: {
            url: '/list',
            views: {
                'mainItem@start': {
                    template: '<company-list-view></company-list-view>'
                }
            }
        },
        search: {
            url: '/search',
            views: {
                'mainItem@start': {
                    template: '<company-search-view></company-search-view>'
                }
            }
        },
        update: {
            url: '/update',
            views: {
                'mainItem@start': {
                    template: '<company-update-view></company-update-view>'
                }
            }
        },
        delete: {
            // would be used under start.company.list state, hence url resolves to: #/company/list/delete
            url: '/delete',
            /**
             * On state enter event listener
             * @param  {$modal} Modal service
             * @ngInject
             */
            onEnter: ["$modal", function($modal) {
                $modal.open({
                    template: '<company-delete-view></company-delete-view>',
                    backdrop: 'static',
                    keyboard: false,
                    windowClass: 'modal',
                    controller: 'CompanyViewController'
                });
            }]
        }
    },
    beneficiary: {
        initial: {
            url: 'beneficiary',
            views: {
                'mainItem@start': {
                    template: '<beneficiary-view></beneficiary-view>'
                }
            }
        },
        list: {
            url: '/list',
            views: {
                'mainItem@start': {
                    template: '<beneficiary-list-view></beneficiary-list-view>'
                }
            }
        },
        search: {
            url: '/search',
            views: {
                'mainItem@start': {
                    template: '<beneficiary-search-view></beneficiary-seach-view>'
                }
            }
        },
        update: {
            url: '/update',
            views: {
                'mainItem@start': {
                    template: '<beneficiary-update-view></beneficiary-update-view>'
                }
            }
        },
        delete: {
            /** would be used under start.beneficiary.list or start.beneficiary.search state,
             *  hence url resolves to: #/beneficiary/list/delete or  #/beneficiary/search/delete
             */
            url: '/delete',
            /**
             * On state enter event listener
             * @param  {$modal} Modal service
             * @ngInject
             */
            onEnter: ["$modal", function($modal) {
                $modal.open({
                    template: '<beneficiary-delete-view></beneficiary-delete-view>',
                    backdrop: 'static',
                    keyboard: false,
                    windowClass: 'modal',
                    controller: 'BeneficiaryViewController'
                });
            }]
        }
    }
};

exports.stateConfig = stateConfig;

},{}],18:[function(require,module,exports){
/**
 * This service provide custom word lookup for case normalization if one is not provided by the service client
 *
 * @param {$window} The angular window service
 * @ngInject
 */
var service = function($window) {
    'use strict';
    var serviceInstance = {};

    serviceInstance.isFormValid = function(formId) {
        var isValid = true;
        var formEl = $window.document.getElementById(formId);
        console.log(formEl);
        if (!formEl || (formEl && formEl.className && formEl.className.indexOf('ng-invalid') > -1)) return false;
        // otherwise, perform sanity check
        var elements = $window.document.getElementById(formId).elements;
        for (var i = 0, element = elements[i++]; i < elements.length; i++) {
            if ((element.type === 'text' || element.type === 'checkbox' || element.type === 'radio' || element.type === 'date' || element.type === 'datetime-local' || element.type === 'email' || element.type === 'month' || element.type === 'number' || element.type === 'time' || element.type === 'url' || element.type === 'week' || element.type === 'textarea' || element.type === 'select') && (element.className.indexOf('ng-invalid') > -1)) {
                isValid = false;
                return isValid;
            }
        }

        return isValid;
    };

    serviceInstance.isBlank = function(value) {
        return angular.isUndefined(value) || value === null || value.length === 0;
    };

    serviceInstance.isValidId = function(id) {
        return parseInt(id) >= 1;
    }

    return serviceInstance;
};
service.$inject = ["$window"];

exports.service = service;

},{}],19:[function(require,module,exports){
/**
 * Company Create Component Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/company/CompanyCreateView.html',
        restrict: 'AE',
        scope: false,
        controllerAs: 'ctrl',
        controller: 'CompanyViewController'
    };
};

exports.directive = directive;

},{}],20:[function(require,module,exports){
/**
 * Company Delete Component Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/company/CompanyDeleteView.html',
        restrict: 'AE',
        scope: false,
        controllerAs: 'ctrl',
        controller: 'CompanyViewController'
    };
};

exports.directive = directive;

},{}],21:[function(require,module,exports){
/**
 * Company Table List Component Directive
 *
 * @ngInject
 */
var directive = function() {
    'use strict';
    return {
        templateUrl: 'app/components/company/CompanyListFragmentView.html',
        restrict: 'AE',
        scope: {
            companies: '=',
            delref: '=',
            searchRequestSumbitted: '='
        },
        controllerAs: 'ctrl',
        controller: 'CompanyViewController'
    };
};

exports.directive = directive;

},{}],22:[function(require,module,exports){
/**
 * Company Table List Component Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/company/CompanyListView.html',
        restrict: 'AE',
        scope: false,
        controllerAs: 'ctrl',
        controller: 'CompanyViewController'
    };
};

exports.directive = directive;

},{}],23:[function(require,module,exports){
/**
 * Company Search Component Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/company/CompanySearchView.html',
        restrict: 'AE',
        scope: false,
        controllerAs: 'ctrl',
        controller: 'CompanyViewController'
    };
};

exports.directive = directive;

},{}],24:[function(require,module,exports){
/**
 * This service helps to perform http requests (GET, POST, PUT, DELETE) for company tasks
 *
 * @param {$http} The AngularJS http service
 * @param {$timeout} The AngularJS timeout service
 *
 * @ngInject
 */
var service = function($http, $timeout) {
    'use strict';

    var serviceInstance = {};
    serviceInstance.selectedCompanyId = null;
    serviceInstance.popOnDelete = null;
    serviceInstance.company = null;
    serviceInstance.companies = [];
    serviceInstance.searchRequestSumbitted = false;

    serviceInstance.getCompany = function(url, callback) {
        $http({
            url: url,
            method: 'GET',
            dataType: 'jsonp'
        }).then(function(results) {
            callback(results);
        }, function(error) {
            var errorData = {
                status: error.status ? error.status : 500,
                message: error.data ? error.data : 'Error occured while retrieving company details'
            };
            callback(errorData);
        });
    };

    serviceInstance.createCompany = function(url, data, callback) {
        $http({
            url: url,
            data: data,
            method: 'POST',
            dataType: 'jsonp'
        }).then(function(results) {
            callback(results);
        }, function(error) {
            var errorData = {
                status: error.status ? error.status : 500,
                message: error.data ? error.data : 'Error occured while retrieving company details'
            };
            callback(errorData);
        });
    };
    serviceInstance.updateCompany = function(url, data, callback) {
        $http({
            url: url,
            method: 'PUT',
            data: data,
            dataType: 'jsonp'
        }).then(function(results) {
            callback(results);
        }, function(error) {
            var errorData = {
                status: error.status ? error.status : 500,
                message: error.data ? error.data : 'Error occured while retrieving company details'
            };
            callback(errorData);
        });
    };

    serviceInstance.deleteCompany = function(url, callback) {
        $http({
            url: url,
            method: 'DELETE',
            dataType: 'jsonp'
        }).then(function(results) {
            callback(results);
        }, function(error) {
            var errorData = {
                status: error.status ? error.status : 500,
                message: error.data ? error.data : 'Error occured while retrieving company details'
            };
            callback(errorData);
        });
    };


    return serviceInstance;
};
service.$inject = ["$http", "$timeout"];

exports.service = service;

},{}],25:[function(require,module,exports){
/**
 * Company Update Component Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/company/CompanyUpdateView.html',
        restrict: 'AE',
        scope: false,
        controllerAs: 'ctrl',
        controller: 'CompanyViewController'
    };
};

exports.directive = directive;

},{}],26:[function(require,module,exports){
/**
 * Company View controller
 *
 * This controller is responsible for handing company form module related logic
 *
 * @param {$rootScope} Angular root scope service
 * @param {$scope} Angular scope service
 * @param {$q} Angular promise service
 * @param {$timeout} Angular timeout service
 * @param {$window} Angular window service
 * @param {$document} Angular document service
 * @param {$log} Angular logger service
 * @param {$modal} Angular modal service
 * @param {beneficiaryService} Beneficiary service
 * @param {companyService} Company service
 * @param {utilService} Utility service
 * @param {blockUI} Block UI service
 * @param {inform} Inform provider service
 * @param {CONSTANTS} Project constants values
 *
 * @ngInject
 *
 */
var controller = function($rootScope, $scope, $q, $timeout, $window, $document, $log, $state, $modal, beneficiaryService, companyService, utilService, blockUI, inform, CONSTANTS) {
    'use strict';
    var ctrl = this;

    $scope.useExistingBeneficiary = false;
    $scope.minimumValidBeneficiary = false;
    $scope.beneficiaryId = null;
    $scope.beneficiarySearched = false;
    $scope.beneficiaryFound = false;
    $scope.companyFound = false;
    $scope.searchRequestSumbitted = false;
    $scope.addRequestSubmitted = false;
    $scope.updateRequestSubmitted = false;
    $scope.deleteRequestSubmitted = false;
    $scope.deleteSuccessful = false;
    $scope.serviceUrl = CONSTANTS.url.path;
    $scope.initCompany = {
        "name": null,
        "address": null,
        "city": null,
        "country": null,
        "email": null,
        "phoneNumber": null,
        "beneficiaries": [{
            "id": -1,
            "firstName": null,
            "lastName": null
        }]
    };

    $scope.companies = companyService.companies.length > 0 ? companyService.companies : [];
    $scope.company = companyService.company &&
                    ($state.current.name === 'start.company.update' || $state.current.name === 'start.company.list.delete' || $state.current.name === 'start.company.search.delete') ?
                    companyService.company : $scope.initCompany;

    $scope.verifyMinimumValidBeneficiary = function() {
        for (var i = 0; i < $scope.company.beneficiaries.length; i++) {
            $scope.minimumValidBeneficiary = $scope.company.beneficiaries[i].id !== -1 ||
                                            (!utilService.isBlank($scope.company.beneficiaries[i].firstName) && !utilService.isBlank($scope.company.beneficiaries[i].lastName));
            if ($scope.minimumValidBeneficiary) {
                break;
            }
        }
    };

    $scope.resetCompany = function() {
        $timeout(function() {
            $scope.company = $scope.initCompany;
            $scope.companies = [];
        });
    };

    $scope.addCompany = function($event) {
        $event.stopPropagation();
        $scope.addRequestSubmitted = false;
        companyService.company = $scope.company;
        if (utilService.isFormValid('companyDetailsForm')) {
            $scope.verifyMinimumValidBeneficiary();
            if (!$scope.minimumValidBeneficiary) {
                $scope.registerPopoverShow('#addCompany');
                return;
            }
            $log.info('valid');
        } else {
            $log.warn('form invalid');
            return;
        }

        var companyCreateBlock = blockUI.instances.get('companyCreateBlock');
        // companyCreateBlock.start();
        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;
        companyService.createCompany(url, $scope.company, function(result) {
            $timeout(function() {
                $scope.addRequestSubmitted = true;
                if (result && result.data) {
                    if (result.data.id > 0) {
                        inform.add('Company created successfully.', {
                            ttl: 2500
                        });
                        $timeout(function() {
                            $state.go('start.company', {}, {reload:true});
                        }, 2500);
                    } else {
                        inform.add('Request completed, however company couldn\'t be created.', {
                            ttl: 5000,
                            type: 'warning'
                        });
                    }
                } else {
                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Error creating company.', {
                        ttl: 5000,
                        type: 'danger'
                    });
                    $timeout(function() {
                        $scope.addRequestSubmitted = false;
                    }, 5000);
                }
                // companyCreateBlock.stop();
            });
        });
    };

    $scope.cancelAddCompany = function() {
        $state.go('start.company');
    };

    $scope.updateCompany = function($event) {
        $event.stopPropagation();
        $scope.updateRequestSubmitted = false;
        companyService.company = $scope.company;
        if (utilService.isFormValid('companyUpdateForm')) {
            $scope.verifyMinimumValidBeneficiary();
            if (!$scope.minimumValidBeneficiary) {
                $scope.registerPopoverShow('#updateCompany');
                return;
            }
        } else {
            $log.warn('form invalid');
            return;
        }

        // var companyUpdateBlock = blockUI.instances.get('companyUpdateBlock');
        // companyUpdateBlock.start();
        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;
        companyService.updateCompany(url, $scope.company, function(result) {
            $timeout(function() {
                $scope.updateRequestSubmitted = true;
                if (result && result.data) {
                    if (result.data.status === true) {
                        inform.add('Company updated successfully.', {
                            ttl: 4000
                        });
                        $timeout(function() {
                            $state.go('start.company.list', {}, {reload: true});
                        }, 4500);
                    } else {
                        inform.add('Request completed successfully, but no update performed on company.', {
                            ttl: 5000,
                            type: 'warning'
                        });
                    }
                } else {
                    inform.add(result && result.message && result.message.errorMessage ? result.message.errorMessage : 'Company couldn\'t be updated.', {
                        ttl: 5000,
                        type: 'danger'
                    });
                    $timeout(function() {
                        $scope.updateRequestSubmitted = false;
                    }, 5000);
                }
                // companyUpdateBlock.stop();
            });
        });
    };

    $scope.cancelOrCloseCompanyUpdate = function() {
        $state.go('start.company.list', {}, {reload: true});
    };

    $scope.deleteCompany = function($event) {
        $event.stopPropagation();
        $scope.company = companyService.company;
        // var companyUpdateBlock = blockUI.instances.get('companyUpdateBlock');
        // companyUpdateBlock.start();
        var url = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath + '/' + $scope.company.id;
        companyService.deleteCompany(url, function(result) {
            $timeout(function() {
                $scope.deleteRequestSubmitted = true;
                if (result && result.data && result.data.status === true) {
                    $scope.deleteSuccessful = true;
                }
                // companyUpdateBlock.stop();
            });
        });
    };

    $scope.cancelOrCloseCompanyDelete = function() {
        $scope.$dismiss();
        $state.go('start.company.list', {}, {reload: true});
    };

    $scope.fetchCompany = function(id) {
        $scope.companies.splice(0, $scope.companies.length);

        var idSearch = !utilService.isBlank(id);
        var baseUrl = $scope.serviceUrl + '/' + CONSTANTS.url.companyContextPath;
        var url = idSearch ? baseUrl + '/' + id : baseUrl;
        //var companyListBlock = blockUI.instances.get('companyListBlock');
        //companyListBlock.start();
        companyService.getCompany(url, function(result) {
            $timeout(function() {
                $scope.searchRequestSumbitted = true;
                companyService.searchRequestSumbitted = $scope.searchRequestSumbitted;
                if (result && result.data) {
                    if (idSearch) {
                        $scope.companies.push(result.data);
                    } else {
                        $scope.companies = result.data;
                    }
                    companyService.companies = $scope.companies;
                    $scope.companyFound = true;
                }
                //companyListBlock.stop();
            });
        });
    };

    $scope.searchCompany = function(id, $event) {
        $event.stopPropagation();
        $timeout(function() {
            if (!utilService.isValidId(id)) {
                $scope.registerPopoverShow('#searchExistingCompanyId');
                return;
            }
            $scope.fetchCompany(id);
        });
    };

    $scope.searchBeneficiary = function(id, $event) {
        $event.stopPropagation();

        if (!utilService.isValidId(id)) {
            $scope.registerPopoverShow('#searchExistingBeneficiaryId');
            return;
        }
        var url = $scope.serviceUrl + '/' + CONSTANTS.url.beneficiaryContextPath + '/' + id;

        var companySearchBlock = blockUI.instances.get('companySearchBlock');
        companySearchBlock.start();
        beneficiaryService.findBeneficiary(url, function(result) {
            $timeout(function() {
                $scope.beneficiarySearched = true;
                if (result && result.data) {
                    $scope.verifyMinimumValidBeneficiary();
                    // remove all empty forms
                    if (!$scope.minimumValidBeneficiary) {
                        $scope.company.beneficiaries.splice(0, $scope.company.beneficiaries.length);
                    }
                    $scope.company.beneficiaries.push(result.data);
                    $scope.disableBeneficiary(result.data.id);
                    $scope.minimumValidBeneficiary = true;
                    $scope.beneficiaryFound = true;
                    $scope.beneficiaryId = null;
                }
                companySearchBlock.stop();
            });
        });
    };

    $scope.mutateCompanyOptions = function(company, $index, $event) {
        $event.stopPropagation();
        companyService.selectedCompanyId = '#company' + $index;
        companyService.company = company;
        $scope.registerPopoverPrep(companyService.selectedCompanyId);
        $scope.registerPopoverShow(companyService.selectedCompanyId);
    };

    $scope.addBeneficiary = function() {
        $scope.company.beneficiaries.push({
            "firstName": "",
            "lastName": ""
        });
    };

    $scope.removeBeneficiary = function($event, beneficiary) {
        $event.stopPropagation();
        if ($scope.company.beneficiaries.indexOf(beneficiary) != -1) {
            $timeout(function() {
                if ($scope.company.beneficiaries.length === 1) {
                    $scope.registerPopoverShow('#removeBeneficiary');
                    return;
                }
                $scope.company.beneficiaries.splice($scope.company.beneficiaries.indexOf(beneficiary), 1);
            });
        }
    };

    $scope.disableBeneficiary = function(beneficiaryId) {
        $rootScope.$emit('disableBeneficiary', {
            beneficiaries: $scope.company.beneficiaries,
            beneficiaryId: beneficiaryId
        });
    }

    /* initialize popover */

    $scope.discardMessage = function($event) {
        $event ? $event.stopPropagation() : '';
        companyService.popOnDelete = "delete";
        $scope.registerPopoverHide('[id*=popover]');
    };

    companyService.popOnDelete = "delete";

    $scope.registerPopoverPrep = function(id) {
        angular.element($document.find(id)).popover({
            trigger: 'manual'
        });
    };

    $scope.registerPopoverShow = function(id) {
        if (companyService.popOnDelete !== "popover") {
            companyService.popOnDelete = "popover";
            angular.element($document.find(id)).popover('show');
        }
    };

    $scope.registerPopoverHide = function(id) {
        var el = angular.element($document.find(id));
        el ? el.popover('hide') : '';
    };

    $scope.registerPopoverPrep('#removeBeneficiary');
    $scope.registerPopoverPrep('#addCompany');
    $scope.registerPopoverPrep('#updateCompany');
    $scope.registerPopoverPrep('#searchExistingBeneficiaryId');
    $scope.registerPopoverPrep('#searchExistingCompanyId');
    $scope.registerPopoverHide('[id*=popover]');

    // clear all informs
    inform.clear();
};
controller.$inject = ["$rootScope", "$scope", "$q", "$timeout", "$window", "$document", "$log", "$state", "$modal", "beneficiaryService", "companyService", "utilService", "blockUI", "inform", "CONSTANTS"];

exports.controller = controller;

},{}],27:[function(require,module,exports){
/**
 * Main Company Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/company/CompanyView.html',
        restrict: 'AE',
        scope: false
    };
};

exports.directive = directive;

},{}],28:[function(require,module,exports){
/**
 * Side Nav View controller
 *
 * This controller is responsible for handing request from side nav
 *
 * @param {$rootScope} Angular root scope service
 * @param {$scope} Angular scope service
 * @param {$timeout} Angular timeout service
 * @param {$window} Angular window service
 * @param {$document} Angular document service
 * @param {$log} Angular logger service
 * @param {beneficiaryService} Beneficiary service
 * @param {companyService} Company service
 *
 * @ngInject
 *
 */
var controller = function() {
    'use strict';
    var ctrl = this;

};

exports.controller = controller;

},{}],29:[function(require,module,exports){
/**
 * Side Nav Component Directive
 *
 * @ngInject
 */
var directive = function () {
    'use strict';
    return {
        templateUrl: 'app/components/nav/SideNavView.html',
        restrict: 'AE',
        scope: false,
        controllerAs: 'ctrl',
        controller: 'SideNavViewController'
    };
};

exports.directive = directive;

},{}],30:[function(require,module,exports){
var translationsEN = {
    "BENEFICIARY": {
        "ID": "Id",
        "FIRST_NAME": "First name",
        "LAST_NAME": "Last name"
    }
};

exports.translationsEN = translationsEN;

},{}],31:[function(require,module,exports){
'use strict';

var states = require('./components/common/States');
var configBlock = {
    /**
     * @param {$logProvider} The log provider service
     * @param {$translateProvider} The angular translate service
     * @ngInject
     */
    settings: ["$logProvider", "$translateProvider", function($logProvider, $translateProvider) {
        $logProvider.debugEnabled(true); // Turns global logging with $log.debug on

        var i18n_en = require('./components/nls/i18n-en');
        $translateProvider.useSanitizeValueStrategy('sanitizeParameters');
        $translateProvider.translations('en', i18n_en.translationsEN).useStaticFilesLoader({
                files: [{
                    prefix: './components/nls/i18n-',
                    suffix: '.json'
                }]
            })
            .preferredLanguage('en')
            .fallbackLanguage('en');
    }],
    /**
     * @param {$stateProvider} $stateProvider The UI router stateProvider service
     * @param {$urlRouterProvider} The UI router urlRouterProvider service
     * @param {$modalStateProvider} The custom modal state provider service
     * @ngInject
     */
    states: ["$stateProvider", "$urlRouterProvider", function($stateProvider, $urlRouterProvider) {
        $urlRouterProvider.otherwise('/');
        $stateProvider
            .state('start', states.stateConfig.main)
            .state('start.company', states.stateConfig.company.initial)
            .state('start.company.list', states.stateConfig.company.list)
            .state('start.company.list.delete',  angular.copy(states.stateConfig.company.delete))
            .state('start.company.search', states.stateConfig.company.search)
            .state('start.company.search.delete', angular.copy(states.stateConfig.company.delete))
            .state('start.company.update', states.stateConfig.company.update)
            .state('start.beneficiary', states.stateConfig.beneficiary.initial)
            .state('start.beneficiary.list', states.stateConfig.beneficiary.list)
            .state('start.beneficiary.list.delete', angular.copy(states.stateConfig.beneficiary.delete))
            .state('start.beneficiary.search', states.stateConfig.beneficiary.search)
            .state('start.beneficiary.search.delete', angular.copy(states.stateConfig.beneficiary.delete))
            .state('start.beneficiary.update', states.stateConfig.beneficiary.update)
    }],

    /**
     * @param  {blockUIConfig} The block UI config service
     * @ngInject
     */
    blockUI: ["blockUIConfig", function(blockUIConfig) {
        blockUIConfig.delay = 100;
        blockUIConfig.autoBlock = false;
        blockUIConfig.autoInjectBodyBlock = false;
        blockUIConfig.template = '<div><img src="dist/images/ajax-loader.gif" /> Processing...</h1>';
    }],

    /**
     * @param  {informProvider} The inform provider service
     * @ngInject
     */
    inform: ["informProvider", function(informProvider) {
        informProvider.defaults({
            /**
             * The time to live for the message in milliseconds.
             * Default value is 5000. Specify <0 to make the message sticky.
             */
            ttl: -1,

            /**
             * The type of message to enable styling.
             * Values can be 'default', 'primary', 'success', 'info', 'warning', 'danger' or any other custom required type.
             * Default value is 'info'. If 'default' is specified as value, then 'info' is used
             */
            type: 'success',
            /**
             * Allow html formatting
             * Default value is false
             */
            html: true
        });
    }],

    /**
     * Modal block
     * @param  {$rootScope}  Angular root scope service
     * @param  {$modalStack} Angular UI modal stack
     * @ngInject
     */
    modal: ["$rootScope", "$modalStack", function($rootScope, $modalStack) {
        $rootScope.$on('$stateChangeStart', function() {
            var top = $modalStack.getTop();
            if (top) {
                $modalStack.dismiss(top.key);
            }
        });
    }],

    /**
     * Href sanitization whitelist
     * @param  {$compileProvide} Angular compile provider service
     * @ngInject
     */
    hrefSanitize: ["$compileProvider", function($compileProvider) {
        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|file|chrome‌​-extension|blob:chrome-extension):/);
    }],

    namespace: 'com.companyregistry'
};

exports.configBlock = configBlock;

},{"./components/common/States":17,"./components/nls/i18n-en":30}],32:[function(require,module,exports){
'use strict';

exports.constants = {
    url: {
				// path: 'http://localhost:8080/companyregistry',
				path: 'https://companyregistry.herokuapp.com',
        companyContextPath: 'companies',
        beneficiaryContextPath: 'beneficiaries'
    }
};

},{}],33:[function(require,module,exports){
/**
 * @license AngularJS v1.4.7
 * (c) 2010-2015 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {'use strict';

/* jshint ignore:start */
var noop        = angular.noop;
var extend      = angular.extend;
var jqLite      = angular.element;
var forEach     = angular.forEach;
var isArray     = angular.isArray;
var isString    = angular.isString;
var isObject    = angular.isObject;
var isUndefined = angular.isUndefined;
var isDefined   = angular.isDefined;
var isFunction  = angular.isFunction;
var isElement   = angular.isElement;

var ELEMENT_NODE = 1;
var COMMENT_NODE = 8;

var ADD_CLASS_SUFFIX = '-add';
var REMOVE_CLASS_SUFFIX = '-remove';
var EVENT_CLASS_PREFIX = 'ng-';
var ACTIVE_CLASS_SUFFIX = '-active';

var NG_ANIMATE_CLASSNAME = 'ng-animate';
var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';

// Detect proper transitionend/animationend event names.
var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;

// If unprefixed events are not supported but webkit-prefixed are, use the latter.
// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.
// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`
// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.
// Register both events in case `window.onanimationend` is not supported because of that,
// do the same for `transitionend` as Safari is likely to exhibit similar behavior.
// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit
// therefore there is no reason to test anymore for other vendor prefixes:
// http://caniuse.com/#search=transition
if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
  CSS_PREFIX = '-webkit-';
  TRANSITION_PROP = 'WebkitTransition';
  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
} else {
  TRANSITION_PROP = 'transition';
  TRANSITIONEND_EVENT = 'transitionend';
}

if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
  CSS_PREFIX = '-webkit-';
  ANIMATION_PROP = 'WebkitAnimation';
  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
} else {
  ANIMATION_PROP = 'animation';
  ANIMATIONEND_EVENT = 'animationend';
}

var DURATION_KEY = 'Duration';
var PROPERTY_KEY = 'Property';
var DELAY_KEY = 'Delay';
var TIMING_KEY = 'TimingFunction';
var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
var ANIMATION_PLAYSTATE_KEY = 'PlayState';
var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;

var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;

var isPromiseLike = function(p) {
  return p && p.then ? true : false;
};

function assertArg(arg, name, reason) {
  if (!arg) {
    throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
  }
  return arg;
}

function mergeClasses(a,b) {
  if (!a && !b) return '';
  if (!a) return b;
  if (!b) return a;
  if (isArray(a)) a = a.join(' ');
  if (isArray(b)) b = b.join(' ');
  return a + ' ' + b;
}

function packageStyles(options) {
  var styles = {};
  if (options && (options.to || options.from)) {
    styles.to = options.to;
    styles.from = options.from;
  }
  return styles;
}

function pendClasses(classes, fix, isPrefix) {
  var className = '';
  classes = isArray(classes)
      ? classes
      : classes && isString(classes) && classes.length
          ? classes.split(/\s+/)
          : [];
  forEach(classes, function(klass, i) {
    if (klass && klass.length > 0) {
      className += (i > 0) ? ' ' : '';
      className += isPrefix ? fix + klass
                            : klass + fix;
    }
  });
  return className;
}

function removeFromArray(arr, val) {
  var index = arr.indexOf(val);
  if (val >= 0) {
    arr.splice(index, 1);
  }
}

function stripCommentsFromElement(element) {
  if (element instanceof jqLite) {
    switch (element.length) {
      case 0:
        return [];
        break;

      case 1:
        // there is no point of stripping anything if the element
        // is the only element within the jqLite wrapper.
        // (it's important that we retain the element instance.)
        if (element[0].nodeType === ELEMENT_NODE) {
          return element;
        }
        break;

      default:
        return jqLite(extractElementNode(element));
        break;
    }
  }

  if (element.nodeType === ELEMENT_NODE) {
    return jqLite(element);
  }
}

function extractElementNode(element) {
  if (!element[0]) return element;
  for (var i = 0; i < element.length; i++) {
    var elm = element[i];
    if (elm.nodeType == ELEMENT_NODE) {
      return elm;
    }
  }
}

function $$addClass($$jqLite, element, className) {
  forEach(element, function(elm) {
    $$jqLite.addClass(elm, className);
  });
}

function $$removeClass($$jqLite, element, className) {
  forEach(element, function(elm) {
    $$jqLite.removeClass(elm, className);
  });
}

function applyAnimationClassesFactory($$jqLite) {
  return function(element, options) {
    if (options.addClass) {
      $$addClass($$jqLite, element, options.addClass);
      options.addClass = null;
    }
    if (options.removeClass) {
      $$removeClass($$jqLite, element, options.removeClass);
      options.removeClass = null;
    }
  }
}

function prepareAnimationOptions(options) {
  options = options || {};
  if (!options.$$prepared) {
    var domOperation = options.domOperation || noop;
    options.domOperation = function() {
      options.$$domOperationFired = true;
      domOperation();
      domOperation = noop;
    };
    options.$$prepared = true;
  }
  return options;
}

function applyAnimationStyles(element, options) {
  applyAnimationFromStyles(element, options);
  applyAnimationToStyles(element, options);
}

function applyAnimationFromStyles(element, options) {
  if (options.from) {
    element.css(options.from);
    options.from = null;
  }
}

function applyAnimationToStyles(element, options) {
  if (options.to) {
    element.css(options.to);
    options.to = null;
  }
}

function mergeAnimationOptions(element, target, newOptions) {
  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);

  if (newOptions.preparationClasses) {
    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
    delete newOptions.preparationClasses;
  }

  // noop is basically when there is no callback; otherwise something has been set
  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;

  extend(target, newOptions);

  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.
  if (realDomOperation) {
    target.domOperation = realDomOperation;
  }

  if (classes.addClass) {
    target.addClass = classes.addClass;
  } else {
    target.addClass = null;
  }

  if (classes.removeClass) {
    target.removeClass = classes.removeClass;
  } else {
    target.removeClass = null;
  }

  return target;
}

function resolveElementClasses(existing, toAdd, toRemove) {
  var ADD_CLASS = 1;
  var REMOVE_CLASS = -1;

  var flags = {};
  existing = splitClassesToLookup(existing);

  toAdd = splitClassesToLookup(toAdd);
  forEach(toAdd, function(value, key) {
    flags[key] = ADD_CLASS;
  });

  toRemove = splitClassesToLookup(toRemove);
  forEach(toRemove, function(value, key) {
    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
  });

  var classes = {
    addClass: '',
    removeClass: ''
  };

  forEach(flags, function(val, klass) {
    var prop, allow;
    if (val === ADD_CLASS) {
      prop = 'addClass';
      allow = !existing[klass];
    } else if (val === REMOVE_CLASS) {
      prop = 'removeClass';
      allow = existing[klass];
    }
    if (allow) {
      if (classes[prop].length) {
        classes[prop] += ' ';
      }
      classes[prop] += klass;
    }
  });

  function splitClassesToLookup(classes) {
    if (isString(classes)) {
      classes = classes.split(' ');
    }

    var obj = {};
    forEach(classes, function(klass) {
      // sometimes the split leaves empty string values
      // incase extra spaces were applied to the options
      if (klass.length) {
        obj[klass] = true;
      }
    });
    return obj;
  }

  return classes;
}

function getDomNode(element) {
  return (element instanceof angular.element) ? element[0] : element;
}

function applyGeneratedPreparationClasses(element, event, options) {
  var classes = '';
  if (event) {
    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
  }
  if (options.addClass) {
    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
  }
  if (options.removeClass) {
    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
  }
  if (classes.length) {
    options.preparationClasses = classes;
    element.addClass(classes);
  }
}

function clearGeneratedClasses(element, options) {
  if (options.preparationClasses) {
    element.removeClass(options.preparationClasses);
    options.preparationClasses = null;
  }
  if (options.activeClasses) {
    element.removeClass(options.activeClasses);
    options.activeClasses = null;
  }
}

function blockTransitions(node, duration) {
  // we use a negative delay value since it performs blocking
  // yet it doesn't kill any existing transitions running on the
  // same element which makes this safe for class-based animations
  var value = duration ? '-' + duration + 's' : '';
  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
  return [TRANSITION_DELAY_PROP, value];
}

function blockKeyframeAnimations(node, applyBlock) {
  var value = applyBlock ? 'paused' : '';
  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
  applyInlineStyle(node, [key, value]);
  return [key, value];
}

function applyInlineStyle(node, styleTuple) {
  var prop = styleTuple[0];
  var value = styleTuple[1];
  node.style[prop] = value;
}

function concatWithSpace(a,b) {
  if (!a) return b;
  if (!b) return a;
  return a + ' ' + b;
}

var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
  var queue, cancelFn;

  function scheduler(tasks) {
    // we make a copy since RAFScheduler mutates the state
    // of the passed in array variable and this would be difficult
    // to track down on the outside code
    queue = queue.concat(tasks);
    nextTick();
  }

  queue = scheduler.queue = [];

  /* waitUntilQuiet does two things:
   * 1. It will run the FINAL `fn` value only when an uncancelled RAF has passed through
   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.
   *
   * The motivation here is that animation code can request more time from the scheduler
   * before the next wave runs. This allows for certain DOM properties such as classes to
   * be resolved in time for the next animation to run.
   */
  scheduler.waitUntilQuiet = function(fn) {
    if (cancelFn) cancelFn();

    cancelFn = $$rAF(function() {
      cancelFn = null;
      fn();
      nextTick();
    });
  };

  return scheduler;

  function nextTick() {
    if (!queue.length) return;

    var items = queue.shift();
    for (var i = 0; i < items.length; i++) {
      items[i]();
    }

    if (!cancelFn) {
      $$rAF(function() {
        if (!cancelFn) nextTick();
      });
    }
  }
}];

var $$AnimateChildrenDirective = [function() {
  return function(scope, element, attrs) {
    var val = attrs.ngAnimateChildren;
    if (angular.isString(val) && val.length === 0) { //empty attribute
      element.data(NG_ANIMATE_CHILDREN_DATA, true);
    } else {
      attrs.$observe('ngAnimateChildren', function(value) {
        value = value === 'on' || value === 'true';
        element.data(NG_ANIMATE_CHILDREN_DATA, value);
      });
    }
  };
}];

var ANIMATE_TIMER_KEY = '$$animateCss';

/**
 * @ngdoc service
 * @name $animateCss
 * @kind object
 *
 * @description
 * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes
 * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT
 * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or
 * directives to create more complex animations that can be purely driven using CSS code.
 *
 * Note that only browsers that support CSS transitions and/or keyframe animations are capable of
 * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).
 *
 * ## Usage
 * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that
 * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,
 * any automatic control over cancelling animations and/or preventing animations from being run on
 * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to
 * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger
 * the CSS animation.
 *
 * The example below shows how we can create a folding animation on an element using `ng-if`:
 *
 * ```html
 * <!-- notice the `fold-animation` CSS class -->
 * <div ng-if="onOff" class="fold-animation">
 *   This element will go BOOM
 * </div>
 * <button ng-click="onOff=true">Fold In</button>
 * ```
 *
 * Now we create the **JavaScript animation** that will trigger the CSS transition:
 *
 * ```js
 * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var height = element[0].offsetHeight;
 *       return $animateCss(element, {
 *         from: { height:'0px' },
 *         to: { height:height + 'px' },
 *         duration: 1 // one second
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * ## More Advanced Uses
 *
 * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks
 * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.
 *
 * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,
 * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with
 * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order
 * to provide a working animation that will run in CSS.
 *
 * The example below showcases a more advanced version of the `.fold-animation` from the example above:
 *
 * ```js
 * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var height = element[0].offsetHeight;
 *       return $animateCss(element, {
 *         addClass: 'red large-text pulse-twice',
 *         easing: 'ease-out',
 *         from: { height:'0px' },
 *         to: { height:height + 'px' },
 *         duration: 1 // one second
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * Since we're adding/removing CSS classes then the CSS transition will also pick those up:
 *
 * ```css
 * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,
 * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/
 * .red { background:red; }
 * .large-text { font-size:20px; }
 *
 * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/
 * .pulse-twice {
 *   animation: 0.5s pulse linear 2;
 *   -webkit-animation: 0.5s pulse linear 2;
 * }
 *
 * @keyframes pulse {
 *   from { transform: scale(0.5); }
 *   to { transform: scale(1.5); }
 * }
 *
 * @-webkit-keyframes pulse {
 *   from { -webkit-transform: scale(0.5); }
 *   to { -webkit-transform: scale(1.5); }
 * }
 * ```
 *
 * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.
 *
 * ## How the Options are handled
 *
 * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation
 * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline
 * styles using the `from` and `to` properties.
 *
 * ```js
 * var animator = $animateCss(element, {
 *   from: { background:'red' },
 *   to: { background:'blue' }
 * });
 * animator.start();
 * ```
 *
 * ```css
 * .rotating-animation {
 *   animation:0.5s rotate linear;
 *   -webkit-animation:0.5s rotate linear;
 * }
 *
 * @keyframes rotate {
 *   from { transform: rotate(0deg); }
 *   to { transform: rotate(360deg); }
 * }
 *
 * @-webkit-keyframes rotate {
 *   from { -webkit-transform: rotate(0deg); }
 *   to { -webkit-transform: rotate(360deg); }
 * }
 * ```
 *
 * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is
 * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition
 * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition
 * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied
 * and spread across the transition and keyframe animation.
 *
 * ## What is returned
 *
 * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually
 * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are
 * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:
 *
 * ```js
 * var animator = $animateCss(element, { ... });
 * ```
 *
 * Now what do the contents of our `animator` variable look like:
 *
 * ```js
 * {
 *   // starts the animation
 *   start: Function,
 *
 *   // ends (aborts) the animation
 *   end: Function
 * }
 * ```
 *
 * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.
 * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and stlyes may have been
 * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties
 * and that changing them will not reconfigure the parameters of the animation.
 *
 * ### runner.done() vs runner.then()
 * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the
 * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.
 * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`
 * unless you really need a digest to kick off afterwards.
 *
 * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss
 * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).
 * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.
 *
 * @param {DOMElement} element the element that will be animated
 * @param {object} options the animation-related options that will be applied during the animation
 *
 * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied
 * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)
 * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).
 * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).
 * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).
 * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.
 * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.
 * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.
 * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.
 * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`
 * is provided then the animation will be skipped entirely.
 * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is
 * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value
 * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same
 * CSS delay value.
 * * `stagger` - A numeric time value representing the delay between successively animated elements
 * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})
 * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a
 * * `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)
 * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occuring on the classes being added and removed.)
 * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once
 *    the animation is closed. This is useful for when the styles are used purely for the sake of
 *    the animation and do not have a lasting visual effect on the element (e.g. a colapse and open animation).
 *    By default this value is set to `false`.
 *
 * @return {object} an object with start and end methods and details about the animation.
 *
 * * `start` - The method to start the animation. This will return a `Promise` when called.
 * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.
 */
var ONE_SECOND = 1000;
var BASE_TEN = 10;

var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
var CLOSING_TIME_BUFFER = 1.5;

var DETECT_CSS_PROPERTIES = {
  transitionDuration:      TRANSITION_DURATION_PROP,
  transitionDelay:         TRANSITION_DELAY_PROP,
  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,
  animationDuration:       ANIMATION_DURATION_PROP,
  animationDelay:          ANIMATION_DELAY_PROP,
  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
};

var DETECT_STAGGER_CSS_PROPERTIES = {
  transitionDuration:      TRANSITION_DURATION_PROP,
  transitionDelay:         TRANSITION_DELAY_PROP,
  animationDuration:       ANIMATION_DURATION_PROP,
  animationDelay:          ANIMATION_DELAY_PROP
};

function getCssKeyframeDurationStyle(duration) {
  return [ANIMATION_DURATION_PROP, duration + 's'];
}

function getCssDelayStyle(delay, isKeyframeAnimation) {
  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
  return [prop, delay + 's'];
}

function computeCssStyles($window, element, properties) {
  var styles = Object.create(null);
  var detectedStyles = $window.getComputedStyle(element) || {};
  forEach(properties, function(formalStyleName, actualStyleName) {
    var val = detectedStyles[formalStyleName];
    if (val) {
      var c = val.charAt(0);

      // only numerical-based values have a negative sign or digit as the first value
      if (c === '-' || c === '+' || c >= 0) {
        val = parseMaxTime(val);
      }

      // by setting this to null in the event that the delay is not set or is set directly as 0
      // then we can still allow for zegative values to be used later on and not mistake this
      // value for being greater than any other negative value.
      if (val === 0) {
        val = null;
      }
      styles[actualStyleName] = val;
    }
  });

  return styles;
}

function parseMaxTime(str) {
  var maxValue = 0;
  var values = str.split(/\s*,\s*/);
  forEach(values, function(value) {
    // it's always safe to consider only second values and omit `ms` values since
    // getComputedStyle will always handle the conversion for us
    if (value.charAt(value.length - 1) == 's') {
      value = value.substring(0, value.length - 1);
    }
    value = parseFloat(value) || 0;
    maxValue = maxValue ? Math.max(value, maxValue) : value;
  });
  return maxValue;
}

function truthyTimingValue(val) {
  return val === 0 || val != null;
}

function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
  var style = TRANSITION_PROP;
  var value = duration + 's';
  if (applyOnlyDuration) {
    style += DURATION_KEY;
  } else {
    value += ' linear all';
  }
  return [style, value];
}

function createLocalCacheLookup() {
  var cache = Object.create(null);
  return {
    flush: function() {
      cache = Object.create(null);
    },

    count: function(key) {
      var entry = cache[key];
      return entry ? entry.total : 0;
    },

    get: function(key) {
      var entry = cache[key];
      return entry && entry.value;
    },

    put: function(key, value) {
      if (!cache[key]) {
        cache[key] = { total: 1, value: value };
      } else {
        cache[key].total++;
      }
    }
  };
}

// we do not reassign an already present style value since
// if we detect the style property value again we may be
// detecting styles that were added via the `from` styles.
// We make use of `isDefined` here since an empty string
// or null value (which is what getPropertyValue will return
// for a non-existing style) will still be marked as a valid
// value for the style (a falsy value implies that the style
// is to be removed at the end of the animation). If we had a simple
// "OR" statement then it would not be enough to catch that.
function registerRestorableStyles(backup, node, properties) {
  forEach(properties, function(prop) {
    backup[prop] = isDefined(backup[prop])
        ? backup[prop]
        : node.style.getPropertyValue(prop);
  });
}

var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
  var gcsLookup = createLocalCacheLookup();
  var gcsStaggerLookup = createLocalCacheLookup();

  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',
               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$animate',
       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,
                $$forceReflow,   $sniffer,   $$rAFScheduler, $animate) {

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    var parentCounter = 0;
    function gcsHashFn(node, extraClasses) {
      var KEY = "$$ngAnimateParentKey";
      var parentNode = node.parentNode;
      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
    }

    function computeCachedCssStyles(node, className, cacheKey, properties) {
      var timings = gcsLookup.get(cacheKey);

      if (!timings) {
        timings = computeCssStyles($window, node, properties);
        if (timings.animationIterationCount === 'infinite') {
          timings.animationIterationCount = 1;
        }
      }

      // we keep putting this in multiple times even though the value and the cacheKey are the same
      // because we're keeping an interal tally of how many duplicate animations are detected.
      gcsLookup.put(cacheKey, timings);
      return timings;
    }

    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
      var stagger;

      // if we have one or more existing matches of matching elements
      // containing the same parent + CSS styles (which is how cacheKey works)
      // then staggering is possible
      if (gcsLookup.count(cacheKey) > 0) {
        stagger = gcsStaggerLookup.get(cacheKey);

        if (!stagger) {
          var staggerClassName = pendClasses(className, '-stagger');

          $$jqLite.addClass(node, staggerClassName);

          stagger = computeCssStyles($window, node, properties);

          // force the conversion of a null value to zero incase not set
          stagger.animationDuration = Math.max(stagger.animationDuration, 0);
          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);

          $$jqLite.removeClass(node, staggerClassName);

          gcsStaggerLookup.put(cacheKey, stagger);
        }
      }

      return stagger || {};
    }

    var cancelLastRAFRequest;
    var rafWaitQueue = [];
    function waitUntilQuiet(callback) {
      rafWaitQueue.push(callback);
      $$rAFScheduler.waitUntilQuiet(function() {
        gcsLookup.flush();
        gcsStaggerLookup.flush();

        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.
        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.
        var pageWidth = $$forceReflow();

        // we use a for loop to ensure that if the queue is changed
        // during this looping then it will consider new requests
        for (var i = 0; i < rafWaitQueue.length; i++) {
          rafWaitQueue[i](pageWidth);
        }
        rafWaitQueue.length = 0;
      });
    }

    function computeTimings(node, className, cacheKey) {
      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
      var aD = timings.animationDelay;
      var tD = timings.transitionDelay;
      timings.maxDelay = aD && tD
          ? Math.max(aD, tD)
          : (aD || tD);
      timings.maxDuration = Math.max(
          timings.animationDuration * timings.animationIterationCount,
          timings.transitionDuration);

      return timings;
    }

    return function init(element, options) {
      var restoreStyles = {};
      var node = getDomNode(element);
      if (!node
          || !node.parentNode
          || !$animate.enabled()) {
        return closeAndReturnNoopAnimator();
      }

      options = prepareAnimationOptions(options);

      var temporaryStyles = [];
      var classes = element.attr('class');
      var styles = packageStyles(options);
      var animationClosed;
      var animationPaused;
      var animationCompleted;
      var runner;
      var runnerHost;
      var maxDelay;
      var maxDelayTime;
      var maxDuration;
      var maxDurationTime;

      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
        return closeAndReturnNoopAnimator();
      }

      var method = options.event && isArray(options.event)
            ? options.event.join(' ')
            : options.event;

      var isStructural = method && options.structural;
      var structuralClassName = '';
      var addRemoveClassName = '';

      if (isStructural) {
        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
      } else if (method) {
        structuralClassName = method;
      }

      if (options.addClass) {
        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
      }

      if (options.removeClass) {
        if (addRemoveClassName.length) {
          addRemoveClassName += ' ';
        }
        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
      }

      // there may be a situation where a structural animation is combined together
      // with CSS classes that need to resolve before the animation is computed.
      // However this means that there is no explicit CSS code to block the animation
      // from happening (by setting 0s none in the class name). If this is the case
      // we need to apply the classes before the first rAF so we know to continue if
      // there actually is a detected transition or keyframe animation
      if (options.applyClassesEarly && addRemoveClassName.length) {
        applyAnimationClasses(element, options);
      }

      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
      var fullClassName = classes + ' ' + preparationClasses;
      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;

      // there is no way we can trigger an animation if no styles and
      // no classes are being applied which would then trigger a transition,
      // unless there a is raw keyframe value that is applied to the element.
      if (!containsKeyframeAnimation
           && !hasToStyles
           && !preparationClasses) {
        return closeAndReturnNoopAnimator();
      }

      var cacheKey, stagger;
      if (options.stagger > 0) {
        var staggerVal = parseFloat(options.stagger);
        stagger = {
          transitionDelay: staggerVal,
          animationDelay: staggerVal,
          transitionDuration: 0,
          animationDuration: 0
        };
      } else {
        cacheKey = gcsHashFn(node, fullClassName);
        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
      }

      if (!options.$$skipPreparationClasses) {
        $$jqLite.addClass(element, preparationClasses);
      }

      var applyOnlyDuration;

      if (options.transitionStyle) {
        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
        applyInlineStyle(node, transitionStyle);
        temporaryStyles.push(transitionStyle);
      }

      if (options.duration >= 0) {
        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);

        // we set the duration so that it will be picked up by getComputedStyle later
        applyInlineStyle(node, durationStyle);
        temporaryStyles.push(durationStyle);
      }

      if (options.keyframeStyle) {
        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
        applyInlineStyle(node, keyframeStyle);
        temporaryStyles.push(keyframeStyle);
      }

      var itemIndex = stagger
          ? options.staggerIndex >= 0
              ? options.staggerIndex
              : gcsLookup.count(cacheKey)
          : 0;

      var isFirst = itemIndex === 0;

      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY
      // without causing any combination of transitions to kick in. By adding a negative delay value
      // it forces the setup class' transition to end immediately. We later then remove the negative
      // transition delay to allow for the transition to naturally do it's thing. The beauty here is
      // that if there is no transition defined then nothing will happen and this will also allow
      // other transitions to be stacked on top of each other without any chopping them out.
      if (isFirst && !options.skipBlocking) {
        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
      }

      var timings = computeTimings(node, fullClassName, cacheKey);
      var relativeDelay = timings.maxDelay;
      maxDelay = Math.max(relativeDelay, 0);
      maxDuration = timings.maxDuration;

      var flags = {};
      flags.hasTransitions          = timings.transitionDuration > 0;
      flags.hasAnimations           = timings.animationDuration > 0;
      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';
      flags.applyTransitionDuration = hasToStyles && (
                                        (flags.hasTransitions && !flags.hasTransitionAll)
                                         || (flags.hasAnimations && !flags.hasTransitions));
      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;
      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;
      flags.recalculateTimingStyles = addRemoveClassName.length > 0;

      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;

        if (flags.applyTransitionDuration) {
          flags.hasTransitions = true;
          timings.transitionDuration = maxDuration;
          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
        }

        if (flags.applyAnimationDuration) {
          flags.hasAnimations = true;
          timings.animationDuration = maxDuration;
          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
        }
      }

      if (maxDuration === 0 && !flags.recalculateTimingStyles) {
        return closeAndReturnNoopAnimator();
      }

      if (options.delay != null) {
        var delayStyle = parseFloat(options.delay);

        if (flags.applyTransitionDelay) {
          temporaryStyles.push(getCssDelayStyle(delayStyle));
        }

        if (flags.applyAnimationDelay) {
          temporaryStyles.push(getCssDelayStyle(delayStyle, true));
        }
      }

      // we need to recalculate the delay value since we used a pre-emptive negative
      // delay value and the delay value is required for the final event checking. This
      // property will ensure that this will happen after the RAF phase has passed.
      if (options.duration == null && timings.transitionDuration > 0) {
        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
      }

      maxDelayTime = maxDelay * ONE_SECOND;
      maxDurationTime = maxDuration * ONE_SECOND;
      if (!options.skipBlocking) {
        flags.blockTransition = timings.transitionDuration > 0;
        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&
                                       stagger.animationDelay > 0 &&
                                       stagger.animationDuration === 0;
      }

      if (options.from) {
        if (options.cleanupStyles) {
          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
        }
        applyAnimationFromStyles(element, options);
      }

      if (flags.blockTransition || flags.blockKeyframeAnimation) {
        applyBlocking(maxDuration);
      } else if (!options.skipBlocking) {
        blockTransitions(node, false);
      }

      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging
      return {
        $$willAnimate: true,
        end: endFn,
        start: function() {
          if (animationClosed) return;

          runnerHost = {
            end: endFn,
            cancel: cancelFn,
            resume: null, //this will be set during the start() phase
            pause: null
          };

          runner = new $$AnimateRunner(runnerHost);

          waitUntilQuiet(start);

          // we don't have access to pause/resume the animation
          // since it hasn't run yet. AnimateRunner will therefore
          // set noop functions for resume and pause and they will
          // later be overridden once the animation is triggered
          return runner;
        }
      };

      function endFn() {
        close();
      }

      function cancelFn() {
        close(true);
      }

      function close(rejected) { // jshint ignore:line
        // if the promise has been called already then we shouldn't close
        // the animation again
        if (animationClosed || (animationCompleted && animationPaused)) return;
        animationClosed = true;
        animationPaused = false;

        if (!options.$$skipPreparationClasses) {
          $$jqLite.removeClass(element, preparationClasses);
        }
        $$jqLite.removeClass(element, activeClasses);

        blockKeyframeAnimations(node, false);
        blockTransitions(node, false);

        forEach(temporaryStyles, function(entry) {
          // There is only one way to remove inline style properties entirely from elements.
          // By using `removeProperty` this works, but we need to convert camel-cased CSS
          // styles down to hyphenated values.
          node.style[entry[0]] = '';
        });

        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);

        if (Object.keys(restoreStyles).length) {
          forEach(restoreStyles, function(value, prop) {
            value ? node.style.setProperty(prop, value)
                  : node.style.removeProperty(prop);
          });
        }

        // the reason why we have this option is to allow a synchronous closing callback
        // that is fired as SOON as the animation ends (when the CSS is removed) or if
        // the animation never takes off at all. A good example is a leave animation since
        // the element must be removed just after the animation is over or else the element
        // will appear on screen for one animation frame causing an overbearing flicker.
        if (options.onDone) {
          options.onDone();
        }

        // if the preparation function fails then the promise is not setup
        if (runner) {
          runner.complete(!rejected);
        }
      }

      function applyBlocking(duration) {
        if (flags.blockTransition) {
          blockTransitions(node, duration);
        }

        if (flags.blockKeyframeAnimation) {
          blockKeyframeAnimations(node, !!duration);
        }
      }

      function closeAndReturnNoopAnimator() {
        runner = new $$AnimateRunner({
          end: endFn,
          cancel: cancelFn
        });

        // should flush the cache animation
        waitUntilQuiet(noop);
        close();

        return {
          $$willAnimate: false,
          start: function() {
            return runner;
          },
          end: endFn
        };
      }

      function start() {
        if (animationClosed) return;
        if (!node.parentNode) {
          close();
          return;
        }

        var startTime, events = [];

        // even though we only pause keyframe animations here the pause flag
        // will still happen when transitions are used. Only the transition will
        // not be paused since that is not possible. If the animation ends when
        // paused then it will not complete until unpaused or cancelled.
        var playPause = function(playAnimation) {
          if (!animationCompleted) {
            animationPaused = !playAnimation;
            if (timings.animationDuration) {
              var value = blockKeyframeAnimations(node, animationPaused);
              animationPaused
                  ? temporaryStyles.push(value)
                  : removeFromArray(temporaryStyles, value);
            }
          } else if (animationPaused && playAnimation) {
            animationPaused = false;
            close();
          }
        };

        // checking the stagger duration prevents an accidently cascade of the CSS delay style
        // being inherited from the parent. If the transition duration is zero then we can safely
        // rely that the delay value is an intential stagger delay style.
        var maxStagger = itemIndex > 0
                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||
                            (timings.animationDuration && stagger.animationDuration === 0))
                         && Math.max(stagger.animationDelay, stagger.transitionDelay);
        if (maxStagger) {
          $timeout(triggerAnimationStart,
                   Math.floor(maxStagger * itemIndex * ONE_SECOND),
                   false);
        } else {
          triggerAnimationStart();
        }

        // this will decorate the existing promise runner with pause/resume methods
        runnerHost.resume = function() {
          playPause(true);
        };

        runnerHost.pause = function() {
          playPause(false);
        };

        function triggerAnimationStart() {
          // just incase a stagger animation kicks in when the animation
          // itself was cancelled entirely
          if (animationClosed) return;

          applyBlocking(false);

          forEach(temporaryStyles, function(entry) {
            var key = entry[0];
            var value = entry[1];
            node.style[key] = value;
          });

          applyAnimationClasses(element, options);
          $$jqLite.addClass(element, activeClasses);

          if (flags.recalculateTimingStyles) {
            fullClassName = node.className + ' ' + preparationClasses;
            cacheKey = gcsHashFn(node, fullClassName);

            timings = computeTimings(node, fullClassName, cacheKey);
            relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;

            if (maxDuration === 0) {
              close();
              return;
            }

            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
          }

          if (flags.applyAnimationDelay) {
            relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay)
                  ? parseFloat(options.delay)
                  : relativeDelay;

            maxDelay = Math.max(relativeDelay, 0);
            timings.animationDelay = relativeDelay;
            delayStyle = getCssDelayStyle(relativeDelay, true);
            temporaryStyles.push(delayStyle);
            node.style[delayStyle[0]] = delayStyle[1];
          }

          maxDelayTime = maxDelay * ONE_SECOND;
          maxDurationTime = maxDuration * ONE_SECOND;

          if (options.easing) {
            var easeProp, easeVal = options.easing;
            if (flags.hasTransitions) {
              easeProp = TRANSITION_PROP + TIMING_KEY;
              temporaryStyles.push([easeProp, easeVal]);
              node.style[easeProp] = easeVal;
            }
            if (flags.hasAnimations) {
              easeProp = ANIMATION_PROP + TIMING_KEY;
              temporaryStyles.push([easeProp, easeVal]);
              node.style[easeProp] = easeVal;
            }
          }

          if (timings.transitionDuration) {
            events.push(TRANSITIONEND_EVENT);
          }

          if (timings.animationDuration) {
            events.push(ANIMATIONEND_EVENT);
          }

          startTime = Date.now();
          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
          var endTime = startTime + timerTime;

          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
          var setupFallbackTimer = true;
          if (animationsData.length) {
            var currentTimerData = animationsData[0];
            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
            if (setupFallbackTimer) {
              $timeout.cancel(currentTimerData.timer);
            } else {
              animationsData.push(close);
            }
          }

          if (setupFallbackTimer) {
            var timer = $timeout(onAnimationExpired, timerTime, false);
            animationsData[0] = {
              timer: timer,
              expectedEndTime: endTime
            };
            animationsData.push(close);
            element.data(ANIMATE_TIMER_KEY, animationsData);
          }

          element.on(events.join(' '), onAnimationProgress);
          if (options.to) {
            if (options.cleanupStyles) {
              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
            }
            applyAnimationToStyles(element, options);
          }
        }

        function onAnimationExpired() {
          var animationsData = element.data(ANIMATE_TIMER_KEY);

          // this will be false in the event that the element was
          // removed from the DOM (via a leave animation or something
          // similar)
          if (animationsData) {
            for (var i = 1; i < animationsData.length; i++) {
              animationsData[i]();
            }
            element.removeData(ANIMATE_TIMER_KEY);
          }
        }

        function onAnimationProgress(event) {
          event.stopPropagation();
          var ev = event.originalEvent || event;
          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();

          /* Firefox (or possibly just Gecko) likes to not round values up
           * when a ms measurement is used for the animation */
          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));

          /* $manualTimeStamp is a mocked timeStamp value which is set
           * within browserTrigger(). This is only here so that tests can
           * mock animations properly. Real events fallback to event.timeStamp,
           * or, if they don't, then a timeStamp is automatically created for them.
           * We're checking to see if the timeStamp surpasses the expected delay,
           * but we're using elapsedTime instead of the timeStamp on the 2nd
           * pre-condition since animations sometimes close off early */
          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
            // we set this flag to ensure that if the transition is paused then, when resumed,
            // the animation will automatically close itself since transitions cannot be paused.
            animationCompleted = true;
            close();
          }
        }
      }
    };
  }];
}];

var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
  $$animationProvider.drivers.push('$$animateCssDriver');

  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';

  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';

  function isDocumentFragment(node) {
    return node.parentNode && node.parentNode.nodeType === 11;
  }

  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',
       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {

    // only browsers that support these properties can render animations
    if (!$sniffer.animations && !$sniffer.transitions) return noop;

    var bodyNode = $document[0].body;
    var rootNode = getDomNode($rootElement);

    var rootBodyElement = jqLite(
      // this is to avoid using something that exists outside of the body
      // we also special case the doc fragement case because our unit test code
      // appends the $rootElement to the body after the app has been bootstrapped
      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode
    );

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    return function initDriverFn(animationDetails) {
      return animationDetails.from && animationDetails.to
          ? prepareFromToAnchorAnimation(animationDetails.from,
                                         animationDetails.to,
                                         animationDetails.classes,
                                         animationDetails.anchors)
          : prepareRegularAnimation(animationDetails);
    };

    function filterCssClasses(classes) {
      //remove all the `ng-` stuff
      return classes.replace(/\bng-\S+\b/g, '');
    }

    function getUniqueValues(a, b) {
      if (isString(a)) a = a.split(' ');
      if (isString(b)) b = b.split(' ');
      return a.filter(function(val) {
        return b.indexOf(val) === -1;
      }).join(' ');
    }

    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
      var startingClasses = filterCssClasses(getClassVal(clone));

      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);

      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);

      rootBodyElement.append(clone);

      var animatorIn, animatorOut = prepareOutAnimation();

      // the user may not end up using the `out` animation and
      // only making use of the `in` animation or vice-versa.
      // In either case we should allow this and not assume the
      // animation is over unless both animations are not used.
      if (!animatorOut) {
        animatorIn = prepareInAnimation();
        if (!animatorIn) {
          return end();
        }
      }

      var startingAnimator = animatorOut || animatorIn;

      return {
        start: function() {
          var runner;

          var currentAnimation = startingAnimator.start();
          currentAnimation.done(function() {
            currentAnimation = null;
            if (!animatorIn) {
              animatorIn = prepareInAnimation();
              if (animatorIn) {
                currentAnimation = animatorIn.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  end();
                  runner.complete();
                });
                return currentAnimation;
              }
            }
            // in the event that there is no `in` animation
            end();
            runner.complete();
          });

          runner = new $$AnimateRunner({
            end: endFn,
            cancel: endFn
          });

          return runner;

          function endFn() {
            if (currentAnimation) {
              currentAnimation.end();
            }
          }
        }
      };

      function calculateAnchorStyles(anchor) {
        var styles = {};

        var coords = getDomNode(anchor).getBoundingClientRect();

        // we iterate directly since safari messes up and doesn't return
        // all the keys for the coods object when iterated
        forEach(['width','height','top','left'], function(key) {
          var value = coords[key];
          switch (key) {
            case 'top':
              value += bodyNode.scrollTop;
              break;
            case 'left':
              value += bodyNode.scrollLeft;
              break;
          }
          styles[key] = Math.floor(value) + 'px';
        });
        return styles;
      }

      function prepareOutAnimation() {
        var animator = $animateCss(clone, {
          addClass: NG_OUT_ANCHOR_CLASS_NAME,
          delay: true,
          from: calculateAnchorStyles(outAnchor)
        });

        // read the comment within `prepareRegularAnimation` to understand
        // why this check is necessary
        return animator.$$willAnimate ? animator : null;
      }

      function getClassVal(element) {
        return element.attr('class') || '';
      }

      function prepareInAnimation() {
        var endingClasses = filterCssClasses(getClassVal(inAnchor));
        var toAdd = getUniqueValues(endingClasses, startingClasses);
        var toRemove = getUniqueValues(startingClasses, endingClasses);

        var animator = $animateCss(clone, {
          to: calculateAnchorStyles(inAnchor),
          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
          delay: true
        });

        // read the comment within `prepareRegularAnimation` to understand
        // why this check is necessary
        return animator.$$willAnimate ? animator : null;
      }

      function end() {
        clone.remove();
        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
      }
    }

    function prepareFromToAnchorAnimation(from, to, classes, anchors) {
      var fromAnimation = prepareRegularAnimation(from, noop);
      var toAnimation = prepareRegularAnimation(to, noop);

      var anchorAnimations = [];
      forEach(anchors, function(anchor) {
        var outElement = anchor['out'];
        var inElement = anchor['in'];
        var animator = prepareAnchoredAnimation(classes, outElement, inElement);
        if (animator) {
          anchorAnimations.push(animator);
        }
      });

      // no point in doing anything when there are no elements to animate
      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;

      return {
        start: function() {
          var animationRunners = [];

          if (fromAnimation) {
            animationRunners.push(fromAnimation.start());
          }

          if (toAnimation) {
            animationRunners.push(toAnimation.start());
          }

          forEach(anchorAnimations, function(animation) {
            animationRunners.push(animation.start());
          });

          var runner = new $$AnimateRunner({
            end: endFn,
            cancel: endFn // CSS-driven animations cannot be cancelled, only ended
          });

          $$AnimateRunner.all(animationRunners, function(status) {
            runner.complete(status);
          });

          return runner;

          function endFn() {
            forEach(animationRunners, function(runner) {
              runner.end();
            });
          }
        }
      };
    }

    function prepareRegularAnimation(animationDetails) {
      var element = animationDetails.element;
      var options = animationDetails.options || {};

      if (animationDetails.structural) {
        options.event = animationDetails.event;
        options.structural = true;
        options.applyClassesEarly = true;

        // we special case the leave animation since we want to ensure that
        // the element is removed as soon as the animation is over. Otherwise
        // a flicker might appear or the element may not be removed at all
        if (animationDetails.event === 'leave') {
          options.onDone = options.domOperation;
        }
      }

      // We assign the preparationClasses as the actual animation event since
      // the internals of $animateCss will just suffix the event token values
      // with `-active` to trigger the animation.
      if (options.preparationClasses) {
        options.event = concatWithSpace(options.event, options.preparationClasses);
      }

      var animator = $animateCss(element, options);

      // the driver lookup code inside of $$animation attempts to spawn a
      // driver one by one until a driver returns a.$$willAnimate animator object.
      // $animateCss will always return an object, however, it will pass in
      // a flag as a hint as to whether an animation was detected or not
      return animator.$$willAnimate ? animator : null;
    }
  }];
}];

// TODO(matsko): use caching here to speed things up for detection
// TODO(matsko): add documentation
//  by the time...

var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',
       function($injector,   $$AnimateRunner,   $$jqLite) {

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
         // $animateJs(element, 'enter');
    return function(element, event, classes, options) {
      // the `classes` argument is optional and if it is not used
      // then the classes will be resolved from the element's className
      // property as well as options.addClass/options.removeClass.
      if (arguments.length === 3 && isObject(classes)) {
        options = classes;
        classes = null;
      }

      options = prepareAnimationOptions(options);
      if (!classes) {
        classes = element.attr('class') || '';
        if (options.addClass) {
          classes += ' ' + options.addClass;
        }
        if (options.removeClass) {
          classes += ' ' + options.removeClass;
        }
      }

      var classesToAdd = options.addClass;
      var classesToRemove = options.removeClass;

      // the lookupAnimations function returns a series of animation objects that are
      // matched up with one or more of the CSS classes. These animation objects are
      // defined via the module.animation factory function. If nothing is detected then
      // we don't return anything which then makes $animation query the next driver.
      var animations = lookupAnimations(classes);
      var before, after;
      if (animations.length) {
        var afterFn, beforeFn;
        if (event == 'leave') {
          beforeFn = 'leave';
          afterFn = 'afterLeave'; // TODO(matsko): get rid of this
        } else {
          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
          afterFn = event;
        }

        if (event !== 'enter' && event !== 'move') {
          before = packageAnimations(element, event, options, animations, beforeFn);
        }
        after  = packageAnimations(element, event, options, animations, afterFn);
      }

      // no matching animations
      if (!before && !after) return;

      function applyOptions() {
        options.domOperation();
        applyAnimationClasses(element, options);
      }

      return {
        start: function() {
          var closeActiveAnimations;
          var chain = [];

          if (before) {
            chain.push(function(fn) {
              closeActiveAnimations = before(fn);
            });
          }

          if (chain.length) {
            chain.push(function(fn) {
              applyOptions();
              fn(true);
            });
          } else {
            applyOptions();
          }

          if (after) {
            chain.push(function(fn) {
              closeActiveAnimations = after(fn);
            });
          }

          var animationClosed = false;
          var runner = new $$AnimateRunner({
            end: function() {
              endAnimations();
            },
            cancel: function() {
              endAnimations(true);
            }
          });

          $$AnimateRunner.chain(chain, onComplete);
          return runner;

          function onComplete(success) {
            animationClosed = true;
            applyOptions();
            applyAnimationStyles(element, options);
            runner.complete(success);
          }

          function endAnimations(cancelled) {
            if (!animationClosed) {
              (closeActiveAnimations || noop)(cancelled);
              onComplete(cancelled);
            }
          }
        }
      };

      function executeAnimationFn(fn, element, event, options, onDone) {
        var args;
        switch (event) {
          case 'animate':
            args = [element, options.from, options.to, onDone];
            break;

          case 'setClass':
            args = [element, classesToAdd, classesToRemove, onDone];
            break;

          case 'addClass':
            args = [element, classesToAdd, onDone];
            break;

          case 'removeClass':
            args = [element, classesToRemove, onDone];
            break;

          default:
            args = [element, onDone];
            break;
        }

        args.push(options);

        var value = fn.apply(fn, args);
        if (value) {
          if (isFunction(value.start)) {
            value = value.start();
          }

          if (value instanceof $$AnimateRunner) {
            value.done(onDone);
          } else if (isFunction(value)) {
            // optional onEnd / onCancel callback
            return value;
          }
        }

        return noop;
      }

      function groupEventedAnimations(element, event, options, animations, fnName) {
        var operations = [];
        forEach(animations, function(ani) {
          var animation = ani[fnName];
          if (!animation) return;

          // note that all of these animations will run in parallel
          operations.push(function() {
            var runner;
            var endProgressCb;

            var resolved = false;
            var onAnimationComplete = function(rejected) {
              if (!resolved) {
                resolved = true;
                (endProgressCb || noop)(rejected);
                runner.complete(!rejected);
              }
            };

            runner = new $$AnimateRunner({
              end: function() {
                onAnimationComplete();
              },
              cancel: function() {
                onAnimationComplete(true);
              }
            });

            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
              var cancelled = result === false;
              onAnimationComplete(cancelled);
            });

            return runner;
          });
        });

        return operations;
      }

      function packageAnimations(element, event, options, animations, fnName) {
        var operations = groupEventedAnimations(element, event, options, animations, fnName);
        if (operations.length === 0) {
          var a,b;
          if (fnName === 'beforeSetClass') {
            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
          } else if (fnName === 'setClass') {
            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
          }

          if (a) {
            operations = operations.concat(a);
          }
          if (b) {
            operations = operations.concat(b);
          }
        }

        if (operations.length === 0) return;

        // TODO(matsko): add documentation
        return function startAnimation(callback) {
          var runners = [];
          if (operations.length) {
            forEach(operations, function(animateFn) {
              runners.push(animateFn());
            });
          }

          runners.length ? $$AnimateRunner.all(runners, callback) : callback();

          return function endFn(reject) {
            forEach(runners, function(runner) {
              reject ? runner.cancel() : runner.end();
            });
          };
        };
      }
    };

    function lookupAnimations(classes) {
      classes = isArray(classes) ? classes : classes.split(' ');
      var matches = [], flagMap = {};
      for (var i=0; i < classes.length; i++) {
        var klass = classes[i],
            animationFactory = $animateProvider.$$registeredAnimations[klass];
        if (animationFactory && !flagMap[klass]) {
          matches.push($injector.get(animationFactory));
          flagMap[klass] = true;
        }
      }
      return matches;
    }
  }];
}];

var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
  $$animationProvider.drivers.push('$$animateJsDriver');
  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
    return function initDriverFn(animationDetails) {
      if (animationDetails.from && animationDetails.to) {
        var fromAnimation = prepareAnimation(animationDetails.from);
        var toAnimation = prepareAnimation(animationDetails.to);
        if (!fromAnimation && !toAnimation) return;

        return {
          start: function() {
            var animationRunners = [];

            if (fromAnimation) {
              animationRunners.push(fromAnimation.start());
            }

            if (toAnimation) {
              animationRunners.push(toAnimation.start());
            }

            $$AnimateRunner.all(animationRunners, done);

            var runner = new $$AnimateRunner({
              end: endFnFactory(),
              cancel: endFnFactory()
            });

            return runner;

            function endFnFactory() {
              return function() {
                forEach(animationRunners, function(runner) {
                  // at this point we cannot cancel animations for groups just yet. 1.5+
                  runner.end();
                });
              };
            }

            function done(status) {
              runner.complete(status);
            }
          }
        };
      } else {
        return prepareAnimation(animationDetails);
      }
    };

    function prepareAnimation(animationDetails) {
      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations
      var element = animationDetails.element;
      var event = animationDetails.event;
      var options = animationDetails.options;
      var classes = animationDetails.classes;
      return $$animateJs(element, event, classes, options);
    }
  }];
}];

var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
  var PRE_DIGEST_STATE = 1;
  var RUNNING_STATE = 2;

  var rules = this.rules = {
    skip: [],
    cancel: [],
    join: []
  };

  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
    return rules[ruleType].some(function(fn) {
      return fn(element, currentAnimation, previousAnimation);
    });
  }

  function hasAnimationClasses(options, and) {
    options = options || {};
    var a = (options.addClass || '').length > 0;
    var b = (options.removeClass || '').length > 0;
    return and ? a && b : a || b;
  }

  rules.join.push(function(element, newAnimation, currentAnimation) {
    // if the new animation is class-based then we can just tack that on
    return !newAnimation.structural && hasAnimationClasses(newAnimation.options);
  });

  rules.skip.push(function(element, newAnimation, currentAnimation) {
    // there is no need to animate anything if no classes are being added and
    // there is no structural animation that will be triggered
    return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);
  });

  rules.skip.push(function(element, newAnimation, currentAnimation) {
    // why should we trigger a new structural animation if the element will
    // be removed from the DOM anyway?
    return currentAnimation.event == 'leave' && newAnimation.structural;
  });

  rules.skip.push(function(element, newAnimation, currentAnimation) {
    // if there is an ongoing current animation then don't even bother running the class-based animation
    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
  });

  rules.cancel.push(function(element, newAnimation, currentAnimation) {
    // there can never be two structural animations running at the same time
    return currentAnimation.structural && newAnimation.structural;
  });

  rules.cancel.push(function(element, newAnimation, currentAnimation) {
    // if the previous animation is already running, but the new animation will
    // be triggered, but the new animation is structural
    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
  });

  rules.cancel.push(function(element, newAnimation, currentAnimation) {
    var nO = newAnimation.options;
    var cO = currentAnimation.options;

    // if the exact same CSS class is added/removed then it's safe to cancel it
    return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);
  });

  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',
               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',
       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,
                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {

    var activeAnimationsLookup = new $$HashMap();
    var disabledElementsLookup = new $$HashMap();
    var animationsEnabled = null;

    function postDigestTaskFactory() {
      var postDigestCalled = false;
      return function(fn) {
        // we only issue a call to postDigest before
        // it has first passed. This prevents any callbacks
        // from not firing once the animation has completed
        // since it will be out of the digest cycle.
        if (postDigestCalled) {
          fn();
        } else {
          $rootScope.$$postDigest(function() {
            postDigestCalled = true;
            fn();
          });
        }
      };
    }

    // Wait until all directive and route-related templates are downloaded and
    // compiled. The $templateRequest.totalPendingRequests variable keeps track of
    // all of the remote templates being currently downloaded. If there are no
    // templates currently downloading then the watcher will still fire anyway.
    var deregisterWatch = $rootScope.$watch(
      function() { return $templateRequest.totalPendingRequests === 0; },
      function(isEmpty) {
        if (!isEmpty) return;
        deregisterWatch();

        // Now that all templates have been downloaded, $animate will wait until
        // the post digest queue is empty before enabling animations. By having two
        // calls to $postDigest calls we can ensure that the flag is enabled at the
        // very end of the post digest queue. Since all of the animations in $animate
        // use $postDigest, it's important that the code below executes at the end.
        // This basically means that the page is fully downloaded and compiled before
        // any animations are triggered.
        $rootScope.$$postDigest(function() {
          $rootScope.$$postDigest(function() {
            // we check for null directly in the event that the application already called
            // .enabled() with whatever arguments that it provided it with
            if (animationsEnabled === null) {
              animationsEnabled = true;
            }
          });
        });
      }
    );

    var callbackRegistry = {};

    // remember that the classNameFilter is set during the provider/config
    // stage therefore we can optimize here and setup a helper function
    var classNameFilter = $animateProvider.classNameFilter();
    var isAnimatableClassName = !classNameFilter
              ? function() { return true; }
              : function(className) {
                return classNameFilter.test(className);
              };

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function normalizeAnimationOptions(element, options) {
      return mergeAnimationOptions(element, options, {});
    }

    function findCallbacks(element, event) {
      var targetNode = getDomNode(element);

      var matches = [];
      var entries = callbackRegistry[event];
      if (entries) {
        forEach(entries, function(entry) {
          if (entry.node.contains(targetNode)) {
            matches.push(entry.callback);
          }
        });
      }

      return matches;
    }

    return {
      on: function(event, container, callback) {
        var node = extractElementNode(container);
        callbackRegistry[event] = callbackRegistry[event] || [];
        callbackRegistry[event].push({
          node: node,
          callback: callback
        });
      },

      off: function(event, container, callback) {
        var entries = callbackRegistry[event];
        if (!entries) return;

        callbackRegistry[event] = arguments.length === 1
            ? null
            : filterFromRegistry(entries, container, callback);

        function filterFromRegistry(list, matchContainer, matchCallback) {
          var containerNode = extractElementNode(matchContainer);
          return list.filter(function(entry) {
            var isMatch = entry.node === containerNode &&
                            (!matchCallback || entry.callback === matchCallback);
            return !isMatch;
          });
        }
      },

      pin: function(element, parentElement) {
        assertArg(isElement(element), 'element', 'not an element');
        assertArg(isElement(parentElement), 'parentElement', 'not an element');
        element.data(NG_ANIMATE_PIN_DATA, parentElement);
      },

      push: function(element, event, options, domOperation) {
        options = options || {};
        options.domOperation = domOperation;
        return queueAnimation(element, event, options);
      },

      // this method has four signatures:
      //  () - global getter
      //  (bool) - global setter
      //  (element) - element getter
      //  (element, bool) - element setter<F37>
      enabled: function(element, bool) {
        var argCount = arguments.length;

        if (argCount === 0) {
          // () - Global getter
          bool = !!animationsEnabled;
        } else {
          var hasElement = isElement(element);

          if (!hasElement) {
            // (bool) - Global setter
            bool = animationsEnabled = !!element;
          } else {
            var node = getDomNode(element);
            var recordExists = disabledElementsLookup.get(node);

            if (argCount === 1) {
              // (element) - Element getter
              bool = !recordExists;
            } else {
              // (element, bool) - Element setter
              bool = !!bool;
              if (!bool) {
                disabledElementsLookup.put(node, true);
              } else if (recordExists) {
                disabledElementsLookup.remove(node);
              }
            }
          }
        }

        return bool;
      }
    };

    function queueAnimation(element, event, options) {
      var node, parent;
      element = stripCommentsFromElement(element);
      if (element) {
        node = getDomNode(element);
        parent = element.parent();
      }

      options = prepareAnimationOptions(options);

      // we create a fake runner with a working promise.
      // These methods will become available after the digest has passed
      var runner = new $$AnimateRunner();

      // this is used to trigger callbacks in postDigest mode
      var runInNextPostDigestOrNow = postDigestTaskFactory();

      if (isArray(options.addClass)) {
        options.addClass = options.addClass.join(' ');
      }

      if (options.addClass && !isString(options.addClass)) {
        options.addClass = null;
      }

      if (isArray(options.removeClass)) {
        options.removeClass = options.removeClass.join(' ');
      }

      if (options.removeClass && !isString(options.removeClass)) {
        options.removeClass = null;
      }

      if (options.from && !isObject(options.from)) {
        options.from = null;
      }

      if (options.to && !isObject(options.to)) {
        options.to = null;
      }

      // there are situations where a directive issues an animation for
      // a jqLite wrapper that contains only comment nodes... If this
      // happens then there is no way we can perform an animation
      if (!node) {
        close();
        return runner;
      }

      var className = [node.className, options.addClass, options.removeClass].join(' ');
      if (!isAnimatableClassName(className)) {
        close();
        return runner;
      }

      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;

      // this is a hard disable of all animations for the application or on
      // the element itself, therefore  there is no need to continue further
      // past this point if not enabled
      var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);
      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
      var hasExistingAnimation = !!existingAnimation.state;

      // there is no point in traversing the same collection of parent ancestors if a followup
      // animation will be run on the same element that already did all that checking work
      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
        skipAnimations = !areAnimationsAllowed(element, parent, event);
      }

      if (skipAnimations) {
        close();
        return runner;
      }

      if (isStructural) {
        closeChildAnimations(element);
      }

      var newAnimation = {
        structural: isStructural,
        element: element,
        event: event,
        close: close,
        options: options,
        runner: runner
      };

      if (hasExistingAnimation) {
        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
        if (skipAnimationFlag) {
          if (existingAnimation.state === RUNNING_STATE) {
            close();
            return runner;
          } else {
            mergeAnimationOptions(element, existingAnimation.options, options);
            return existingAnimation.runner;
          }
        }

        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
        if (cancelAnimationFlag) {
          if (existingAnimation.state === RUNNING_STATE) {
            // this will end the animation right away and it is safe
            // to do so since the animation is already running and the
            // runner callback code will run in async
            existingAnimation.runner.end();
          } else if (existingAnimation.structural) {
            // this means that the animation is queued into a digest, but
            // hasn't started yet. Therefore it is safe to run the close
            // method which will call the runner methods in async.
            existingAnimation.close();
          } else {
            // this will merge the new animation options into existing animation options
            mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);
            return existingAnimation.runner;
          }
        } else {
          // a joined animation means that this animation will take over the existing one
          // so an example would involve a leave animation taking over an enter. Then when
          // the postDigest kicks in the enter will be ignored.
          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
          if (joinAnimationFlag) {
            if (existingAnimation.state === RUNNING_STATE) {
              normalizeAnimationOptions(element, options);
            } else {
              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);

              event = newAnimation.event = existingAnimation.event;
              options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);

              //we return the same runner since only the option values of this animation will
              //be fed into the `existingAnimation`.
              return existingAnimation.runner;
            }
          }
        }
      } else {
        // normalization in this case means that it removes redundant CSS classes that
        // already exist (addClass) or do not exist (removeClass) on the element
        normalizeAnimationOptions(element, options);
      }

      // when the options are merged and cleaned up we may end up not having to do
      // an animation at all, therefore we should check this before issuing a post
      // digest callback. Structural animations will always run no matter what.
      var isValidAnimation = newAnimation.structural;
      if (!isValidAnimation) {
        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present
        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)
                            || hasAnimationClasses(newAnimation.options);
      }

      if (!isValidAnimation) {
        close();
        clearElementAnimationState(element);
        return runner;
      }

      // the counter keeps track of cancelled animations
      var counter = (existingAnimation.counter || 0) + 1;
      newAnimation.counter = counter;

      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);

      $rootScope.$$postDigest(function() {
        var animationDetails = activeAnimationsLookup.get(node);
        var animationCancelled = !animationDetails;
        animationDetails = animationDetails || {};

        // if addClass/removeClass is called before something like enter then the
        // registered parent element may not be present. The code below will ensure
        // that a final value for parent element is obtained
        var parentElement = element.parent() || [];

        // animate/structural/class-based animations all have requirements. Otherwise there
        // is no point in performing an animation. The parent node must also be set.
        var isValidAnimation = parentElement.length > 0
                                && (animationDetails.event === 'animate'
                                    || animationDetails.structural
                                    || hasAnimationClasses(animationDetails.options));

        // this means that the previous animation was cancelled
        // even if the follow-up animation is the same event
        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
          // if another animation did not take over then we need
          // to make sure that the domOperation and options are
          // handled accordingly
          if (animationCancelled) {
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
          }

          // if the event changed from something like enter to leave then we do
          // it, otherwise if it's the same then the end result will be the same too
          if (animationCancelled || (isStructural && animationDetails.event !== event)) {
            options.domOperation();
            runner.end();
          }

          // in the event that the element animation was not cancelled or a follow-up animation
          // isn't allowed to animate from here then we need to clear the state of the element
          // so that any future animations won't read the expired animation data.
          if (!isValidAnimation) {
            clearElementAnimationState(element);
          }

          return;
        }

        // this combined multiple class to addClass / removeClass into a setClass event
        // so long as a structural event did not take over the animation
        event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true)
            ? 'setClass'
            : animationDetails.event;

        markElementAnimationState(element, RUNNING_STATE);
        var realRunner = $$animation(element, event, animationDetails.options);

        realRunner.done(function(status) {
          close(!status);
          var animationDetails = activeAnimationsLookup.get(node);
          if (animationDetails && animationDetails.counter === counter) {
            clearElementAnimationState(getDomNode(element));
          }
          notifyProgress(runner, event, 'close', {});
        });

        // this will update the runner's flow-control events based on
        // the `realRunner` object.
        runner.setHost(realRunner);
        notifyProgress(runner, event, 'start', {});
      });

      return runner;

      function notifyProgress(runner, event, phase, data) {
        runInNextPostDigestOrNow(function() {
          var callbacks = findCallbacks(element, event);
          if (callbacks.length) {
            // do not optimize this call here to RAF because
            // we don't know how heavy the callback code here will
            // be and if this code is buffered then this can
            // lead to a performance regression.
            $$rAF(function() {
              forEach(callbacks, function(callback) {
                callback(element, phase, data);
              });
            });
          }
        });
        runner.progress(event, phase, data);
      }

      function close(reject) { // jshint ignore:line
        clearGeneratedClasses(element, options);
        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);
        options.domOperation();
        runner.complete(!reject);
      }
    }

    function closeChildAnimations(element) {
      var node = getDomNode(element);
      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
      forEach(children, function(child) {
        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
        var animationDetails = activeAnimationsLookup.get(child);
        switch (state) {
          case RUNNING_STATE:
            animationDetails.runner.end();
            /* falls through */
          case PRE_DIGEST_STATE:
            if (animationDetails) {
              activeAnimationsLookup.remove(child);
            }
            break;
        }
      });
    }

    function clearElementAnimationState(element) {
      var node = getDomNode(element);
      node.removeAttribute(NG_ANIMATE_ATTR_NAME);
      activeAnimationsLookup.remove(node);
    }

    function isMatchingElement(nodeOrElmA, nodeOrElmB) {
      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
    }

    function areAnimationsAllowed(element, parentElement, event) {
      var bodyElement = jqLite($document[0].body);
      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
      var rootElementDetected = isMatchingElement(element, $rootElement);
      var parentAnimationDetected = false;
      var animateChildren;

      var parentHost = element.data(NG_ANIMATE_PIN_DATA);
      if (parentHost) {
        parentElement = parentHost;
      }

      while (parentElement && parentElement.length) {
        if (!rootElementDetected) {
          // angular doesn't want to attempt to animate elements outside of the application
          // therefore we need to ensure that the rootElement is an ancestor of the current element
          rootElementDetected = isMatchingElement(parentElement, $rootElement);
        }

        var parentNode = parentElement[0];
        if (parentNode.nodeType !== ELEMENT_NODE) {
          // no point in inspecting the #document element
          break;
        }

        var details = activeAnimationsLookup.get(parentNode) || {};
        // either an enter, leave or move animation will commence
        // therefore we can't allow any animations to take place
        // but if a parent animation is class-based then that's ok
        if (!parentAnimationDetected) {
          parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);
        }

        if (isUndefined(animateChildren) || animateChildren === true) {
          var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);
          if (isDefined(value)) {
            animateChildren = value;
          }
        }

        // there is no need to continue traversing at this point
        if (parentAnimationDetected && animateChildren === false) break;

        if (!rootElementDetected) {
          // angular doesn't want to attempt to animate elements outside of the application
          // therefore we need to ensure that the rootElement is an ancestor of the current element
          rootElementDetected = isMatchingElement(parentElement, $rootElement);
          if (!rootElementDetected) {
            parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
          }
        }

        if (!bodyElementDetected) {
          // we also need to ensure that the element is or will be apart of the body element
          // otherwise it is pointless to even issue an animation to be rendered
          bodyElementDetected = isMatchingElement(parentElement, bodyElement);
        }

        parentElement = parentElement.parent();
      }

      var allowAnimation = !parentAnimationDetected || animateChildren;
      return allowAnimation && rootElementDetected && bodyElementDetected;
    }

    function markElementAnimationState(element, state, details) {
      details = details || {};
      details.state = state;

      var node = getDomNode(element);
      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);

      var oldValue = activeAnimationsLookup.get(node);
      var newValue = oldValue
          ? extend(oldValue, details)
          : details;
      activeAnimationsLookup.put(node, newValue);
    }
  }];
}];

var $$AnimateAsyncRunFactory = ['$$rAF', function($$rAF) {
  var waitQueue = [];

  function waitForTick(fn) {
    waitQueue.push(fn);
    if (waitQueue.length > 1) return;
    $$rAF(function() {
      for (var i = 0; i < waitQueue.length; i++) {
        waitQueue[i]();
      }
      waitQueue = [];
    });
  }

  return function() {
    var passed = false;
    waitForTick(function() {
      passed = true;
    });
    return function(callback) {
      passed ? callback() : waitForTick(callback);
    };
  };
}];

var $$AnimateRunnerFactory = ['$q', '$sniffer', '$$animateAsyncRun',
                      function($q,   $sniffer,   $$animateAsyncRun) {

  var INITIAL_STATE = 0;
  var DONE_PENDING_STATE = 1;
  var DONE_COMPLETE_STATE = 2;

  AnimateRunner.chain = function(chain, callback) {
    var index = 0;

    next();
    function next() {
      if (index === chain.length) {
        callback(true);
        return;
      }

      chain[index](function(response) {
        if (response === false) {
          callback(false);
          return;
        }
        index++;
        next();
      });
    }
  };

  AnimateRunner.all = function(runners, callback) {
    var count = 0;
    var status = true;
    forEach(runners, function(runner) {
      runner.done(onProgress);
    });

    function onProgress(response) {
      status = status && response;
      if (++count === runners.length) {
        callback(status);
      }
    }
  };

  function AnimateRunner(host) {
    this.setHost(host);

    this._doneCallbacks = [];
    this._runInAnimationFrame = $$animateAsyncRun();
    this._state = 0;
  }

  AnimateRunner.prototype = {
    setHost: function(host) {
      this.host = host || {};
    },

    done: function(fn) {
      if (this._state === DONE_COMPLETE_STATE) {
        fn();
      } else {
        this._doneCallbacks.push(fn);
      }
    },

    progress: noop,

    getPromise: function() {
      if (!this.promise) {
        var self = this;
        this.promise = $q(function(resolve, reject) {
          self.done(function(status) {
            status === false ? reject() : resolve();
          });
        });
      }
      return this.promise;
    },

    then: function(resolveHandler, rejectHandler) {
      return this.getPromise().then(resolveHandler, rejectHandler);
    },

    'catch': function(handler) {
      return this.getPromise()['catch'](handler);
    },

    'finally': function(handler) {
      return this.getPromise()['finally'](handler);
    },

    pause: function() {
      if (this.host.pause) {
        this.host.pause();
      }
    },

    resume: function() {
      if (this.host.resume) {
        this.host.resume();
      }
    },

    end: function() {
      if (this.host.end) {
        this.host.end();
      }
      this._resolve(true);
    },

    cancel: function() {
      if (this.host.cancel) {
        this.host.cancel();
      }
      this._resolve(false);
    },

    complete: function(response) {
      var self = this;
      if (self._state === INITIAL_STATE) {
        self._state = DONE_PENDING_STATE;
        self._runInAnimationFrame(function() {
          self._resolve(response);
        });
      }
    },

    _resolve: function(response) {
      if (this._state !== DONE_COMPLETE_STATE) {
        forEach(this._doneCallbacks, function(fn) {
          fn(response);
        });
        this._doneCallbacks.length = 0;
        this._state = DONE_COMPLETE_STATE;
      }
    }
  };

  return AnimateRunner;
}];

var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';

  var drivers = this.drivers = [];

  var RUNNER_STORAGE_KEY = '$$animationRunner';

  function setRunner(element, runner) {
    element.data(RUNNER_STORAGE_KEY, runner);
  }

  function removeRunner(element) {
    element.removeData(RUNNER_STORAGE_KEY);
  }

  function getRunner(element) {
    return element.data(RUNNER_STORAGE_KEY);
  }

  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',
       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {

    var animationQueue = [];
    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function sortAnimations(animations) {
      var tree = { children: [] };
      var i, lookup = new $$HashMap();

      // this is done first beforehand so that the hashmap
      // is filled with a list of the elements that will be animated
      for (i = 0; i < animations.length; i++) {
        var animation = animations[i];
        lookup.put(animation.domNode, animations[i] = {
          domNode: animation.domNode,
          fn: animation.fn,
          children: []
        });
      }

      for (i = 0; i < animations.length; i++) {
        processNode(animations[i]);
      }

      return flatten(tree);

      function processNode(entry) {
        if (entry.processed) return entry;
        entry.processed = true;

        var elementNode = entry.domNode;
        var parentNode = elementNode.parentNode;
        lookup.put(elementNode, entry);

        var parentEntry;
        while (parentNode) {
          parentEntry = lookup.get(parentNode);
          if (parentEntry) {
            if (!parentEntry.processed) {
              parentEntry = processNode(parentEntry);
            }
            break;
          }
          parentNode = parentNode.parentNode;
        }

        (parentEntry || tree).children.push(entry);
        return entry;
      }

      function flatten(tree) {
        var result = [];
        var queue = [];
        var i;

        for (i = 0; i < tree.children.length; i++) {
          queue.push(tree.children[i]);
        }

        var remainingLevelEntries = queue.length;
        var nextLevelEntries = 0;
        var row = [];

        for (i = 0; i < queue.length; i++) {
          var entry = queue[i];
          if (remainingLevelEntries <= 0) {
            remainingLevelEntries = nextLevelEntries;
            nextLevelEntries = 0;
            result.push(row);
            row = [];
          }
          row.push(entry.fn);
          entry.children.forEach(function(childEntry) {
            nextLevelEntries++;
            queue.push(childEntry);
          });
          remainingLevelEntries--;
        }

        if (row.length) {
          result.push(row);
        }

        return result;
      }
    }

    // TODO(matsko): document the signature in a better way
    return function(element, event, options) {
      options = prepareAnimationOptions(options);
      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;

      // there is no animation at the current moment, however
      // these runner methods will get later updated with the
      // methods leading into the driver's end/cancel methods
      // for now they just stop the animation from starting
      var runner = new $$AnimateRunner({
        end: function() { close(); },
        cancel: function() { close(true); }
      });

      if (!drivers.length) {
        close();
        return runner;
      }

      setRunner(element, runner);

      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
      var tempClasses = options.tempClasses;
      if (tempClasses) {
        classes += ' ' + tempClasses;
        options.tempClasses = null;
      }

      animationQueue.push({
        // this data is used by the postDigest code and passed into
        // the driver step function
        element: element,
        classes: classes,
        event: event,
        structural: isStructural,
        options: options,
        beforeStart: beforeStart,
        close: close
      });

      element.on('$destroy', handleDestroyedElement);

      // we only want there to be one function called within the post digest
      // block. This way we can group animations for all the animations that
      // were apart of the same postDigest flush call.
      if (animationQueue.length > 1) return runner;

      $rootScope.$$postDigest(function() {
        var animations = [];
        forEach(animationQueue, function(entry) {
          // the element was destroyed early on which removed the runner
          // form its storage. This means we can't animate this element
          // at all and it already has been closed due to destruction.
          if (getRunner(entry.element)) {
            animations.push(entry);
          } else {
            entry.close();
          }
        });

        // now any future animations will be in another postDigest
        animationQueue.length = 0;

        var groupedAnimations = groupAnimations(animations);
        var toBeSortedAnimations = [];

        forEach(groupedAnimations, function(animationEntry) {
          toBeSortedAnimations.push({
            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
            fn: function triggerAnimationStart() {
              // it's important that we apply the `ng-animate` CSS class and the
              // temporary classes before we do any driver invoking since these
              // CSS classes may be required for proper CSS detection.
              animationEntry.beforeStart();

              var startAnimationFn, closeFn = animationEntry.close;

              // in the event that the element was removed before the digest runs or
              // during the RAF sequencing then we should not trigger the animation.
              var targetElement = animationEntry.anchors
                  ? (animationEntry.from.element || animationEntry.to.element)
                  : animationEntry.element;

              if (getRunner(targetElement)) {
                var operation = invokeFirstDriver(animationEntry);
                if (operation) {
                  startAnimationFn = operation.start;
                }
              }

              if (!startAnimationFn) {
                closeFn();
              } else {
                var animationRunner = startAnimationFn();
                animationRunner.done(function(status) {
                  closeFn(!status);
                });
                updateAnimationRunners(animationEntry, animationRunner);
              }
            }
          });
        });

        // we need to sort each of the animations in order of parent to child
        // relationships. This ensures that the child classes are applied at the
        // right time.
        $$rAFScheduler(sortAnimations(toBeSortedAnimations));
      });

      return runner;

      // TODO(matsko): change to reference nodes
      function getAnchorNodes(node) {
        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)
              ? [node]
              : node.querySelectorAll(SELECTOR);
        var anchors = [];
        forEach(items, function(node) {
          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
          if (attr && attr.length) {
            anchors.push(node);
          }
        });
        return anchors;
      }

      function groupAnimations(animations) {
        var preparedAnimations = [];
        var refLookup = {};
        forEach(animations, function(animation, index) {
          var element = animation.element;
          var node = getDomNode(element);
          var event = animation.event;
          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];

          if (anchorNodes.length) {
            var direction = enterOrMove ? 'to' : 'from';

            forEach(anchorNodes, function(anchor) {
              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
              refLookup[key] = refLookup[key] || {};
              refLookup[key][direction] = {
                animationID: index,
                element: jqLite(anchor)
              };
            });
          } else {
            preparedAnimations.push(animation);
          }
        });

        var usedIndicesLookup = {};
        var anchorGroups = {};
        forEach(refLookup, function(operations, key) {
          var from = operations.from;
          var to = operations.to;

          if (!from || !to) {
            // only one of these is set therefore we can't have an
            // anchor animation since all three pieces are required
            var index = from ? from.animationID : to.animationID;
            var indexKey = index.toString();
            if (!usedIndicesLookup[indexKey]) {
              usedIndicesLookup[indexKey] = true;
              preparedAnimations.push(animations[index]);
            }
            return;
          }

          var fromAnimation = animations[from.animationID];
          var toAnimation = animations[to.animationID];
          var lookupKey = from.animationID.toString();
          if (!anchorGroups[lookupKey]) {
            var group = anchorGroups[lookupKey] = {
              structural: true,
              beforeStart: function() {
                fromAnimation.beforeStart();
                toAnimation.beforeStart();
              },
              close: function() {
                fromAnimation.close();
                toAnimation.close();
              },
              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
              from: fromAnimation,
              to: toAnimation,
              anchors: [] // TODO(matsko): change to reference nodes
            };

            // the anchor animations require that the from and to elements both have at least
            // one shared CSS class which effictively marries the two elements together to use
            // the same animation driver and to properly sequence the anchor animation.
            if (group.classes.length) {
              preparedAnimations.push(group);
            } else {
              preparedAnimations.push(fromAnimation);
              preparedAnimations.push(toAnimation);
            }
          }

          anchorGroups[lookupKey].anchors.push({
            'out': from.element, 'in': to.element
          });
        });

        return preparedAnimations;
      }

      function cssClassesIntersection(a,b) {
        a = a.split(' ');
        b = b.split(' ');
        var matches = [];

        for (var i = 0; i < a.length; i++) {
          var aa = a[i];
          if (aa.substring(0,3) === 'ng-') continue;

          for (var j = 0; j < b.length; j++) {
            if (aa === b[j]) {
              matches.push(aa);
              break;
            }
          }
        }

        return matches.join(' ');
      }

      function invokeFirstDriver(animationDetails) {
        // we loop in reverse order since the more general drivers (like CSS and JS)
        // may attempt more elements, but custom drivers are more particular
        for (var i = drivers.length - 1; i >= 0; i--) {
          var driverName = drivers[i];
          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check

          var factory = $injector.get(driverName);
          var driver = factory(animationDetails);
          if (driver) {
            return driver;
          }
        }
      }

      function beforeStart() {
        element.addClass(NG_ANIMATE_CLASSNAME);
        if (tempClasses) {
          $$jqLite.addClass(element, tempClasses);
        }
      }

      function updateAnimationRunners(animation, newRunner) {
        if (animation.from && animation.to) {
          update(animation.from.element);
          update(animation.to.element);
        } else {
          update(animation.element);
        }

        function update(element) {
          getRunner(element).setHost(newRunner);
        }
      }

      function handleDestroyedElement() {
        var runner = getRunner(element);
        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
          runner.end();
        }
      }

      function close(rejected) { // jshint ignore:line
        element.off('$destroy', handleDestroyedElement);
        removeRunner(element);

        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);
        options.domOperation();

        if (tempClasses) {
          $$jqLite.removeClass(element, tempClasses);
        }

        element.removeClass(NG_ANIMATE_CLASSNAME);
        runner.complete(!rejected);
      }
    };
  }];
}];

/* global angularAnimateModule: true,

   $$AnimateAsyncRunFactory,
   $$rAFSchedulerFactory,
   $$AnimateChildrenDirective,
   $$AnimateRunnerFactory,
   $$AnimateQueueProvider,
   $$AnimationProvider,
   $AnimateCssProvider,
   $$AnimateCssDriverProvider,
   $$AnimateJsProvider,
   $$AnimateJsDriverProvider,
*/

/**
 * @ngdoc module
 * @name ngAnimate
 * @description
 *
 * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via
 * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.
 *
 * <div doc-module-components="ngAnimate"></div>
 *
 * # Usage
 * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based
 * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For
 * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within
 * the HTML element that the animation will be triggered on.
 *
 * ## Directive Support
 * The following directives are "animation aware":
 *
 * | Directive                                                                                                | Supported Animations                                                     |
 * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
 * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |
 * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |
 * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |
 * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |
 * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |
 * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |
 * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |
 * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |
 * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |
 * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |
 *
 * (More information can be found by visiting each the documentation associated with each directive.)
 *
 * ## CSS-based Animations
 *
 * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML
 * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.
 *
 * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:
 *
 * ```html
 * <div ng-if="bool" class="fade">
 *    Fade me in out
 * </div>
 * <button ng-click="bool=true">Fade In!</button>
 * <button ng-click="bool=false">Fade Out!</button>
 * ```
 *
 * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:
 *
 * ```css
 * /&#42; The starting CSS styles for the enter animation &#42;/
 * .fade.ng-enter {
 *   transition:0.5s linear all;
 *   opacity:0;
 * }
 *
 * /&#42; The finishing CSS styles for the enter animation &#42;/
 * .fade.ng-enter.ng-enter-active {
 *   opacity:1;
 * }
 * ```
 *
 * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two
 * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition
 * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.
 *
 * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:
 *
 * ```css
 * /&#42; now the element will fade out before it is removed from the DOM &#42;/
 * .fade.ng-leave {
 *   transition:0.5s linear all;
 *   opacity:1;
 * }
 * .fade.ng-leave.ng-leave-active {
 *   opacity:0;
 * }
 * ```
 *
 * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:
 *
 * ```css
 * /&#42; there is no need to define anything inside of the destination
 * CSS class since the keyframe will take charge of the animation &#42;/
 * .fade.ng-leave {
 *   animation: my_fade_animation 0.5s linear;
 *   -webkit-animation: my_fade_animation 0.5s linear;
 * }
 *
 * @keyframes my_fade_animation {
 *   from { opacity:1; }
 *   to { opacity:0; }
 * }
 *
 * @-webkit-keyframes my_fade_animation {
 *   from { opacity:1; }
 *   to { opacity:0; }
 * }
 * ```
 *
 * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.
 *
 * ### CSS Class-based Animations
 *
 * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different
 * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added
 * and removed.
 *
 * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:
 *
 * ```html
 * <div ng-show="bool" class="fade">
 *   Show and hide me
 * </div>
 * <button ng-click="bool=true">Toggle</button>
 *
 * <style>
 * .fade.ng-hide {
 *   transition:0.5s linear all;
 *   opacity:0;
 * }
 * </style>
 * ```
 *
 * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since
 * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.
 *
 * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation
 * with CSS styles.
 *
 * ```html
 * <div ng-class="{on:onOff}" class="highlight">
 *   Highlight this box
 * </div>
 * <button ng-click="onOff=!onOff">Toggle</button>
 *
 * <style>
 * .highlight {
 *   transition:0.5s linear all;
 * }
 * .highlight.on-add {
 *   background:white;
 * }
 * .highlight.on {
 *   background:yellow;
 * }
 * .highlight.on-remove {
 *   background:black;
 * }
 * </style>
 * ```
 *
 * We can also make use of CSS keyframes by placing them within the CSS classes.
 *
 *
 * ### CSS Staggering Animations
 * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a
 * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be
 * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for
 * the animation. The style property expected within the stagger class can either be a **transition-delay** or an
 * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).
 *
 * ```css
 * .my-animation.ng-enter {
 *   /&#42; standard transition code &#42;/
 *   transition: 1s linear all;
 *   opacity:0;
 * }
 * .my-animation.ng-enter-stagger {
 *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/
 *   transition-delay: 0.1s;
 *
 *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate
 *     to not accidentally inherit a delay property from another CSS class &#42;/
 *   transition-duration: 0s;
 * }
 * .my-animation.ng-enter.ng-enter-active {
 *   /&#42; standard transition styles &#42;/
 *   opacity:1;
 * }
 * ```
 *
 * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations
 * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this
 * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation
 * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.
 *
 * The following code will issue the **ng-leave-stagger** event on the element provided:
 *
 * ```js
 * var kids = parent.children();
 *
 * $animate.leave(kids[0]); //stagger index=0
 * $animate.leave(kids[1]); //stagger index=1
 * $animate.leave(kids[2]); //stagger index=2
 * $animate.leave(kids[3]); //stagger index=3
 * $animate.leave(kids[4]); //stagger index=4
 *
 * window.requestAnimationFrame(function() {
 *   //stagger has reset itself
 *   $animate.leave(kids[5]); //stagger index=0
 *   $animate.leave(kids[6]); //stagger index=1
 *
 *   $scope.$digest();
 * });
 * ```
 *
 * Stagger animations are currently only supported within CSS-defined animations.
 *
 * ### The `ng-animate` CSS class
 *
 * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.
 * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).
 *
 * Therefore, animations can be applied to an element using this temporary class directly via CSS.
 *
 * ```css
 * .zipper.ng-animate {
 *   transition:0.5s linear all;
 * }
 * .zipper.ng-enter {
 *   opacity:0;
 * }
 * .zipper.ng-enter.ng-enter-active {
 *   opacity:1;
 * }
 * .zipper.ng-leave {
 *   opacity:1;
 * }
 * .zipper.ng-leave.ng-leave-active {
 *   opacity:0;
 * }
 * ```
 *
 * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove
 * the CSS class once an animation has completed.)
 *
 *
 * ## JavaScript-based Animations
 *
 * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared
 * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the
 * `module.animation()` module function we can register the ainmation.
 *
 * Let's see an example of a enter/leave animation using `ngRepeat`:
 *
 * ```html
 * <div ng-repeat="item in items" class="slide">
 *   {{ item }}
 * </div>
 * ```
 *
 * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:
 *
 * ```js
 * myModule.animation('.slide', [function() {
 *   return {
 *     // make note that other events (like addClass/removeClass)
 *     // have different function input parameters
 *     enter: function(element, doneFn) {
 *       jQuery(element).fadeIn(1000, doneFn);
 *
 *       // remember to call doneFn so that angular
 *       // knows that the animation has concluded
 *     },
 *
 *     move: function(element, doneFn) {
 *       jQuery(element).fadeIn(1000, doneFn);
 *     },
 *
 *     leave: function(element, doneFn) {
 *       jQuery(element).fadeOut(1000, doneFn);
 *     }
 *   }
 * }]
 * ```
 *
 * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as
 * greensock.js and velocity.js.
 *
 * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define
 * our animations inside of the same registered animation, however, the function input arguments are a bit different:
 *
 * ```html
 * <div ng-class="color" class="colorful">
 *   this box is moody
 * </div>
 * <button ng-click="color='red'">Change to red</button>
 * <button ng-click="color='blue'">Change to blue</button>
 * <button ng-click="color='green'">Change to green</button>
 * ```
 *
 * ```js
 * myModule.animation('.colorful', [function() {
 *   return {
 *     addClass: function(element, className, doneFn) {
 *       // do some cool animation and call the doneFn
 *     },
 *     removeClass: function(element, className, doneFn) {
 *       // do some cool animation and call the doneFn
 *     },
 *     setClass: function(element, addedClass, removedClass, doneFn) {
 *       // do some cool animation and call the doneFn
 *     }
 *   }
 * }]
 * ```
 *
 * ## CSS + JS Animations Together
 *
 * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,
 * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking
 * charge of the animation**:
 *
 * ```html
 * <div ng-if="bool" class="slide">
 *   Slide in and out
 * </div>
 * ```
 *
 * ```js
 * myModule.animation('.slide', [function() {
 *   return {
 *     enter: function(element, doneFn) {
 *       jQuery(element).slideIn(1000, doneFn);
 *     }
 *   }
 * }]
 * ```
 *
 * ```css
 * .slide.ng-enter {
 *   transition:0.5s linear all;
 *   transform:translateY(-100px);
 * }
 * .slide.ng-enter.ng-enter-active {
 *   transform:translateY(0);
 * }
 * ```
 *
 * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the
 * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from
 * our own JS-based animation code:
 *
 * ```js
 * myModule.animation('.slide', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.
 *       var runner = $animateCss(element, {
 *         event: 'enter',
 *         structural: true
 *       }).start();
*        runner.done(doneFn);
 *     }
 *   }
 * }]
 * ```
 *
 * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.
 *
 * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or
 * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that
 * data into `$animateCss` directly:
 *
 * ```js
 * myModule.animation('.slide', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var runner = $animateCss(element, {
 *         event: 'enter',
 *         structural: true,
 *         addClass: 'maroon-setting',
 *         from: { height:0 },
 *         to: { height: 200 }
 *       }).start();
 *
 *       runner.done(doneFn);
 *     }
 *   }
 * }]
 * ```
 *
 * Now we can fill in the rest via our transition CSS code:
 *
 * ```css
 * /&#42; the transition tells ngAnimate to make the animation happen &#42;/
 * .slide.ng-enter { transition:0.5s linear all; }
 *
 * /&#42; this extra CSS class will be absorbed into the transition
 * since the $animateCss code is adding the class &#42;/
 * .maroon-setting { background:red; }
 * ```
 *
 * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.
 *
 * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.
 *
 * ## Animation Anchoring (via `ng-animate-ref`)
 *
 * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between
 * structural areas of an application (like views) by pairing up elements using an attribute
 * called `ng-animate-ref`.
 *
 * Let's say for example we have two views that are managed by `ng-view` and we want to show
 * that there is a relationship between two components situated in within these views. By using the
 * `ng-animate-ref` attribute we can identify that the two components are paired together and we
 * can then attach an animation, which is triggered when the view changes.
 *
 * Say for example we have the following template code:
 *
 * ```html
 * <!-- index.html -->
 * <div ng-view class="view-animation">
 * </div>
 *
 * <!-- home.html -->
 * <a href="#/banner-page">
 *   <img src="./banner.jpg" class="banner" ng-animate-ref="banner">
 * </a>
 *
 * <!-- banner-page.html -->
 * <img src="./banner.jpg" class="banner" ng-animate-ref="banner">
 * ```
 *
 * Now, when the view changes (once the link is clicked), ngAnimate will examine the
 * HTML contents to see if there is a match reference between any components in the view
 * that is leaving and the view that is entering. It will scan both the view which is being
 * removed (leave) and inserted (enter) to see if there are any paired DOM elements that
 * contain a matching ref value.
 *
 * The two images match since they share the same ref value. ngAnimate will now create a
 * transport element (which is a clone of the first image element) and it will then attempt
 * to animate to the position of the second image element in the next view. For the animation to
 * work a special CSS class called `ng-anchor` will be added to the transported element.
 *
 * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then
 * ngAnimate will handle the entire transition for us as well as the addition and removal of
 * any changes of CSS classes between the elements:
 *
 * ```css
 * .banner.ng-anchor {
 *   /&#42; this animation will last for 1 second since there are
 *          two phases to the animation (an `in` and an `out` phase) &#42;/
 *   transition:0.5s linear all;
 * }
 * ```
 *
 * We also **must** include animations for the views that are being entered and removed
 * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).
 *
 * ```css
 * .view-animation.ng-enter, .view-animation.ng-leave {
 *   transition:0.5s linear all;
 *   position:fixed;
 *   left:0;
 *   top:0;
 *   width:100%;
 * }
 * .view-animation.ng-enter {
 *   transform:translateX(100%);
 * }
 * .view-animation.ng-leave,
 * .view-animation.ng-enter.ng-enter-active {
 *   transform:translateX(0%);
 * }
 * .view-animation.ng-leave.ng-leave-active {
 *   transform:translateX(-100%);
 * }
 * ```
 *
 * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:
 * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away
 * from its origin. Once that animation is over then the `in` stage occurs which animates the
 * element to its destination. The reason why there are two animations is to give enough time
 * for the enter animation on the new element to be ready.
 *
 * The example above sets up a transition for both the in and out phases, but we can also target the out or
 * in phases directly via `ng-anchor-out` and `ng-anchor-in`.
 *
 * ```css
 * .banner.ng-anchor-out {
 *   transition: 0.5s linear all;
 *
 *   /&#42; the scale will be applied during the out animation,
 *          but will be animated away when the in animation runs &#42;/
 *   transform: scale(1.2);
 * }
 *
 * .banner.ng-anchor-in {
 *   transition: 1s linear all;
 * }
 * ```
 *
 *
 *
 *
 * ### Anchoring Demo
 *
  <example module="anchoringExample"
           name="anchoringExample"
           id="anchoringExample"
           deps="angular-animate.js;angular-route.js"
           animations="true">
    <file name="index.html">
      <a href="#/">Home</a>
      <hr />
      <div class="view-container">
        <div ng-view class="view"></div>
      </div>
    </file>
    <file name="script.js">
      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])
        .config(['$routeProvider', function($routeProvider) {
          $routeProvider.when('/', {
            templateUrl: 'home.html',
            controller: 'HomeController as home'
          });
          $routeProvider.when('/profile/:id', {
            templateUrl: 'profile.html',
            controller: 'ProfileController as profile'
          });
        }])
        .run(['$rootScope', function($rootScope) {
          $rootScope.records = [
            { id:1, title: "Miss Beulah Roob" },
            { id:2, title: "Trent Morissette" },
            { id:3, title: "Miss Ava Pouros" },
            { id:4, title: "Rod Pouros" },
            { id:5, title: "Abdul Rice" },
            { id:6, title: "Laurie Rutherford Sr." },
            { id:7, title: "Nakia McLaughlin" },
            { id:8, title: "Jordon Blanda DVM" },
            { id:9, title: "Rhoda Hand" },
            { id:10, title: "Alexandrea Sauer" }
          ];
        }])
        .controller('HomeController', [function() {
          //empty
        }])
        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {
          var index = parseInt($routeParams.id, 10);
          var record = $rootScope.records[index - 1];

          this.title = record.title;
          this.id = record.id;
        }]);
    </file>
    <file name="home.html">
      <h2>Welcome to the home page</h1>
      <p>Please click on an element</p>
      <a class="record"
         ng-href="#/profile/{{ record.id }}"
         ng-animate-ref="{{ record.id }}"
         ng-repeat="record in records">
        {{ record.title }}
      </a>
    </file>
    <file name="profile.html">
      <div class="profile record" ng-animate-ref="{{ profile.id }}">
        {{ profile.title }}
      </div>
    </file>
    <file name="animations.css">
      .record {
        display:block;
        font-size:20px;
      }
      .profile {
        background:black;
        color:white;
        font-size:100px;
      }
      .view-container {
        position:relative;
      }
      .view-container > .view.ng-animate {
        position:absolute;
        top:0;
        left:0;
        width:100%;
        min-height:500px;
      }
      .view.ng-enter, .view.ng-leave,
      .record.ng-anchor {
        transition:0.5s linear all;
      }
      .view.ng-enter {
        transform:translateX(100%);
      }
      .view.ng-enter.ng-enter-active, .view.ng-leave {
        transform:translateX(0%);
      }
      .view.ng-leave.ng-leave-active {
        transform:translateX(-100%);
      }
      .record.ng-anchor-out {
        background:red;
      }
    </file>
  </example>
 *
 * ### How is the element transported?
 *
 * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting
 * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element
 * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The
 * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match
 * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied
 * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class
 * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element
 * will become visible since the shim class will be removed.
 *
 * ### How is the morphing handled?
 *
 * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out
 * what CSS classes differ between the starting element and the destination element. These different CSS classes
 * will be added/removed on the anchor element and a transition will be applied (the transition that is provided
 * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will
 * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that
 * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since
 * the cloned element is placed inside of root element which is likely close to the body element).
 *
 * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.
 *
 *
 * ## Using $animate in your directive code
 *
 * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?
 * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's
 * imagine we have a greeting box that shows and hides itself when the data changes
 *
 * ```html
 * <greeting-box active="onOrOff">Hi there</greeting-box>
 * ```
 *
 * ```js
 * ngModule.directive('greetingBox', ['$animate', function($animate) {
 *   return function(scope, element, attrs) {
 *     attrs.$observe('active', function(value) {
 *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');
 *     });
 *   });
 * }]);
 * ```
 *
 * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element
 * in our HTML code then we can trigger a CSS or JS animation to happen.
 *
 * ```css
 * /&#42; normally we would create a CSS class to reference on the element &#42;/
 * greeting-box.on { transition:0.5s linear all; background:green; color:white; }
 * ```
 *
 * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's
 * possible be sure to visit the {@link ng.$animate $animate service API page}.
 *
 *
 * ### Preventing Collisions With Third Party Libraries
 *
 * Some third-party frameworks place animation duration defaults across many element or className
 * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which
 * is expecting actual animations on these elements and has to wait for their completion.
 *
 * You can prevent this unwanted behavior by using a prefix on all your animation classes:
 *
 * ```css
 * /&#42; prefixed with animate- &#42;/
 * .animate-fade-add.animate-fade-add-active {
 *   transition:1s linear all;
 *   opacity:0;
 * }
 * ```
 *
 * You then configure `$animate` to enforce this prefix:
 *
 * ```js
 * $animateProvider.classNameFilter(/animate-/);
 * ```
 *
 * This also may provide your application with a speed boost since only specific elements containing CSS class prefix
 * will be evaluated for animation when any DOM changes occur in the application.
 *
 * ## Callbacks and Promises
 *
 * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger
 * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has
 * ended by chaining onto the returned promise that animation method returns.
 *
 * ```js
 * // somewhere within the depths of the directive
 * $animate.enter(element, parent).then(function() {
 *   //the animation has completed
 * });
 * ```
 *
 * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case
 * anymore.)
 *
 * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering
 * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view
 * routing controller to hook into that:
 *
 * ```js
 * ngModule.controller('HomePageController', ['$animate', function($animate) {
 *   $animate.on('enter', ngViewElement, function(element) {
 *     // the animation for this route has completed
 *   }]);
 * }])
 * ```
 *
 * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)
 */

/**
 * @ngdoc service
 * @name $animate
 * @kind object
 *
 * @description
 * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.
 *
 * Click here {@link ng.$animate to learn more about animations with `$animate`}.
 */
angular.module('ngAnimate', [])
  .directive('ngAnimateChildren', $$AnimateChildrenDirective)
  .factory('$$rAFScheduler', $$rAFSchedulerFactory)

  .factory('$$AnimateRunner', $$AnimateRunnerFactory)
  .factory('$$animateAsyncRun', $$AnimateAsyncRunFactory)

  .provider('$$animateQueue', $$AnimateQueueProvider)
  .provider('$$animation', $$AnimationProvider)

  .provider('$animateCss', $AnimateCssProvider)
  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)

  .provider('$$animateJs', $$AnimateJsProvider)
  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);


})(window, window.angular);

},{}],34:[function(require,module,exports){
require('./angular-animate');
module.exports = 'ngAnimate';

},{"./angular-animate":33}],35:[function(require,module,exports){
/*!
   angular-block-ui v0.2.0
   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui
   License: MIT
*/
(function(angular) {

var blkUI = angular.module('blockUI', []);

blkUI.config(["$provide", "$httpProvider", function ($provide, $httpProvider) {

  $provide.decorator('$exceptionHandler', ['$delegate', '$injector',
    function ($delegate, $injector) {
      var blockUI, blockUIConfig;

      return function (exception, cause) {

        blockUIConfig = blockUIConfig || $injector.get('blockUIConfig');

        if (blockUIConfig.resetOnException) {
          try {
            blockUI = blockUI || $injector.get('blockUI');
            blockUI.instances.reset();
          } catch (ex) {
            console.log('$exceptionHandler', exception);
          }
        }

        $delegate(exception, cause);
      };
    }
  ]);

  $httpProvider.interceptors.push('blockUIHttpInterceptor');
}]);

blkUI.run(["$document", "blockUIConfig", "$templateCache", function ($document, blockUIConfig, $templateCache) {
  if (blockUIConfig.autoInjectBodyBlock) {
    $document.find('body').attr('block-ui', 'main');
  }

  if (blockUIConfig.template) {

    // Swap the builtin template with the custom template.
    // Create a magic cache key and place the template in the cache.

    blockUIConfig.templateUrl = '$$block-ui-template$$';
    $templateCache.put(blockUIConfig.templateUrl, blockUIConfig.template);
  }
}]);

function moduleLoaded(name) {
  try {
    angular.module(name);
  } catch(ex) {
    return false;
  }
  return true;
}
blkUI.config(["$provide", function ($provide) {
  $provide.decorator('$location', decorateLocation);
}]);

var decorateLocation = [
  '$delegate', 'blockUI', 'blockUIConfig',
  function ($delegate, blockUI, blockUIConfig) {

    if (blockUIConfig.blockBrowserNavigation) {

      blockUI.$_blockLocationChange = true;

      var overrides = ['url', 'path', 'search', 'hash', 'state'];

      function hook(f) {
        var s = $delegate[f];
        $delegate[f] = function () {

          //        console.log(f, Date.now(), arguments);

          var result = s.apply($delegate, arguments);

          // The call was a setter if the $location service is returned.

          if (result === $delegate) {

            // Mark the mainblock ui to allow the location change.

            blockUI.$_blockLocationChange = false;
          }

          return result;
        };
      }

      angular.forEach(overrides, hook);

    }

    return $delegate;
}];

// Called from block-ui-directive for the 'main' instance.

function blockNavigation($scope, mainBlockUI, blockUIConfig) {

  if (blockUIConfig.blockBrowserNavigation) {

    function registerLocationChange() {

      $scope.$on('$locationChangeStart', function (event) {

        //        console.log('$locationChangeStart', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);

        if (mainBlockUI.$_blockLocationChange && mainBlockUI.state().blockCount > 0) {
          event.preventDefault();
        }
      });

      $scope.$on('$locationChangeSuccess', function () {
        mainBlockUI.$_blockLocationChange = blockUIConfig.blockBrowserNavigation;

        //        console.log('$locationChangeSuccess', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);
      });
    }

    if (moduleLoaded('ngRoute')) {

      // After the initial content has been loaded we'll spy on any location
      // changes and discard them when needed.

      var fn = $scope.$on('$viewContentLoaded', function () {

        // Unhook the view loaded and hook a function that will prevent
        // location changes while the block is active.

        fn();
        registerLocationChange();

      });

    } else {
      registerLocationChange();
    }

  }
}
blkUI.directive('blockUiContainer', ["blockUIConfig", "blockUiContainerLinkFn", function (blockUIConfig, blockUiContainerLinkFn) {
  return {
    scope: true,
    restrict: 'A',
    templateUrl: blockUIConfig.templateUrl,
    compile: function($element) {
      return blockUiContainerLinkFn;
    }
  };
}]).factory('blockUiContainerLinkFn', ["blockUI", "blockUIUtils", function (blockUI, blockUIUtils) {

  return function ($scope, $element, $attrs) {

    var srvInstance = $element.inheritedData('block-ui');

    if (!srvInstance) {
      throw new Error('No parent block-ui service instance located.');
    }

    // Expose the state on the scope

    $scope.state = srvInstance.state();

//    $scope.$watch('state.blocking', function(value) {
//      $element.toggleClass('block-ui-visible', !!value);
//    });
//
//    $scope.$watch('state.blockCount > 0', function(value) {
//      $element.toggleClass('block-ui-active', !!value);
//    });
  };
}]);
blkUI.directive('blockUi', ["blockUiCompileFn", function (blockUiCompileFn) {

  return {
    scope: true,
    restrict: 'A',
    compile: blockUiCompileFn
  };

}]).factory('blockUiCompileFn', ["blockUiPreLinkFn", function (blockUiPreLinkFn) {

  return function ($element, $attrs) {

    // Class should be added here to prevent an animation delay error.

    $element.append('<div block-ui-container class="block-ui-container"></div>');

    return {
      pre: blockUiPreLinkFn
    };

  };

}]).factory('blockUiPreLinkFn', ["blockUI", "blockUIUtils", "blockUIConfig", function (blockUI, blockUIUtils, blockUIConfig) {

  return function ($scope, $element, $attrs) {

    // If the element does not have the class "block-ui" set, we set the
    // default css classes from the config.

    if (!$element.hasClass('block-ui')) {
      $element.addClass(blockUIConfig.cssClass);
    }

    // Expose the blockUiMessageClass attribute value on the scope

    $attrs.$observe('blockUiMessageClass', function (value) {
      $scope.$_blockUiMessageClass = value;
    });

    // Create the blockUI instance
    // Prefix underscore to prevent integers:
    // https://github.com/McNull/angular-block-ui/pull/8

    var instanceId = $attrs.blockUi || '_' + $scope.$id;
    var srvInstance = blockUI.instances.get(instanceId);

    // If this is the main (topmost) block element we'll also need to block any
    // location changes while the block is active.

    if (instanceId === 'main') {
      blockNavigation($scope, srvInstance, blockUIConfig);
    } else {
      // Locate the parent blockUI instance
      var parentInstance = $element.inheritedData('block-ui');

      if (parentInstance) {
        // TODO: assert if parent is already set to something else
        srvInstance._parent = parentInstance;
      }
    }

    // Ensure the instance is released when the scope is destroyed

    $scope.$on('$destroy', function () {
      srvInstance.release();
    });

    // Increase the reference count

    srvInstance.addRef();

    // Expose the state on the scope

    $scope.$_blockUiState = srvInstance.state();

    $scope.$watch('$_blockUiState.blocking', function (value) {
      // Set the aria-busy attribute if needed
      $element.attr('aria-busy', !!value);
      $element.toggleClass('block-ui-visible', !!value);
    });

    $scope.$watch('$_blockUiState.blockCount > 0', function (value) {
      $element.toggleClass('block-ui-active', !!value);
    });

    // If a pattern is provided assign it to the state

    var pattern = $attrs.blockUiPattern;

    if (pattern) {
      var regExp = blockUIUtils.buildRegExp(pattern);
      srvInstance.pattern(regExp);
    }

    // Store a reference to the service instance on the element

    $element.data('block-ui', srvInstance);

  };

}]);
//.factory('blockUiPostLinkFn', function(blockUIUtils) {
//
//  return function($scope, $element, $attrs) {
//
//    var $message;
//
//    $attrs.$observe('blockUiMessageClass', function(value) {
//
//      $message = $message || blockUIUtils.findElement($element, function($e) {
//        return $e.hasClass('block-ui-message');
//      });
//
//      $message.addClass(value);
//
//    });
//  };
//
//});
blkUI.constant('blockUIConfig', {
    templateUrl: 'angular-block-ui/angular-block-ui.ng.html',
    delay: 250,
    message: "Loading ...",
    autoBlock: true,
    resetOnException: true,
    requestFilter: angular.noop,
    autoInjectBodyBlock: true,
    cssClass: 'block-ui block-ui-anim-fade',
    blockBrowserNavigation: false
});


blkUI.factory('blockUIHttpInterceptor', ["$q", "$injector", "blockUIConfig", "$templateCache", function($q, $injector, blockUIConfig, $templateCache) {

  var blockUI;

  function injectBlockUI() {
    blockUI = blockUI || $injector.get('blockUI');
  }

  function stopBlockUI(config) {
    if (blockUIConfig.autoBlock && (config && !config.$_noBlock && config.$_blocks)) {
      injectBlockUI();
      config.$_blocks.stop();
    }
  }

  function error(rejection) {

    try {
      stopBlockUI(rejection.config);
    } catch(ex) {
      console.log('httpRequestError', ex);
    }

    return $q.reject(rejection);
  }

  return {
    request: function(config) {

      // Only block when autoBlock is enabled ...
      // ... and the request doesn't match a cached template.

      if (blockUIConfig.autoBlock &&
        !(config.method == 'GET' && $templateCache.get(config.url))) {

        // Don't block excluded requests

        var result = blockUIConfig.requestFilter(config);

        if (result === false) {
          // Tag the config so we don't unblock this request
          config.$_noBlock = true;
        } else {

          injectBlockUI();

          config.$_blocks = blockUI.instances.locate(config);
          config.$_blocks.start(result);
        }
      }

      return config;
    },

    requestError: error,

    response: function(response) {

      // If the connection to the website goes down the response interceptor gets and error with "cannot read property config of null".
      // https://github.com/McNull/angular-block-ui/issues/53

      if(response) {
        stopBlockUI(response.config);
      }

      return response;
    },

    responseError: error
  };

}]);

blkUI.factory('blockUI', ["blockUIConfig", "$timeout", "blockUIUtils", "$document", function(blockUIConfig, $timeout, blockUIUtils, $document) {

  var $body = $document.find('body');

  function BlockUI(id) {

    var self = this;

    var state = {
      id: id,
      blockCount: 0,
      message: blockUIConfig.message,
      blocking: false
    }, startPromise, doneCallbacks = [];

    this._id = id;

    this._refs = 0;

    this.start = function(message) {

      if(state.blockCount > 0) {
        message = message || state.message || blockUIConfig.message;
      } else {
        message = message || blockUIConfig.message;
      }

      state.message = message;

      state.blockCount++;

      // Check if the focused element is part of the block scope

      var $ae = angular.element($document[0].activeElement);

      if($ae.length && blockUIUtils.isElementInBlockScope($ae, self)) {

        // Let the active element lose focus and store a reference 
        // to restore focus when we're done (reset)

        self._restoreFocus = $ae[0];

        // https://github.com/McNull/angular-block-ui/issues/13
        // http://stackoverflow.com/questions/22698058/apply-already-in-progress-error-when-using-typeahead-plugin-found-to-be-relate
        // Queue the blur after any ng-blur expression.

        $timeout(function() {
          // Ensure we still need to blur
          if(self._restoreFocus) {
            self._restoreFocus.blur();
          }
        });
      }

      if (!startPromise) {
        startPromise = $timeout(function() {
          startPromise = null;
          state.blocking = true;
        }, blockUIConfig.delay);
      }
    };

    this._cancelStartTimeout = function() {
      if (startPromise) {
        $timeout.cancel(startPromise);
        startPromise = null;
      }
    };

    this.stop = function() {
      state.blockCount = Math.max(0, --state.blockCount);

      if (state.blockCount === 0) {
        self.reset(true);
      }
    };

    this.message = function(value) {
      state.message = value;
    };

    this.pattern = function(regexp) {
      if (regexp !== undefined) {
        self._pattern = regexp;
      }

      return self._pattern;
    };

    this.reset = function(executeCallbacks) {
      
      self._cancelStartTimeout();
      state.blockCount = 0;
      state.blocking = false;

      // Restore the focus to the element that was active
      // before the block start, but not if the user has 
      // focused something else while the block was active.

      if(self._restoreFocus && 
         (!$document[0].activeElement || $document[0].activeElement === $body[0])) {
        self._restoreFocus.focus();
        self._restoreFocus = null;
      }
      
      try {
        if (executeCallbacks) {
          angular.forEach(doneCallbacks, function(cb) {
            cb();
          });
        }
      } finally {
        doneCallbacks.length = 0;
      }
    };

    this.done = function(fn) {
      doneCallbacks.push(fn);
    };

    this.state = function() {
      return state;
    };

    this.addRef = function() {
      self._refs += 1;
    };

    this.release = function() {
      if(--self._refs <= 0) {
        mainBlock.instances._destroy(self);
      }
    };
  }

  var instances = [];

  instances.get = function(id) {

    if(!isNaN(id)) {
      throw new Error('BlockUI id cannot be a number');
    }

    var instance = instances[id];

    if(!instance) {
      // TODO: ensure no array instance trashing [xxx] -- current workaround: '_' + $scope.$id
      instance = instances[id] = new BlockUI(id);
      instances.push(instance);
    }

    return instance;
  };

  instances._destroy = function(idOrInstance) {
    if (angular.isString(idOrInstance)) {
      idOrInstance = instances[idOrInstance];
    }

    if (idOrInstance) {
      idOrInstance.reset();

      var i = blockUIUtils.indexOf(instances, idOrInstance);
      instances.splice(i, 1);

      delete instances[idOrInstance.state().id];
    }
  };
  
  instances.locate = function(request) {

    var result = [];

    // Add function wrappers that will be executed on every item
    // in the array.
    
    blockUIUtils.forEachFnHook(result, 'start');
    blockUIUtils.forEachFnHook(result, 'stop');

    var i = instances.length;

    while(i--) {
      var instance = instances[i];
      var pattern = instance._pattern;

      if(pattern && pattern.test(request.url)) {
        result.push(instance);
      }
    }

    if(result.length === 0) {
      result.push(mainBlock);
    }

    return result;
  };

  // Propagate the reset to all instances

  blockUIUtils.forEachFnHook(instances, 'reset');

  var mainBlock = instances.get('main');

  mainBlock.addRef();
  mainBlock.instances = instances;

  return mainBlock;
}]);


blkUI.factory('blockUIUtils', function() {

  var $ = angular.element;

  var utils = {
    buildRegExp: function(pattern) {
      var match = pattern.match(/^\/(.*)\/([gim]*)$/), regExp;

      if(match) {
        regExp = new RegExp(match[1], match[2]);
      } else {
        throw Error('Incorrect regular expression format: ' + pattern);
      }

      return regExp;
    },
    forEachFn: function(arr, fnName, args) {
      var i = arr.length;
      while(i--) {
        var t = arr[i];
        t[fnName].apply(t, args);
      }
    },
    forEachFnHook: function(arr, fnName) {
      arr[fnName] = function() {
        utils.forEachFn(this, fnName, arguments);
      }
    },
    isElementInBlockScope: function($element, blockScope) {
      var c = $element.inheritedData('block-ui');

      while(c) {
        if(c === blockScope) {
          return true;
        }

        c = c._parent;
      }

      return false;
    },
    findElement: function ($element, predicateFn, traverse) {
      var ret = null;

      if (predicateFn($element)) {
        ret = $element;
      } else {

        var $elements;

        if (traverse) {
          $elements = $element.parent();
        } else {
          $elements = $element.children();
        }

        var i = $elements.length;
        while (!ret && i--) {
          ret = utils.findElement($($elements[i]), predicateFn, traverse);
        }
      }

      return ret;
    },
    indexOf: function(arr, obj, start) {
//      if(Array.prototype.indexOf) {
//        return arr.indexOf(obj, start);
//      }

      for (var i = (start || 0), j = arr.length; i < j; i++) {
        if (arr[i] === obj) {
          return i;
        }
      }

      return -1;
    }
  };

  return utils;

});
// Automatically generated.
// This file is already embedded in your main javascript output, there's no need to include this file
// manually in the index.html. This file is only here for your debugging pleasures.
angular.module('blockUI').run(['$templateCache', function($templateCache){
  $templateCache.put('angular-block-ui/angular-block-ui.ng.html', '<div class=\"block-ui-overlay\"></div><div class=\"block-ui-message-container\" aria-live=\"assertive\" aria-atomic=\"true\"><div class=\"block-ui-message\" ng-class=\"$_blockUiMessageClass\">{{ state.message }}</div></div>');
}]);
})(angular);
if (typeof module !== "undefined") module.exports = "blockUI";


},{}],36:[function(require,module,exports){
var css = "/*!\n   angular-block-ui v0.2.0\n   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui\n   License: MIT\n*/\n.block-ui {\n  position: relative;\n}\nbody.block-ui {\n  position: static;\n}\n.block-ui-main>.block-ui-container,\nbody.block-ui>.block-ui-container {\n  position: fixed;\n}\n.block-ui-container {\n  position: absolute;\n  z-index: 10000;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  height: 0;\n  overflow: hidden;\n  opacity: 0;\n  filter: alpha(opacity=00);\n}\n.block-ui-active>.block-ui-container {\n  height: 100%;\n  cursor: wait;\n}\n.block-ui-active .block-ui-active>.block-ui-container {\n  height: 0;\n}\n.block-ui-visible>.block-ui-container {\n  opacity: 1;\n  filter: alpha(opacity=100);\n}\n.block-ui-overlay {\n  width: 100%;\n  height: 100%;\n  opacity: .5;\n  filter: alpha(opacity=50);\n  background-color: #fff;\n}\n.block-ui-message-container {\n  position: absolute;\n  top: 35%;\n  left: 0;\n  right: 0;\n  height: 0;\n  text-align: center;\n  z-index: 10001;\n}\n.block-ui-message {\n  display: inline-block;\n  text-align: left;\n  background-color: #333;\n  color: #f5f5f5;\n  padding: 20px;\n  border-radius: 4px;\n  font-size: 20px;\n  font-weight: 700;\n  filter: alpha(opacity=100);\n}\n.block-ui-anim-fade>.block-ui-container {\n  -webkit-transition: height 0s linear 200ms,opacity 200ms ease 0s;\n  transition: height 0s linear 200ms,opacity 200ms ease 0s;\n}\n.block-ui-anim-fade.block-ui-active>.block-ui-container {\n  -webkit-transition-delay: 0s;\n  transition-delay: 0s;\n}\n"; (require("browserify-css").createStyle(css, { "href": "node_modules\\angular-block-ui\\dist\\angular-block-ui.min.css"})); module.exports = css;
},{"browserify-css":41}],37:[function(require,module,exports){
/**
 * @license AngularJS v1.4.7
 * (c) 2010-2015 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {'use strict';

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *     Any commits to this file should be reviewed with security in mind.  *
 *   Changes to this file can potentially create security vulnerabilities. *
 *          An approval from 2 Core members with history of modifying      *
 *                         this file is required.                          *
 *                                                                         *
 *  Does the change somehow allow for arbitrary javascript to be executed? *
 *    Or allows for someone to change the prototype of built-in objects?   *
 *     Or gives undesired access to variables likes document or window?    *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

var $sanitizeMinErr = angular.$$minErr('$sanitize');

/**
 * @ngdoc module
 * @name ngSanitize
 * @description
 *
 * # ngSanitize
 *
 * The `ngSanitize` module provides functionality to sanitize HTML.
 *
 *
 * <div doc-module-components="ngSanitize"></div>
 *
 * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
 */

/*
 * HTML Parser By Misko Hevery (misko@hevery.com)
 * based on:  HTML Parser By John Resig (ejohn.org)
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 *
 * // Use like so:
 * htmlParser(htmlString, {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * });
 *
 */


/**
 * @ngdoc service
 * @name $sanitize
 * @kind function
 *
 * @description
 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
 *   then serialized back to properly escaped html string. This means that no unsafe input can make
 *   it into the returned string, however, since our parser is more strict than a typical browser
 *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a
 *   browser, won't make it through the sanitizer. The input may also contain SVG markup.
 *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and
 *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.
 *
 * @param {string} html HTML input.
 * @returns {string} Sanitized HTML.
 *
 * @example
   <example module="sanitizeExample" deps="angular-sanitize.js">
   <file name="index.html">
     <script>
         angular.module('sanitizeExample', ['ngSanitize'])
           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
             $scope.snippet =
               '<p style="color:blue">an html\n' +
               '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
               'snippet</p>';
             $scope.deliberatelyTrustDangerousSnippet = function() {
               return $sce.trustAsHtml($scope.snippet);
             };
           }]);
     </script>
     <div ng-controller="ExampleController">
        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <td>Directive</td>
           <td>How</td>
           <td>Source</td>
           <td>Rendered</td>
         </tr>
         <tr id="bind-html-with-sanitize">
           <td>ng-bind-html</td>
           <td>Automatically uses $sanitize</td>
           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind-html="snippet"></div></td>
         </tr>
         <tr id="bind-html-with-trust">
           <td>ng-bind-html</td>
           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
           <td>
           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
&lt;/div&gt;</pre>
           </td>
           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
         </tr>
         <tr id="bind-default">
           <td>ng-bind</td>
           <td>Automatically escapes</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
       </div>
   </file>
   <file name="protractor.js" type="protractor">
     it('should sanitize the html snippet by default', function() {
       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
         toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
     });

     it('should inline raw snippet if bound to a trusted value', function() {
       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).
         toBe("<p style=\"color:blue\">an html\n" +
              "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
              "snippet</p>");
     });

     it('should escape snippet without any filter', function() {
       expect(element(by.css('#bind-default div')).getInnerHtml()).
         toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
              "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
              "snippet&lt;/p&gt;");
     });

     it('should update', function() {
       element(by.model('snippet')).clear();
       element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
         toBe('new <b>text</b>');
       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(
         'new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(
         "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
     });
   </file>
   </example>
 */
function $SanitizeProvider() {
  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
    return function(html) {
      var buf = [];
      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
        return !/^unsafe/.test($$sanitizeUri(uri, isImage));
      }));
      return buf.join('');
    };
  }];
}

function sanitizeText(chars) {
  var buf = [];
  var writer = htmlSanitizeWriter(buf, angular.noop);
  writer.chars(chars);
  return buf.join('');
}


// Regular Expressions for parsing tags and attributes
var START_TAG_REGEXP =
       /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
  END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
  ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
  BEGIN_TAG_REGEXP = /^</,
  BEGING_END_TAGE_REGEXP = /^<\//,
  COMMENT_REGEXP = /<!--(.*?)-->/g,
  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
  CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
  SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
  // Match everything outside of normal chars and " (quote character)
  NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;


// Good source of info about elements and attributes
// http://dev.w3.org/html5/spec/Overview.html#semantics
// http://simon.html5.org/html-elements

// Safe Void Elements - HTML5
// http://dev.w3.org/html5/spec/Overview.html#void-elements
var voidElements = makeMap("area,br,col,hr,img,wbr");

// Elements that you can, intentionally, leave open (and which close themselves)
// http://dev.w3.org/html5/spec/Overview.html#optional-tags
var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
    optionalEndTagInlineElements = makeMap("rp,rt"),
    optionalEndTagElements = angular.extend({},
                                            optionalEndTagInlineElements,
                                            optionalEndTagBlockElements);

// Safe Block Elements - HTML5
var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," +
        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));

// Inline Elements - HTML5
var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," +
        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));

// SVG Elements
// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.
// They can potentially allow for arbitrary javascript to be executed. See #11290
var svgElements = makeMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," +
        "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," +
        "radialGradient,rect,stop,svg,switch,text,title,tspan,use");

// Special Elements (can contain anything)
var specialElements = makeMap("script,style");

var validElements = angular.extend({},
                                   voidElements,
                                   blockElements,
                                   inlineElements,
                                   optionalEndTagElements,
                                   svgElements);

//Attributes that have href and hence need to be sanitized
var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");

var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
    'valign,value,vspace,width');

// SVG attributes (without "id" and "name" attributes)
// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);

var validAttrs = angular.extend({},
                                uriAttrs,
                                svgAttrs,
                                htmlAttrs);

function makeMap(str, lowercaseKeys) {
  var obj = {}, items = str.split(','), i;
  for (i = 0; i < items.length; i++) {
    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
  }
  return obj;
}


/**
 * @example
 * htmlParser(htmlString, {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * });
 *
 * @param {string} html string
 * @param {object} handler
 */
function htmlParser(html, handler) {
  if (typeof html !== 'string') {
    if (html === null || typeof html === 'undefined') {
      html = '';
    } else {
      html = '' + html;
    }
  }
  var index, chars, match, stack = [], last = html, text;
  stack.last = function() { return stack[stack.length - 1]; };

  while (html) {
    text = '';
    chars = true;

    // Make sure we're not in a script or style element
    if (!stack.last() || !specialElements[stack.last()]) {

      // Comment
      if (html.indexOf("<!--") === 0) {
        // comments containing -- are not allowed unless they terminate the comment
        index = html.indexOf("--", 4);

        if (index >= 0 && html.lastIndexOf("-->", index) === index) {
          if (handler.comment) handler.comment(html.substring(4, index));
          html = html.substring(index + 3);
          chars = false;
        }
      // DOCTYPE
      } else if (DOCTYPE_REGEXP.test(html)) {
        match = html.match(DOCTYPE_REGEXP);

        if (match) {
          html = html.replace(match[0], '');
          chars = false;
        }
      // end tag
      } else if (BEGING_END_TAGE_REGEXP.test(html)) {
        match = html.match(END_TAG_REGEXP);

        if (match) {
          html = html.substring(match[0].length);
          match[0].replace(END_TAG_REGEXP, parseEndTag);
          chars = false;
        }

      // start tag
      } else if (BEGIN_TAG_REGEXP.test(html)) {
        match = html.match(START_TAG_REGEXP);

        if (match) {
          // We only have a valid start-tag if there is a '>'.
          if (match[4]) {
            html = html.substring(match[0].length);
            match[0].replace(START_TAG_REGEXP, parseStartTag);
          }
          chars = false;
        } else {
          // no ending tag found --- this piece should be encoded as an entity.
          text += '<';
          html = html.substring(1);
        }
      }

      if (chars) {
        index = html.indexOf("<");

        text += index < 0 ? html : html.substring(0, index);
        html = index < 0 ? "" : html.substring(index);

        if (handler.chars) handler.chars(decodeEntities(text));
      }

    } else {
      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\W\w].
      html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'),
        function(all, text) {
          text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");

          if (handler.chars) handler.chars(decodeEntities(text));

          return "";
      });

      parseEndTag("", stack.last());
    }

    if (html == last) {
      throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " +
                                        "of html: {0}", html);
    }
    last = html;
  }

  // Clean up any remaining tags
  parseEndTag();

  function parseStartTag(tag, tagName, rest, unary) {
    tagName = angular.lowercase(tagName);
    if (blockElements[tagName]) {
      while (stack.last() && inlineElements[stack.last()]) {
        parseEndTag("", stack.last());
      }
    }

    if (optionalEndTagElements[tagName] && stack.last() == tagName) {
      parseEndTag("", tagName);
    }

    unary = voidElements[tagName] || !!unary;

    if (!unary) {
      stack.push(tagName);
    }

    var attrs = {};

    rest.replace(ATTR_REGEXP,
      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
        var value = doubleQuotedValue
          || singleQuotedValue
          || unquotedValue
          || '';

        attrs[name] = decodeEntities(value);
    });
    if (handler.start) handler.start(tagName, attrs, unary);
  }

  function parseEndTag(tag, tagName) {
    var pos = 0, i;
    tagName = angular.lowercase(tagName);
    if (tagName) {
      // Find the closest opened tag of the same type
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos] == tagName) break;
      }
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (i = stack.length - 1; i >= pos; i--)
        if (handler.end) handler.end(stack[i]);

      // Remove the open elements from the stack
      stack.length = pos;
    }
  }
}

var hiddenPre=document.createElement("pre");
/**
 * decodes all entities into regular string
 * @param value
 * @returns {string} A string with decoded entities.
 */
function decodeEntities(value) {
  if (!value) { return ''; }

  hiddenPre.innerHTML = value.replace(/</g,"&lt;");
  // innerText depends on styling as it doesn't display hidden elements.
  // Therefore, it's better to use textContent not to cause unnecessary reflows.
  return hiddenPre.textContent;
}

/**
 * Escapes all potentially dangerous characters, so that the
 * resulting string can be safely inserted into attribute or
 * element text.
 * @param value
 * @returns {string} escaped text
 */
function encodeEntities(value) {
  return value.
    replace(/&/g, '&amp;').
    replace(SURROGATE_PAIR_REGEXP, function(value) {
      var hi = value.charCodeAt(0);
      var low = value.charCodeAt(1);
      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
    }).
    replace(NON_ALPHANUMERIC_REGEXP, function(value) {
      return '&#' + value.charCodeAt(0) + ';';
    }).
    replace(/</g, '&lt;').
    replace(/>/g, '&gt;');
}

/**
 * create an HTML/XML writer which writes to buffer
 * @param {Array} buf use buf.jain('') to get out sanitized html string
 * @returns {object} in the form of {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * }
 */
function htmlSanitizeWriter(buf, uriValidator) {
  var ignore = false;
  var out = angular.bind(buf, buf.push);
  return {
    start: function(tag, attrs, unary) {
      tag = angular.lowercase(tag);
      if (!ignore && specialElements[tag]) {
        ignore = tag;
      }
      if (!ignore && validElements[tag] === true) {
        out('<');
        out(tag);
        angular.forEach(attrs, function(value, key) {
          var lkey=angular.lowercase(key);
          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
          if (validAttrs[lkey] === true &&
            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
            out(' ');
            out(key);
            out('="');
            out(encodeEntities(value));
            out('"');
          }
        });
        out(unary ? '/>' : '>');
      }
    },
    end: function(tag) {
        tag = angular.lowercase(tag);
        if (!ignore && validElements[tag] === true) {
          out('</');
          out(tag);
          out('>');
        }
        if (tag == ignore) {
          ignore = false;
        }
      },
    chars: function(chars) {
        if (!ignore) {
          out(encodeEntities(chars));
        }
      }
  };
}


// define ngSanitize module and register $sanitize service
angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);

/* global sanitizeText: false */

/**
 * @ngdoc filter
 * @name linky
 * @kind function
 *
 * @description
 * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and
 * plain email address links.
 *
 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
 *
 * @param {string} text Input text.
 * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.
 * @returns {string} Html-linkified text.
 *
 * @usage
   <span ng-bind-html="linky_expression | linky"></span>
 *
 * @example
   <example module="linkyExample" deps="angular-sanitize.js">
     <file name="index.html">
       <script>
         angular.module('linkyExample', ['ngSanitize'])
           .controller('ExampleController', ['$scope', function($scope) {
             $scope.snippet =
               'Pretty text with some links:\n'+
               'http://angularjs.org/,\n'+
               'mailto:us@somewhere.org,\n'+
               'another@somewhere.org,\n'+
               'and one more: ftp://127.0.0.1/.';
             $scope.snippetWithTarget = 'http://angularjs.org/';
           }]);
       </script>
       <div ng-controller="ExampleController">
       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <td>Filter</td>
           <td>Source</td>
           <td>Rendered</td>
         </tr>
         <tr id="linky-filter">
           <td>linky filter</td>
           <td>
             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
           </td>
           <td>
             <div ng-bind-html="snippet | linky"></div>
           </td>
         </tr>
         <tr id="linky-target">
          <td>linky target</td>
          <td>
            <pre>&lt;div ng-bind-html="snippetWithTarget | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
          </td>
          <td>
            <div ng-bind-html="snippetWithTarget | linky:'_blank'"></div>
          </td>
         </tr>
         <tr id="escaped-html">
           <td>no filter</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
     </file>
     <file name="protractor.js" type="protractor">
       it('should linkify the snippet with urls', function() {
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
       });

       it('should not linkify snippet without the linky filter', function() {
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
       });

       it('should update', function() {
         element(by.model('snippet')).clear();
         element(by.model('snippet')).sendKeys('new http://link.');
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('new http://link.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
             .toBe('new http://link.');
       });

       it('should work with the target property', function() {
        expect(element(by.id('linky-target')).
            element(by.binding("snippetWithTarget | linky:'_blank'")).getText()).
            toBe('http://angularjs.org/');
        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
       });
     </file>
   </example>
 */
angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
  var LINKY_URL_REGEXP =
        /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
      MAILTO_REGEXP = /^mailto:/i;

  return function(text, target) {
    if (!text) return text;
    var match;
    var raw = text;
    var html = [];
    var url;
    var i;
    while ((match = raw.match(LINKY_URL_REGEXP))) {
      // We can not end in these as they are sometimes found at the end of the sentence
      url = match[0];
      // if we did not match ftp/http/www/mailto then assume mailto
      if (!match[2] && !match[4]) {
        url = (match[3] ? 'http://' : 'mailto:') + url;
      }
      i = match.index;
      addText(raw.substr(0, i));
      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
      raw = raw.substring(i + match[0].length);
    }
    addText(raw);
    return $sanitize(html.join(''));

    function addText(text) {
      if (!text) {
        return;
      }
      html.push(sanitizeText(text));
    }

    function addLink(url, text) {
      html.push('<a ');
      if (angular.isDefined(target)) {
        html.push('target="',
                  target,
                  '" ');
      }
      html.push('href="',
                url.replace(/"/g, '&quot;'),
                '">');
      addText(text);
      html.push('</a>');
    }
  };
}]);


})(window, window.angular);

},{}],38:[function(require,module,exports){
require('./angular-sanitize');
module.exports = 'ngSanitize';

},{"./angular-sanitize":37}],39:[function(require,module,exports){
/*!
 * angular-translate - v2.10.0 - 2016-02-28
 * 
 * Copyright (c) 2016 The angular-translate team, Pascal Precht; Licensed MIT
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define([], function () {
      return (factory());
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    factory();
  }
}(this, function () {

/**
 * @ngdoc overview
 * @name pascalprecht.translate
 *
 * @description
 * The main module which holds everything together.
 */
angular.module('pascalprecht.translate', ['ng'])
  .run(runTranslate);

function runTranslate($translate) {

  'use strict';

  var key = $translate.storageKey(),
    storage = $translate.storage();

  var fallbackFromIncorrectStorageValue = function () {
    var preferred = $translate.preferredLanguage();
    if (angular.isString(preferred)) {
      $translate.use(preferred);
      // $translate.use() will also remember the language.
      // So, we don't need to call storage.put() here.
    } else {
      storage.put(key, $translate.use());
    }
  };

  fallbackFromIncorrectStorageValue.displayName = 'fallbackFromIncorrectStorageValue';

  if (storage) {
    if (!storage.get(key)) {
      fallbackFromIncorrectStorageValue();
    } else {
      $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);
    }
  } else if (angular.isString($translate.preferredLanguage())) {
    $translate.use($translate.preferredLanguage());
  }
}
runTranslate.$inject = ['$translate'];

runTranslate.displayName = 'runTranslate';

/**
 * @ngdoc object
 * @name pascalprecht.translate.$translateSanitizationProvider
 *
 * @description
 *
 * Configurations for $translateSanitization
 */
angular.module('pascalprecht.translate').provider('$translateSanitization', $translateSanitizationProvider);

function $translateSanitizationProvider () {

  'use strict';

  var $sanitize,
      currentStrategy = null, // TODO change to either 'sanitize', 'escape' or ['sanitize', 'escapeParameters'] in 3.0.
      hasConfiguredStrategy = false,
      hasShownNoStrategyConfiguredWarning = false,
      strategies;

  /**
   * Definition of a sanitization strategy function
   * @callback StrategyFunction
   * @param {string|object} value - value to be sanitized (either a string or an interpolated value map)
   * @param {string} mode - either 'text' for a string (translation) or 'params' for the interpolated params
   * @return {string|object}
   */

  /**
   * @ngdoc property
   * @name strategies
   * @propertyOf pascalprecht.translate.$translateSanitizationProvider
   *
   * @description
   * Following strategies are built-in:
   * <dl>
   *   <dt>sanitize</dt>
   *   <dd>Sanitizes HTML in the translation text using $sanitize</dd>
   *   <dt>escape</dt>
   *   <dd>Escapes HTML in the translation</dd>
   *   <dt>sanitizeParameters</dt>
   *   <dd>Sanitizes HTML in the values of the interpolation parameters using $sanitize</dd>
   *   <dt>escapeParameters</dt>
   *   <dd>Escapes HTML in the values of the interpolation parameters</dd>
   *   <dt>escaped</dt>
   *   <dd>Support legacy strategy name 'escaped' for backwards compatibility (will be removed in 3.0)</dd>
   * </dl>
   *
   */

  strategies = {
    sanitize: function (value, mode) {
      if (mode === 'text') {
        value = htmlSanitizeValue(value);
      }
      return value;
    },
    escape: function (value, mode) {
      if (mode === 'text') {
        value = htmlEscapeValue(value);
      }
      return value;
    },
    sanitizeParameters: function (value, mode) {
      if (mode === 'params') {
        value = mapInterpolationParameters(value, htmlSanitizeValue);
      }
      return value;
    },
    escapeParameters: function (value, mode) {
      if (mode === 'params') {
        value = mapInterpolationParameters(value, htmlEscapeValue);
      }
      return value;
    }
  };
  // Support legacy strategy name 'escaped' for backwards compatibility.
  // TODO should be removed in 3.0
  strategies.escaped = strategies.escapeParameters;

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateSanitizationProvider#addStrategy
   * @methodOf pascalprecht.translate.$translateSanitizationProvider
   *
   * @description
   * Adds a sanitization strategy to the list of known strategies.
   *
   * @param {string} strategyName - unique key for a strategy
   * @param {StrategyFunction} strategyFunction - strategy function
   * @returns {object} this
   */
  this.addStrategy = function (strategyName, strategyFunction) {
    strategies[strategyName] = strategyFunction;
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateSanitizationProvider#removeStrategy
   * @methodOf pascalprecht.translate.$translateSanitizationProvider
   *
   * @description
   * Removes a sanitization strategy from the list of known strategies.
   *
   * @param {string} strategyName - unique key for a strategy
   * @returns {object} this
   */
  this.removeStrategy = function (strategyName) {
    delete strategies[strategyName];
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateSanitizationProvider#useStrategy
   * @methodOf pascalprecht.translate.$translateSanitizationProvider
   *
   * @description
   * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.
   *
   * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.
   * @returns {object} this
   */
  this.useStrategy = function (strategy) {
    hasConfiguredStrategy = true;
    currentStrategy = strategy;
    return this;
  };

  /**
   * @ngdoc object
   * @name pascalprecht.translate.$translateSanitization
   * @requires $injector
   * @requires $log
   *
   * @description
   * Sanitizes interpolation parameters and translated texts.
   *
   */
  this.$get = ['$injector', '$log', function ($injector, $log) {

    var cachedStrategyMap = {};

    var applyStrategies = function (value, mode, selectedStrategies) {
      angular.forEach(selectedStrategies, function (selectedStrategy) {
        if (angular.isFunction(selectedStrategy)) {
          value = selectedStrategy(value, mode);
        } else if (angular.isFunction(strategies[selectedStrategy])) {
          value = strategies[selectedStrategy](value, mode);
        } else if (angular.isString(strategies[selectedStrategy])) {
          if (!cachedStrategyMap[strategies[selectedStrategy]]) {
            try {
              cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);
            } catch (e) {
              cachedStrategyMap[strategies[selectedStrategy]] = function() {};
              throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \'' + selectedStrategy + '\'');
            }
          }
          value = cachedStrategyMap[strategies[selectedStrategy]](value, mode);
        } else {
          throw new Error('pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: \'' + selectedStrategy + '\'');
        }
      });
      return value;
    };

    // TODO: should be removed in 3.0
    var showNoStrategyConfiguredWarning = function () {
      if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {
        $log.warn('pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.');
        hasShownNoStrategyConfiguredWarning = true;
      }
    };

    if ($injector.has('$sanitize')) {
      $sanitize = $injector.get('$sanitize');
    }

    return {
      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translateSanitization#useStrategy
       * @methodOf pascalprecht.translate.$translateSanitization
       *
       * @description
       * Selects a sanitization strategy. When an array is provided the strategies will be executed in order.
       *
       * @param {string|StrategyFunction|array} strategy The sanitization strategy / strategies which should be used. Either a name of an existing strategy, a custom strategy function, or an array consisting of multiple names and / or custom functions.
       */
      useStrategy: (function (self) {
        return function (strategy) {
          self.useStrategy(strategy);
        };
      })(this),

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translateSanitization#sanitize
       * @methodOf pascalprecht.translate.$translateSanitization
       *
       * @description
       * Sanitizes a value.
       *
       * @param {string|object} value The value which should be sanitized.
       * @param {string} mode The current sanitization mode, either 'params' or 'text'.
       * @param {string|StrategyFunction|array} [strategy] Optional custom strategy which should be used instead of the currently selected strategy.
       * @returns {string|object} sanitized value
       */
      sanitize: function (value, mode, strategy) {
        if (!currentStrategy) {
          showNoStrategyConfiguredWarning();
        }

        if (arguments.length < 3) {
          strategy = currentStrategy;
        }

        if (!strategy) {
          return value;
        }

        var selectedStrategies = angular.isArray(strategy) ? strategy : [strategy];
        return applyStrategies(value, mode, selectedStrategies);
      }
    };
  }];

  var htmlEscapeValue = function (value) {
    var element = angular.element('<div></div>');
    element.text(value); // not chainable, see #1044
    return element.html();
  };

  var htmlSanitizeValue = function (value) {
    if (!$sanitize) {
      throw new Error('pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as \'escape\'.');
    }
    return $sanitize(value);
  };

  var mapInterpolationParameters = function (value, iteratee, stack) {
    if (angular.isObject(value)) {
      var result = angular.isArray(value) ? [] : {};

      if (!stack) {
        stack = [];
      } else {
        if (stack.indexOf(value) > -1) {
          throw new Error('pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object');
        }
      }

      stack.push(value);
      angular.forEach(value, function (propertyValue, propertyKey) {
        result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack);
      });
      stack.splice(-1, 1); // remove last

      return result;
    } else if (angular.isNumber(value)) {
      return value;
    } else {
      return iteratee(value);
    }
  };
}

/**
 * @ngdoc object
 * @name pascalprecht.translate.$translateProvider
 * @description
 *
 * $translateProvider allows developers to register translation-tables, asynchronous loaders
 * and similar to configure translation behavior directly inside of a module.
 *
 */
angular.module('pascalprecht.translate')
.constant('pascalprechtTranslateOverrider', {})
.provider('$translate', $translate);

function $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {

  'use strict';

  var $translationTable = {},
      $preferredLanguage,
      $availableLanguageKeys = [],
      $languageKeyAliases,
      $fallbackLanguage,
      $fallbackWasString,
      $uses,
      $nextLang,
      $storageFactory,
      $storageKey = $STORAGE_KEY,
      $storagePrefix,
      $missingTranslationHandlerFactory,
      $interpolationFactory,
      $interpolatorFactories = [],
      $loaderFactory,
      $cloakClassName = 'translate-cloak',
      $loaderOptions,
      $notFoundIndicatorLeft,
      $notFoundIndicatorRight,
      $postCompilingEnabled = false,
      $forceAsyncReloadEnabled = false,
      $nestedObjectDelimeter = '.',
      $isReady = false,
      loaderCache,
      directivePriority = 0,
      statefulFilter = true,
      uniformLanguageTagResolver = 'default',
      languageTagResolver = {
        'default': function (tag) {
          return (tag || '').split('-').join('_');
        },
        java: function (tag) {
          var temp = (tag || '').split('-').join('_');
          var parts = temp.split('_');
          return parts.length > 1 ? (parts[0].toLowerCase() + '_' + parts[1].toUpperCase()) : temp;
        },
        bcp47: function (tag) {
          var temp = (tag || '').split('_').join('-');
          var parts = temp.split('-');
          return parts.length > 1 ? (parts[0].toLowerCase() + '-' + parts[1].toUpperCase()) : temp;
        }
      };

  var version = '2.10.0';

  // tries to determine the browsers language
  var getFirstBrowserLanguage = function () {

    // internal purpose only
    if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {
      return pascalprechtTranslateOverrider.getLocale();
    }

    var nav = $windowProvider.$get().navigator,
        browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],
        i,
        language;

    // support for HTML 5.1 "navigator.languages"
    if (angular.isArray(nav.languages)) {
      for (i = 0; i < nav.languages.length; i++) {
        language = nav.languages[i];
        if (language && language.length) {
          return language;
        }
      }
    }

    // support for other well known properties in browsers
    for (i = 0; i < browserLanguagePropertyKeys.length; i++) {
      language = nav[browserLanguagePropertyKeys[i]];
      if (language && language.length) {
        return language;
      }
    }

    return null;
  };
  getFirstBrowserLanguage.displayName = 'angular-translate/service: getFirstBrowserLanguage';

  // tries to determine the browsers locale
  var getLocale = function () {
    var locale = getFirstBrowserLanguage() || '';
    if (languageTagResolver[uniformLanguageTagResolver]) {
      locale = languageTagResolver[uniformLanguageTagResolver](locale);
    }
    return locale;
  };
  getLocale.displayName = 'angular-translate/service: getLocale';

  /**
   * @name indexOf
   * @private
   *
   * @description
   * indexOf polyfill. Kinda sorta.
   *
   * @param {array} array Array to search in.
   * @param {string} searchElement Element to search for.
   *
   * @returns {int} Index of search element.
   */
  var indexOf = function(array, searchElement) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === searchElement) {
        return i;
      }
    }
    return -1;
  };

  /**
   * @name trim
   * @private
   *
   * @description
   * trim polyfill
   *
   * @returns {string} The string stripped of whitespace from both ends
   */
  var trim = function() {
    return this.toString().replace(/^\s+|\s+$/g, '');
  };

  var negotiateLocale = function (preferred) {
    if(!preferred) {
      return;
    }

    var avail = [],
        locale = angular.lowercase(preferred),
        i = 0,
        n = $availableLanguageKeys.length;

    for (; i < n; i++) {
      avail.push(angular.lowercase($availableLanguageKeys[i]));
    }

    // Check for an exact match in our list of available keys
    if (indexOf(avail, locale) > -1) {
      return preferred;
    }

    if ($languageKeyAliases) {
      var alias;
      for (var langKeyAlias in $languageKeyAliases) {
        var hasWildcardKey = false;
        var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) &&
          angular.lowercase(langKeyAlias) === angular.lowercase(preferred);

        if (langKeyAlias.slice(-1) === '*') {
          hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length-1);
        }
        if (hasExactKey || hasWildcardKey) {
          alias = $languageKeyAliases[langKeyAlias];
          if (indexOf(avail, angular.lowercase(alias)) > -1) {
            return alias;
          }
        }
      }
    }

    // Check for a language code without region
    var parts = preferred.split('_');

    if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {
      return parts[0];
    }

    // If everything fails, return undefined.
    return;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#translations
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Registers a new translation table for specific language key.
   *
   * To register a translation table for specific language, pass a defined language
   * key as first parameter.
   *
   * <pre>
   *  // register translation table for language: 'de_DE'
   *  $translateProvider.translations('de_DE', {
   *    'GREETING': 'Hallo Welt!'
   *  });
   *
   *  // register another one
   *  $translateProvider.translations('en_US', {
   *    'GREETING': 'Hello world!'
   *  });
   * </pre>
   *
   * When registering multiple translation tables for for the same language key,
   * the actual translation table gets extended. This allows you to define module
   * specific translation which only get added, once a specific module is loaded in
   * your app.
   *
   * Invoking this method with no arguments returns the translation table which was
   * registered with no language key. Invoking it with a language key returns the
   * related translation table.
   *
   * @param {string} key A language key.
   * @param {object} translationTable A plain old JavaScript object that represents a translation table.
   *
   */
  var translations = function (langKey, translationTable) {

    if (!langKey && !translationTable) {
      return $translationTable;
    }

    if (langKey && !translationTable) {
      if (angular.isString(langKey)) {
        return $translationTable[langKey];
      }
    } else {
      if (!angular.isObject($translationTable[langKey])) {
        $translationTable[langKey] = {};
      }
      angular.extend($translationTable[langKey], flatObject(translationTable));
    }
    return this;
  };

  this.translations = translations;

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#cloakClassName
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   *
   * Let's you change the class name for `translate-cloak` directive.
   * Default class name is `translate-cloak`.
   *
   * @param {string} name translate-cloak class name
   */
  this.cloakClassName = function (name) {
    if (!name) {
      return $cloakClassName;
    }
    $cloakClassName = name;
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#nestedObjectDelimeter
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   *
   * Let's you change the delimiter for namespaced translations.
   * Default delimiter is `.`.
   *
   * @param {string} delimiter namespace separator
   */
  this.nestedObjectDelimeter = function (delimiter) {
    if (!delimiter) {
      return $nestedObjectDelimeter;
    }
    $nestedObjectDelimeter = delimiter;
    return this;
  };

  /**
   * @name flatObject
   * @private
   *
   * @description
   * Flats an object. This function is used to flatten given translation data with
   * namespaces, so they are later accessible via dot notation.
   */
  var flatObject = function (data, path, result, prevKey) {
    var key, keyWithPath, keyWithShortPath, val;

    if (!path) {
      path = [];
    }
    if (!result) {
      result = {};
    }
    for (key in data) {
      if (!Object.prototype.hasOwnProperty.call(data, key)) {
        continue;
      }
      val = data[key];
      if (angular.isObject(val)) {
        flatObject(val, path.concat(key), result, key);
      } else {
        keyWithPath = path.length ? ('' + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key) : key;
        if(path.length && key === prevKey){
          // Create shortcut path (foo.bar == foo.bar.bar)
          keyWithShortPath = '' + path.join($nestedObjectDelimeter);
          // Link it to original path
          result[keyWithShortPath] = '@:' + keyWithPath;
        }
        result[keyWithPath] = val;
      }
    }
    return result;
  };
  flatObject.displayName = 'flatObject';

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#addInterpolation
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Adds interpolation services to angular-translate, so it can manage them.
   *
   * @param {object} factory Interpolation service factory
   */
  this.addInterpolation = function (factory) {
    $interpolatorFactories.push(factory);
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#useMessageFormatInterpolation
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells angular-translate to use interpolation functionality of messageformat.js.
   * This is useful when having high level pluralization and gender selection.
   */
  this.useMessageFormatInterpolation = function () {
    return this.useInterpolation('$translateMessageFormatInterpolation');
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#useInterpolation
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells angular-translate which interpolation style to use as default, application-wide.
   * Simply pass a factory/service name. The interpolation service has to implement
   * the correct interface.
   *
   * @param {string} factory Interpolation service name.
   */
  this.useInterpolation = function (factory) {
    $interpolationFactory = factory;
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#useSanitizeStrategy
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Simply sets a sanitation strategy type.
   *
   * @param {string} value Strategy type.
   */
  this.useSanitizeValueStrategy = function (value) {
    $translateSanitizationProvider.useStrategy(value);
    return this;
  };

 /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#preferredLanguage
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells the module which of the registered translation tables to use for translation
   * at initial startup by passing a language key. Similar to `$translateProvider#use`
   * only that it says which language to **prefer**.
   *
   * @param {string} langKey A language key.
   */
  this.preferredLanguage = function(langKey) {
    if (langKey) {
      setupPreferredLanguage(langKey);
      return this;
    }
    return $preferredLanguage;
  };
  var setupPreferredLanguage = function (langKey) {
    if (langKey) {
      $preferredLanguage = langKey;
    }
    return $preferredLanguage;
  };
  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicator
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Sets an indicator which is used when a translation isn't found. E.g. when
   * setting the indicator as 'X' and one tries to translate a translation id
   * called `NOT_FOUND`, this will result in `X NOT_FOUND X`.
   *
   * Internally this methods sets a left indicator and a right indicator using
   * `$translateProvider.translationNotFoundIndicatorLeft()` and
   * `$translateProvider.translationNotFoundIndicatorRight()`.
   *
   * **Note**: These methods automatically add a whitespace between the indicators
   * and the translation id.
   *
   * @param {string} indicator An indicator, could be any string.
   */
  this.translationNotFoundIndicator = function (indicator) {
    this.translationNotFoundIndicatorLeft(indicator);
    this.translationNotFoundIndicatorRight(indicator);
    return this;
  };

  /**
   * ngdoc function
   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Sets an indicator which is used when a translation isn't found left to the
   * translation id.
   *
   * @param {string} indicator An indicator.
   */
  this.translationNotFoundIndicatorLeft = function (indicator) {
    if (!indicator) {
      return $notFoundIndicatorLeft;
    }
    $notFoundIndicatorLeft = indicator;
    return this;
  };

  /**
   * ngdoc function
   * @name pascalprecht.translate.$translateProvider#translationNotFoundIndicatorLeft
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Sets an indicator which is used when a translation isn't found right to the
   * translation id.
   *
   * @param {string} indicator An indicator.
   */
  this.translationNotFoundIndicatorRight = function (indicator) {
    if (!indicator) {
      return $notFoundIndicatorRight;
    }
    $notFoundIndicatorRight = indicator;
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#fallbackLanguage
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells the module which of the registered translation tables to use when missing translations
   * at initial startup by passing a language key. Similar to `$translateProvider#use`
   * only that it says which language to **fallback**.
   *
   * @param {string||array} langKey A language key.
   *
   */
  this.fallbackLanguage = function (langKey) {
    fallbackStack(langKey);
    return this;
  };

  var fallbackStack = function (langKey) {
    if (langKey) {
      if (angular.isString(langKey)) {
        $fallbackWasString = true;
        $fallbackLanguage = [ langKey ];
      } else if (angular.isArray(langKey)) {
        $fallbackWasString = false;
        $fallbackLanguage = langKey;
      }
      if (angular.isString($preferredLanguage)  && indexOf($fallbackLanguage, $preferredLanguage) < 0) {
        $fallbackLanguage.push($preferredLanguage);
      }

      return this;
    } else {
      if ($fallbackWasString) {
        return $fallbackLanguage[0];
      } else {
        return $fallbackLanguage;
      }
    }
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#use
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Set which translation table to use for translation by given language key. When
   * trying to 'use' a language which isn't provided, it'll throw an error.
   *
   * You actually don't have to use this method since `$translateProvider#preferredLanguage`
   * does the job too.
   *
   * @param {string} langKey A language key.
   */
  this.use = function (langKey) {
    if (langKey) {
      if (!$translationTable[langKey] && (!$loaderFactory)) {
        // only throw an error, when not loading translation data asynchronously
        throw new Error('$translateProvider couldn\'t find translationTable for langKey: \'' + langKey + '\'');
      }
      $uses = langKey;
      return this;
    }
    return $uses;
  };

 /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#storageKey
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells the module which key must represent the choosed language by a user in the storage.
   *
   * @param {string} key A key for the storage.
   */
  var storageKey = function(key) {
    if (!key) {
      if ($storagePrefix) {
        return $storagePrefix + $storageKey;
      }
      return $storageKey;
    }
    $storageKey = key;
    return this;
  };

  this.storageKey = storageKey;

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#useUrlLoader
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells angular-translate to use `$translateUrlLoader` extension service as loader.
   *
   * @param {string} url Url
   * @param {Object=} options Optional configuration object
   */
  this.useUrlLoader = function (url, options) {
    return this.useLoader('$translateUrlLoader', angular.extend({ url: url }, options));
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#useStaticFilesLoader
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells angular-translate to use `$translateStaticFilesLoader` extension service as loader.
   *
   * @param {Object=} options Optional configuration object
   */
  this.useStaticFilesLoader = function (options) {
    return this.useLoader('$translateStaticFilesLoader', options);
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#useLoader
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells angular-translate to use any other service as loader.
   *
   * @param {string} loaderFactory Factory name to use
   * @param {Object=} options Optional configuration object
   */
  this.useLoader = function (loaderFactory, options) {
    $loaderFactory = loaderFactory;
    $loaderOptions = options || {};
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#useLocalStorage
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells angular-translate to use `$translateLocalStorage` service as storage layer.
   *
   */
  this.useLocalStorage = function () {
    return this.useStorage('$translateLocalStorage');
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#useCookieStorage
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells angular-translate to use `$translateCookieStorage` service as storage layer.
   */
  this.useCookieStorage = function () {
    return this.useStorage('$translateCookieStorage');
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#useStorage
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells angular-translate to use custom service as storage layer.
   */
  this.useStorage = function (storageFactory) {
    $storageFactory = storageFactory;
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#storagePrefix
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Sets prefix for storage key.
   *
   * @param {string} prefix Storage key prefix
   */
  this.storagePrefix = function (prefix) {
    if (!prefix) {
      return prefix;
    }
    $storagePrefix = prefix;
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandlerLog
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells angular-translate to use built-in log handler when trying to translate
   * a translation Id which doesn't exist.
   *
   * This is actually a shortcut method for `useMissingTranslationHandler()`.
   *
   */
  this.useMissingTranslationHandlerLog = function () {
    return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#useMissingTranslationHandler
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Expects a factory name which later gets instantiated with `$injector`.
   * This method can be used to tell angular-translate to use a custom
   * missingTranslationHandler. Just build a factory which returns a function
   * and expects a translation id as argument.
   *
   * Example:
   * <pre>
   *  app.config(function ($translateProvider) {
   *    $translateProvider.useMissingTranslationHandler('customHandler');
   *  });
   *
   *  app.factory('customHandler', function (dep1, dep2) {
   *    return function (translationId) {
   *      // something with translationId and dep1 and dep2
   *    };
   *  });
   * </pre>
   *
   * @param {string} factory Factory name
   */
  this.useMissingTranslationHandler = function (factory) {
    $missingTranslationHandlerFactory = factory;
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#usePostCompiling
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * If post compiling is enabled, all translated values will be processed
   * again with AngularJS' $compile.
   *
   * Example:
   * <pre>
   *  app.config(function ($translateProvider) {
   *    $translateProvider.usePostCompiling(true);
   *  });
   * </pre>
   *
   * @param {string} factory Factory name
   */
  this.usePostCompiling = function (value) {
    $postCompilingEnabled = !(!value);
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#forceAsyncReload
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * If force async reload is enabled, async loader will always be called
   * even if $translationTable already contains the language key, adding
   * possible new entries to the $translationTable.
   *
   * Example:
   * <pre>
   *  app.config(function ($translateProvider) {
   *    $translateProvider.forceAsyncReload(true);
   *  });
   * </pre>
   *
   * @param {boolean} value - valid values are true or false
   */
  this.forceAsyncReload = function (value) {
    $forceAsyncReloadEnabled = !(!value);
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#uniformLanguageTag
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells angular-translate which language tag should be used as a result when determining
   * the current browser language.
   *
   * This setting must be set before invoking {@link pascalprecht.translate.$translateProvider#methods_determinePreferredLanguage determinePreferredLanguage()}.
   *
   * <pre>
   * $translateProvider
   *   .uniformLanguageTag('bcp47')
   *   .determinePreferredLanguage()
   * </pre>
   *
   * The resolver currently supports:
   * * default
   *     (traditionally: hyphens will be converted into underscores, i.e. en-US => en_US)
   *     en-US => en_US
   *     en_US => en_US
   *     en-us => en_us
   * * java
   *     like default, but the second part will be always in uppercase
   *     en-US => en_US
   *     en_US => en_US
   *     en-us => en_US
   * * BCP 47 (RFC 4646 & 4647)
   *     en-US => en-US
   *     en_US => en-US
   *     en-us => en-US
   *
   * See also:
   * * http://en.wikipedia.org/wiki/IETF_language_tag
   * * http://www.w3.org/International/core/langtags/
   * * http://tools.ietf.org/html/bcp47
   *
   * @param {string|object} options - options (or standard)
   * @param {string} options.standard - valid values are 'default', 'bcp47', 'java'
   */
  this.uniformLanguageTag = function (options) {

    if (!options) {
      options = {};
    } else if (angular.isString(options)) {
      options = {
        standard: options
      };
    }

    uniformLanguageTagResolver = options.standard;

    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#determinePreferredLanguage
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Tells angular-translate to try to determine on its own which language key
   * to set as preferred language. When `fn` is given, angular-translate uses it
   * to determine a language key, otherwise it uses the built-in `getLocale()`
   * method.
   *
   * The `getLocale()` returns a language key in the format `[lang]_[country]` or
   * `[lang]` depending on what the browser provides.
   *
   * Use this method at your own risk, since not all browsers return a valid
   * locale (see {@link pascalprecht.translate.$translateProvider#methods_uniformLanguageTag uniformLanguageTag()}).
   *
   * @param {Function=} fn Function to determine a browser's locale
   */
  this.determinePreferredLanguage = function (fn) {

    var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();

    if (!$availableLanguageKeys.length) {
      $preferredLanguage = locale;
    } else {
      $preferredLanguage = negotiateLocale(locale) || locale;
    }

    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#registerAvailableLanguageKeys
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Registers a set of language keys the app will work with. Use this method in
   * combination with
   * {@link pascalprecht.translate.$translateProvider#determinePreferredLanguage determinePreferredLanguage}.
   * When available languages keys are registered, angular-translate
   * tries to find the best fitting language key depending on the browsers locale,
   * considering your language key convention.
   *
   * @param {object} languageKeys Array of language keys the your app will use
   * @param {object=} aliases Alias map.
   */
  this.registerAvailableLanguageKeys = function (languageKeys, aliases) {
    if (languageKeys) {
      $availableLanguageKeys = languageKeys;
      if (aliases) {
        $languageKeyAliases = aliases;
      }
      return this;
    }
    return $availableLanguageKeys;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#useLoaderCache
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Registers a cache for internal $http based loaders.
   * {@link pascalprecht.translate.$translationCache $translationCache}.
   * When false the cache will be disabled (default). When true or undefined
   * the cache will be a default (see $cacheFactory). When an object it will
   * be treat as a cache object itself: the usage is $http({cache: cache})
   *
   * @param {object} cache boolean, string or cache-object
   */
  this.useLoaderCache = function (cache) {
    if (cache === false) {
      // disable cache
      loaderCache = undefined;
    } else if (cache === true) {
      // enable cache using AJS defaults
      loaderCache = true;
    } else if (typeof(cache) === 'undefined') {
      // enable cache using default
      loaderCache = '$translationCache';
    } else if (cache) {
      // enable cache using given one (see $cacheFactory)
      loaderCache = cache;
    }
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#directivePriority
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Sets the default priority of the translate directive. The standard value is `0`.
   * Calling this function without an argument will return the current value.
   *
   * @param {number} priority for the translate-directive
   */
  this.directivePriority = function (priority) {
    if (priority === undefined) {
      // getter
      return directivePriority;
    } else {
      // setter with chaining
      directivePriority = priority;
      return this;
    }
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateProvider#statefulFilter
   * @methodOf pascalprecht.translate.$translateProvider
   *
   * @description
   * Since AngularJS 1.3, filters which are not stateless (depending at the scope)
   * have to explicit define this behavior.
   * Sets whether the translate filter should be stateful or stateless. The standard value is `true`
   * meaning being stateful.
   * Calling this function without an argument will return the current value.
   *
   * @param {boolean} state - defines the state of the filter
   */
  this.statefulFilter = function (state) {
    if (state === undefined) {
      // getter
      return statefulFilter;
    } else {
      // setter with chaining
      statefulFilter = state;
      return this;
    }
  };

  /**
   * @ngdoc object
   * @name pascalprecht.translate.$translate
   * @requires $interpolate
   * @requires $log
   * @requires $rootScope
   * @requires $q
   *
   * @description
   * The `$translate` service is the actual core of angular-translate. It expects a translation id
   * and optional interpolate parameters to translate contents.
   *
   * <pre>
   *  $translate('HEADLINE_TEXT').then(function (translation) {
   *    $scope.translatedText = translation;
   *  });
   * </pre>
   *
   * @param {string|array} translationId A token which represents a translation id
   *                                     This can be optionally an array of translation ids which
   *                                     results that the function returns an object where each key
   *                                     is the translation id and the value the translation.
   * @param {object=} interpolateParams An object hash for dynamic values
   * @param {string} interpolationId The id of the interpolation to use
   * @param {string} forceLanguage A language to be used instead of the current language
   * @returns {object} promise
   */
  this.$get = [
    '$log',
    '$injector',
    '$rootScope',
    '$q',
    function ($log, $injector, $rootScope, $q) {

      var Storage,
          defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),
          pendingLoader = false,
          interpolatorHashMap = {},
          langPromises = {},
          fallbackIndex,
          startFallbackIteration;

      var $translate = function (translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage) {

        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses
              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;

        // Duck detection: If the first argument is an array, a bunch of translations was requested.
        // The result is an object.
        if (angular.isArray(translationId)) {
          // Inspired by Q.allSettled by Kris Kowal
          // https://github.com/kriskowal/q/blob/b0fa72980717dc202ffc3cbf03b936e10ebbb9d7/q.js#L1553-1563
          // This transforms all promises regardless resolved or rejected
          var translateAll = function (translationIds) {
            var results = {}; // storing the actual results
            var promises = []; // promises to wait for
            // Wraps the promise a) being always resolved and b) storing the link id->value
            var translate = function (translationId) {
              var deferred = $q.defer();
              var regardless = function (value) {
                results[translationId] = value;
                deferred.resolve([translationId, value]);
              };
              // we don't care whether the promise was resolved or rejected; just store the values
              $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage).then(regardless, regardless);
              return deferred.promise;
            };
            for (var i = 0, c = translationIds.length; i < c; i++) {
              promises.push(translate(translationIds[i]));
            }
            // wait for all (including storing to results)
            return $q.all(promises).then(function () {
              // return the results
              return results;
            });
          };
          return translateAll(translationId);
        }

        var deferred = $q.defer();

        // trim off any whitespace
        if (translationId) {
          translationId = trim.apply(translationId);
        }

        var promiseToWaitFor = (function () {
          var promise = $preferredLanguage ?
            langPromises[$preferredLanguage] :
            langPromises[uses];

          fallbackIndex = 0;

          if ($storageFactory && !promise) {
            // looks like there's no pending promise for $preferredLanguage or
            // $uses. Maybe there's one pending for a language that comes from
            // storage.
            var langKey = Storage.get($storageKey);
            promise = langPromises[langKey];

            if ($fallbackLanguage && $fallbackLanguage.length) {
                var index = indexOf($fallbackLanguage, langKey);
                // maybe the language from storage is also defined as fallback language
                // we increase the fallback language index to not search in that language
                // as fallback, since it's probably the first used language
                // in that case the index starts after the first element
                fallbackIndex = (index === 0) ? 1 : 0;

                // but we can make sure to ALWAYS fallback to preferred language at least
                if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {
                  $fallbackLanguage.push($preferredLanguage);
                }
            }
          }
          return promise;
        }());

        if (!promiseToWaitFor) {
          // no promise to wait for? okay. Then there's no loader registered
          // nor is a one pending for language that comes from storage.
          // We can just translate.
          determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);
        } else {
          var promiseResolved = function () {
            // $uses may have changed while waiting
            if (!forceLanguage) {
              uses = $uses;
            }
            determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses).then(deferred.resolve, deferred.reject);
          };
          promiseResolved.displayName = 'promiseResolved';

          promiseToWaitFor['finally'](promiseResolved);
        }
        return deferred.promise;
      };

      /**
       * @name applyNotFoundIndicators
       * @private
       *
       * @description
       * Applies not fount indicators to given translation id, if needed.
       * This function gets only executed, if a translation id doesn't exist,
       * which is why a translation id is expected as argument.
       *
       * @param {string} translationId Translation id.
       * @returns {string} Same as given translation id but applied with not found
       * indicators.
       */
      var applyNotFoundIndicators = function (translationId) {
        // applying notFoundIndicators
        if ($notFoundIndicatorLeft) {
          translationId = [$notFoundIndicatorLeft, translationId].join(' ');
        }
        if ($notFoundIndicatorRight) {
          translationId = [translationId, $notFoundIndicatorRight].join(' ');
        }
        return translationId;
      };

      /**
       * @name useLanguage
       * @private
       *
       * @description
       * Makes actual use of a language by setting a given language key as used
       * language and informs registered interpolators to also use the given
       * key as locale.
       *
       * @param {key} Locale key.
       */
      var useLanguage = function (key) {
        $uses = key;

        // make sure to store new language key before triggering success event
        if ($storageFactory) {
          Storage.put($translate.storageKey(), $uses);
        }

        $rootScope.$emit('$translateChangeSuccess', {language: key});

        // inform default interpolator
        defaultInterpolator.setLocale($uses);

        var eachInterpolator = function (interpolator, id) {
          interpolatorHashMap[id].setLocale($uses);
        };
        eachInterpolator.displayName = 'eachInterpolatorLocaleSetter';

        // inform all others too!
        angular.forEach(interpolatorHashMap, eachInterpolator);
        $rootScope.$emit('$translateChangeEnd', {language: key});
      };

      /**
       * @name loadAsync
       * @private
       *
       * @description
       * Kicks of registered async loader using `$injector` and applies existing
       * loader options. When resolved, it updates translation tables accordingly
       * or rejects with given language key.
       *
       * @param {string} key Language key.
       * @return {Promise} A promise.
       */
      var loadAsync = function (key) {
        if (!key) {
          throw 'No language key specified for loading.';
        }

        var deferred = $q.defer();

        $rootScope.$emit('$translateLoadingStart', {language: key});
        pendingLoader = true;

        var cache = loaderCache;
        if (typeof(cache) === 'string') {
          // getting on-demand instance of loader
          cache = $injector.get(cache);
        }

        var loaderOptions = angular.extend({}, $loaderOptions, {
          key: key,
          $http: angular.extend({}, {
            cache: cache
          }, $loaderOptions.$http)
        });

        var onLoaderSuccess = function (data) {
          var translationTable = {};
          $rootScope.$emit('$translateLoadingSuccess', {language: key});

          if (angular.isArray(data)) {
            angular.forEach(data, function (table) {
              angular.extend(translationTable, flatObject(table));
            });
          } else {
            angular.extend(translationTable, flatObject(data));
          }
          pendingLoader = false;
          deferred.resolve({
            key: key,
            table: translationTable
          });
          $rootScope.$emit('$translateLoadingEnd', {language: key});
        };
        onLoaderSuccess.displayName = 'onLoaderSuccess';

        var onLoaderError = function (key) {
          $rootScope.$emit('$translateLoadingError', {language: key});
          deferred.reject(key);
          $rootScope.$emit('$translateLoadingEnd', {language: key});
        };
        onLoaderError.displayName = 'onLoaderError';

        $injector.get($loaderFactory)(loaderOptions)
          .then(onLoaderSuccess, onLoaderError);

        return deferred.promise;
      };

      if ($storageFactory) {
        Storage = $injector.get($storageFactory);

        if (!Storage.get || !Storage.put) {
          throw new Error('Couldn\'t use storage \'' + $storageFactory + '\', missing get() or put() method!');
        }
      }

      // if we have additional interpolations that were added via
      // $translateProvider.addInterpolation(), we have to map'em
      if ($interpolatorFactories.length) {
        var eachInterpolationFactory = function (interpolatorFactory) {
          var interpolator = $injector.get(interpolatorFactory);
          // setting initial locale for each interpolation service
          interpolator.setLocale($preferredLanguage || $uses);
          // make'em recognizable through id
          interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;
        };
        eachInterpolationFactory.displayName = 'interpolationFactoryAdder';

        angular.forEach($interpolatorFactories, eachInterpolationFactory);
      }

      /**
       * @name getTranslationTable
       * @private
       *
       * @description
       * Returns a promise that resolves to the translation table
       * or is rejected if an error occurred.
       *
       * @param langKey
       * @returns {Q.promise}
       */
      var getTranslationTable = function (langKey) {
        var deferred = $q.defer();
        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {
          deferred.resolve($translationTable[langKey]);
        } else if (langPromises[langKey]) {
          var onResolve = function (data) {
            translations(data.key, data.table);
            deferred.resolve(data.table);
          };
          onResolve.displayName = 'translationTableResolver';
          langPromises[langKey].then(onResolve, deferred.reject);
        } else {
          deferred.reject();
        }
        return deferred.promise;
      };

      /**
       * @name getFallbackTranslation
       * @private
       *
       * @description
       * Returns a promise that will resolve to the translation
       * or be rejected if no translation was found for the language.
       * This function is currently only used for fallback language translation.
       *
       * @param langKey The language to translate to.
       * @param translationId
       * @param interpolateParams
       * @param Interpolator
       * @returns {Q.promise}
       */
      var getFallbackTranslation = function (langKey, translationId, interpolateParams, Interpolator) {
        var deferred = $q.defer();

        var onResolve = function (translationTable) {
          if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {
            Interpolator.setLocale(langKey);
            var translation = translationTable[translationId];
            if (translation.substr(0, 2) === '@:') {
              getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator)
                .then(deferred.resolve, deferred.reject);
            } else {
              deferred.resolve(Interpolator.interpolate(translationTable[translationId], interpolateParams));
            }
            Interpolator.setLocale($uses);
          } else {
            deferred.reject();
          }
        };
        onResolve.displayName = 'fallbackTranslationResolver';

        getTranslationTable(langKey).then(onResolve, deferred.reject);

        return deferred.promise;
      };

      /**
       * @name getFallbackTranslationInstant
       * @private
       *
       * @description
       * Returns a translation
       * This function is currently only used for fallback language translation.
       *
       * @param langKey The language to translate to.
       * @param translationId
       * @param interpolateParams
       * @param Interpolator
       * @returns {string} translation
       */
      var getFallbackTranslationInstant = function (langKey, translationId, interpolateParams, Interpolator) {
        var result, translationTable = $translationTable[langKey];

        if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {
          Interpolator.setLocale(langKey);
          result = Interpolator.interpolate(translationTable[translationId], interpolateParams);
          if (result.substr(0, 2) === '@:') {
            return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);
          }
          Interpolator.setLocale($uses);
        }

        return result;
      };


      /**
       * @name translateByHandler
       * @private
       *
       * Translate by missing translation handler.
       *
       * @param translationId
       * @returns translation created by $missingTranslationHandler or translationId is $missingTranslationHandler is
       * absent
       */
      var translateByHandler = function (translationId, interpolateParams) {
        // If we have a handler factory - we might also call it here to determine if it provides
        // a default text for a translationid that can't be found anywhere in our tables
        if ($missingTranslationHandlerFactory) {
          var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams);
          if (resultString !== undefined) {
            return resultString;
          } else {
            return translationId;
          }
        } else {
          return translationId;
        }
      };

      /**
       * @name resolveForFallbackLanguage
       * @private
       *
       * Recursive helper function for fallbackTranslation that will sequentially look
       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.
       *
       * @param fallbackLanguageIndex
       * @param translationId
       * @param interpolateParams
       * @param Interpolator
       * @returns {Q.promise} Promise that will resolve to the translation.
       */
      var resolveForFallbackLanguage = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {
        var deferred = $q.defer();

        if (fallbackLanguageIndex < $fallbackLanguage.length) {
          var langKey = $fallbackLanguage[fallbackLanguageIndex];
          getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(
            deferred.resolve,
            function () {
              // Look in the next fallback language for a translation.
              // It delays the resolving by passing another promise to resolve.
              resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve);
            }
          );
        } else {
          // No translation found in any fallback language
          // if a default translation text is set in the directive, then return this as a result
          if (defaultTranslationText) {
            deferred.resolve(defaultTranslationText);
          } else {
            // if no default translation is set and an error handler is defined, send it to the handler
            // and then return the result
            deferred.resolve(translateByHandler(translationId, interpolateParams));
          }
        }
        return deferred.promise;
      };

      /**
       * @name resolveForFallbackLanguageInstant
       * @private
       *
       * Recursive helper function for fallbackTranslation that will sequentially look
       * for a translation in the fallbackLanguages starting with fallbackLanguageIndex.
       *
       * @param fallbackLanguageIndex
       * @param translationId
       * @param interpolateParams
       * @param Interpolator
       * @returns {string} translation
       */
      var resolveForFallbackLanguageInstant = function (fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {
        var result;

        if (fallbackLanguageIndex < $fallbackLanguage.length) {
          var langKey = $fallbackLanguage[fallbackLanguageIndex];
          result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);
          if (!result) {
            result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);
          }
        }
        return result;
      };

      /**
       * Translates with the usage of the fallback languages.
       *
       * @param translationId
       * @param interpolateParams
       * @param Interpolator
       * @returns {Q.promise} Promise, that resolves to the translation.
       */
      var fallbackTranslation = function (translationId, interpolateParams, Interpolator, defaultTranslationText) {
        // Start with the fallbackLanguage with index 0
        return resolveForFallbackLanguage((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText);
      };

      /**
       * Translates with the usage of the fallback languages.
       *
       * @param translationId
       * @param interpolateParams
       * @param Interpolator
       * @returns {String} translation
       */
      var fallbackTranslationInstant = function (translationId, interpolateParams, Interpolator) {
        // Start with the fallbackLanguage with index 0
        return resolveForFallbackLanguageInstant((startFallbackIteration>0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator);
      };

      var determineTranslation = function (translationId, interpolateParams, interpolationId, defaultTranslationText, uses) {

        var deferred = $q.defer();

        var table = uses ? $translationTable[uses] : $translationTable,
            Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;

        // if the translation id exists, we can just interpolate it
        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {
          var translation = table[translationId];

          // If using link, rerun $translate with linked translationId and return it
          if (translation.substr(0, 2) === '@:') {

            $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses)
              .then(deferred.resolve, deferred.reject);
          } else {
            deferred.resolve(Interpolator.interpolate(translation, interpolateParams));
          }
        } else {
          var missingTranslationHandlerTranslation;
          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise
          if ($missingTranslationHandlerFactory && !pendingLoader) {
            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);
          }

          // since we couldn't translate the inital requested translation id,
          // we try it now with one or more fallback languages, if fallback language(s) is
          // configured.
          if (uses && $fallbackLanguage && $fallbackLanguage.length) {
            fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText)
                .then(function (translation) {
                  deferred.resolve(translation);
                }, function (_translationId) {
                  deferred.reject(applyNotFoundIndicators(_translationId));
                });
          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
            // looks like the requested translation id doesn't exists.
            // Now, if there is a registered handler for missing translations and no
            // asyncLoader is pending, we execute the handler
            if (defaultTranslationText) {
              deferred.resolve(defaultTranslationText);
              } else {
                deferred.resolve(missingTranslationHandlerTranslation);
              }
          } else {
            if (defaultTranslationText) {
              deferred.resolve(defaultTranslationText);
            } else {
              deferred.reject(applyNotFoundIndicators(translationId));
            }
          }
        }
        return deferred.promise;
      };

      var determineTranslationInstant = function (translationId, interpolateParams, interpolationId, uses) {

        var result, table = uses ? $translationTable[uses] : $translationTable,
            Interpolator = defaultInterpolator;

        // if the interpolation id exists use custom interpolator
        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {
          Interpolator = interpolatorHashMap[interpolationId];
        }

        // if the translation id exists, we can just interpolate it
        if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {
          var translation = table[translationId];

          // If using link, rerun $translate with linked translationId and return it
          if (translation.substr(0, 2) === '@:') {
            result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses);
          } else {
            result = Interpolator.interpolate(translation, interpolateParams);
          }
        } else {
          var missingTranslationHandlerTranslation;
          // for logging purposes only (as in $translateMissingTranslationHandlerLog), value is not returned to promise
          if ($missingTranslationHandlerFactory && !pendingLoader) {
            missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams);
          }

          // since we couldn't translate the inital requested translation id,
          // we try it now with one or more fallback languages, if fallback language(s) is
          // configured.
          if (uses && $fallbackLanguage && $fallbackLanguage.length) {
            fallbackIndex = 0;
            result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);
          } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
            // looks like the requested translation id doesn't exists.
            // Now, if there is a registered handler for missing translations and no
            // asyncLoader is pending, we execute the handler
            result = missingTranslationHandlerTranslation;
          } else {
            result = applyNotFoundIndicators(translationId);
          }
        }

        return result;
      };

      var clearNextLangAndPromise = function(key) {
        if ($nextLang === key) {
          $nextLang = undefined;
        }
        langPromises[key] = undefined;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#preferredLanguage
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns the language key for the preferred language.
       *
       * @param {string} langKey language String or Array to be used as preferredLanguage (changing at runtime)
       *
       * @return {string} preferred language key
       */
      $translate.preferredLanguage = function (langKey) {
        if(langKey) {
          setupPreferredLanguage(langKey);
        }
        return $preferredLanguage;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#cloakClassName
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns the configured class name for `translate-cloak` directive.
       *
       * @return {string} cloakClassName
       */
      $translate.cloakClassName = function () {
        return $cloakClassName;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#nestedObjectDelimeter
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns the configured delimiter for nested namespaces.
       *
       * @return {string} nestedObjectDelimeter
       */
      $translate.nestedObjectDelimeter = function () {
        return $nestedObjectDelimeter;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#fallbackLanguage
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns the language key for the fallback languages or sets a new fallback stack.
       *
       * @param {string=} langKey language String or Array of fallback languages to be used (to change stack at runtime)
       *
       * @return {string||array} fallback language key
       */
      $translate.fallbackLanguage = function (langKey) {
        if (langKey !== undefined && langKey !== null) {
          fallbackStack(langKey);

          // as we might have an async loader initiated and a new translation language might have been defined
          // we need to add the promise to the stack also. So - iterate.
          if ($loaderFactory) {
            if ($fallbackLanguage && $fallbackLanguage.length) {
              for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                if (!langPromises[$fallbackLanguage[i]]) {
                  langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);
                }
              }
            }
          }
          $translate.use($translate.use());
        }
        if ($fallbackWasString) {
          return $fallbackLanguage[0];
        } else {
          return $fallbackLanguage;
        }

      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#useFallbackLanguage
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Sets the first key of the fallback language stack to be used for translation.
       * Therefore all languages in the fallback array BEFORE this key will be skipped!
       *
       * @param {string=} langKey Contains the langKey the iteration shall start with. Set to false if you want to
       * get back to the whole stack
       */
      $translate.useFallbackLanguage = function (langKey) {
        if (langKey !== undefined && langKey !== null) {
          if (!langKey) {
            startFallbackIteration = 0;
          } else {
            var langKeyPosition = indexOf($fallbackLanguage, langKey);
            if (langKeyPosition > -1) {
              startFallbackIteration = langKeyPosition;
            }
          }

        }

      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#proposedLanguage
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns the language key of language that is currently loaded asynchronously.
       *
       * @return {string} language key
       */
      $translate.proposedLanguage = function () {
        return $nextLang;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#storage
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns registered storage.
       *
       * @return {object} Storage
       */
      $translate.storage = function () {
        return Storage;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#negotiateLocale
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns a language key based on available languages and language aliases. If a
       * language key cannot be resolved, returns undefined.
       *
       * If no or a falsy key is given, returns undefined.
       *
       * @param {string} [key] Language key
       * @return {string|undefined} Language key or undefined if no language key is found.
       */
      $translate.negotiateLocale = negotiateLocale;

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#use
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Tells angular-translate which language to use by given language key. This method is
       * used to change language at runtime. It also takes care of storing the language
       * key in a configured store to let your app remember the choosed language.
       *
       * When trying to 'use' a language which isn't available it tries to load it
       * asynchronously with registered loaders.
       *
       * Returns promise object with loaded language file data or string of the currently used language.
       *
       * If no or a falsy key is given it returns the currently used language key.
       * The returned string will be ```undefined``` if setting up $translate hasn't finished.
       * @example
       * $translate.use("en_US").then(function(data){
       *   $scope.text = $translate("HELLO");
       * });
       *
       * @param {string} [key] Language key
       * @return {object|string} Promise with loaded language data or the language key if a falsy param was given.
       */
      $translate.use = function (key) {
        if (!key) {
          return $uses;
        }

        var deferred = $q.defer();

        $rootScope.$emit('$translateChangeStart', {language: key});

        // Try to get the aliased language key
        var aliasedKey = negotiateLocale(key);
        if (aliasedKey) {
          key = aliasedKey;
        }

        // if there isn't a translation table for the language we've requested,
        // we load it asynchronously
        $nextLang = key;
        if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {
          langPromises[key] = loadAsync(key).then(function (translation) {
            translations(translation.key, translation.table);
            deferred.resolve(translation.key);
            if ($nextLang === key) {
              useLanguage(translation.key);
            }
            return translation;
          }, function (key) {
            $rootScope.$emit('$translateChangeError', {language: key});
            deferred.reject(key);
            $rootScope.$emit('$translateChangeEnd', {language: key});
            return $q.reject(key);
          });
          langPromises[key]['finally'](function () {
            clearNextLangAndPromise(key);
          });
        } else if (langPromises[key]) {
          // we are already loading this asynchronously
          // resolve our new deferred when the old langPromise is resolved
          langPromises[key].then(function (translation) {
            if ($nextLang === translation.key) {
              useLanguage(translation.key);
            }
            deferred.resolve(translation.key);
            return translation;
          }, function (key) {
            // find first available fallback language if that request has failed
            if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0) {
              return $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);
            } else {
              return deferred.reject(key);
            }
          });
        } else {
          deferred.resolve(key);
          useLanguage(key);
        }

        return deferred.promise;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#storageKey
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns the key for the storage.
       *
       * @return {string} storage key
       */
      $translate.storageKey = function () {
        return storageKey();
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#isPostCompilingEnabled
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns whether post compiling is enabled or not
       *
       * @return {bool} storage key
       */
      $translate.isPostCompilingEnabled = function () {
        return $postCompilingEnabled;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#isForceAsyncReloadEnabled
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns whether force async reload is enabled or not
       *
       * @return {boolean} forceAsyncReload value
       */
      $translate.isForceAsyncReloadEnabled = function () {
        return $forceAsyncReloadEnabled;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#refresh
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Refreshes a translation table pointed by the given langKey. If langKey is not specified,
       * the module will drop all existent translation tables and load new version of those which
       * are currently in use.
       *
       * Refresh means that the module will drop target translation table and try to load it again.
       *
       * In case there are no loaders registered the refresh() method will throw an Error.
       *
       * If the module is able to refresh translation tables refresh() method will broadcast
       * $translateRefreshStart and $translateRefreshEnd events.
       *
       * @example
       * // this will drop all currently existent translation tables and reload those which are
       * // currently in use
       * $translate.refresh();
       * // this will refresh a translation table for the en_US language
       * $translate.refresh('en_US');
       *
       * @param {string} langKey A language key of the table, which has to be refreshed
       *
       * @return {promise} Promise, which will be resolved in case a translation tables refreshing
       * process is finished successfully, and reject if not.
       */
      $translate.refresh = function (langKey) {
        if (!$loaderFactory) {
          throw new Error('Couldn\'t refresh translation table, no loader registered!');
        }

        var deferred = $q.defer();

        function resolve() {
          deferred.resolve();
          $rootScope.$emit('$translateRefreshEnd', {language: langKey});
        }

        function reject() {
          deferred.reject();
          $rootScope.$emit('$translateRefreshEnd', {language: langKey});
        }

        $rootScope.$emit('$translateRefreshStart', {language: langKey});

        if (!langKey) {
          // if there's no language key specified we refresh ALL THE THINGS!
          var tables = [], loadingKeys = {};

          // reload registered fallback languages
          if ($fallbackLanguage && $fallbackLanguage.length) {
            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
              tables.push(loadAsync($fallbackLanguage[i]));
              loadingKeys[$fallbackLanguage[i]] = true;
            }
          }

          // reload currently used language
          if ($uses && !loadingKeys[$uses]) {
            tables.push(loadAsync($uses));
          }

          var allTranslationsLoaded = function (tableData) {
            $translationTable = {};
            angular.forEach(tableData, function (data) {
              translations(data.key, data.table);
            });
            if ($uses) {
              useLanguage($uses);
            }
            resolve();
          };
          allTranslationsLoaded.displayName = 'refreshPostProcessor';

          $q.all(tables).then(allTranslationsLoaded, reject);

        } else if ($translationTable[langKey]) {

          var oneTranslationsLoaded = function (data) {
            translations(data.key, data.table);
            if (langKey === $uses) {
              useLanguage($uses);
            }
            resolve();
          };
          oneTranslationsLoaded.displayName = 'refreshPostProcessor';

          loadAsync(langKey).then(oneTranslationsLoaded, reject);

        } else {
          reject();
        }
        return deferred.promise;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#instant
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns a translation instantly from the internal state of loaded translation. All rules
       * regarding the current language, the preferred language of even fallback languages will be
       * used except any promise handling. If a language was not found, an asynchronous loading
       * will be invoked in the background.
       *
       * @param {string|array} translationId A token which represents a translation id
       *                                     This can be optionally an array of translation ids which
       *                                     results that the function's promise returns an object where
       *                                     each key is the translation id and the value the translation.
       * @param {object} interpolateParams Params
       * @param {string} interpolationId The id of the interpolation to use
       * @param {string} forceLanguage A language to be used instead of the current language
       *
       * @return {string|object} translation
       */
      $translate.instant = function (translationId, interpolateParams, interpolationId, forceLanguage) {

        // we don't want to re-negotiate $uses
        var uses = (forceLanguage && forceLanguage !== $uses) ? // we don't want to re-negotiate $uses
              (negotiateLocale(forceLanguage) || forceLanguage) : $uses;

        // Detect undefined and null values to shorten the execution and prevent exceptions
        if (translationId === null || angular.isUndefined(translationId)) {
          return translationId;
        }

        // Duck detection: If the first argument is an array, a bunch of translations was requested.
        // The result is an object.
        if (angular.isArray(translationId)) {
          var results = {};
          for (var i = 0, c = translationId.length; i < c; i++) {
            results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage);
          }
          return results;
        }

        // We discarded unacceptable values. So we just need to verify if translationId is empty String
        if (angular.isString(translationId) && translationId.length < 1) {
          return translationId;
        }

        // trim off any whitespace
        if (translationId) {
          translationId = trim.apply(translationId);
        }

        var result, possibleLangKeys = [];
        if ($preferredLanguage) {
          possibleLangKeys.push($preferredLanguage);
        }
        if (uses) {
          possibleLangKeys.push(uses);
        }
        if ($fallbackLanguage && $fallbackLanguage.length) {
          possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);
        }
        for (var j = 0, d = possibleLangKeys.length; j < d; j++) {
          var possibleLangKey = possibleLangKeys[j];
          if ($translationTable[possibleLangKey]) {
            if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {
              result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses);
            }
          }
          if (typeof result !== 'undefined') {
            break;
          }
        }

        if (!result && result !== '') {
          if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {
            result = applyNotFoundIndicators(translationId);
          } else {
            // Return translation of default interpolator if not found anything.
            result = defaultInterpolator.interpolate(translationId, interpolateParams);
            if ($missingTranslationHandlerFactory && !pendingLoader) {
              result = translateByHandler(translationId, interpolateParams);
            }
          }
        }

        return result;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#versionInfo
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns the current version information for the angular-translate library
       *
       * @return {string} angular-translate version
       */
      $translate.versionInfo = function () {
        return version;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#loaderCache
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns the defined loaderCache.
       *
       * @return {boolean|string|object} current value of loaderCache
       */
      $translate.loaderCache = function () {
        return loaderCache;
      };

      // internal purpose only
      $translate.directivePriority = function () {
        return directivePriority;
      };

      // internal purpose only
      $translate.statefulFilter = function () {
        return statefulFilter;
      };

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#isReady
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns whether the service is "ready" to translate (i.e. loading 1st language).
       *
       * See also {@link pascalprecht.translate.$translate#methods_onReady onReady()}.
       *
       * @return {boolean} current value of ready
       */
      $translate.isReady = function () {
        return $isReady;
      };

      var $onReadyDeferred = $q.defer();
      $onReadyDeferred.promise.then(function () {
        $isReady = true;
      });

      /**
       * @ngdoc function
       * @name pascalprecht.translate.$translate#onReady
       * @methodOf pascalprecht.translate.$translate
       *
       * @description
       * Returns whether the service is "ready" to translate (i.e. loading 1st language).
       *
       * See also {@link pascalprecht.translate.$translate#methods_isReady isReady()}.
       *
       * @param {Function=} fn Function to invoke when service is ready
       * @return {object} Promise resolved when service is ready
       */
      $translate.onReady = function (fn) {
        var deferred = $q.defer();
        if (angular.isFunction(fn)) {
          deferred.promise.then(fn);
        }
        if ($isReady) {
          deferred.resolve();
        } else {
          $onReadyDeferred.promise.then(deferred.resolve);
        }
        return deferred.promise;
      };

      // Whenever $translateReady is being fired, this will ensure the state of $isReady
      var globalOnReadyListener = $rootScope.$on('$translateReady', function () {
        $onReadyDeferred.resolve();
        globalOnReadyListener(); // one time only
        globalOnReadyListener = null;
      });
      var globalOnChangeListener = $rootScope.$on('$translateChangeEnd', function () {
        $onReadyDeferred.resolve();
        globalOnChangeListener(); // one time only
        globalOnChangeListener = null;
      });

      if ($loaderFactory) {

        // If at least one async loader is defined and there are no
        // (default) translations available we should try to load them.
        if (angular.equals($translationTable, {})) {
          if ($translate.use()) {
            $translate.use($translate.use());
          }
        }

        // Also, if there are any fallback language registered, we start
        // loading them asynchronously as soon as we can.
        if ($fallbackLanguage && $fallbackLanguage.length) {
          var processAsyncResult = function (translation) {
            translations(translation.key, translation.table);
            $rootScope.$emit('$translateChangeEnd', { language: translation.key });
            return translation;
          };
          for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
            var fallbackLanguageId = $fallbackLanguage[i];
            if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {
              langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);
            }
          }
        }
      } else {
        $rootScope.$emit('$translateReady', { language: $translate.use() });
      }

      return $translate;
    }
  ];
}
$translate.$inject = ['$STORAGE_KEY', '$windowProvider', '$translateSanitizationProvider', 'pascalprechtTranslateOverrider'];

$translate.displayName = 'displayName';

/**
 * @ngdoc object
 * @name pascalprecht.translate.$translateDefaultInterpolation
 * @requires $interpolate
 *
 * @description
 * Uses angular's `$interpolate` services to interpolate strings against some values.
 *
 * Be aware to configure a proper sanitization strategy.
 *
 * See also:
 * * {@link pascalprecht.translate.$translateSanitization}
 *
 * @return {object} $translateDefaultInterpolation Interpolator service
 */
angular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', $translateDefaultInterpolation);

function $translateDefaultInterpolation ($interpolate, $translateSanitization) {

  'use strict';

  var $translateInterpolator = {},
      $locale,
      $identifier = 'default';

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateDefaultInterpolation#setLocale
   * @methodOf pascalprecht.translate.$translateDefaultInterpolation
   *
   * @description
   * Sets current locale (this is currently not use in this interpolation).
   *
   * @param {string} locale Language key or locale.
   */
  $translateInterpolator.setLocale = function (locale) {
    $locale = locale;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateDefaultInterpolation#getInterpolationIdentifier
   * @methodOf pascalprecht.translate.$translateDefaultInterpolation
   *
   * @description
   * Returns an identifier for this interpolation service.
   *
   * @returns {string} $identifier
   */
  $translateInterpolator.getInterpolationIdentifier = function () {
    return $identifier;
  };

  /**
   * @deprecated will be removed in 3.0
   * @see {@link pascalprecht.translate.$translateSanitization}
   */
  $translateInterpolator.useSanitizeValueStrategy = function (value) {
    $translateSanitization.useStrategy(value);
    return this;
  };

  /**
   * @ngdoc function
   * @name pascalprecht.translate.$translateDefaultInterpolation#interpolate
   * @methodOf pascalprecht.translate.$translateDefaultInterpolation
   *
   * @description
   * Interpolates given string agains given interpolate params using angulars
   * `$interpolate` service.
   *
   * @returns {string} interpolated string.
   */
  $translateInterpolator.interpolate = function (string, interpolationParams) {
    interpolationParams = interpolationParams || {};
    interpolationParams = $translateSanitization.sanitize(interpolationParams, 'params');

    var interpolatedText = $interpolate(string)(interpolationParams);
    interpolatedText = $translateSanitization.sanitize(interpolatedText, 'text');

    return interpolatedText;
  };

  return $translateInterpolator;
}
$translateDefaultInterpolation.$inject = ['$interpolate', '$translateSanitization'];

$translateDefaultInterpolation.displayName = '$translateDefaultInterpolation';

angular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');

angular.module('pascalprecht.translate')
/**
 * @ngdoc directive
 * @name pascalprecht.translate.directive:translate
 * @requires $compile
 * @requires $filter
 * @requires $interpolate
 * @restrict AE
 *
 * @description
 * Translates given translation id either through attribute or DOM content.
 * Internally it uses `translate` filter to translate translation id. It possible to
 * pass an optional `translate-values` object literal as string into translation id.
 *
 * @param {string=} translate Translation id which could be either string or interpolated string.
 * @param {string=} translate-values Values to pass into translation id. Can be passed as object literal string or interpolated object.
 * @param {string=} translate-attr-ATTR translate Translation id and put it into ATTR attribute.
 * @param {string=} translate-default will be used unless translation was successful
 * @param {boolean=} translate-compile (default true if present) defines locally activation of {@link pascalprecht.translate.$translateProvider#methods_usePostCompiling}
 *
 * @example
   <example module="ngView">
    <file name="index.html">
      <div ng-controller="TranslateCtrl">

        <pre translate="TRANSLATION_ID"></pre>
        <pre translate>TRANSLATION_ID</pre>
        <pre translate translate-attr-title="TRANSLATION_ID"></pre>
        <pre translate="{{translationId}}"></pre>
        <pre translate>{{translationId}}</pre>
        <pre translate="WITH_VALUES" translate-values="{value: 5}"></pre>
        <pre translate translate-values="{value: 5}">WITH_VALUES</pre>
        <pre translate="WITH_VALUES" translate-values="{{values}}"></pre>
        <pre translate translate-values="{{values}}">WITH_VALUES</pre>
        <pre translate translate-attr-title="WITH_VALUES" translate-values="{{values}}"></pre>

      </div>
    </file>
    <file name="script.js">
      angular.module('ngView', ['pascalprecht.translate'])

      .config(function ($translateProvider) {

        $translateProvider.translations('en',{
          'TRANSLATION_ID': 'Hello there!',
          'WITH_VALUES': 'The following value is dynamic: {{value}}'
        }).preferredLanguage('en');

      });

      angular.module('ngView').controller('TranslateCtrl', function ($scope) {
        $scope.translationId = 'TRANSLATION_ID';

        $scope.values = {
          value: 78
        };
      });
    </file>
    <file name="scenario.js">
      it('should translate', function () {
        inject(function ($rootScope, $compile) {
          $rootScope.translationId = 'TRANSLATION_ID';

          element = $compile('<p translate="TRANSLATION_ID"></p>')($rootScope);
          $rootScope.$digest();
          expect(element.text()).toBe('Hello there!');

          element = $compile('<p translate="{{translationId}}"></p>')($rootScope);
          $rootScope.$digest();
          expect(element.text()).toBe('Hello there!');

          element = $compile('<p translate>TRANSLATION_ID</p>')($rootScope);
          $rootScope.$digest();
          expect(element.text()).toBe('Hello there!');

          element = $compile('<p translate>{{translationId}}</p>')($rootScope);
          $rootScope.$digest();
          expect(element.text()).toBe('Hello there!');

          element = $compile('<p translate translate-attr-title="TRANSLATION_ID"></p>')($rootScope);
          $rootScope.$digest();
          expect(element.attr('title')).toBe('Hello there!');
        });
      });
    </file>
   </example>
 */
.directive('translate', translateDirective);
function translateDirective($translate, $q, $interpolate, $compile, $parse, $rootScope) {

  'use strict';

  /**
   * @name trim
   * @private
   *
   * @description
   * trim polyfill
   *
   * @returns {string} The string stripped of whitespace from both ends
   */
  var trim = function() {
    return this.toString().replace(/^\s+|\s+$/g, '');
  };

  return {
    restrict: 'AE',
    scope: true,
    priority: $translate.directivePriority(),
    compile: function (tElement, tAttr) {

      var translateValuesExist = (tAttr.translateValues) ?
        tAttr.translateValues : undefined;

      var translateInterpolation = (tAttr.translateInterpolation) ?
        tAttr.translateInterpolation : undefined;

      var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);

      var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',
          watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';

      return function linkFn(scope, iElement, iAttr) {

        scope.interpolateParams = {};
        scope.preText = '';
        scope.postText = '';
        scope.translateNamespace = getTranslateNamespace(scope);
        var translationIds = {};

        var initInterpolationParams = function (interpolateParams, iAttr, tAttr) {
          // initial setup
          if (iAttr.translateValues) {
            angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));
          }
          // initially fetch all attributes if existing and fill the params
          if (translateValueExist) {
            for (var attr in tAttr) {
              if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {
                var attributeName = angular.lowercase(attr.substr(14, 1)) + attr.substr(15);
                interpolateParams[attributeName] = tAttr[attr];
              }
            }
          }
        };

        // Ensures any change of the attribute "translate" containing the id will
        // be re-stored to the scope's "translationId".
        // If the attribute has no content, the element's text value (white spaces trimmed off) will be used.
        var observeElementTranslation = function (translationId) {

          // Remove any old watcher
          if (angular.isFunction(observeElementTranslation._unwatchOld)) {
            observeElementTranslation._unwatchOld();
            observeElementTranslation._unwatchOld = undefined;
          }

          if (angular.equals(translationId , '') || !angular.isDefined(translationId)) {
            var iElementText = trim.apply(iElement.text());

            // Resolve translation id by inner html if required
            var interpolateMatches = iElementText.match(interpolateRegExp);
            // Interpolate translation id if required
            if (angular.isArray(interpolateMatches)) {
              scope.preText = interpolateMatches[1];
              scope.postText = interpolateMatches[3];
              translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);
              var watcherMatches = iElementText.match(watcherRegExp);
              if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {
                observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function (newValue) {
                  translationIds.translate = newValue;
                  updateTranslations();
                });
              }
            } else {
              // do not assigne the translation id if it is empty.
              translationIds.translate = !iElementText ? undefined : iElementText;
            }
          } else {
            translationIds.translate = translationId;
          }
          updateTranslations();
        };

        var observeAttributeTranslation = function (translateAttr) {
          iAttr.$observe(translateAttr, function (translationId) {
            translationIds[translateAttr] = translationId;
            updateTranslations();
          });
        };

        // initial setup with values
        initInterpolationParams(scope.interpolateParams, iAttr, tAttr);

        var firstAttributeChangedEvent = true;
        iAttr.$observe('translate', function (translationId) {
          if (typeof translationId === 'undefined') {
            // case of element "<translate>xyz</translate>"
            observeElementTranslation('');
          } else {
            // case of regular attribute
            if (translationId !== '' || !firstAttributeChangedEvent) {
              translationIds.translate = translationId;
              updateTranslations();
            }
          }
          firstAttributeChangedEvent = false;
        });

        for (var translateAttr in iAttr) {
          if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr') {
            observeAttributeTranslation(translateAttr);
          }
        }

        iAttr.$observe('translateDefault', function (value) {
          scope.defaultText = value;
          updateTranslations();
        });

        if (translateValuesExist) {
          iAttr.$observe('translateValues', function (interpolateParams) {
            if (interpolateParams) {
              scope.$parent.$watch(function () {
                angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));
              });
            }
          });
        }

        if (translateValueExist) {
          var observeValueAttribute = function (attrName) {
            iAttr.$observe(attrName, function (value) {
              var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);
              scope.interpolateParams[attributeName] = value;
            });
          };
          for (var attr in iAttr) {
            if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {
              observeValueAttribute(attr);
            }
          }
        }

        // Master update function
        var updateTranslations = function () {
          for (var key in translationIds) {

            if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {
              updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);
            }
          }
        };

        // Put translation processing function outside loop
        var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {
          if (translationId) {
            // if translation id starts with '.' and translateNamespace given, prepend namespace
            if (translateNamespace && translationId.charAt(0) === '.') {
              translationId = translateNamespace + translationId;
            }

            $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage)
              .then(function (translation) {
                applyTranslation(translation, scope, true, translateAttr);
              }, function (translationId) {
                applyTranslation(translationId, scope, false, translateAttr);
              });
          } else {
            // as an empty string cannot be translated, we can solve this using successful=false
            applyTranslation(translationId, scope, false, translateAttr);
          }
        };

        var applyTranslation = function (value, scope, successful, translateAttr) {
          if (translateAttr === 'translate') {
            // default translate into innerHTML
            if (!successful && typeof scope.defaultText !== 'undefined') {
              value = scope.defaultText;
            }
            iElement.empty().append(scope.preText + value + scope.postText);
            var globallyEnabled = $translate.isPostCompilingEnabled();
            var locallyDefined = typeof tAttr.translateCompile !== 'undefined';
            var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';
            if ((globallyEnabled && !locallyDefined) || locallyEnabled) {
              $compile(iElement.contents())(scope);
            }
          } else {
            // translate attribute
            if (!successful && typeof scope.defaultText !== 'undefined') {
              value = scope.defaultText;
            }
            var attributeName = iAttr.$attr[translateAttr];
            if (attributeName.substr(0, 5) === 'data-') {
              // ensure html5 data prefix is stripped
              attributeName = attributeName.substr(5);
            }
            attributeName = attributeName.substr(15);
            iElement.attr(attributeName, value);
          }
        };

        if (translateValuesExist || translateValueExist || iAttr.translateDefault) {
          scope.$watch('interpolateParams', updateTranslations, true);
        }
        scope.$watch('translateLanguage', updateTranslations);

        // Ensures the text will be refreshed after the current language was changed
        // w/ $translate.use(...)
        var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);

        // ensure translation will be looked up at least one
        if (iElement.text().length) {
          if (iAttr.translate) {
            observeElementTranslation(iAttr.translate);
          } else {
            observeElementTranslation('');
          }
        } else if (iAttr.translate) {
          // ensure attribute will be not skipped
          observeElementTranslation(iAttr.translate);
        }
        updateTranslations();
        scope.$on('$destroy', unbind);
      };
    }
  };
}
translateDirective.$inject = ['$translate', '$q', '$interpolate', '$compile', '$parse', '$rootScope'];

/**
 * Returns the scope's namespace.
 * @private
 * @param scope
 * @returns {string}
 */
function getTranslateNamespace(scope) {
  'use strict';
  if (scope.translateNamespace) {
    return scope.translateNamespace;
  }
  if (scope.$parent) {
    return getTranslateNamespace(scope.$parent);
  }
}

translateDirective.displayName = 'translateDirective';

angular.module('pascalprecht.translate')
/**
 * @ngdoc directive
 * @name pascalprecht.translate.directive:translateCloak
 * @requires $rootScope
 * @requires $translate
 * @restrict A
 *
 * $description
 * Adds a `translate-cloak` class name to the given element where this directive
 * is applied initially and removes it, once a loader has finished loading.
 *
 * This directive can be used to prevent initial flickering when loading translation
 * data asynchronously.
 *
 * The class name is defined in
 * {@link pascalprecht.translate.$translateProvider#cloakClassName $translate.cloakClassName()}.
 *
 * @param {string=} translate-cloak If a translationId is provided, it will be used for showing
 *                                  or hiding the cloak. Basically it relies on the translation
 *                                  resolve.
 */
.directive('translateCloak', translateCloakDirective);

function translateCloakDirective($translate, $rootScope) {

  'use strict';

  return {
    compile: function (tElement) {
      var applyCloak = function () {
        tElement.addClass($translate.cloakClassName());
      },
      removeCloak = function () {
        tElement.removeClass($translate.cloakClassName());
      };
      $translate.onReady(function () {
        removeCloak();
      });
      applyCloak();

      return function linkFn(scope, iElement, iAttr) {
        if (iAttr.translateCloak && iAttr.translateCloak.length) {
          // Register a watcher for the defined translation allowing a fine tuned cloak
          iAttr.$observe('translateCloak', function (translationId) {
            $translate(translationId).then(removeCloak, applyCloak);
          });
          // Register for change events as this is being another indicicator revalidating the cloak)
          $rootScope.$on('$translateChangeSuccess', function () {
            $translate(iAttr.translateCloak).then(removeCloak, applyCloak);
          });
        }
      };
    }
  };
}
translateCloakDirective.$inject = ['$translate', '$rootScope'];

translateCloakDirective.displayName = 'translateCloakDirective';

angular.module('pascalprecht.translate')
/**
 * @ngdoc directive
 * @name pascalprecht.translate.directive:translateNamespace
 * @restrict A
 *
 * @description
 * Translates given translation id either through attribute or DOM content.
 * Internally it uses `translate` filter to translate translation id. It possible to
 * pass an optional `translate-values` object literal as string into translation id.
 *
 * @param {string=} translate namespace name which could be either string or interpolated string.
 *
 * @example
   <example module="ngView">
    <file name="index.html">
      <div translate-namespace="CONTENT">

        <div>
            <h1 translate>.HEADERS.TITLE</h1>
            <h1 translate>.HEADERS.WELCOME</h1>
        </div>

        <div translate-namespace=".HEADERS">
            <h1 translate>.TITLE</h1>
            <h1 translate>.WELCOME</h1>
        </div>

      </div>
    </file>
    <file name="script.js">
      angular.module('ngView', ['pascalprecht.translate'])

      .config(function ($translateProvider) {

        $translateProvider.translations('en',{
          'TRANSLATION_ID': 'Hello there!',
          'CONTENT': {
            'HEADERS': {
                TITLE: 'Title'
            }
          },
          'CONTENT.HEADERS.WELCOME': 'Welcome'
        }).preferredLanguage('en');

      });

    </file>
   </example>
 */
.directive('translateNamespace', translateNamespaceDirective);

function translateNamespaceDirective() {

  'use strict';

  return {
    restrict: 'A',
    scope: true,
    compile: function () {
      return {
        pre: function (scope, iElement, iAttrs) {
          scope.translateNamespace = getTranslateNamespace(scope);

          if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === '.') {
            scope.translateNamespace += iAttrs.translateNamespace;
          } else {
            scope.translateNamespace = iAttrs.translateNamespace;
          }
        }
      };
    }
  };
}

/**
 * Returns the scope's namespace.
 * @private
 * @param scope
 * @returns {string}
 */
function getTranslateNamespace(scope) {
  'use strict';
  if (scope.translateNamespace) {
    return scope.translateNamespace;
  }
  if (scope.$parent) {
    return getTranslateNamespace(scope.$parent);
  }
}

translateNamespaceDirective.displayName = 'translateNamespaceDirective';

angular.module('pascalprecht.translate')
/**
 * @ngdoc directive
 * @name pascalprecht.translate.directive:translateLanguage
 * @restrict A
 *
 * @description
 * Forces the language to the directives in the underlying scope.
 *
 * @param {string=} translate language that will be negotiated.
 *
 * @example
   <example module="ngView">
    <file name="index.html">
      <div>

        <div>
            <h1 translate>HELLO</h1>
        </div>

        <div translate-language="de">
            <h1 translate>HELLO</h1>
        </div>

      </div>
    </file>
    <file name="script.js">
      angular.module('ngView', ['pascalprecht.translate'])

      .config(function ($translateProvider) {

        $translateProvider
          .translations('en',{
            'HELLO': 'Hello world!'
          })
          .translations('de',{
            'HELLO': 'Hallo Welt!'
          })
          .translations(.preferredLanguage('en');

      });

    </file>
   </example>
 */
.directive('translateLanguage', translateLanguageDirective);

function translateLanguageDirective() {

  'use strict';

  return {
    restrict: 'A',
    scope: true,
    compile: function () {
      return function linkFn(scope, iElement, iAttrs) {
        iAttrs.$observe('translateLanguage', function (newTranslateLanguage) {
          scope.translateLanguage = newTranslateLanguage;
        });
      };
    }
  };
}

translateLanguageDirective.displayName = 'translateLanguageDirective';


angular.module('pascalprecht.translate')
/**
 * @ngdoc filter
 * @name pascalprecht.translate.filter:translate
 * @requires $parse
 * @requires pascalprecht.translate.$translate
 * @function
 *
 * @description
 * Uses `$translate` service to translate contents. Accepts interpolate parameters
 * to pass dynamized values though translation.
 *
 * @param {string} translationId A translation id to be translated.
 * @param {*=} interpolateParams Optional object literal (as hash or string) to pass values into translation.
 *
 * @returns {string} Translated text.
 *
 * @example
   <example module="ngView">
    <file name="index.html">
      <div ng-controller="TranslateCtrl">

        <pre>{{ 'TRANSLATION_ID' | translate }}</pre>
        <pre>{{ translationId | translate }}</pre>
        <pre>{{ 'WITH_VALUES' | translate:'{value: 5}' }}</pre>
        <pre>{{ 'WITH_VALUES' | translate:values }}</pre>

      </div>
    </file>
    <file name="script.js">
      angular.module('ngView', ['pascalprecht.translate'])

      .config(function ($translateProvider) {

        $translateProvider.translations('en', {
          'TRANSLATION_ID': 'Hello there!',
          'WITH_VALUES': 'The following value is dynamic: {{value}}'
        });
        $translateProvider.preferredLanguage('en');

      });

      angular.module('ngView').controller('TranslateCtrl', function ($scope) {
        $scope.translationId = 'TRANSLATION_ID';

        $scope.values = {
          value: 78
        };
      });
    </file>
   </example>
 */
.filter('translate', translateFilterFactory);

function translateFilterFactory($parse, $translate) {

  'use strict';

  var translateFilter = function (translationId, interpolateParams, interpolation, forceLanguage) {

    if (!angular.isObject(interpolateParams)) {
      interpolateParams = $parse(interpolateParams)(this);
    }

    return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);
  };

  if ($translate.statefulFilter()) {
    translateFilter.$stateful = true;
  }

  return translateFilter;
}
translateFilterFactory.$inject = ['$parse', '$translate'];

translateFilterFactory.displayName = 'translateFilterFactory';

angular.module('pascalprecht.translate')

/**
 * @ngdoc object
 * @name pascalprecht.translate.$translationCache
 * @requires $cacheFactory
 *
 * @description
 * The first time a translation table is used, it is loaded in the translation cache for quick retrieval. You
 * can load translation tables directly into the cache by consuming the
 * `$translationCache` service directly.
 *
 * @return {object} $cacheFactory object.
 */
  .factory('$translationCache', $translationCache);

function $translationCache($cacheFactory) {

  'use strict';

  return $cacheFactory('translations');
}
$translationCache.$inject = ['$cacheFactory'];

$translationCache.displayName = '$translationCache';
return 'pascalprecht.translate';

}));

},{}],40:[function(require,module,exports){
/**
 * State-based routing for AngularJS
 * @version v0.2.18
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */

/* commonjs package manager support (eg componentjs) */
if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports){
  module.exports = 'ui.router';
}

(function (window, angular, undefined) {
/*jshint globalstrict:true*/
/*global angular:false*/
'use strict';

var isDefined = angular.isDefined,
    isFunction = angular.isFunction,
    isString = angular.isString,
    isObject = angular.isObject,
    isArray = angular.isArray,
    forEach = angular.forEach,
    extend = angular.extend,
    copy = angular.copy,
    toJson = angular.toJson;

function inherit(parent, extra) {
  return extend(new (extend(function() {}, { prototype: parent }))(), extra);
}

function merge(dst) {
  forEach(arguments, function(obj) {
    if (obj !== dst) {
      forEach(obj, function(value, key) {
        if (!dst.hasOwnProperty(key)) dst[key] = value;
      });
    }
  });
  return dst;
}

/**
 * Finds the common ancestor path between two states.
 *
 * @param {Object} first The first state.
 * @param {Object} second The second state.
 * @return {Array} Returns an array of state names in descending order, not including the root.
 */
function ancestors(first, second) {
  var path = [];

  for (var n in first.path) {
    if (first.path[n] !== second.path[n]) break;
    path.push(first.path[n]);
  }
  return path;
}

/**
 * IE8-safe wrapper for `Object.keys()`.
 *
 * @param {Object} object A JavaScript object.
 * @return {Array} Returns the keys of the object as an array.
 */
function objectKeys(object) {
  if (Object.keys) {
    return Object.keys(object);
  }
  var result = [];

  forEach(object, function(val, key) {
    result.push(key);
  });
  return result;
}

/**
 * IE8-safe wrapper for `Array.prototype.indexOf()`.
 *
 * @param {Array} array A JavaScript array.
 * @param {*} value A value to search the array for.
 * @return {Number} Returns the array index value of `value`, or `-1` if not present.
 */
function indexOf(array, value) {
  if (Array.prototype.indexOf) {
    return array.indexOf(value, Number(arguments[2]) || 0);
  }
  var len = array.length >>> 0, from = Number(arguments[2]) || 0;
  from = (from < 0) ? Math.ceil(from) : Math.floor(from);

  if (from < 0) from += len;

  for (; from < len; from++) {
    if (from in array && array[from] === value) return from;
  }
  return -1;
}

/**
 * Merges a set of parameters with all parameters inherited between the common parents of the
 * current state and a given destination state.
 *
 * @param {Object} currentParams The value of the current state parameters ($stateParams).
 * @param {Object} newParams The set of parameters which will be composited with inherited params.
 * @param {Object} $current Internal definition of object representing the current state.
 * @param {Object} $to Internal definition of object representing state to transition to.
 */
function inheritParams(currentParams, newParams, $current, $to) {
  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];

  for (var i in parents) {
    if (!parents[i] || !parents[i].params) continue;
    parentParams = objectKeys(parents[i].params);
    if (!parentParams.length) continue;

    for (var j in parentParams) {
      if (indexOf(inheritList, parentParams[j]) >= 0) continue;
      inheritList.push(parentParams[j]);
      inherited[parentParams[j]] = currentParams[parentParams[j]];
    }
  }
  return extend({}, inherited, newParams);
}

/**
 * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.
 *
 * @param {Object} a The first object.
 * @param {Object} b The second object.
 * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,
 *                     it defaults to the list of keys in `a`.
 * @return {Boolean} Returns `true` if the keys match, otherwise `false`.
 */
function equalForKeys(a, b, keys) {
  if (!keys) {
    keys = [];
    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility
  }

  for (var i=0; i<keys.length; i++) {
    var k = keys[i];
    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized
  }
  return true;
}

/**
 * Returns the subset of an object, based on a list of keys.
 *
 * @param {Array} keys
 * @param {Object} values
 * @return {Boolean} Returns a subset of `values`.
 */
function filterByKeys(keys, values) {
  var filtered = {};

  forEach(keys, function (name) {
    filtered[name] = values[name];
  });
  return filtered;
}

// like _.indexBy
// when you know that your index values will be unique, or you want last-one-in to win
function indexBy(array, propName) {
  var result = {};
  forEach(array, function(item) {
    result[item[propName]] = item;
  });
  return result;
}

// extracted from underscore.js
// Return a copy of the object only containing the whitelisted properties.
function pick(obj) {
  var copy = {};
  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
  forEach(keys, function(key) {
    if (key in obj) copy[key] = obj[key];
  });
  return copy;
}

// extracted from underscore.js
// Return a copy of the object omitting the blacklisted properties.
function omit(obj) {
  var copy = {};
  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
  for (var key in obj) {
    if (indexOf(keys, key) == -1) copy[key] = obj[key];
  }
  return copy;
}

function pluck(collection, key) {
  var result = isArray(collection) ? [] : {};

  forEach(collection, function(val, i) {
    result[i] = isFunction(key) ? key(val) : val[key];
  });
  return result;
}

function filter(collection, callback) {
  var array = isArray(collection);
  var result = array ? [] : {};
  forEach(collection, function(val, i) {
    if (callback(val, i)) {
      result[array ? result.length : i] = val;
    }
  });
  return result;
}

function map(collection, callback) {
  var result = isArray(collection) ? [] : {};

  forEach(collection, function(val, i) {
    result[i] = callback(val, i);
  });
  return result;
}

/**
 * @ngdoc overview
 * @name ui.router.util
 *
 * @description
 * # ui.router.util sub-module
 *
 * This module is a dependency of other sub-modules. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 *
 */
angular.module('ui.router.util', ['ng']);

/**
 * @ngdoc overview
 * @name ui.router.router
 * 
 * @requires ui.router.util
 *
 * @description
 * # ui.router.router sub-module
 *
 * This module is a dependency of other sub-modules. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 */
angular.module('ui.router.router', ['ui.router.util']);

/**
 * @ngdoc overview
 * @name ui.router.state
 * 
 * @requires ui.router.router
 * @requires ui.router.util
 *
 * @description
 * # ui.router.state sub-module
 *
 * This module is a dependency of the main ui.router module. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 * 
 */
angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);

/**
 * @ngdoc overview
 * @name ui.router
 *
 * @requires ui.router.state
 *
 * @description
 * # ui.router
 * 
 * ## The main module for ui.router 
 * There are several sub-modules included with the ui.router module, however only this module is needed
 * as a dependency within your angular app. The other modules are for organization purposes. 
 *
 * The modules are:
 * * ui.router - the main "umbrella" module
 * * ui.router.router - 
 * 
 * *You'll need to include **only** this module as the dependency within your angular app.*
 * 
 * <pre>
 * <!doctype html>
 * <html ng-app="myApp">
 * <head>
 *   <script src="js/angular.js"></script>
 *   <!-- Include the ui-router script -->
 *   <script src="js/angular-ui-router.min.js"></script>
 *   <script>
 *     // ...and add 'ui.router' as a dependency
 *     var myApp = angular.module('myApp', ['ui.router']);
 *   </script>
 * </head>
 * <body>
 * </body>
 * </html>
 * </pre>
 */
angular.module('ui.router', ['ui.router.state']);

angular.module('ui.router.compat', ['ui.router']);

/**
 * @ngdoc object
 * @name ui.router.util.$resolve
 *
 * @requires $q
 * @requires $injector
 *
 * @description
 * Manages resolution of (acyclic) graphs of promises.
 */
$Resolve.$inject = ['$q', '$injector'];
function $Resolve(  $q,    $injector) {
  
  var VISIT_IN_PROGRESS = 1,
      VISIT_DONE = 2,
      NOTHING = {},
      NO_DEPENDENCIES = [],
      NO_LOCALS = NOTHING,
      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });
  

  /**
   * @ngdoc function
   * @name ui.router.util.$resolve#study
   * @methodOf ui.router.util.$resolve
   *
   * @description
   * Studies a set of invocables that are likely to be used multiple times.
   * <pre>
   * $resolve.study(invocables)(locals, parent, self)
   * </pre>
   * is equivalent to
   * <pre>
   * $resolve.resolve(invocables, locals, parent, self)
   * </pre>
   * but the former is more efficient (in fact `resolve` just calls `study` 
   * internally).
   *
   * @param {object} invocables Invocable objects
   * @return {function} a function to pass in locals, parent and self
   */
  this.study = function (invocables) {
    if (!isObject(invocables)) throw new Error("'invocables' must be an object");
    var invocableKeys = objectKeys(invocables || {});
    
    // Perform a topological sort of invocables to build an ordered plan
    var plan = [], cycle = [], visited = {};
    function visit(value, key) {
      if (visited[key] === VISIT_DONE) return;
      
      cycle.push(key);
      if (visited[key] === VISIT_IN_PROGRESS) {
        cycle.splice(0, indexOf(cycle, key));
        throw new Error("Cyclic dependency: " + cycle.join(" -> "));
      }
      visited[key] = VISIT_IN_PROGRESS;
      
      if (isString(value)) {
        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);
      } else {
        var params = $injector.annotate(value);
        forEach(params, function (param) {
          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
        });
        plan.push(key, value, params);
      }
      
      cycle.pop();
      visited[key] = VISIT_DONE;
    }
    forEach(invocables, visit);
    invocables = cycle = visited = null; // plan is all that's required
    
    function isResolve(value) {
      return isObject(value) && value.then && value.$$promises;
    }
    
    return function (locals, parent, self) {
      if (isResolve(locals) && self === undefined) {
        self = parent; parent = locals; locals = null;
      }
      if (!locals) locals = NO_LOCALS;
      else if (!isObject(locals)) {
        throw new Error("'locals' must be an object");
      }       
      if (!parent) parent = NO_PARENT;
      else if (!isResolve(parent)) {
        throw new Error("'parent' must be a promise returned by $resolve.resolve()");
      }
      
      // To complete the overall resolution, we have to wait for the parent
      // promise and for the promise for each invokable in our plan.
      var resolution = $q.defer(),
          result = resolution.promise,
          promises = result.$$promises = {},
          values = extend({}, locals),
          wait = 1 + plan.length/3,
          merged = false;
          
      function done() {
        // Merge parent values we haven't got yet and publish our own $$values
        if (!--wait) {
          if (!merged) merge(values, parent.$$values); 
          result.$$values = values;
          result.$$promises = result.$$promises || true; // keep for isResolve()
          delete result.$$inheritedValues;
          resolution.resolve(values);
        }
      }
      
      function fail(reason) {
        result.$$failure = reason;
        resolution.reject(reason);
      }

      // Short-circuit if parent has already failed
      if (isDefined(parent.$$failure)) {
        fail(parent.$$failure);
        return result;
      }
      
      if (parent.$$inheritedValues) {
        merge(values, omit(parent.$$inheritedValues, invocableKeys));
      }

      // Merge parent values if the parent has already resolved, or merge
      // parent promises and wait if the parent resolve is still in progress.
      extend(promises, parent.$$promises);
      if (parent.$$values) {
        merged = merge(values, omit(parent.$$values, invocableKeys));
        result.$$inheritedValues = omit(parent.$$values, invocableKeys);
        done();
      } else {
        if (parent.$$inheritedValues) {
          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
        }        
        parent.then(done, fail);
      }
      
      // Process each invocable in the plan, but ignore any where a local of the same name exists.
      for (var i=0, ii=plan.length; i<ii; i+=3) {
        if (locals.hasOwnProperty(plan[i])) done();
        else invoke(plan[i], plan[i+1], plan[i+2]);
      }
      
      function invoke(key, invocable, params) {
        // Create a deferred for this invocation. Failures will propagate to the resolution as well.
        var invocation = $q.defer(), waitParams = 0;
        function onfailure(reason) {
          invocation.reject(reason);
          fail(reason);
        }
        // Wait for any parameter that we have a promise for (either from parent or from this
        // resolve; in that case study() will have made sure it's ordered before us in the plan).
        forEach(params, function (dep) {
          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
            waitParams++;
            promises[dep].then(function (result) {
              values[dep] = result;
              if (!(--waitParams)) proceed();
            }, onfailure);
          }
        });
        if (!waitParams) proceed();
        function proceed() {
          if (isDefined(result.$$failure)) return;
          try {
            invocation.resolve($injector.invoke(invocable, self, values));
            invocation.promise.then(function (result) {
              values[key] = result;
              done();
            }, onfailure);
          } catch (e) {
            onfailure(e);
          }
        }
        // Publish promise synchronously; invocations further down in the plan may depend on it.
        promises[key] = invocation.promise;
      }
      
      return result;
    };
  };
  
  /**
   * @ngdoc function
   * @name ui.router.util.$resolve#resolve
   * @methodOf ui.router.util.$resolve
   *
   * @description
   * Resolves a set of invocables. An invocable is a function to be invoked via 
   * `$injector.invoke()`, and can have an arbitrary number of dependencies. 
   * An invocable can either return a value directly,
   * or a `$q` promise. If a promise is returned it will be resolved and the 
   * resulting value will be used instead. Dependencies of invocables are resolved 
   * (in this order of precedence)
   *
   * - from the specified `locals`
   * - from another invocable that is part of this `$resolve` call
   * - from an invocable that is inherited from a `parent` call to `$resolve` 
   *   (or recursively
   * - from any ancestor `$resolve` of that parent).
   *
   * The return value of `$resolve` is a promise for an object that contains 
   * (in this order of precedence)
   *
   * - any `locals` (if specified)
   * - the resolved return values of all injectables
   * - any values inherited from a `parent` call to `$resolve` (if specified)
   *
   * The promise will resolve after the `parent` promise (if any) and all promises 
   * returned by injectables have been resolved. If any invocable 
   * (or `$injector.invoke`) throws an exception, or if a promise returned by an 
   * invocable is rejected, the `$resolve` promise is immediately rejected with the 
   * same error. A rejection of a `parent` promise (if specified) will likewise be 
   * propagated immediately. Once the `$resolve` promise has been rejected, no 
   * further invocables will be called.
   * 
   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`
   * to throw an error. As a special case, an injectable can depend on a parameter 
   * with the same name as the injectable, which will be fulfilled from the `parent` 
   * injectable of the same name. This allows inherited values to be decorated. 
   * Note that in this case any other injectable in the same `$resolve` with the same
   * dependency would see the decorated value, not the inherited value.
   *
   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an 
   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) 
   * exception.
   *
   * Invocables are invoked eagerly as soon as all dependencies are available. 
   * This is true even for dependencies inherited from a `parent` call to `$resolve`.
   *
   * As a special case, an invocable can be a string, in which case it is taken to 
   * be a service name to be passed to `$injector.get()`. This is supported primarily 
   * for backwards-compatibility with the `resolve` property of `$routeProvider` 
   * routes.
   *
   * @param {object} invocables functions to invoke or 
   * `$injector` services to fetch.
   * @param {object} locals  values to make available to the injectables
   * @param {object} parent  a promise returned by another call to `$resolve`.
   * @param {object} self  the `this` for the invoked methods
   * @return {object} Promise for an object that contains the resolved return value
   * of all invocables, as well as any inherited and local values.
   */
  this.resolve = function (invocables, locals, parent, self) {
    return this.study(invocables)(locals, parent, self);
  };
}

angular.module('ui.router.util').service('$resolve', $Resolve);


/**
 * @ngdoc object
 * @name ui.router.util.$templateFactory
 *
 * @requires $http
 * @requires $templateCache
 * @requires $injector
 *
 * @description
 * Service. Manages loading of templates.
 */
$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
function $TemplateFactory(  $http,   $templateCache,   $injector) {

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromConfig
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template from a configuration object. 
   *
   * @param {object} config Configuration object for which to load a template. 
   * The following properties are search in the specified order, and the first one 
   * that is defined is used to create the template:
   *
   * @param {string|object} config.template html string template or function to 
   * load via {@link ui.router.util.$templateFactory#fromString fromString}.
   * @param {string|object} config.templateUrl url to load or a function returning 
   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.
   * @param {Function} config.templateProvider function to invoke via 
   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.
   * @param {object} params  Parameters to pass to the template function.
   * @param {object} locals Locals to pass to `invoke` if the template is loaded 
   * via a `templateProvider`. Defaults to `{ params: params }`.
   *
   * @return {string|object}  The template html as a string, or a promise for 
   * that string,or `null` if no template is configured.
   */
  this.fromConfig = function (config, params, locals) {
    return (
      isDefined(config.template) ? this.fromString(config.template, params) :
      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :
      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :
      null
    );
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromString
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template from a string or a function returning a string.
   *
   * @param {string|object} template html template as a string or function that 
   * returns an html template as a string.
   * @param {object} params Parameters to pass to the template function.
   *
   * @return {string|object} The template html as a string, or a promise for that 
   * string.
   */
  this.fromString = function (template, params) {
    return isFunction(template) ? template(params) : template;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromUrl
   * @methodOf ui.router.util.$templateFactory
   * 
   * @description
   * Loads a template from the a URL via `$http` and `$templateCache`.
   *
   * @param {string|Function} url url of the template to load, or a function 
   * that returns a url.
   * @param {Object} params Parameters to pass to the url function.
   * @return {string|Promise.<string>} The template html as a string, or a promise 
   * for that string.
   */
  this.fromUrl = function (url, params) {
    if (isFunction(url)) url = url(params);
    if (url == null) return null;
    else return $http
        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})
        .then(function(response) { return response.data; });
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromProvider
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template by invoking an injectable provider function.
   *
   * @param {Function} provider Function to invoke via `$injector.invoke`
   * @param {Object} params Parameters for the template.
   * @param {Object} locals Locals to pass to `invoke`. Defaults to 
   * `{ params: params }`.
   * @return {string|Promise.<string>} The template html as a string, or a promise 
   * for that string.
   */
  this.fromProvider = function (provider, params, locals) {
    return $injector.invoke(provider, null, locals || { params: params });
  };
}

angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);

var $$UMFP; // reference to $UrlMatcherFactoryProvider

/**
 * @ngdoc object
 * @name ui.router.util.type:UrlMatcher
 *
 * @description
 * Matches URLs against patterns and extracts named parameters from the path or the search
 * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list
 * of search parameters. Multiple search parameter names are separated by '&'. Search parameters
 * do not influence whether or not a URL is matched, but their values are passed through into
 * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.
 *
 * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace
 * syntax, which optionally allows a regular expression for the parameter to be specified:
 *
 * * `':'` name - colon placeholder
 * * `'*'` name - catch-all placeholder
 * * `'{' name '}'` - curly placeholder
 * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the
 *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
 *
 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
 * must be unique within the pattern (across both path and search parameters). For colon
 * placeholders or curly placeholders without an explicit regexp, a path parameter matches any
 * number of characters other than '/'. For catch-all placeholders the path parameter matches
 * any number of characters.
 *
 * Examples:
 *
 * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
 * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
 * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
 * * `'/user/{id:[^/]*}'` - Same as the previous example.
 * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
 *   parameter consists of 1 to 8 hex digits.
 * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
 *   path into the parameter 'path'.
 * * `'/files/*path'` - ditto.
 * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
 *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start
 *
 * @param {string} pattern  The pattern to compile into a matcher.
 * @param {Object} config  A configuration object hash:
 * @param {Object=} parentMatcher Used to concatenate the pattern/config onto
 *   an existing UrlMatcher
 *
 * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.
 * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.
 *
 * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any
 *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns
 *   non-null) will start with this prefix.
 *
 * @property {string} source  The pattern that was passed into the constructor
 *
 * @property {string} sourcePath  The path portion of the source property
 *
 * @property {string} sourceSearch  The search portion of the source property
 *
 * @property {string} regex  The constructed regex that will be used to match against the url when
 *   it is time to determine which url will match.
 *
 * @returns {Object}  New `UrlMatcher` object
 */
function UrlMatcher(pattern, config, parentMatcher) {
  config = extend({ params: {} }, isObject(config) ? config : {});

  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
  //   '*' name
  //   ':' name
  //   '{' name '}'
  //   '{' name ':' regexp '}'
  // The regular expression is somewhat complicated due to the need to allow curly braces
  // inside the regular expression. The placeholder regexp breaks down as follows:
  //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
  //    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
  //    [^{}\\]+                       - anything other than curly braces or backslash
  //    \\.                            - a backslash escape
  //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
  var placeholder       = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      compiled = '^', last = 0, m,
      segments = this.segments = [],
      parentParams = parentMatcher ? parentMatcher.params : {},
      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
      paramNames = [];

  function addParameter(id, type, config, location) {
    paramNames.push(id);
    if (parentParams[id]) return parentParams[id];
    if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
    if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
    params[id] = new $$UMFP.Param(id, type, config, location);
    return params[id];
  }

  function quoteRegExp(string, pattern, squash, optional) {
    var surroundPattern = ['',''], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
    if (!pattern) return result;
    switch(squash) {
      case false: surroundPattern = ['(', ')' + (optional ? "?" : "")]; break;
      case true:
        result = result.replace(/\/$/, '');
        surroundPattern = ['(?:\/(', ')|\/)?'];
      break;
      default:    surroundPattern = ['(' + squash + "|", ')?']; break;
    }
    return result + surroundPattern[0] + pattern + surroundPattern[1];
  }

  this.source = pattern;

  // Split into static segments separated by path parameter placeholders.
  // The number of segments is always 1 more than the number of parameters.
  function matchDetails(m, isSearch) {
    var id, regexp, segment, type, cfg, arrayMode;
    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null
    cfg         = config.params[id];
    segment     = pattern.substring(last, m.index);
    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);

    if (regexp) {
      type      = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });
    }

    return {
      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg
    };
  }

  var p, param, segment;
  while ((m = placeholder.exec(pattern))) {
    p = matchDetails(m, false);
    if (p.segment.indexOf('?') >= 0) break; // we're into the search part

    param = addParameter(p.id, p.type, p.cfg, "path");
    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
    segments.push(p.segment);
    last = placeholder.lastIndex;
  }
  segment = pattern.substring(last);

  // Find any search parameter names and remove them from the last segment
  var i = segment.indexOf('?');

  if (i >= 0) {
    var search = this.sourceSearch = segment.substring(i);
    segment = segment.substring(0, i);
    this.sourcePath = pattern.substring(0, last + i);

    if (search.length > 0) {
      last = 0;
      while ((m = searchPlaceholder.exec(search))) {
        p = matchDetails(m, true);
        param = addParameter(p.id, p.type, p.cfg, "search");
        last = placeholder.lastIndex;
        // check if ?&
      }
    }
  } else {
    this.sourcePath = pattern;
    this.sourceSearch = '';
  }

  compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
  segments.push(segment);

  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
  this.prefix = segments[0];
  this.$$paramNames = paramNames;
}

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#concat
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Returns a new matcher for a pattern constructed by appending the path part and adding the
 * search parameters of the specified pattern to this pattern. The current pattern is not
 * modified. This can be understood as creating a pattern for URLs that are relative to (or
 * suffixes of) the current pattern.
 *
 * @example
 * The following two matchers are equivalent:
 * <pre>
 * new UrlMatcher('/user/{id}?q').concat('/details?date');
 * new UrlMatcher('/user/{id}/details?q&date');
 * </pre>
 *
 * @param {string} pattern  The pattern to append.
 * @param {Object} config  An object hash of the configuration for the matcher.
 * @returns {UrlMatcher}  A matcher for the concatenated pattern.
 */
UrlMatcher.prototype.concat = function (pattern, config) {
  // Because order of search parameters is irrelevant, we can add our own search
  // parameters to the end of the new pattern. Parse the new pattern by itself
  // and then join the bits together, but it's much easier to do this on a string level.
  var defaultConfig = {
    caseInsensitive: $$UMFP.caseInsensitive(),
    strict: $$UMFP.strictMode(),
    squash: $$UMFP.defaultSquashPolicy()
  };
  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
};

UrlMatcher.prototype.toString = function () {
  return this.source;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#exec
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Tests the specified path against this matcher, and returns an object containing the captured
 * parameter values, or null if the path does not match. The returned object contains the values
 * of any search parameters that are mentioned in the pattern, but their value may be null if
 * they are not present in `searchParams`. This means that search parameters are always treated
 * as optional.
 *
 * @example
 * <pre>
 * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
 *   x: '1', q: 'hello'
 * });
 * // returns { id: 'bob', q: 'hello', r: null }
 * </pre>
 *
 * @param {string} path  The URL path to match, e.g. `$location.path()`.
 * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.
 * @returns {Object}  The captured parameter values.
 */
UrlMatcher.prototype.exec = function (path, searchParams) {
  var m = this.regexp.exec(path);
  if (!m) return null;
  searchParams = searchParams || {};

  var paramNames = this.parameters(), nTotal = paramNames.length,
    nPath = this.segments.length - 1,
    values = {}, i, j, cfg, paramName;

  if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");

  function decodePathArray(string) {
    function reverseString(str) { return str.split("").reverse().join(""); }
    function unquoteDashes(str) { return str.replace(/\\-/g, "-"); }

    var split = reverseString(string).split(/-(?!\\)/);
    var allReversed = map(split, reverseString);
    return map(allReversed, unquoteDashes).reverse();
  }

  var param, paramVal;
  for (i = 0; i < nPath; i++) {
    paramName = paramNames[i];
    param = this.params[paramName];
    paramVal = m[i+1];
    // if the param value matches a pre-replace pair, replace the value before decoding.
    for (j = 0; j < param.replace.length; j++) {
      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
    }
    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);
    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
    values[paramName] = param.value(paramVal);
  }
  for (/**/; i < nTotal; i++) {
    paramName = paramNames[i];
    values[paramName] = this.params[paramName].value(searchParams[paramName]);
    param = this.params[paramName];
    paramVal = searchParams[paramName];
    for (j = 0; j < param.replace.length; j++) {
      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
    }
    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
    values[paramName] = param.value(paramVal);
  }

  return values;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#parameters
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Returns the names of all path and search parameters of this pattern in an unspecified order.
 *
 * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the
 *    pattern has no parameters, an empty array is returned.
 */
UrlMatcher.prototype.parameters = function (param) {
  if (!isDefined(param)) return this.$$paramNames;
  return this.params[param] || null;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#validates
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Checks an object hash of parameters to validate their correctness according to the parameter
 * types of this `UrlMatcher`.
 *
 * @param {Object} params The object hash of parameters to validate.
 * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.
 */
UrlMatcher.prototype.validates = function (params) {
  return this.params.$$validates(params);
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#format
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Creates a URL that matches this pattern by substituting the specified values
 * for the path and search parameters. Null values for path parameters are
 * treated as empty strings.
 *
 * @example
 * <pre>
 * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
 * // returns '/user/bob?q=yes'
 * </pre>
 *
 * @param {Object} values  the values to substitute for the parameters in this pattern.
 * @returns {string}  the formatted URL (path and optionally search part).
 */
UrlMatcher.prototype.format = function (values) {
  values = values || {};
  var segments = this.segments, params = this.parameters(), paramset = this.params;
  if (!this.validates(values)) return null;

  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];

  function encodeDashes(str) { // Replace dashes with encoded "\-"
    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });
  }

  for (i = 0; i < nTotal; i++) {
    var isPathParam = i < nPath;
    var name = params[i], param = paramset[name], value = param.value(values[name]);
    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
    var squash = isDefaultValue ? param.squash : false;
    var encoded = param.type.encode(value);

    if (isPathParam) {
      var nextSegment = segments[i + 1];
      var isFinalPathParam = i + 1 === nPath;

      if (squash === false) {
        if (encoded != null) {
          if (isArray(encoded)) {
            result += map(encoded, encodeDashes).join("-");
          } else {
            result += encodeURIComponent(encoded);
          }
        }
        result += nextSegment;
      } else if (squash === true) {
        var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
        result += nextSegment.match(capture)[1];
      } else if (isString(squash)) {
        result += squash + nextSegment;
      }

      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);
    } else {
      if (encoded == null || (isDefaultValue && squash !== false)) continue;
      if (!isArray(encoded)) encoded = [ encoded ];
      if (encoded.length === 0) continue;
      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
      result += (search ? '&' : '?') + (name + '=' + encoded);
      search = true;
    }
  }

  return result;
};

/**
 * @ngdoc object
 * @name ui.router.util.type:Type
 *
 * @description
 * Implements an interface to define custom parameter types that can be decoded from and encoded to
 * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}
 * objects when matching or formatting URLs, or comparing or validating parameter values.
 *
 * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more
 * information on registering custom types.
 *
 * @param {Object} config  A configuration object which contains the custom type definition.  The object's
 *        properties will override the default methods and/or pattern in `Type`'s public interface.
 * @example
 * <pre>
 * {
 *   decode: function(val) { return parseInt(val, 10); },
 *   encode: function(val) { return val && val.toString(); },
 *   equals: function(a, b) { return this.is(a) && a === b; },
 *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },
 *   pattern: /\d+/
 * }
 * </pre>
 *
 * @property {RegExp} pattern The regular expression pattern used to match values of this type when
 *           coming from a substring of a URL.
 *
 * @returns {Object}  Returns a new `Type` object.
 */
function Type(config) {
  extend(this, config);
}

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#is
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Detects whether a value is of a particular type. Accepts a native (decoded) value
 * and determines whether it matches the current `Type` object.
 *
 * @param {*} val  The value to check.
 * @param {string} key  Optional. If the type check is happening in the context of a specific
 *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the
 *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.
 * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.
 */
Type.prototype.is = function(val, key) {
  return true;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#encode
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the
 * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it
 * only needs to be a representation of `val` that has been coerced to a string.
 *
 * @param {*} val  The value to encode.
 * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
 *        meta-programming of `Type` objects.
 * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.
 */
Type.prototype.encode = function(val, key) {
  return val;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#decode
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Converts a parameter value (from URL string or transition param) to a custom/native value.
 *
 * @param {string} val  The URL parameter value to decode.
 * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
 *        meta-programming of `Type` objects.
 * @returns {*}  Returns a custom representation of the URL parameter value.
 */
Type.prototype.decode = function(val, key) {
  return val;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#equals
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Determines whether two decoded values are equivalent.
 *
 * @param {*} a  A value to compare against.
 * @param {*} b  A value to compare against.
 * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.
 */
Type.prototype.equals = function(a, b) {
  return a == b;
};

Type.prototype.$subPattern = function() {
  var sub = this.pattern.toString();
  return sub.substr(1, sub.length - 2);
};

Type.prototype.pattern = /.*/;

Type.prototype.toString = function() { return "{Type:" + this.name + "}"; };

/** Given an encoded string, or a decoded object, returns a decoded object */
Type.prototype.$normalize = function(val) {
  return this.is(val) ? val : this.decode(val);
};

/*
 * Wraps an existing custom Type as an array of Type, depending on 'mode'.
 * e.g.:
 * - urlmatcher pattern "/path?{queryParam[]:int}"
 * - url: "/path?queryParam=1&queryParam=2
 * - $stateParams.queryParam will be [1, 2]
 * if `mode` is "auto", then
 * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
 * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
 */
Type.prototype.$asArray = function(mode, isSearch) {
  if (!mode) return this;
  if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");

  function ArrayType(type, mode) {
    function bindTo(type, callbackName) {
      return function() {
        return type[callbackName].apply(type, arguments);
      };
    }

    // Wrap non-array value as array
    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }
    // Unwrap array value for "auto" mode. Return undefined for empty array.
    function arrayUnwrap(val) {
      switch(val.length) {
        case 0: return undefined;
        case 1: return mode === "auto" ? val[0] : val;
        default: return val;
      }
    }
    function falsey(val) { return !val; }

    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
    function arrayHandler(callback, allTruthyMode) {
      return function handleArray(val) {
        if (isArray(val) && val.length === 0) return val;
        val = arrayWrap(val);
        var result = map(val, callback);
        if (allTruthyMode === true)
          return filter(result, falsey).length === 0;
        return arrayUnwrap(result);
      };
    }

    // Wraps type (.equals) functions to operate on each value of an array
    function arrayEqualsHandler(callback) {
      return function handleArray(val1, val2) {
        var left = arrayWrap(val1), right = arrayWrap(val2);
        if (left.length !== right.length) return false;
        for (var i = 0; i < left.length; i++) {
          if (!callback(left[i], right[i])) return false;
        }
        return true;
      };
    }

    this.encode = arrayHandler(bindTo(type, 'encode'));
    this.decode = arrayHandler(bindTo(type, 'decode'));
    this.is     = arrayHandler(bindTo(type, 'is'), true);
    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
    this.pattern = type.pattern;
    this.$normalize = arrayHandler(bindTo(type, '$normalize'));
    this.name = type.name;
    this.$arrayMode = mode;
  }

  return new ArrayType(this, mode);
};



/**
 * @ngdoc object
 * @name ui.router.util.$urlMatcherFactory
 *
 * @description
 * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory
 * is also available to providers under the name `$urlMatcherFactoryProvider`.
 */
function $UrlMatcherFactory() {
  $$UMFP = this;

  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;

  // Use tildes to pre-encode slashes.
  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,
  // and bidirectional encoding/decoding fails.
  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character
  function valToString(val) { return val != null ? val.toString().replace(/~/g, "~~").replace(/\//g, "~2F") : val; }
  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, "/").replace(/~~/g, "~") : val; }

  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
    "string": {
      encode: valToString,
      decode: valFromString,
      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.
      // In 0.2.x, string params are optional by default for backwards compat
      is: function(val) { return val == null || !isDefined(val) || typeof val === "string"; },
      pattern: /[^/]*/
    },
    "int": {
      encode: valToString,
      decode: function(val) { return parseInt(val, 10); },
      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },
      pattern: /\d+/
    },
    "bool": {
      encode: function(val) { return val ? 1 : 0; },
      decode: function(val) { return parseInt(val, 10) !== 0; },
      is: function(val) { return val === true || val === false; },
      pattern: /0|1/
    },
    "date": {
      encode: function (val) {
        if (!this.is(val))
          return undefined;
        return [ val.getFullYear(),
          ('0' + (val.getMonth() + 1)).slice(-2),
          ('0' + val.getDate()).slice(-2)
        ].join("-");
      },
      decode: function (val) {
        if (this.is(val)) return val;
        var match = this.capture.exec(val);
        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
      },
      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },
      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },
      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
    },
    "json": {
      encode: angular.toJson,
      decode: angular.fromJson,
      is: angular.isObject,
      equals: angular.equals,
      pattern: /[^/]*/
    },
    "any": { // does not encode/decode
      encode: angular.identity,
      decode: angular.identity,
      equals: angular.equals,
      pattern: /.*/
    }
  };

  function getDefaultConfig() {
    return {
      strict: isStrictMode,
      caseInsensitive: isCaseInsensitive
    };
  }

  function isInjectable(value) {
    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
  }

  /**
   * [Internal] Get the default value of a parameter, which may be an injectable function.
   */
  $UrlMatcherFactory.$$getDefaultValue = function(config) {
    if (!isInjectable(config.value)) return config.value;
    if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
    return injector.invoke(config.value);
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#caseInsensitive
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Defines whether URL matching should be case sensitive (the default behavior), or not.
   *
   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;
   * @returns {boolean} the current value of caseInsensitive
   */
  this.caseInsensitive = function(value) {
    if (isDefined(value))
      isCaseInsensitive = value;
    return isCaseInsensitive;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#strictMode
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Defines whether URLs should match trailing slashes, or not (the default behavior).
   *
   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.
   * @returns {boolean} the current value of strictMode
   */
  this.strictMode = function(value) {
    if (isDefined(value))
      isStrictMode = value;
    return isStrictMode;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Sets the default behavior when generating or matching URLs with default parameter values.
   *
   * @param {string} value A string that defines the default parameter URL squashing behavior.
   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
   *             parameter is surrounded by slashes, squash (remove) one slash from the URL
   *    any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
   *             the parameter value from the URL and replace it with this string.
   */
  this.defaultSquashPolicy = function(value) {
    if (!isDefined(value)) return defaultSquashPolicy;
    if (value !== true && value !== false && !isString(value))
      throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
    defaultSquashPolicy = value;
    return value;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#compile
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.
   *
   * @param {string} pattern  The URL pattern.
   * @param {Object} config  The config object hash.
   * @returns {UrlMatcher}  The UrlMatcher.
   */
  this.compile = function (pattern, config) {
    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#isMatcher
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.
   *
   * @param {Object} object  The object to perform the type check against.
   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by
   *          implementing all the same methods.
   */
  this.isMatcher = function (o) {
    if (!isObject(o)) return false;
    var result = true;

    forEach(UrlMatcher.prototype, function(val, name) {
      if (isFunction(val)) {
        result = result && (isDefined(o[name]) && isFunction(o[name]));
      }
    });
    return result;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#type
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to
   * generate URLs with typed parameters.
   *
   * @param {string} name  The type name.
   * @param {Object|Function} definition   The type definition. See
   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.
   * @param {Object|Function} definitionFn (optional) A function that is injected before the app
   *        runtime starts.  The result of this function is merged into the existing `definition`.
   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.
   *
   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.
   *
   * @example
   * This is a simple example of a custom type that encodes and decodes items from an
   * array, using the array index as the URL-encoded value:
   *
   * <pre>
   * var list = ['John', 'Paul', 'George', 'Ringo'];
   *
   * $urlMatcherFactoryProvider.type('listItem', {
   *   encode: function(item) {
   *     // Represent the list item in the URL using its corresponding index
   *     return list.indexOf(item);
   *   },
   *   decode: function(item) {
   *     // Look up the list item by index
   *     return list[parseInt(item, 10)];
   *   },
   *   is: function(item) {
   *     // Ensure the item is valid by checking to see that it appears
   *     // in the list
   *     return list.indexOf(item) > -1;
   *   }
   * });
   *
   * $stateProvider.state('list', {
   *   url: "/list/{item:listItem}",
   *   controller: function($scope, $stateParams) {
   *     console.log($stateParams.item);
   *   }
   * });
   *
   * // ...
   *
   * // Changes URL to '/list/3', logs "Ringo" to the console
   * $state.go('list', { item: "Ringo" });
   * </pre>
   *
   * This is a more complex example of a type that relies on dependency injection to
   * interact with services, and uses the parameter name from the URL to infer how to
   * handle encoding and decoding parameter values:
   *
   * <pre>
   * // Defines a custom type that gets a value from a service,
   * // where each service gets different types of values from
   * // a backend API:
   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {
   *
   *   // Matches up services to URL parameter names
   *   var services = {
   *     user: Users,
   *     post: Posts
   *   };
   *
   *   return {
   *     encode: function(object) {
   *       // Represent the object in the URL using its unique ID
   *       return object.id;
   *     },
   *     decode: function(value, key) {
   *       // Look up the object by ID, using the parameter
   *       // name (key) to call the correct service
   *       return services[key].findById(value);
   *     },
   *     is: function(object, key) {
   *       // Check that object is a valid dbObject
   *       return angular.isObject(object) && object.id && services[key];
   *     }
   *     equals: function(a, b) {
   *       // Check the equality of decoded objects by comparing
   *       // their unique IDs
   *       return a.id === b.id;
   *     }
   *   };
   * });
   *
   * // In a config() block, you can then attach URLs with
   * // type-annotated parameters:
   * $stateProvider.state('users', {
   *   url: "/users",
   *   // ...
   * }).state('users.item', {
   *   url: "/{user:dbObject}",
   *   controller: function($scope, $stateParams) {
   *     // $stateParams.user will now be an object returned from
   *     // the Users service
   *   },
   *   // ...
   * });
   * </pre>
   */
  this.type = function (name, definition, definitionFn) {
    if (!isDefined(definition)) return $types[name];
    if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");

    $types[name] = new Type(extend({ name: name }, definition));
    if (definitionFn) {
      typeQueue.push({ name: name, def: definitionFn });
      if (!enqueue) flushTypeQueue();
    }
    return this;
  };

  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s
  function flushTypeQueue() {
    while(typeQueue.length) {
      var type = typeQueue.shift();
      if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
      angular.extend($types[type.name], injector.invoke(type.def));
    }
  }

  // Register default types. Store them in the prototype of $types.
  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });
  $types = inherit($types, {});

  /* No need to document $get, since it returns this */
  this.$get = ['$injector', function ($injector) {
    injector = $injector;
    enqueue = false;
    flushTypeQueue();

    forEach(defaultTypes, function(type, name) {
      if (!$types[name]) $types[name] = new Type(type);
    });
    return this;
  }];

  this.Param = function Param(id, type, config, location) {
    var self = this;
    config = unwrapShorthand(config);
    type = getType(config, type, location);
    var arrayMode = getArrayMode();
    type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
    if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
      config.value = ""; // for 0.2.x; in 0.3.0+ do not automatically default to ""
    var isOptional = config.value !== undefined;
    var squash = getSquashPolicy(config, isOptional);
    var replace = getReplace(config, arrayMode, isOptional, squash);

    function unwrapShorthand(config) {
      var keys = isObject(config) ? objectKeys(config) : [];
      var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 &&
                        indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
      if (isShorthand) config = { value: config };
      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };
      return config;
    }

    function getType(config, urlType, location) {
      if (config.type && urlType) throw new Error("Param '"+id+"' has two type configurations.");
      if (urlType) return urlType;
      if (!config.type) return (location === "config" ? $types.any : $types.string);

      if (angular.isString(config.type))
        return $types[config.type];
      if (config.type instanceof Type)
        return config.type;
      return new Type(config.type);
    }

    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
    function getArrayMode() {
      var arrayDefaults = { array: (location === "search" ? "auto" : false) };
      var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
      return extend(arrayDefaults, arrayParamNomenclature, config).array;
    }

    /**
     * returns false, true, or the squash value to indicate the "default parameter url squash policy".
     */
    function getSquashPolicy(config, isOptional) {
      var squash = config.squash;
      if (!isOptional || squash === false) return false;
      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
      if (squash === true || isString(squash)) return squash;
      throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
    }

    function getReplace(config, arrayMode, isOptional, squash) {
      var replace, configuredKeys, defaultPolicy = [
        { from: "",   to: (isOptional || arrayMode ? undefined : "") },
        { from: null, to: (isOptional || arrayMode ? undefined : "") }
      ];
      replace = isArray(config.replace) ? config.replace : [];
      if (isString(squash))
        replace.push({ from: squash, to: undefined });
      configuredKeys = map(replace, function(item) { return item.from; } );
      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);
    }

    /**
     * [Internal] Get the default value of a parameter, which may be an injectable function.
     */
    function $$getDefaultValue() {
      if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
      var defaultValue = injector.invoke(config.$$fn);
      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
        throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
      return defaultValue;
    }

    /**
     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
     * default value, which may be the result of an injectable function.
     */
    function $value(value) {
      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }
      function $replace(value) {
        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });
        return replacement.length ? replacement[0] : value;
      }
      value = $replace(value);
      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
    }

    function toString() { return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}"; }

    extend(this, {
      id: id,
      type: type,
      location: location,
      array: arrayMode,
      squash: squash,
      replace: replace,
      isOptional: isOptional,
      value: $value,
      dynamic: undefined,
      config: config,
      toString: toString
    });
  };

  function ParamSet(params) {
    extend(this, params || {});
  }

  ParamSet.prototype = {
    $$new: function() {
      return inherit(this, extend(new ParamSet(), { $$parent: this}));
    },
    $$keys: function () {
      var keys = [], chain = [], parent = this,
        ignore = objectKeys(ParamSet.prototype);
      while (parent) { chain.push(parent); parent = parent.$$parent; }
      chain.reverse();
      forEach(chain, function(paramset) {
        forEach(objectKeys(paramset), function(key) {
            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);
        });
      });
      return keys;
    },
    $$values: function(paramValues) {
      var values = {}, self = this;
      forEach(self.$$keys(), function(key) {
        values[key] = self[key].value(paramValues && paramValues[key]);
      });
      return values;
    },
    $$equals: function(paramValues1, paramValues2) {
      var equal = true, self = this;
      forEach(self.$$keys(), function(key) {
        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
        if (!self[key].type.equals(left, right)) equal = false;
      });
      return equal;
    },
    $$validates: function $$validate(paramValues) {
      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;
      for (i = 0; i < keys.length; i++) {
        param = this[keys[i]];
        rawVal = paramValues[keys[i]];
        if ((rawVal === undefined || rawVal === null) && param.isOptional)
          break; // There was no parameter value, but the param is optional
        normalized = param.type.$normalize(rawVal);
        if (!param.type.is(normalized))
          return false; // The value was not of the correct Type, and could not be decoded to the correct Type
        encoded = param.type.encode(normalized);
        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp
      }
      return true;
    },
    $$parent: undefined
  };

  this.ParamSet = ParamSet;
}

// Register as a provider so it's available to other providers
angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);

/**
 * @ngdoc object
 * @name ui.router.router.$urlRouterProvider
 *
 * @requires ui.router.util.$urlMatcherFactoryProvider
 * @requires $locationProvider
 *
 * @description
 * `$urlRouterProvider` has the responsibility of watching `$location`. 
 * When `$location` changes it runs through a list of rules one by one until a 
 * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify 
 * a url in a state configuration. All urls are compiled into a UrlMatcher object.
 *
 * There are several methods on `$urlRouterProvider` that make it useful to use directly
 * in your module config.
 */
$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
function $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {
  var rules = [], otherwise = null, interceptDeferred = false, listener;

  // Returns a string that is a prefix of all strings matching the RegExp
  function regExpPrefix(re) {
    var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
    return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
  }

  // Interpolates matched values into a String.replace()-style pattern
  function interpolate(pattern, match) {
    return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
      return match[what === '$' ? 0 : Number(what)];
    });
  }

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#rule
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Defines rules that are used by `$urlRouterProvider` to find matches for
   * specific URLs.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   // Here's an example of how you might allow case insensitive urls
   *   $urlRouterProvider.rule(function ($injector, $location) {
   *     var path = $location.path(),
   *         normalized = path.toLowerCase();
   *
   *     if (path !== normalized) {
   *       return normalized;
   *     }
   *   });
   * });
   * </pre>
   *
   * @param {function} rule Handler function that takes `$injector` and `$location`
   * services as arguments. You can use them to return a valid path as a string.
   *
   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
   */
  this.rule = function (rule) {
    if (!isFunction(rule)) throw new Error("'rule' must be a function");
    rules.push(rule);
    return this;
  };

  /**
   * @ngdoc object
   * @name ui.router.router.$urlRouterProvider#otherwise
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Defines a path that is used when an invalid route is requested.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   // if the path doesn't match any of the urls you configured
   *   // otherwise will take care of routing the user to the
   *   // specified url
   *   $urlRouterProvider.otherwise('/index');
   *
   *   // Example of using function rule as param
   *   $urlRouterProvider.otherwise(function ($injector, $location) {
   *     return '/a/valid/url';
   *   });
   * });
   * </pre>
   *
   * @param {string|function} rule The url path you want to redirect to or a function 
   * rule that returns the url path. The function version is passed two params: 
   * `$injector` and `$location` services, and must return a url string.
   *
   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
   */
  this.otherwise = function (rule) {
    if (isString(rule)) {
      var redirect = rule;
      rule = function () { return redirect; };
    }
    else if (!isFunction(rule)) throw new Error("'rule' must be a function");
    otherwise = rule;
    return this;
  };


  function handleIfMatch($injector, handler, match) {
    if (!match) return false;
    var result = $injector.invoke(handler, handler, { $match: match });
    return isDefined(result) ? result : true;
  }

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#when
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Registers a handler for a given url matching. 
   * 
   * If the handler is a string, it is
   * treated as a redirect, and is interpolated according to the syntax of match
   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).
   *
   * If the handler is a function, it is injectable. It gets invoked if `$location`
   * matches. You have the option of inject the match object as `$match`.
   *
   * The handler can return
   *
   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
   *   will continue trying to find another one that matches.
   * - **string** which is treated as a redirect and passed to `$location.url()`
   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
   *     if ($state.$current.navigable !== state ||
   *         !equalForKeys($match, $stateParams) {
   *      $state.transitionTo(state, $match, false);
   *     }
   *   });
   * });
   * </pre>
   *
   * @param {string|object} what The incoming path that you want to redirect.
   * @param {string|function} handler The path you want to redirect your user to.
   */
  this.when = function (what, handler) {
    var redirect, handlerIsString = isString(handler);
    if (isString(what)) what = $urlMatcherFactory.compile(what);

    if (!handlerIsString && !isFunction(handler) && !isArray(handler))
      throw new Error("invalid 'handler' in when()");

    var strategies = {
      matcher: function (what, handler) {
        if (handlerIsString) {
          redirect = $urlMatcherFactory.compile(handler);
          handler = ['$match', function ($match) { return redirect.format($match); }];
        }
        return extend(function ($injector, $location) {
          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
        }, {
          prefix: isString(what.prefix) ? what.prefix : ''
        });
      },
      regex: function (what, handler) {
        if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");

        if (handlerIsString) {
          redirect = handler;
          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];
        }
        return extend(function ($injector, $location) {
          return handleIfMatch($injector, handler, what.exec($location.path()));
        }, {
          prefix: regExpPrefix(what)
        });
      }
    };

    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };

    for (var n in check) {
      if (check[n]) return this.rule(strategies[n](what, handler));
    }

    throw new Error("invalid 'what' in when()");
  };

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#deferIntercept
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Disables (or enables) deferring location change interception.
   *
   * If you wish to customize the behavior of syncing the URL (for example, if you wish to
   * defer a transition but maintain the current URL), call this method at configuration time.
   * Then, at run time, call `$urlRouter.listen()` after you have configured your own
   * `$locationChangeSuccess` event handler.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *
   *   // Prevent $urlRouter from automatically intercepting URL changes;
   *   // this allows you to configure custom behavior in between
   *   // location changes and route synchronization:
   *   $urlRouterProvider.deferIntercept();
   *
   * }).run(function ($rootScope, $urlRouter, UserService) {
   *
   *   $rootScope.$on('$locationChangeSuccess', function(e) {
   *     // UserService is an example service for managing user state
   *     if (UserService.isLoggedIn()) return;
   *
   *     // Prevent $urlRouter's default handler from firing
   *     e.preventDefault();
   *
   *     UserService.handleLogin().then(function() {
   *       // Once the user has logged in, sync the current URL
   *       // to the router:
   *       $urlRouter.sync();
   *     });
   *   });
   *
   *   // Configures $urlRouter's listener *after* your custom listener
   *   $urlRouter.listen();
   * });
   * </pre>
   *
   * @param {boolean} defer Indicates whether to defer location change interception. Passing
            no parameter is equivalent to `true`.
   */
  this.deferIntercept = function (defer) {
    if (defer === undefined) defer = true;
    interceptDeferred = defer;
  };

  /**
   * @ngdoc object
   * @name ui.router.router.$urlRouter
   *
   * @requires $location
   * @requires $rootScope
   * @requires $injector
   * @requires $browser
   *
   * @description
   *
   */
  this.$get = $get;
  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];
  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {

    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;

    function appendBasePath(url, isHtml5, absolute) {
      if (baseHref === '/') return url;
      if (isHtml5) return baseHref.slice(0, -1) + url;
      if (absolute) return baseHref.slice(1) + url;
      return url;
    }

    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
    function update(evt) {
      if (evt && evt.defaultPrevented) return;
      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
      lastPushedUrl = undefined;
      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573
      //if (ignoreUpdate) return true;

      function check(rule) {
        var handled = rule($injector, $location);

        if (!handled) return false;
        if (isString(handled)) $location.replace().url(handled);
        return true;
      }
      var n = rules.length, i;

      for (i = 0; i < n; i++) {
        if (check(rules[i])) return;
      }
      // always check otherwise last to allow dynamic updates to the set of rules
      if (otherwise) check(otherwise);
    }

    function listen() {
      listener = listener || $rootScope.$on('$locationChangeSuccess', update);
      return listener;
    }

    if (!interceptDeferred) listen();

    return {
      /**
       * @ngdoc function
       * @name ui.router.router.$urlRouter#sync
       * @methodOf ui.router.router.$urlRouter
       *
       * @description
       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.
       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,
       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed
       * with the transition by calling `$urlRouter.sync()`.
       *
       * @example
       * <pre>
       * angular.module('app', ['ui.router'])
       *   .run(function($rootScope, $urlRouter) {
       *     $rootScope.$on('$locationChangeSuccess', function(evt) {
       *       // Halt state change from even starting
       *       evt.preventDefault();
       *       // Perform custom logic
       *       var meetsRequirement = ...
       *       // Continue with the update and state transition if logic allows
       *       if (meetsRequirement) $urlRouter.sync();
       *     });
       * });
       * </pre>
       */
      sync: function() {
        update();
      },

      listen: function() {
        return listen();
      },

      update: function(read) {
        if (read) {
          location = $location.url();
          return;
        }
        if ($location.url() === location) return;

        $location.url(location);
        $location.replace();
      },

      push: function(urlMatcher, params, options) {
         var url = urlMatcher.format(params || {});

        // Handle the special hash param, if needed
        if (url !== null && params && params['#']) {
            url += '#' + params['#'];
        }

        $location.url(url);
        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
        if (options && options.replace) $location.replace();
      },

      /**
       * @ngdoc function
       * @name ui.router.router.$urlRouter#href
       * @methodOf ui.router.router.$urlRouter
       *
       * @description
       * A URL generation method that returns the compiled URL for a given
       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.
       *
       * @example
       * <pre>
       * $bob = $urlRouter.href(new UrlMatcher("/about/:person"), {
       *   person: "bob"
       * });
       * // $bob == "/about/bob";
       * </pre>
       *
       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.
       * @param {object=} params An object of parameter values to fill the matcher's required parameters.
       * @param {object=} options Options object. The options are:
       *
       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
       *
       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
       */
      href: function(urlMatcher, params, options) {
        if (!urlMatcher.validates(params)) return null;

        var isHtml5 = $locationProvider.html5Mode();
        if (angular.isObject(isHtml5)) {
          isHtml5 = isHtml5.enabled;
        }

        isHtml5 = isHtml5 && $sniffer.history;
        
        var url = urlMatcher.format(params);
        options = options || {};

        if (!isHtml5 && url !== null) {
          url = "#" + $locationProvider.hashPrefix() + url;
        }

        // Handle special hash param, if needed
        if (url !== null && params && params['#']) {
          url += '#' + params['#'];
        }

        url = appendBasePath(url, isHtml5, options.absolute);

        if (!options.absolute || !url) {
          return url;
        }

        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();
        port = (port === 80 || port === 443 ? '' : ':' + port);

        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
      }
    };
  }
}

angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);

/**
 * @ngdoc object
 * @name ui.router.state.$stateProvider
 *
 * @requires ui.router.router.$urlRouterProvider
 * @requires ui.router.util.$urlMatcherFactoryProvider
 *
 * @description
 * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely
 * on state.
 *
 * A state corresponds to a "place" in the application in terms of the overall UI and
 * navigation. A state describes (via the controller / template / view properties) what
 * the UI looks like and does at that place.
 *
 * States often have things in common, and the primary way of factoring out these
 * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
 * nested states.
 *
 * The `$stateProvider` provides interfaces to declare these states for your app.
 */
$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
function $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {

  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';

  // Builds state properties from definition passed to registerState()
  var stateBuilder = {

    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.
    // state.children = [];
    // if (parent) parent.children.push(state);
    parent: function(state) {
      if (isDefined(state.parent) && state.parent) return findState(state.parent);
      // regex matches any valid composite state name
      // would match "contact.list" but not "contacts"
      var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
      return compositeName ? findState(compositeName[1]) : root;
    },

    // inherit 'data' from parent and override by own values (if any)
    data: function(state) {
      if (state.parent && state.parent.data) {
        state.data = state.self.data = inherit(state.parent.data, state.data);
      }
      return state.data;
    },

    // Build a URLMatcher if necessary, either via a relative or absolute URL
    url: function(state) {
      var url = state.url, config = { params: state.params || {} };

      if (isString(url)) {
        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);
        return (state.parent.navigable || root).url.concat(url, config);
      }

      if (!url || $urlMatcherFactory.isMatcher(url)) return url;
      throw new Error("Invalid url '" + url + "' in state '" + state + "'");
    },

    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
    navigable: function(state) {
      return state.url ? state : (state.parent ? state.parent.navigable : null);
    },

    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params
    ownParams: function(state) {
      var params = state.url && state.url.params || new $$UMFP.ParamSet();
      forEach(state.params || {}, function(config, id) {
        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config");
      });
      return params;
    },

    // Derive parameters for this state and ensure they're a super-set of parent's parameters
    params: function(state) {
      var ownParams = pick(state.ownParams, state.ownParams.$$keys());
      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
    },

    // If there is no explicit multi-view configuration, make one up so we don't have
    // to handle both cases in the view directive later. Note that having an explicit
    // 'views' property will mean the default unnamed view properties are ignored. This
    // is also a good time to resolve view names to absolute names, so everything is a
    // straight lookup at link time.
    views: function(state) {
      var views = {};

      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {
        if (name.indexOf('@') < 0) name += '@' + state.parent.name;
        views[name] = view;
      });
      return views;
    },

    // Keep a full path from the root down to this state as this is needed for state activation.
    path: function(state) {
      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path
    },

    // Speed up $state.contains() as it's used a lot
    includes: function(state) {
      var includes = state.parent ? extend({}, state.parent.includes) : {};
      includes[state.name] = true;
      return includes;
    },

    $delegates: {}
  };

  function isRelative(stateName) {
    return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
  }

  function findState(stateOrName, base) {
    if (!stateOrName) return undefined;

    var isStr = isString(stateOrName),
        name  = isStr ? stateOrName : stateOrName.name,
        path  = isRelative(name);

    if (path) {
      if (!base) throw new Error("No reference point given for path '"  + name + "'");
      base = findState(base);
      
      var rel = name.split("."), i = 0, pathLength = rel.length, current = base;

      for (; i < pathLength; i++) {
        if (rel[i] === "" && i === 0) {
          current = base;
          continue;
        }
        if (rel[i] === "^") {
          if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
          current = current.parent;
          continue;
        }
        break;
      }
      rel = rel.slice(i).join(".");
      name = current.name + (current.name && rel ? "." : "") + rel;
    }
    var state = states[name];

    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
      return state;
    }
    return undefined;
  }

  function queueState(parentName, state) {
    if (!queue[parentName]) {
      queue[parentName] = [];
    }
    queue[parentName].push(state);
  }

  function flushQueuedChildren(parentName) {
    var queued = queue[parentName] || [];
    while(queued.length) {
      registerState(queued.shift());
    }
  }

  function registerState(state) {
    // Wrap a new object around the state so we can store our private details easily.
    state = inherit(state, {
      self: state,
      resolve: state.resolve || {},
      toString: function() { return this.name; }
    });

    var name = state.name;
    if (!isString(name) || name.indexOf('@') >= 0) throw new Error("State must have a valid name");
    if (states.hasOwnProperty(name)) throw new Error("State '" + name + "' is already defined");

    // Get parent name
    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))
        : (isString(state.parent)) ? state.parent
        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name
        : '';

    // If parent is not registered yet, add state to queue and register later
    if (parentName && !states[parentName]) {
      return queueState(parentName, state.self);
    }

    for (var key in stateBuilder) {
      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
    }
    states[name] = state;

    // Register the state in the global state list and with $urlRouter if necessary.
    if (!state[abstractKey] && state.url) {
      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {
        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
          $state.transitionTo(state, $match, { inherit: true, location: false });
        }
      }]);
    }

    // Register any queued children
    flushQueuedChildren(name);

    return state;
  }

  // Checks text to see if it looks like a glob.
  function isGlob (text) {
    return text.indexOf('*') > -1;
  }

  // Returns true if glob matches current $state name.
  function doesStateMatchGlob (glob) {
    var globSegments = glob.split('.'),
        segments = $state.$current.name.split('.');

    //match single stars
    for (var i = 0, l = globSegments.length; i < l; i++) {
      if (globSegments[i] === '*') {
        segments[i] = '*';
      }
    }

    //match greedy starts
    if (globSegments[0] === '**') {
       segments = segments.slice(indexOf(segments, globSegments[1]));
       segments.unshift('**');
    }
    //match greedy ends
    if (globSegments[globSegments.length - 1] === '**') {
       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
       segments.push('**');
    }

    if (globSegments.length != segments.length) {
      return false;
    }

    return segments.join('') === globSegments.join('');
  }


  // Implicit root state that is always active
  root = registerState({
    name: '',
    url: '^',
    views: null,
    'abstract': true
  });
  root.navigable = null;


  /**
   * @ngdoc function
   * @name ui.router.state.$stateProvider#decorator
   * @methodOf ui.router.state.$stateProvider
   *
   * @description
   * Allows you to extend (carefully) or override (at your own peril) the 
   * `stateBuilder` object used internally by `$stateProvider`. This can be used 
   * to add custom functionality to ui-router, for example inferring templateUrl 
   * based on the state name.
   *
   * When passing only a name, it returns the current (original or decorated) builder
   * function that matches `name`.
   *
   * The builder functions that can be decorated are listed below. Though not all
   * necessarily have a good use case for decoration, that is up to you to decide.
   *
   * In addition, users can attach custom decorators, which will generate new 
   * properties within the state's internal definition. There is currently no clear 
   * use-case for this beyond accessing internal states (i.e. $state.$current), 
   * however, expect this to become increasingly relevant as we introduce additional 
   * meta-programming features.
   *
   * **Warning**: Decorators should not be interdependent because the order of 
   * execution of the builder functions in non-deterministic. Builder functions 
   * should only be dependent on the state definition object and super function.
   *
   *
   * Existing builder functions and current return values:
   *
   * - **parent** `{object}` - returns the parent state object.
   * - **data** `{object}` - returns state data, including any inherited data that is not
   *   overridden by own values (if any).
   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
   *   or `null`.
   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is 
   *   navigable).
   * - **params** `{object}` - returns an array of state params that are ensured to 
   *   be a super-set of parent's params.
   * - **views** `{object}` - returns a views object where each key is an absolute view 
   *   name (i.e. "viewName@stateName") and each value is the config object 
   *   (template, controller) for the view. Even when you don't use the views object 
   *   explicitly on a state config, one is still created for you internally.
   *   So by decorating this builder function you have access to decorating template 
   *   and controller properties.
   * - **ownParams** `{object}` - returns an array of params that belong to the state, 
   *   not including any params defined by ancestor states.
   * - **path** `{string}` - returns the full path from the root down to this state. 
   *   Needed for state activation.
   * - **includes** `{object}` - returns an object that includes every state that 
   *   would pass a `$state.includes()` test.
   *
   * @example
   * <pre>
   * // Override the internal 'views' builder with a function that takes the state
   * // definition, and a reference to the internal function being overridden:
   * $stateProvider.decorator('views', function (state, parent) {
   *   var result = {},
   *       views = parent(state);
   *
   *   angular.forEach(views, function (config, name) {
   *     var autoName = (state.name + '.' + name).replace('.', '/');
   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
   *     result[name] = config;
   *   });
   *   return result;
   * });
   *
   * $stateProvider.state('home', {
   *   views: {
   *     'contact.list': { controller: 'ListController' },
   *     'contact.item': { controller: 'ItemController' }
   *   }
   * });
   *
   * // ...
   *
   * $state.go('home');
   * // Auto-populates list and item views with /partials/home/contact/list.html,
   * // and /partials/home/contact/item.html, respectively.
   * </pre>
   *
   * @param {string} name The name of the builder function to decorate. 
   * @param {object} func A function that is responsible for decorating the original 
   * builder function. The function receives two parameters:
   *
   *   - `{object}` - state - The state config object.
   *   - `{object}` - super - The original builder function.
   *
   * @return {object} $stateProvider - $stateProvider instance
   */
  this.decorator = decorator;
  function decorator(name, func) {
    /*jshint validthis: true */
    if (isString(name) && !isDefined(func)) {
      return stateBuilder[name];
    }
    if (!isFunction(func) || !isString(name)) {
      return this;
    }
    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
      stateBuilder.$delegates[name] = stateBuilder[name];
    }
    stateBuilder[name] = func;
    return this;
  }

  /**
   * @ngdoc function
   * @name ui.router.state.$stateProvider#state
   * @methodOf ui.router.state.$stateProvider
   *
   * @description
   * Registers a state configuration under a given state name. The stateConfig object
   * has the following acceptable properties.
   *
   * @param {string} name A unique state name, e.g. "home", "about", "contacts".
   * To create a parent/child state use a dot, e.g. "about.sales", "home.newest".
   * @param {object} stateConfig State configuration object.
   * @param {string|function=} stateConfig.template
   * <a id='template'></a>
   *   html template as a string or a function that returns
   *   an html template as a string which should be used by the uiView directives. This property 
   *   takes precedence over templateUrl.
   *   
   *   If `template` is a function, it will be called with the following parameters:
   *
   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by
   *     applying the current state
   *
   * <pre>template:
   *   "<h1>inline template definition</h1>" +
   *   "<div ui-view></div>"</pre>
   * <pre>template: function(params) {
   *       return "<h1>generated template</h1>"; }</pre>
   * </div>
   *
   * @param {string|function=} stateConfig.templateUrl
   * <a id='templateUrl'></a>
   *
   *   path or function that returns a path to an html
   *   template that should be used by uiView.
   *   
   *   If `templateUrl` is a function, it will be called with the following parameters:
   *
   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by 
   *     applying the current state
   *
   * <pre>templateUrl: "home.html"</pre>
   * <pre>templateUrl: function(params) {
   *     return myTemplates[params.pageId]; }</pre>
   *
   * @param {function=} stateConfig.templateProvider
   * <a id='templateProvider'></a>
   *    Provider function that returns HTML content string.
   * <pre> templateProvider:
   *       function(MyTemplateService, params) {
   *         return MyTemplateService.getTemplate(params.pageId);
   *       }</pre>
   *
   * @param {string|function=} stateConfig.controller
   * <a id='controller'></a>
   *
   *  Controller fn that should be associated with newly
   *   related scope or the name of a registered controller if passed as a string.
   *   Optionally, the ControllerAs may be declared here.
   * <pre>controller: "MyRegisteredController"</pre>
   * <pre>controller:
   *     "MyRegisteredController as fooCtrl"}</pre>
   * <pre>controller: function($scope, MyService) {
   *     $scope.data = MyService.getData(); }</pre>
   *
   * @param {function=} stateConfig.controllerProvider
   * <a id='controllerProvider'></a>
   *
   * Injectable provider function that returns the actual controller or string.
   * <pre>controllerProvider:
   *   function(MyResolveData) {
   *     if (MyResolveData.foo)
   *       return "FooCtrl"
   *     else if (MyResolveData.bar)
   *       return "BarCtrl";
   *     else return function($scope) {
   *       $scope.baz = "Qux";
   *     }
   *   }</pre>
   *
   * @param {string=} stateConfig.controllerAs
   * <a id='controllerAs'></a>
   * 
   * A controller alias name. If present the controller will be
   *   published to scope under the controllerAs name.
   * <pre>controllerAs: "myCtrl"</pre>
   *
   * @param {string|object=} stateConfig.parent
   * <a id='parent'></a>
   * Optionally specifies the parent state of this state.
   *
   * <pre>parent: 'parentState'</pre>
   * <pre>parent: parentState // JS variable</pre>
   *
   * @param {object=} stateConfig.resolve
   * <a id='resolve'></a>
   *
   * An optional map&lt;string, function&gt; of dependencies which
   *   should be injected into the controller. If any of these dependencies are promises, 
   *   the router will wait for them all to be resolved before the controller is instantiated.
   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired
   *   and the values of the resolved promises are injected into any controllers that reference them.
   *   If any  of the promises are rejected the $stateChangeError event is fired.
   *
   *   The map object is:
   *   
   *   - key - {string}: name of dependency to be injected into controller
   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, 
   *     it is injected and return value it treated as dependency. If result is a promise, it is 
   *     resolved before its value is injected into controller.
   *
   * <pre>resolve: {
   *     myResolve1:
   *       function($http, $stateParams) {
   *         return $http.get("/api/foos/"+stateParams.fooID);
   *       }
   *     }</pre>
   *
   * @param {string=} stateConfig.url
   * <a id='url'></a>
   *
   *   A url fragment with optional parameters. When a state is navigated or
   *   transitioned to, the `$stateParams` service will be populated with any 
   *   parameters that were passed.
   *
   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for
   *   more details on acceptable patterns )
   *
   * examples:
   * <pre>url: "/home"
   * url: "/users/:userid"
   * url: "/books/{bookid:[a-zA-Z_-]}"
   * url: "/books/{categoryid:int}"
   * url: "/books/{publishername:string}/{categoryid:int}"
   * url: "/messages?before&after"
   * url: "/messages?{before:date}&{after:date}"
   * url: "/messages/:mailboxid?{before:date}&{after:date}"
   * </pre>
   *
   * @param {object=} stateConfig.views
   * <a id='views'></a>
   * an optional map&lt;string, object&gt; which defined multiple views, or targets views
   * manually/explicitly.
   *
   * Examples:
   *
   * Targets three named `ui-view`s in the parent state's template
   * <pre>views: {
   *     header: {
   *       controller: "headerCtrl",
   *       templateUrl: "header.html"
   *     }, body: {
   *       controller: "bodyCtrl",
   *       templateUrl: "body.html"
   *     }, footer: {
   *       controller: "footCtrl",
   *       templateUrl: "footer.html"
   *     }
   *   }</pre>
   *
   * Targets named `ui-view="header"` from grandparent state 'top''s template, and named `ui-view="body" from parent state's template.
   * <pre>views: {
   *     'header@top': {
   *       controller: "msgHeaderCtrl",
   *       templateUrl: "msgHeader.html"
   *     }, 'body': {
   *       controller: "messagesCtrl",
   *       templateUrl: "messages.html"
   *     }
   *   }</pre>
   *
   * @param {boolean=} [stateConfig.abstract=false]
   * <a id='abstract'></a>
   * An abstract state will never be directly activated,
   *   but can provide inherited properties to its common children states.
   * <pre>abstract: true</pre>
   *
   * @param {function=} stateConfig.onEnter
   * <a id='onEnter'></a>
   *
   * Callback function for when a state is entered. Good way
   *   to trigger an action or dispatch an event, such as opening a dialog.
   * If minifying your scripts, make sure to explicitly annotate this function,
   * because it won't be automatically annotated by your build tools.
   *
   * <pre>onEnter: function(MyService, $stateParams) {
   *     MyService.foo($stateParams.myParam);
   * }</pre>
   *
   * @param {function=} stateConfig.onExit
   * <a id='onExit'></a>
   *
   * Callback function for when a state is exited. Good way to
   *   trigger an action or dispatch an event, such as opening a dialog.
   * If minifying your scripts, make sure to explicitly annotate this function,
   * because it won't be automatically annotated by your build tools.
   *
   * <pre>onExit: function(MyService, $stateParams) {
   *     MyService.cleanup($stateParams.myParam);
   * }</pre>
   *
   * @param {boolean=} [stateConfig.reloadOnSearch=true]
   * <a id='reloadOnSearch'></a>
   *
   * If `false`, will not retrigger the same state
   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). 
   *   Useful for when you'd like to modify $location.search() without triggering a reload.
   * <pre>reloadOnSearch: false</pre>
   *
   * @param {object=} stateConfig.data
   * <a id='data'></a>
   *
   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is
   *   prototypally inherited.  In other words, adding a data property to a state adds it to
   *   the entire subtree via prototypal inheritance.
   *
   * <pre>data: {
   *     requiredRole: 'foo'
   * } </pre>
   *
   * @param {object=} stateConfig.params
   * <a id='params'></a>
   *
   * A map which optionally configures parameters declared in the `url`, or
   *   defines additional non-url parameters.  For each parameter being
   *   configured, add a configuration object keyed to the name of the parameter.
   *
   *   Each parameter configuration object may contain the following properties:
   *
   *   - ** value ** - {object|function=}: specifies the default value for this
   *     parameter.  This implicitly sets this parameter as optional.
   *
   *     When UI-Router routes to a state and no value is
   *     specified for this parameter in the URL or transition, the
   *     default value will be used instead.  If `value` is a function,
   *     it will be injected and invoked, and the return value used.
   *
   *     *Note*: `undefined` is treated as "no default value" while `null`
   *     is treated as "the default value is `null`".
   *
   *     *Shorthand*: If you only need to configure the default value of the
   *     parameter, you may use a shorthand syntax.   In the **`params`**
   *     map, instead mapping the param name to a full parameter configuration
   *     object, simply set map it to the default parameter value, e.g.:
   *
   * <pre>// define a parameter's default value
   * params: {
   *     param1: { value: "defaultValue" }
   * }
   * // shorthand default values
   * params: {
   *     param1: "defaultValue",
   *     param2: "param2Default"
   * }</pre>
   *
   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be
   *     treated as an array of values.  If you specified a Type, the value will be
   *     treated as an array of the specified Type.  Note: query parameter values
   *     default to a special `"auto"` mode.
   *
   *     For query parameters in `"auto"` mode, if multiple  values for a single parameter
   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values
   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if
   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single
   *     value (e.g.: `{ foo: '1' }`).
   *
   * <pre>params: {
   *     param1: { array: true }
   * }</pre>
   *
   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when
   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the
   *     configured default squash policy.
   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})
   *
   *   There are three squash settings:
   *
   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL
   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed
   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.
   *       This can allow for cleaner looking URLs.
   *     - `"<arbitrary string>"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.
   *
   * <pre>params: {
   *     param1: {
   *       value: "defaultId",
   *       squash: true
   * } }
   * // squash "defaultValue" to "~"
   * params: {
   *     param1: {
   *       value: "defaultValue",
   *       squash: "~"
   * } }
   * </pre>
   *
   *
   * @example
   * <pre>
   * // Some state name examples
   *
   * // stateName can be a single top-level name (must be unique).
   * $stateProvider.state("home", {});
   *
   * // Or it can be a nested state name. This state is a child of the
   * // above "home" state.
   * $stateProvider.state("home.newest", {});
   *
   * // Nest states as deeply as needed.
   * $stateProvider.state("home.newest.abc.xyz.inception", {});
   *
   * // state() returns $stateProvider, so you can chain state declarations.
   * $stateProvider
   *   .state("home", {})
   *   .state("about", {})
   *   .state("contacts", {});
   * </pre>
   *
   */
  this.state = state;
  function state(name, definition) {
    /*jshint validthis: true */
    if (isObject(name)) definition = name;
    else definition.name = name;
    registerState(definition);
    return this;
  }

  /**
   * @ngdoc object
   * @name ui.router.state.$state
   *
   * @requires $rootScope
   * @requires $q
   * @requires ui.router.state.$view
   * @requires $injector
   * @requires ui.router.util.$resolve
   * @requires ui.router.state.$stateParams
   * @requires ui.router.router.$urlRouter
   *
   * @property {object} params A param object, e.g. {sectionId: section.id)}, that 
   * you'd like to test against the current active state.
   * @property {object} current A reference to the state's config object. However 
   * you passed it in. Useful for accessing custom data.
   * @property {object} transition Currently pending transition. A promise that'll 
   * resolve or reject.
   *
   * @description
   * `$state` service is responsible for representing states as well as transitioning
   * between them. It also provides interfaces to ask for current state or even states
   * you're coming from.
   */
  this.$get = $get;
  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {

    var TransitionSuperseded = $q.reject(new Error('transition superseded'));
    var TransitionPrevented = $q.reject(new Error('transition prevented'));
    var TransitionAborted = $q.reject(new Error('transition aborted'));
    var TransitionFailed = $q.reject(new Error('transition failed'));

    // Handles the case where a state which is the target of a transition is not found, and the user
    // can optionally retry or defer the transition
    function handleRedirect(redirect, state, params, options) {
      /**
       * @ngdoc event
       * @name ui.router.state.$state#$stateNotFound
       * @eventOf ui.router.state.$state
       * @eventType broadcast on root scope
       * @description
       * Fired when a requested state **cannot be found** using the provided state name during transition.
       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by
       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,
       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the
       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.
       *
       * @param {Object} event Event object.
       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.
       * @param {State} fromState Current state object.
       * @param {Object} fromParams Current state params.
       *
       * @example
       *
       * <pre>
       * // somewhere, assume lazy.state has not been defined
       * $state.go("lazy.state", {a:1, b:2}, {inherit:false});
       *
       * // somewhere else
       * $scope.$on('$stateNotFound',
       * function(event, unfoundState, fromState, fromParams){
       *     console.log(unfoundState.to); // "lazy.state"
       *     console.log(unfoundState.toParams); // {a:1, b:2}
       *     console.log(unfoundState.options); // {inherit:false} + default options
       * })
       * </pre>
       */
      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);

      if (evt.defaultPrevented) {
        $urlRouter.update();
        return TransitionAborted;
      }

      if (!evt.retry) {
        return null;
      }

      // Allow the handler to return a promise to defer state lookup retry
      if (options.$retry) {
        $urlRouter.update();
        return TransitionFailed;
      }
      var retryTransition = $state.transition = $q.when(evt.retry);

      retryTransition.then(function() {
        if (retryTransition !== $state.transition) return TransitionSuperseded;
        redirect.options.$retry = true;
        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
      }, function() {
        return TransitionAborted;
      });
      $urlRouter.update();

      return retryTransition;
    }

    root.locals = { resolve: null, globals: { $stateParams: {} } };

    $state = {
      params: {},
      current: root.self,
      $current: root,
      transition: null
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#reload
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method that force reloads the current state. All resolves are re-resolved,
     * controllers reinstantiated, and events re-fired.
     *
     * @example
     * <pre>
     * var app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     $state.reload();
     *   }
     * });
     * </pre>
     *
     * `reload()` is just an alias for:
     * <pre>
     * $state.transitionTo($state.current, $stateParams, { 
     *   reload: true, inherit: false, notify: true
     * });
     * </pre>
     *
     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.
     * @example
     * <pre>
     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' 
     * //and current state is 'contacts.detail.item'
     * var app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     //will reload 'contact.detail' and 'contact.detail.item' states
     *     $state.reload('contact.detail');
     *   }
     * });
     * </pre>
     *
     * `reload()` is just an alias for:
     * <pre>
     * $state.transitionTo($state.current, $stateParams, { 
     *   reload: true, inherit: false, notify: true
     * });
     * </pre>

     * @returns {promise} A promise representing the state of the new transition. See
     * {@link ui.router.state.$state#methods_go $state.go}.
     */
    $state.reload = function reload(state) {
      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#go
     * @methodOf ui.router.state.$state
     *
     * @description
     * Convenience method for transitioning to a new state. `$state.go` calls 
     * `$state.transitionTo` internally but automatically sets options to 
     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. 
     * This allows you to easily use an absolute or relative to path and specify 
     * only the parameters you'd like to update (while letting unspecified parameters 
     * inherit from the currently active ancestor states).
     *
     * @example
     * <pre>
     * var app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.go('contact.detail');
     *   };
     * });
     * </pre>
     * <img src='../ngdoc_assets/StateGoExamples.png'/>
     *
     * @param {string} to Absolute state name or relative state path. Some examples:
     *
     * - `$state.go('contact.detail')` - will go to the `contact.detail` state
     * - `$state.go('^')` - will go to a parent state
     * - `$state.go('^.sibling')` - will go to a sibling state
     * - `$state.go('.child.grandchild')` - will go to grandchild state
     *
     * @param {object=} params A map of the parameters that will be sent to the state, 
     * will populate $stateParams. Any parameters that are not specified will be inherited from currently 
     * defined parameters. Only parameters specified in the state definition can be overridden, new 
     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters
     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.
     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child
     * will get you all current parameters, etc.
     * @param {object=} options Options object. The options are:
     *
     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), 
     *    defines which state to be relative from.
     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params
     *    have changed.  It will reload the resolves and views of the current state and parent states.
     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \
     *    the transition reloads the resolves and views for that matched state, and all its children states.
     *
     * @returns {promise} A promise representing the state of the new transition.
     *
     * Possible success values:
     *
     * - $state.current
     *
     * <br/>Possible rejection values:
     *
     * - 'transition superseded' - when a newer transition has been started after this one
     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener
     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or
     *   when a `$stateNotFound` `event.retry` promise errors.
     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.
     * - *resolve error* - when an error has occurred with a `resolve`
     *
     */
    $state.go = function go(to, params, options) {
      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#transitionTo
     * @methodOf ui.router.state.$state
     *
     * @description
     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}
     * uses `transitionTo` internally. `$state.go` is recommended in most situations.
     *
     * @example
     * <pre>
     * var app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.transitionTo('contact.detail');
     *   };
     * });
     * </pre>
     *
     * @param {string} to State name.
     * @param {object=} toParams A map of the parameters that will be sent to the state,
     * will populate $stateParams.
     * @param {object=} options Options object. The options are:
     *
     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), 
     *    defines which state to be relative from.
     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params 
     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
     *    use this when you want to force a reload when *everything* is the same, including search params.
     *    if String, then will reload the state with the name given in reload, and any children.
     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.
     *
     * @returns {promise} A promise representing the state of the new transition. See
     * {@link ui.router.state.$state#methods_go $state.go}.
     */
    $state.transitionTo = function transitionTo(to, toParams, options) {
      toParams = toParams || {};
      options = extend({
        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false
      }, options || {});

      var from = $state.$current, fromParams = $state.params, fromPath = from.path;
      var evt, toState = findState(to, options.relative);

      // Store the hash param for later (since it will be stripped out by various methods)
      var hash = toParams['#'];

      if (!isDefined(toState)) {
        var redirect = { to: to, toParams: toParams, options: options };
        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);

        if (redirectResult) {
          return redirectResult;
        }

        // Always retry once if the $stateNotFound was not prevented
        // (handles either redirect changed or state lazy-definition)
        to = redirect.to;
        toParams = redirect.toParams;
        options = redirect.options;
        toState = findState(to, options.relative);

        if (!isDefined(toState)) {
          if (!options.relative) throw new Error("No such state '" + to + "'");
          throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
        }
      }
      if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
      if (!toState.params.$$validates(toParams)) return TransitionFailed;

      toParams = toState.params.$$values(toParams);
      to = toState;

      var toPath = to.path;

      // Starting from the root of the path, keep all levels that haven't changed
      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];

      if (!options.reload) {
        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
          locals = toLocals[keep] = state.locals;
          keep++;
          state = toPath[keep];
        }
      } else if (isString(options.reload) || isObject(options.reload)) {
        if (isObject(options.reload) && !options.reload.name) {
          throw new Error('Invalid reload state object');
        }
        
        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
        if (options.reload && !reloadState) {
          throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
        }

        while (state && state === fromPath[keep] && state !== reloadState) {
          locals = toLocals[keep] = state.locals;
          keep++;
          state = toPath[keep];
        }
      }

      // If we're going to the same state and all locals are kept, we've got nothing to do.
      // But clear 'transition', as we still want to cancel any other pending transitions.
      // TODO: We may not want to bump 'transition' if we're called from a location change
      // that we've initiated ourselves, because we might accidentally abort a legitimate
      // transition initiated from code?
      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
        if (hash) toParams['#'] = hash;
        $state.params = toParams;
        copy($state.params, $stateParams);
        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
        if (options.location && to.navigable && to.navigable.url) {
          $urlRouter.push(to.navigable.url, toParams, {
            $$avoidResync: true, replace: options.location === 'replace'
          });
          $urlRouter.update(true);
        }
        $state.transition = null;
        return $q.when($state.current);
      }

      // Filter parameters before we pass them to event handlers etc.
      toParams = filterByKeys(to.params.$$keys(), toParams || {});
      
      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart
      if (hash) toParams['#'] = hash;
      
      // Broadcast start event and cancel the transition if requested
      if (options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeStart
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when the state transition **begins**. You can use `event.preventDefault()`
         * to prevent the transition from happening and then the transition promise will be
         * rejected with a `'transition prevented'` value.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         *
         * @example
         *
         * <pre>
         * $rootScope.$on('$stateChangeStart',
         * function(event, toState, toParams, fromState, fromParams){
         *     event.preventDefault();
         *     // transitionTo() promise will be rejected with
         *     // a 'transition prevented' error
         * })
         * </pre>
         */
        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {
          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
          //Don't update and resync url if there's been a new transition started. see issue #2238, #600
          if ($state.transition == null) $urlRouter.update();
          return TransitionPrevented;
        }
      }

      // Resolve locals for the remaining states, but don't update any global state just
      // yet -- if anything fails to resolve the current state needs to remain untouched.
      // We also set up an inheritance chain for the locals here. This allows the view directive
      // to quickly look up the correct definition for each view in the current state. Even
      // though we create the locals object itself outside resolveState(), it is initially
      // empty and gets filled asynchronously. We need to keep track of the promise for the
      // (fully resolved) current locals, and pass this down the chain.
      var resolved = $q.when(locals);

      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
        locals = toLocals[l] = inherit(locals);
        resolved = resolveState(state, toParams, state === to, resolved, locals, options);
      }

      // Once everything is resolved, we are ready to perform the actual transition
      // and return a promise for the new state. We also keep track of what the
      // current promise is, so that we can detect overlapping transitions and
      // keep only the outcome of the last transition.
      var transition = $state.transition = resolved.then(function () {
        var l, entering, exiting;

        if ($state.transition !== transition) return TransitionSuperseded;

        // Exit 'from' states not kept
        for (l = fromPath.length - 1; l >= keep; l--) {
          exiting = fromPath[l];
          if (exiting.self.onExit) {
            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
          }
          exiting.locals = null;
        }

        // Enter 'to' states not kept
        for (l = keep; l < toPath.length; l++) {
          entering = toPath[l];
          entering.locals = toLocals[l];
          if (entering.self.onEnter) {
            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
          }
        }

        // Run it again, to catch any transitions in callbacks
        if ($state.transition !== transition) return TransitionSuperseded;

        // Update globals in $state
        $state.$current = to;
        $state.current = to.self;
        $state.params = toParams;
        copy($state.params, $stateParams);
        $state.transition = null;

        if (options.location && to.navigable) {
          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
            $$avoidResync: true, replace: options.location === 'replace'
          });
        }

        if (options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeSuccess
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired once the state transition is **complete**.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         */
          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
        }
        $urlRouter.update(true);

        return $state.current;
      }, function (error) {
        if ($state.transition !== transition) return TransitionSuperseded;

        $state.transition = null;
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeError
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when an **error occurs** during transition. It's important to note that if you
         * have any errors in your resolve functions (javascript errors, non-existent services, etc)
         * they will not throw traditionally. You must listen for this $stateChangeError event to
         * catch **ALL** errors.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         * @param {Error} error The resolve error object.
         */
        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);

        if (!evt.defaultPrevented) {
            $urlRouter.update();
        }

        return $q.reject(error);
      });

      return transition;
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#is
     * @methodOf ui.router.state.$state
     *
     * @description
     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},
     * but only checks for the full state name. If params is supplied then it will be
     * tested for strict equality against the current active params object, so all params
     * must match with none missing and no extras.
     *
     * @example
     * <pre>
     * $state.$current.name = 'contacts.details.item';
     *
     * // absolute name
     * $state.is('contact.details.item'); // returns true
     * $state.is(contactDetailItemStateObject); // returns true
     *
     * // relative name (. and ^), typically from a template
     * // E.g. from the 'contacts.details' template
     * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
     * </pre>
     *
     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.
     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like
     * to test against the current active state.
     * @param {object=} options An options object.  The options are:
     *
     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will
     * test relative to `options.relative` state (or name).
     *
     * @returns {boolean} Returns true if it is the state.
     */
    $state.is = function is(stateOrName, params, options) {
      options = extend({ relative: $state.$current }, options || {});
      var state = findState(stateOrName, options.relative);

      if (!isDefined(state)) { return undefined; }
      if ($state.$current !== state) { return false; }
      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#includes
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method to determine if the current active state is equal to or is the child of the
     * state stateName. If any params are passed then they will be tested for a match as well.
     * Not all the parameters need to be passed, just the ones you'd like to test for equality.
     *
     * @example
     * Partial and relative names
     * <pre>
     * $state.$current.name = 'contacts.details.item';
     *
     * // Using partial names
     * $state.includes("contacts"); // returns true
     * $state.includes("contacts.details"); // returns true
     * $state.includes("contacts.details.item"); // returns true
     * $state.includes("contacts.list"); // returns false
     * $state.includes("about"); // returns false
     *
     * // Using relative names (. and ^), typically from a template
     * // E.g. from the 'contacts.details' template
     * <div ng-class="{highlighted: $state.includes('.item')}">Item</div>
     * </pre>
     *
     * Basic globbing patterns
     * <pre>
     * $state.$current.name = 'contacts.details.item.url';
     *
     * $state.includes("*.details.*.*"); // returns true
     * $state.includes("*.details.**"); // returns true
     * $state.includes("**.item.**"); // returns true
     * $state.includes("*.details.item.url"); // returns true
     * $state.includes("*.details.*.url"); // returns true
     * $state.includes("*.details.*"); // returns false
     * $state.includes("item.**"); // returns false
     * </pre>
     *
     * @param {string} stateOrName A partial name, relative name, or glob pattern
     * to be searched for within the current state name.
     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,
     * that you'd like to test against the current active state.
     * @param {object=} options An options object.  The options are:
     *
     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,
     * .includes will test relative to `options.relative` state (or name).
     *
     * @returns {boolean} Returns true if it does include the state
     */
    $state.includes = function includes(stateOrName, params, options) {
      options = extend({ relative: $state.$current }, options || {});
      if (isString(stateOrName) && isGlob(stateOrName)) {
        if (!doesStateMatchGlob(stateOrName)) {
          return false;
        }
        stateOrName = $state.$current.name;
      }

      var state = findState(stateOrName, options.relative);
      if (!isDefined(state)) { return undefined; }
      if (!isDefined($state.$current.includes[state.name])) { return false; }
      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
    };


    /**
     * @ngdoc function
     * @name ui.router.state.$state#href
     * @methodOf ui.router.state.$state
     *
     * @description
     * A url generation method that returns the compiled url for the given state populated with the given params.
     *
     * @example
     * <pre>
     * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
     * </pre>
     *
     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.
     * @param {object=} params An object of parameter values to fill the state's required parameters.
     * @param {object=} options Options object. The options are:
     *
     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the
     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka
     *    ancestor with a valid url).
     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), 
     *    defines which state to be relative from.
     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
     * 
     * @returns {string} compiled state url
     */
    $state.href = function href(stateOrName, params, options) {
      options = extend({
        lossy:    true,
        inherit:  true,
        absolute: false,
        relative: $state.$current
      }, options || {});

      var state = findState(stateOrName, options.relative);

      if (!isDefined(state)) return null;
      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);
      
      var nav = (state && options.lossy) ? state.navigable : state;

      if (!nav || nav.url === undefined || nav.url === null) {
        return null;
      }
      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {
        absolute: options.absolute
      });
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#get
     * @methodOf ui.router.state.$state
     *
     * @description
     * Returns the state configuration object for any specific state or all states.
     *
     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for
     * the requested state. If not provided, returns an array of ALL state configs.
     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.
     * @returns {Object|Array} State configuration object or array of all objects.
     */
    $state.get = function (stateOrName, context) {
      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });
      var state = findState(stateOrName, context || $state.$current);
      return (state && state.self) ? state.self : null;
    };

    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
      // Make a restricted $stateParams with only the parameters that apply to this state if
      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,
      // we also need $stateParams to be available for any $injector calls we make during the
      // dependency resolution process.
      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
      var locals = { $stateParams: $stateParams };

      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.
      // We're also including $stateParams in this; that way the parameters are restricted
      // to the set that should be visible to the state, and are independent of when we update
      // the global $state and $stateParams values.
      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
      var promises = [dst.resolve.then(function (globals) {
        dst.globals = globals;
      })];
      if (inherited) promises.push(inherited);

      function resolveViews() {
        var viewsPromises = [];

        // Resolve template and dependencies for all views.
        forEach(state.views, function (view, name) {
          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
          injectables.$template = [ function () {
            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';
          }];

          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {
            // References to the controller (only instantiated at link time)
            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
              var injectLocals = angular.extend({}, injectables, dst.globals);
              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
            } else {
              result.$$controller = view.controller;
            }
            // Provide access to the state itself for internal use
            result.$$state = state;
            result.$$controllerAs = view.controllerAs;
            dst[name] = result;
          }));
        });

        return $q.all(viewsPromises).then(function(){
          return dst.globals;
        });
      }

      // Wait for all the promises and then return the activation object
      return $q.all(promises).then(resolveViews).then(function (values) {
        return dst;
      });
    }

    return $state;
  }

  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
    // Return true if there are no differences in non-search (path/object) params, false if there are differences
    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.
      function notSearchParam(key) {
        return fromAndToState.params[key].location != "search";
      }
      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
      return nonQueryParamSet.$$equals(fromParams, toParams);
    }

    // If reload was not explicitly requested
    // and we're transitioning to the same state we're already in
    // and    the locals didn't change
    //     or they changed in a way that doesn't merit reloading
    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)
    // Then return true.
    if (!options.reload && to === from &&
      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
      return true;
    }
  }
}

angular.module('ui.router.state')
  .factory('$stateParams', function () { return {}; })
  .provider('$state', $StateProvider);


$ViewProvider.$inject = [];
function $ViewProvider() {

  this.$get = $get;
  /**
   * @ngdoc object
   * @name ui.router.state.$view
   *
   * @requires ui.router.util.$templateFactory
   * @requires $rootScope
   *
   * @description
   *
   */
  $get.$inject = ['$rootScope', '$templateFactory'];
  function $get(   $rootScope,   $templateFactory) {
    return {
      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })
      /**
       * @ngdoc function
       * @name ui.router.state.$view#load
       * @methodOf ui.router.state.$view
       *
       * @description
       *
       * @param {string} name name
       * @param {object} options option object.
       */
      load: function load(name, options) {
        var result, defaults = {
          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}
        };
        options = extend(defaults, options);

        if (options.view) {
          result = $templateFactory.fromConfig(options.view, options.params, options.locals);
        }
        return result;
      }
    };
  }
}

angular.module('ui.router.state').provider('$view', $ViewProvider);

/**
 * @ngdoc object
 * @name ui.router.state.$uiViewScrollProvider
 *
 * @description
 * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.
 */
function $ViewScrollProvider() {

  var useAnchorScroll = false;

  /**
   * @ngdoc function
   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll
   * @methodOf ui.router.state.$uiViewScrollProvider
   *
   * @description
   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for
   * scrolling based on the url anchor.
   */
  this.useAnchorScroll = function () {
    useAnchorScroll = true;
  };

  /**
   * @ngdoc object
   * @name ui.router.state.$uiViewScroll
   *
   * @requires $anchorScroll
   * @requires $timeout
   *
   * @description
   * When called with a jqLite element, it scrolls the element into view (after a
   * `$timeout` so the DOM has time to refresh).
   *
   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,
   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.
   */
  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {
    if (useAnchorScroll) {
      return $anchorScroll;
    }

    return function ($element) {
      return $timeout(function () {
        $element[0].scrollIntoView();
      }, 0, false);
    };
  }];
}

angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);

var ngMajorVer = angular.version.major;
var ngMinorVer = angular.version.minor;
/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-view
 *
 * @requires ui.router.state.$state
 * @requires $compile
 * @requires $controller
 * @requires $injector
 * @requires ui.router.state.$uiViewScroll
 * @requires $document
 *
 * @restrict ECA
 *
 * @description
 * The ui-view directive tells $state where to place your templates.
 *
 * @param {string=} name A view name. The name should be unique amongst the other views in the
 * same state. You can have views of the same name that live in different states.
 *
 * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window
 * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll
 * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you
 * scroll ui-view elements into view when they are populated during a state activation.
 *
 * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations
 * will be applied to the ui-view)
 *
 * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)
 * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*
 *
 * @param {string=} onload Expression to evaluate whenever the view updates.
 * 
 * @example
 * A view can be unnamed or named. 
 * <pre>
 * <!-- Unnamed -->
 * <div ui-view></div> 
 * 
 * <!-- Named -->
 * <div ui-view="viewName"></div>
 * </pre>
 *
 * You can only have one unnamed view within any template (or root html). If you are only using a 
 * single view and it is unnamed then you can populate it like so:
 * <pre>
 * <div ui-view></div> 
 * $stateProvider.state("home", {
 *   template: "<h1>HELLO!</h1>"
 * })
 * </pre>
 * 
 * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}
 * config property, by name, in this case an empty name:
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "": {
 *       template: "<h1>HELLO!</h1>"
 *     }
 *   }    
 * })
 * </pre>
 * 
 * But typically you'll only use the views property if you name your view or have more than one view 
 * in the same template. There's not really a compelling reason to name a view if its the only one, 
 * but you could if you wanted, like so:
 * <pre>
 * <div ui-view="main"></div>
 * </pre> 
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "main": {
 *       template: "<h1>HELLO!</h1>"
 *     }
 *   }    
 * })
 * </pre>
 * 
 * Really though, you'll use views to set up multiple views:
 * <pre>
 * <div ui-view></div>
 * <div ui-view="chart"></div> 
 * <div ui-view="data"></div> 
 * </pre>
 * 
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "": {
 *       template: "<h1>HELLO!</h1>"
 *     },
 *     "chart": {
 *       template: "<chart_thing/>"
 *     },
 *     "data": {
 *       template: "<data_thing/>"
 *     }
 *   }    
 * })
 * </pre>
 *
 * Examples for `autoscroll`:
 *
 * <pre>
 * <!-- If autoscroll present with no expression,
 *      then scroll ui-view into view -->
 * <ui-view autoscroll/>
 *
 * <!-- If autoscroll present with valid expression,
 *      then scroll ui-view into view if expression evaluates to true -->
 * <ui-view autoscroll='true'/>
 * <ui-view autoscroll='false'/>
 * <ui-view autoscroll='scopeVariable'/>
 * </pre>
 */
$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
function $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {

  function getService() {
    return ($injector.has) ? function(service) {
      return $injector.has(service) ? $injector.get(service) : null;
    } : function(service) {
      try {
        return $injector.get(service);
      } catch (e) {
        return null;
      }
    };
  }

  var service = getService(),
      $animator = service('$animator'),
      $animate = service('$animate');

  // Returns a set of DOM manipulation functions based on which Angular version
  // it should use
  function getRenderer(attrs, scope) {
    var statics = {
      enter: function (element, target, cb) { target.after(element); cb(); },
      leave: function (element, cb) { element.remove(); cb(); }
    };

    if (!!attrs.noanimation) return statics;

    function animEnabled(element) {
      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);
      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();
      return (!!$animator);
    }

    // ng 1.2+
    if ($animate) {
      return {
        enter: function(element, target, cb) {
          if (!animEnabled(element)) {
            statics.enter(element, target, cb);
          } else if (angular.version.minor > 2) {
            $animate.enter(element, null, target).then(cb);
          } else {
            $animate.enter(element, null, target, cb);
          }
        },
        leave: function(element, cb) {
          if (!animEnabled(element)) {
            statics.leave(element, cb);
          } else if (angular.version.minor > 2) {
            $animate.leave(element).then(cb);
          } else {
            $animate.leave(element, cb);
          }
        }
      };
    }

    // ng 1.1.5
    if ($animator) {
      var animate = $animator && $animator(scope, attrs);

      return {
        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },
        leave: function(element, cb) { animate.leave(element); cb(); }
      };
    }

    return statics;
  }

  var directive = {
    restrict: 'ECA',
    terminal: true,
    priority: 400,
    transclude: 'element',
    compile: function (tElement, tAttrs, $transclude) {
      return function (scope, $element, attrs) {
        var previousEl, currentEl, currentScope, latestLocals,
            onloadExp     = attrs.onload || '',
            autoScrollExp = attrs.autoscroll,
            renderer      = getRenderer(attrs, scope);

        scope.$on('$stateChangeSuccess', function() {
          updateView(false);
        });

        updateView(true);

        function cleanupLastView() {
          var _previousEl = previousEl;
          var _currentScope = currentScope;

          if (_currentScope) {
            _currentScope._willBeDestroyed = true;
          }

          function cleanOld() {
            if (_previousEl) {
              _previousEl.remove();
            }

            if (_currentScope) {
              _currentScope.$destroy();
            }
          }

          if (currentEl) {
            renderer.leave(currentEl, function() {
              cleanOld();
              previousEl = null;
            });

            previousEl = currentEl;
          } else {
            cleanOld();
            previousEl = null;
          }

          currentEl = null;
          currentScope = null;
        }

        function updateView(firstTime) {
          var newScope,
              name            = getUiViewName(scope, attrs, $element, $interpolate),
              previousLocals  = name && $state.$current && $state.$current.locals[name];

          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do
          newScope = scope.$new();
          latestLocals = $state.$current.locals[name];

          /**
           * @ngdoc event
           * @name ui.router.state.directive:ui-view#$viewContentLoading
           * @eventOf ui.router.state.directive:ui-view
           * @eventType emits on ui-view directive scope
           * @description
           *
           * Fired once the view **begins loading**, *before* the DOM is rendered.
           *
           * @param {Object} event Event object.
           * @param {string} viewName Name of the view.
           */
          newScope.$emit('$viewContentLoading', name);

          var clone = $transclude(newScope, function(clone) {
            renderer.enter(clone, $element, function onUiViewEnter() {
              if(currentScope) {
                currentScope.$emit('$viewContentAnimationEnded');
              }

              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                $uiViewScroll(clone);
              }
            });
            cleanupLastView();
          });

          currentEl = clone;
          currentScope = newScope;
          /**
           * @ngdoc event
           * @name ui.router.state.directive:ui-view#$viewContentLoaded
           * @eventOf ui.router.state.directive:ui-view
           * @eventType emits on ui-view directive scope
           * @description
           * Fired once the view is **loaded**, *after* the DOM is rendered.
           *
           * @param {Object} event Event object.
           * @param {string} viewName Name of the view.
           */
          currentScope.$emit('$viewContentLoaded', name);
          currentScope.$eval(onloadExp);
        }
      };
    }
  };

  return directive;
}

$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
function $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {
  return {
    restrict: 'ECA',
    priority: -400,
    compile: function (tElement) {
      var initial = tElement.html();
      return function (scope, $element, attrs) {
        var current = $state.$current,
            name = getUiViewName(scope, attrs, $element, $interpolate),
            locals  = current && current.locals[name];

        if (! locals) {
          return;
        }

        $element.data('$uiView', { name: name, state: locals.$$state });
        $element.html(locals.$template ? locals.$template : initial);

        var link = $compile($element.contents());

        if (locals.$$controller) {
          locals.$scope = scope;
          locals.$element = $element;
          var controller = $controller(locals.$$controller, locals);
          if (locals.$$controllerAs) {
            scope[locals.$$controllerAs] = controller;
          }
          $element.data('$ngControllerController', controller);
          $element.children().data('$ngControllerController', controller);
        }

        link(scope);
      };
    }
  };
}

/**
 * Shared ui-view code for both directives:
 * Given scope, element, and its attributes, return the view's name
 */
function getUiViewName(scope, attrs, element, $interpolate) {
  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
  var inherited = element.inheritedData('$uiView');
  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));
}

angular.module('ui.router.state').directive('uiView', $ViewDirective);
angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);

function parseStateRef(ref, current) {
  var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed;
  if (preparsed) ref = current + '(' + preparsed[1] + ')';
  parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
  if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
  return { state: parsed[1], paramExpr: parsed[3] || null };
}

function stateContext(el) {
  var stateData = el.parent().inheritedData('$uiView');

  if (stateData && stateData.state && stateData.state.name) {
    return stateData.state;
  }
}

function getTypeInfo(el) {
  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
  var isForm = el[0].nodeName === "FORM";

  return {
    attr: isForm ? "action" : (isSvg ? 'xlink:href' : 'href'),
    isAnchor: el.prop("tagName").toUpperCase() === "A",
    clickable: !isForm
  };
}

function clickHook(el, $state, $timeout, type, current) {
  return function(e) {
    var button = e.which || e.button, target = current();

    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
      var transition = $timeout(function() {
        $state.go(target.state, target.params, target.options);
      });
      e.preventDefault();

      // if the state has no URL, ignore one preventDefault from the <a> directive.
      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;

      e.preventDefault = function() {
        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
      };
    }
  };
}

function defaultOpts(el, $state) {
  return { relative: stateContext(el) || $state.$current, inherit: true };
}

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref
 *
 * @requires ui.router.state.$state
 * @requires $timeout
 *
 * @restrict A
 *
 * @description
 * A directive that binds a link (`<a>` tag) to a state. If the state has an associated
 * URL, the directive will automatically generate & update the `href` attribute via
 * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking
 * the link will trigger a state transition with optional parameters.
 *
 * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be
 * handled natively by the browser.
 *
 * You can also use relative state paths within ui-sref, just like the relative
 * paths passed to `$state.go()`. You just need to be aware that the path is relative
 * to the state that the link lives in, in other words the state that loaded the
 * template containing the link.
 *
 * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}
 * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,
 * and `reload`.
 *
 * @example
 * Here's an example of how you'd use ui-sref and how it would compile. If you have the
 * following template:
 * <pre>
 * <a ui-sref="home">Home</a> | <a ui-sref="about">About</a> | <a ui-sref="{page: 2}">Next page</a>
 *
 * <ul>
 *     <li ng-repeat="contact in contacts">
 *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
 *     </li>
 * </ul>
 * </pre>
 *
 * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):
 * <pre>
 * <a href="#/home" ui-sref="home">Home</a> | <a href="#/about" ui-sref="about">About</a> | <a href="#/contacts?page=2" ui-sref="{page: 2}">Next page</a>
 *
 * <ul>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
 *     </li>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
 *     </li>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
 *     </li>
 * </ul>
 *
 * <a ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
 * </pre>
 *
 * @param {string} ui-sref 'stateName' can be any valid absolute or relative state
 * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}
 */
$StateRefDirective.$inject = ['$state', '$timeout'];
function $StateRefDirective($state, $timeout) {
  return {
    restrict: 'A',
    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
    link: function(scope, element, attrs, uiSrefActive) {
      var ref    = parseStateRef(attrs.uiSref, $state.current.name);
      var def    = { state: ref.state, href: null, params: null };
      var type   = getTypeInfo(element);
      var active = uiSrefActive[1] || uiSrefActive[0];

      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});

      var update = function(val) {
        if (val) def.params = angular.copy(val);
        def.href = $state.href(ref.state, def.params, def.options);

        if (active) active.$$addStateInfo(ref.state, def.params);
        if (def.href !== null) attrs.$set(type.attr, def.href);
      };

      if (ref.paramExpr) {
        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);
        def.params = angular.copy(scope.$eval(ref.paramExpr));
      }
      update();

      if (!type.clickable) return;
      element.bind("click", clickHook(element, $state, $timeout, type, function() { return def; }));
    }
  };
}

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-state
 *
 * @requires ui.router.state.uiSref
 *
 * @restrict A
 *
 * @description
 * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,
 * params and override options.
 *
 * @param {string} ui-state 'stateName' can be any valid absolute or relative state
 * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}
 * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}
 */
$StateRefDynamicDirective.$inject = ['$state', '$timeout'];
function $StateRefDynamicDirective($state, $timeout) {
  return {
    restrict: 'A',
    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
    link: function(scope, element, attrs, uiSrefActive) {
      var type   = getTypeInfo(element);
      var active = uiSrefActive[1] || uiSrefActive[0];
      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];
      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';
      var def    = { state: null, params: null, options: null, href: null };

      function runStateRefLink (group) {
        def.state = group[0]; def.params = group[1]; def.options = group[2];
        def.href = $state.href(def.state, def.params, def.options);

        if (active) active.$$addStateInfo(def.state, def.params);
        if (def.href) attrs.$set(type.attr, def.href);
      }

      scope.$watch(watch, runStateRefLink, true);
      runStateRefLink(scope.$eval(watch));

      if (!type.clickable) return;
      element.bind("click", clickHook(element, $state, $timeout, type, function() { return def; }));
    }
  };
}


/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref-active
 *
 * @requires ui.router.state.$state
 * @requires ui.router.state.$stateParams
 * @requires $interpolate
 *
 * @restrict A
 *
 * @description
 * A directive working alongside ui-sref to add classes to an element when the
 * related ui-sref directive's state is active, and removing them when it is inactive.
 * The primary use-case is to simplify the special appearance of navigation menus
 * relying on `ui-sref`, by having the "active" state's menu button appear different,
 * distinguishing it from the inactive menu items.
 *
 * ui-sref-active can live on the same element as ui-sref or on a parent element. The first
 * ui-sref-active found at the same level or above the ui-sref will be used.
 *
 * Will activate when the ui-sref's target state or any child state is active. If you
 * need to activate only when the ui-sref target state is active and *not* any of
 * it's children, then you will use
 * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}
 *
 * @example
 * Given the following template:
 * <pre>
 * <ul>
 *   <li ui-sref-active="active" class="item">
 *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
 *   </li>
 * </ul>
 * </pre>
 *
 *
 * When the app state is "app.user" (or any children states), and contains the state parameter "user" with value "bilbobaggins",
 * the resulting HTML will appear as (note the 'active' class):
 * <pre>
 * <ul>
 *   <li ui-sref-active="active" class="item active">
 *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
 *   </li>
 * </ul>
 * </pre>
 *
 * The class name is interpolated **once** during the directives link time (any further changes to the
 * interpolated value are ignored).
 *
 * Multiple classes may be specified in a space-separated format:
 * <pre>
 * <ul>
 *   <li ui-sref-active='class1 class2 class3'>
 *     <a ui-sref="app.user">link</a>
 *   </li>
 * </ul>
 * </pre>
 *
 * It is also possible to pass ui-sref-active an expression that evaluates
 * to an object hash, whose keys represent active class names and whose
 * values represent the respective state names/globs.
 * ui-sref-active will match if the current active state **includes** any of
 * the specified state names/globs, even the abstract ones.
 *
 * @Example
 * Given the following template, with "admin" being an abstract state:
 * <pre>
 * <div ui-sref-active="{'active': 'admin.*'}">
 *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
 * </div>
 * </pre>
 *
 * When the current state is "admin.roles" the "active" class will be applied
 * to both the <div> and <a> elements. It is important to note that the state
 * names/globs passed to ui-sref-active shadow the state provided by ui-sref.
 */

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref-active-eq
 *
 * @requires ui.router.state.$state
 * @requires ui.router.state.$stateParams
 * @requires $interpolate
 *
 * @restrict A
 *
 * @description
 * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate
 * when the exact target state used in the `ui-sref` is active; no child states.
 *
 */
$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
function $StateRefActiveDirective($state, $stateParams, $interpolate) {
  return  {
    restrict: "A",
    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {
      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;

      // There probably isn't much point in $observing this
      // uiSrefActive and uiSrefActiveEq share the same directive object with some
      // slight difference in logic routing
      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);

      try {
        uiSrefActive = $scope.$eval($attrs.uiSrefActive);
      } catch (e) {
        // Do nothing. uiSrefActive is not a valid expression.
        // Fall back to using $interpolate below
      }
      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
      if (isObject(uiSrefActive)) {
        forEach(uiSrefActive, function(stateOrName, activeClass) {
          if (isString(stateOrName)) {
            var ref = parseStateRef(stateOrName, $state.current.name);
            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
          }
        });
      }

      // Allow uiSref to communicate with uiSrefActive[Equals]
      this.$$addStateInfo = function (newState, newParams) {
        // we already got an explicit state provided by ui-sref-active, so we
        // shadow the one that comes from ui-sref
        if (isObject(uiSrefActive) && states.length > 0) {
          return;
        }
        addState(newState, newParams, uiSrefActive);
        update();
      };

      $scope.$on('$stateChangeSuccess', update);

      function addState(stateName, stateParams, activeClass) {
        var state = $state.get(stateName, stateContext($element));
        var stateHash = createStateHash(stateName, stateParams);

        states.push({
          state: state || { name: stateName },
          params: stateParams,
          hash: stateHash
        });

        activeClasses[stateHash] = activeClass;
      }

      /**
       * @param {string} state
       * @param {Object|string} [params]
       * @return {string}
       */
      function createStateHash(state, params) {
        if (!isString(state)) {
          throw new Error('state should be a string');
        }
        if (isObject(params)) {
          return state + toJson(params);
        }
        params = $scope.$eval(params);
        if (isObject(params)) {
          return state + toJson(params);
        }
        return state;
      }

      // Update route state
      function update() {
        for (var i = 0; i < states.length; i++) {
          if (anyMatch(states[i].state, states[i].params)) {
            addClass($element, activeClasses[states[i].hash]);
          } else {
            removeClass($element, activeClasses[states[i].hash]);
          }

          if (exactMatch(states[i].state, states[i].params)) {
            addClass($element, activeEqClass);
          } else {
            removeClass($element, activeEqClass);
          }
        }
      }

      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }
      function removeClass(el, className) { el.removeClass(className); }
      function anyMatch(state, params) { return $state.includes(state.name, params); }
      function exactMatch(state, params) { return $state.is(state.name, params); }

      update();
    }]
  };
}

angular.module('ui.router.state')
  .directive('uiSref', $StateRefDirective)
  .directive('uiSrefActive', $StateRefActiveDirective)
  .directive('uiSrefActiveEq', $StateRefActiveDirective)
  .directive('uiState', $StateRefDynamicDirective);

/**
 * @ngdoc filter
 * @name ui.router.state.filter:isState
 *
 * @requires ui.router.state.$state
 *
 * @description
 * Translates to {@link ui.router.state.$state#methods_is $state.is("stateName")}.
 */
$IsStateFilter.$inject = ['$state'];
function $IsStateFilter($state) {
  var isFilter = function (state, params) {
    return $state.is(state, params);
  };
  isFilter.$stateful = true;
  return isFilter;
}

/**
 * @ngdoc filter
 * @name ui.router.state.filter:includedByState
 *
 * @requires ui.router.state.$state
 *
 * @description
 * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.
 */
$IncludedByStateFilter.$inject = ['$state'];
function $IncludedByStateFilter($state) {
  var includesFilter = function (state, params, options) {
    return $state.includes(state, params, options);
  };
  includesFilter.$stateful = true;
  return  includesFilter;
}

angular.module('ui.router.state')
  .filter('isState', $IsStateFilter)
  .filter('includedByState', $IncludedByStateFilter);
})(window, window.angular);
},{}],41:[function(require,module,exports){
'use strict';
// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.

module.exports = {
    // Create a <link> tag with optional data attributes
    createLink: function(href, attributes) {
        var head = document.head || document.getElementsByTagName('head')[0];
        var link = document.createElement('link');

        link.href = href;
        link.rel = 'stylesheet';

        for (var key in attributes) {
            if ( ! attributes.hasOwnProperty(key)) {
                continue;
            }
            var value = attributes[key];
            link.setAttribute('data-' + key, value);
        }

        head.appendChild(link);
    },
    // Create a <style> tag with optional data attributes
    createStyle: function(cssText, attributes) {
        var head = document.head || document.getElementsByTagName('head')[0],
            style = document.createElement('style');

        style.type = 'text/css';

        for (var key in attributes) {
            if ( ! attributes.hasOwnProperty(key)) {
                continue;
            }
            var value = attributes[key];
            style.setAttribute('data-' + key, value);
        }
        
        if (style.sheet) { // for jsdom and IE9+
            style.innerHTML = cssText;
            style.sheet.cssText = cssText;
            head.appendChild(style);
        } else if (style.styleSheet) { // for IE8 and below
            head.appendChild(style);
            style.styleSheet.cssText = cssText;
        } else { // for Chrome, Firefox, and Safari
            style.appendChild(document.createTextNode(cssText));
            head.appendChild(style);
        }
    }
};

},{}]},{},[4])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvYW5ndWxhcmNvbnRyb2xsZXJzLmpzIiwiYXBwL2FuZ3VsYXJkaXJlY3RpdmVzLmpzIiwiYXBwL2FuZ3VsYXJzZXJ2aWNlcy5qcyIsImFwcC9hcHAuanMiLCJhcHAvY29tcG9uZW50cy9iZW5lZmljaWFyeS9CZW5lZmljaWFyeUNyZWF0ZVZpZXdEaXJlY3RpdmUuanMiLCJhcHAvY29tcG9uZW50cy9iZW5lZmljaWFyeS9CZW5lZmljaWFyeURlbGV0ZVZpZXdEaXJlY3RpdmUuanMiLCJhcHAvY29tcG9uZW50cy9iZW5lZmljaWFyeS9CZW5lZmljaWFyeURldGFpbFZpZXdEaXJlY3RpdmUuanMiLCJhcHAvY29tcG9uZW50cy9iZW5lZmljaWFyeS9CZW5lZmljaWFyeUxpc3RGcmFnbWVudFZpZXdEaXJlY3RpdmUuanMiLCJhcHAvY29tcG9uZW50cy9iZW5lZmljaWFyeS9CZW5lZmljaWFyeUxpc3RWaWV3RGlyZWN0aXZlLmpzIiwiYXBwL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlTZWFyY2hWaWV3RGlyZWN0aXZlLmpzIiwiYXBwL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlTZXJ2aWNlLmpzIiwiYXBwL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlVcGRhdGVWaWV3RGlyZWN0aXZlLmpzIiwiYXBwL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlWaWV3Q29udHJvbGxlci5qcyIsImFwcC9jb21wb25lbnRzL2JlbmVmaWNpYXJ5L0JlbmVmaWNpYXJ5Vmlld0RpcmVjdGl2ZS5qcyIsImFwcC9jb21wb25lbnRzL2NvbW1vbi9NYWluVmlld0NvbnRyb2xsZXIuanMiLCJhcHAvY29tcG9uZW50cy9jb21tb24vTWFpblZpZXdEaXJlY3RpdmUuanMiLCJhcHAvY29tcG9uZW50cy9jb21tb24vU3RhdGVzLmpzIiwiYXBwL2NvbXBvbmVudHMvY29tbW9uL1V0aWxTZXJ2aWNlLmpzIiwiYXBwL2NvbXBvbmVudHMvY29tcGFueS9Db21wYW55Q3JlYXRlVmlld0RpcmVjdGl2ZS5qcyIsImFwcC9jb21wb25lbnRzL2NvbXBhbnkvQ29tcGFueURlbGV0ZVZpZXdEaXJlY3RpdmUuanMiLCJhcHAvY29tcG9uZW50cy9jb21wYW55L0NvbXBhbnlMaXN0RnJhZ21lbnRWaWV3RGlyZWN0aXZlLmpzIiwiYXBwL2NvbXBvbmVudHMvY29tcGFueS9Db21wYW55TGlzdFZpZXdEaXJlY3RpdmUuanMiLCJhcHAvY29tcG9uZW50cy9jb21wYW55L0NvbXBhbnlTZWFyY2hWaWV3RGlyZWN0aXZlLmpzIiwiYXBwL2NvbXBvbmVudHMvY29tcGFueS9Db21wYW55U2VydmljZS5qcyIsImFwcC9jb21wb25lbnRzL2NvbXBhbnkvQ29tcGFueVVwZGF0ZVZpZXdEaXJlY3RpdmUuanMiLCJhcHAvY29tcG9uZW50cy9jb21wYW55L0NvbXBhbnlWaWV3Q29udHJvbGxlci5qcyIsImFwcC9jb21wb25lbnRzL2NvbXBhbnkvQ29tcGFueVZpZXdEaXJlY3RpdmUuanMiLCJhcHAvY29tcG9uZW50cy9uYXYvU2lkZU5hdlZpZXdDb250cm9sbGVyLmpzIiwiYXBwL2NvbXBvbmVudHMvbmF2L1NpZGVOYXZWaWV3RGlyZWN0aXZlLmpzIiwiYXBwL2NvbXBvbmVudHMvbmxzL2kxOG4tZW4uanMiLCJhcHAvY29uZmlnLmpzIiwiYXBwL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyLWFuaW1hdGUvYW5ndWxhci1hbmltYXRlLmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXItYW5pbWF0ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyLWJsb2NrLXVpL2Rpc3QvYW5ndWxhci1ibG9jay11aS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyLWJsb2NrLXVpL2Rpc3QvYW5ndWxhci1ibG9jay11aS5taW4uY3NzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXItc2FuaXRpemUvYW5ndWxhci1zYW5pdGl6ZS5qcyIsIm5vZGVfbW9kdWxlcy9hbmd1bGFyLXNhbml0aXplL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FuZ3VsYXItdHJhbnNsYXRlL2Rpc3QvYW5ndWxhci10cmFuc2xhdGUuanMiLCJub2RlX21vZHVsZXMvYW5ndWxhci11aS1yb3V0ZXIvcmVsZWFzZS9hbmd1bGFyLXVpLXJvdXRlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNzcy9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3gxSEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVxQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNxQkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgbmcgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1snYW5ndWxhciddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnYW5ndWxhciddIDogbnVsbCk7XHJcbnZhciBNYWluVmlld0NvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvY29tbW9uL01haW5WaWV3Q29udHJvbGxlcicpO1xyXG52YXIgU2lkZU5hdlZpZXdDb250cm9sbGVyID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL25hdi9TaWRlTmF2Vmlld0NvbnRyb2xsZXInKTtcclxudmFyIEJlbmVmaWNpYXJ5Vmlld0NvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlWaWV3Q29udHJvbGxlcicpO1xyXG52YXIgQ29tcGFueVZpZXdDb250cm9sbGVyID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2NvbXBhbnkvQ29tcGFueVZpZXdDb250cm9sbGVyJyk7XHJcbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xyXG5cclxudmFyIG1vZHVsZU5hbWUgPSBjb25maWcuY29uZmlnQmxvY2submFtZXNwYWNlICsgJy5jb250cm9sbGVycyc7XHJcbnZhciBjb250cm9sbGVyc01vZHVsZSA9IG5nLm1vZHVsZShtb2R1bGVOYW1lLCBbXSlcclxuICAgIC5jb250cm9sbGVyKCdNYWluVmlld0NvbnRyb2xsZXInLCBNYWluVmlld0NvbnRyb2xsZXIuY29udHJvbGxlcilcclxuICAgIC5jb250cm9sbGVyKCdTaWRlTmF2Vmlld0NvbnRyb2xsZXInLCBTaWRlTmF2Vmlld0NvbnRyb2xsZXIuY29udHJvbGxlcilcclxuICAgIC5jb250cm9sbGVyKCdCZW5lZmljaWFyeVZpZXdDb250cm9sbGVyJywgQmVuZWZpY2lhcnlWaWV3Q29udHJvbGxlci5jb250cm9sbGVyKVxyXG4gICAgLmNvbnRyb2xsZXIoJ0NvbXBhbnlWaWV3Q29udHJvbGxlcicsIENvbXBhbnlWaWV3Q29udHJvbGxlci5jb250cm9sbGVyKTtcclxuXHJcbmV4cG9ydHMuY29udHJvbGxlcnNNb2R1bGUgPSBjb250cm9sbGVyc01vZHVsZTtcclxuIiwidmFyIG5nID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2FuZ3VsYXInXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2FuZ3VsYXInXSA6IG51bGwpO1xudmFyIE1haW5WaWV3RGlyZWN0aXZlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2NvbW1vbi9NYWluVmlld0RpcmVjdGl2ZScpO1xudmFyIFNpZGVOYXZWaWV3RGlyZWN0aXZlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL25hdi9TaWRlTmF2Vmlld0RpcmVjdGl2ZScpO1xudmFyIEJlbmVmaWNpYXJ5Vmlld0RpcmVjdGl2ZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9iZW5lZmljaWFyeS9CZW5lZmljaWFyeVZpZXdEaXJlY3RpdmUnKTtcbnZhciBCZW5lZmljaWFyeUNyZWF0ZVZpZXdEaXJlY3RpdmUgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlDcmVhdGVWaWV3RGlyZWN0aXZlJyk7XG52YXIgQmVuZWZpY2lhcnlVcGRhdGVWaWV3RGlyZWN0aXZlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2JlbmVmaWNpYXJ5L0JlbmVmaWNpYXJ5VXBkYXRlVmlld0RpcmVjdGl2ZScpO1xudmFyIEJlbmVmaWNpYXJ5RGVsZXRlVmlld0RpcmVjdGl2ZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9iZW5lZmljaWFyeS9CZW5lZmljaWFyeURlbGV0ZVZpZXdEaXJlY3RpdmUnKTtcbnZhciBCZW5lZmljaWFyeUxpc3RWaWV3RGlyZWN0aXZlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2JlbmVmaWNpYXJ5L0JlbmVmaWNpYXJ5TGlzdFZpZXdEaXJlY3RpdmUnKTtcbnZhciBCZW5lZmljaWFyeUxpc3RGcmFnbWVudFZpZXdEaXJlY3RpdmUgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlMaXN0RnJhZ21lbnRWaWV3RGlyZWN0aXZlJyk7XG52YXIgQmVuZWZpY2lhcnlEZXRhaWxWaWV3RGlyZWN0aXZlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2JlbmVmaWNpYXJ5L0JlbmVmaWNpYXJ5RGV0YWlsVmlld0RpcmVjdGl2ZScpO1xudmFyIEJlbmVmaWNpYXJ5U2VhcmNoVmlld0RpcmVjdGl2ZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9iZW5lZmljaWFyeS9CZW5lZmljaWFyeVNlYXJjaFZpZXdEaXJlY3RpdmUnKTtcbnZhciBDb21wYW55Vmlld0RpcmVjdGl2ZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9jb21wYW55L0NvbXBhbnlWaWV3RGlyZWN0aXZlJyk7XG52YXIgQ29tcGFueUNyZWF0ZVZpZXdEaXJlY3RpdmUgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvY29tcGFueS9Db21wYW55Q3JlYXRlVmlld0RpcmVjdGl2ZScpO1xudmFyIENvbXBhbnlVcGRhdGVWaWV3RGlyZWN0aXZlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2NvbXBhbnkvQ29tcGFueVVwZGF0ZVZpZXdEaXJlY3RpdmUnKTtcbnZhciBDb21wYW55RGVsZXRlVmlld0RpcmVjdGl2ZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9jb21wYW55L0NvbXBhbnlEZWxldGVWaWV3RGlyZWN0aXZlJyk7XG52YXIgQ29tcGFueUxpc3RWaWV3RGlyZWN0aXZlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2NvbXBhbnkvQ29tcGFueUxpc3RWaWV3RGlyZWN0aXZlJyk7XG52YXIgQ29tcGFueUxpc3RGcmFnbWVudFZpZXdEaXJlY3RpdmUgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvY29tcGFueS9Db21wYW55TGlzdEZyYWdtZW50Vmlld0RpcmVjdGl2ZScpO1xudmFyIENvbXBhbnlTZWFyY2hWaWV3RGlyZWN0aXZlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2NvbXBhbnkvQ29tcGFueVNlYXJjaFZpZXdEaXJlY3RpdmUnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG52YXIgbW9kdWxlTmFtZSA9IGNvbmZpZy5jb25maWdCbG9jay5uYW1lc3BhY2UgKyAnLmRpcmVjdGl2ZXMnO1xuXG52YXIgZGlyZWN0aXZlc01vZHVsZSA9IG5nLm1vZHVsZShtb2R1bGVOYW1lLCBbXSlcbiAgICAuZGlyZWN0aXZlKCdtYWluVmlldycsIE1haW5WaWV3RGlyZWN0aXZlLmRpcmVjdGl2ZSlcbiAgICAuZGlyZWN0aXZlKCdzaWRlTmF2VmlldycsIFNpZGVOYXZWaWV3RGlyZWN0aXZlLmRpcmVjdGl2ZSlcbiAgICAuZGlyZWN0aXZlKCdiZW5lZmljaWFyeVZpZXcnLCBCZW5lZmljaWFyeVZpZXdEaXJlY3RpdmUuZGlyZWN0aXZlKVxuICAgIC5kaXJlY3RpdmUoJ2JlbmVmaWNpYXJ5Q3JlYXRlVmlldycsIEJlbmVmaWNpYXJ5Q3JlYXRlVmlld0RpcmVjdGl2ZS5kaXJlY3RpdmUpXG4gICAgLmRpcmVjdGl2ZSgnYmVuZWZpY2lhcnlVcGRhdGVWaWV3JywgQmVuZWZpY2lhcnlVcGRhdGVWaWV3RGlyZWN0aXZlLmRpcmVjdGl2ZSlcbiAgICAuZGlyZWN0aXZlKCdiZW5lZmljaWFyeURlbGV0ZVZpZXcnLCBCZW5lZmljaWFyeURlbGV0ZVZpZXdEaXJlY3RpdmUuZGlyZWN0aXZlKVxuICAgIC5kaXJlY3RpdmUoJ2JlbmVmaWNpYXJ5RGV0YWlsVmlldycsIEJlbmVmaWNpYXJ5RGV0YWlsVmlld0RpcmVjdGl2ZS5kaXJlY3RpdmUpXG4gICAgLmRpcmVjdGl2ZSgnYmVuZWZpY2lhcnlTZWFyY2hWaWV3JywgQmVuZWZpY2lhcnlTZWFyY2hWaWV3RGlyZWN0aXZlLmRpcmVjdGl2ZSlcbiAgICAuZGlyZWN0aXZlKCdiZW5lZmljaWFyeUxpc3RWaWV3JywgQmVuZWZpY2lhcnlMaXN0Vmlld0RpcmVjdGl2ZS5kaXJlY3RpdmUpXG4gICAgLmRpcmVjdGl2ZSgnYmVuZWZpY2lhcnlMaXN0RGV0YWlsVmlldycsIEJlbmVmaWNpYXJ5TGlzdFZpZXdEaXJlY3RpdmUuZGlyZWN0aXZlKVxuICAgIC5kaXJlY3RpdmUoJ2JlbmVmaWNpYXJ5TGlzdEZyYWdtZW50VmlldycsIEJlbmVmaWNpYXJ5TGlzdEZyYWdtZW50Vmlld0RpcmVjdGl2ZS5kaXJlY3RpdmUpXG4gICAgLmRpcmVjdGl2ZSgnY29tcGFueVZpZXcnLCBDb21wYW55Vmlld0RpcmVjdGl2ZS5kaXJlY3RpdmUpXG4gICAgLmRpcmVjdGl2ZSgnY29tcGFueUNyZWF0ZVZpZXcnLCBDb21wYW55Q3JlYXRlVmlld0RpcmVjdGl2ZS5kaXJlY3RpdmUpXG4gICAgLmRpcmVjdGl2ZSgnY29tcGFueVVwZGF0ZVZpZXcnLCBDb21wYW55VXBkYXRlVmlld0RpcmVjdGl2ZS5kaXJlY3RpdmUpXG4gICAgLmRpcmVjdGl2ZSgnY29tcGFueURlbGV0ZVZpZXcnLCBDb21wYW55RGVsZXRlVmlld0RpcmVjdGl2ZS5kaXJlY3RpdmUpXG4gICAgLmRpcmVjdGl2ZSgnY29tcGFueVNlYXJjaFZpZXcnLCBDb21wYW55U2VhcmNoVmlld0RpcmVjdGl2ZS5kaXJlY3RpdmUpXG4gICAgLmRpcmVjdGl2ZSgnY29tcGFueUxpc3RWaWV3JywgQ29tcGFueUxpc3RWaWV3RGlyZWN0aXZlLmRpcmVjdGl2ZSlcbiAgICAuZGlyZWN0aXZlKCdjb21wYW55TGlzdEZyYWdtZW50VmlldycsIENvbXBhbnlMaXN0RnJhZ21lbnRWaWV3RGlyZWN0aXZlLmRpcmVjdGl2ZSlcblxuZXhwb3J0cy5kaXJlY3RpdmVzTW9kdWxlID0gZGlyZWN0aXZlc01vZHVsZTtcbiIsInZhciBuZyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wydhbmd1bGFyJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWydhbmd1bGFyJ10gOiBudWxsKTtcbnZhciBCZW5lZmljaWFyeVNlcnZpY2UgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlTZXJ2aWNlJyk7XG52YXIgQ29tcGFueVNlcnZpY2UgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvY29tcGFueS9Db21wYW55U2VydmljZScpO1xudmFyIFV0aWxTZXJ2aWNlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2NvbW1vbi9VdGlsU2VydmljZScpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbnZhciBtb2R1bGVOYW1lID0gY29uZmlnLmNvbmZpZ0Jsb2NrLm5hbWVzcGFjZSArICcuc2VydmljZXMnO1xudmFyIHNlcnZpY2VzTW9kdWxlID0gbmcubW9kdWxlKG1vZHVsZU5hbWUsIFtdKVxuICAgIC5mYWN0b3J5KCdiZW5lZmljaWFyeVNlcnZpY2UnLCBCZW5lZmljaWFyeVNlcnZpY2Uuc2VydmljZSlcbiAgICAuZmFjdG9yeSgnY29tcGFueVNlcnZpY2UnLCBDb21wYW55U2VydmljZS5zZXJ2aWNlKVxuICAgIC5mYWN0b3J5KCd1dGlsU2VydmljZScsIFV0aWxTZXJ2aWNlLnNlcnZpY2UpO1xuXG5leHBvcnRzLnNlcnZpY2VzTW9kdWxlID0gc2VydmljZXNNb2R1bGU7XG4iLCIvKiogTWFpbiBhcHAgKiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5nID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2FuZ3VsYXInXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ2FuZ3VsYXInXSA6IG51bGwpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBzZXJ2aWNlcyA9IHJlcXVpcmUoJy4vYW5ndWxhcnNlcnZpY2VzJyk7XG52YXIgY29udHJvbGxlcnMgPSByZXF1aXJlKCcuL2FuZ3VsYXJjb250cm9sbGVycycpO1xudmFyIGRpcmVjdGl2ZXMgPSByZXF1aXJlKCcuL2FuZ3VsYXJkaXJlY3RpdmVzJyk7XG5cbnZhciBhbmltYXRlTW9kdWxlID0gcmVxdWlyZSgnYW5ndWxhci1hbmltYXRlJyk7XG52YXIgdHJhbnNsYXRlTW9kdWxlID0gcmVxdWlyZSgnYW5ndWxhci10cmFuc2xhdGUnKTtcbnZhciBzYW5pdGl6ZU1vZHVsZSA9IHJlcXVpcmUoJ2FuZ3VsYXItc2FuaXRpemUnKTtcbnZhciBibG9ja1VJTW9kdWxlID0gcmVxdWlyZSgnYW5ndWxhci1ibG9jay11aScpO1xudmFyIHVpUm91dGVyTW9kdWxlID0gcmVxdWlyZSgnYW5ndWxhci11aS1yb3V0ZXInKTtcblxucmVxdWlyZSgnYW5ndWxhci1ibG9jay11aS9kaXN0L2FuZ3VsYXItYmxvY2stdWkubWluLmNzcycpO1xuXG52YXIgbW9kdWxlTmFtZSA9IGNvbmZpZy5jb25maWdCbG9jay5uYW1lc3BhY2U7XG5cbi8vIERlY2xhcmUgYXBwIGxldmVsIG1vZHVsZSB3aGljaCBkZXBlbmRzIG9uIHNlcnZpY2VzLCBjb250cm9sbGVycyBhbmQgZGlyZWN0aXZlc1xubmcubW9kdWxlKG1vZHVsZU5hbWUsIFthbmltYXRlTW9kdWxlLCB0cmFuc2xhdGVNb2R1bGUsIHNhbml0aXplTW9kdWxlLCBibG9ja1VJTW9kdWxlLCB1aVJvdXRlck1vZHVsZSxcbiAgICBzZXJ2aWNlcy5zZXJ2aWNlc01vZHVsZS5uYW1lLCBjb250cm9sbGVycy5jb250cm9sbGVyc01vZHVsZS5uYW1lLCBkaXJlY3RpdmVzLmRpcmVjdGl2ZXNNb2R1bGUubmFtZSxcbiAgICAnaW5mb3JtJywgJ2luZm9ybS1leGNlcHRpb24nLyosICdpbmZvcm0taHR0cC1leGNlcHRpb24nKi9cbl0pO1xuXG5uZy5tb2R1bGUobW9kdWxlTmFtZSlcbiAgLmNvbmZpZyhjb25maWcuY29uZmlnQmxvY2suc2V0dGluZ3MpXG4gIC5jb25maWcoY29uZmlnLmNvbmZpZ0Jsb2NrLnN0YXRlcylcbiAgLmNvbmZpZyhjb25maWcuY29uZmlnQmxvY2suYmxvY2tVSSlcbiAgLmNvbmZpZyhjb25maWcuY29uZmlnQmxvY2suaW5mb3JtKVxuICAuY29uZmlnKGNvbmZpZy5jb25maWdCbG9jay5ocmVmU2FuaXRpemUpO1xuXG5uZy5tb2R1bGUobW9kdWxlTmFtZSlcbiAgLmNvbnN0YW50KCdDT05TVEFOVFMnLCBjb25zdGFudHMuY29uc3RhbnRzKTtcblxudmFyIHJ1bkJsb2NrID0gZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBBZGQgY29kZSB0aGF0IG5lZWRzIGEgcnVuIGJsb2NrIHRvIGV4ZWN1dGUgaGVyZS5cbn07XG5cbm5nLm1vZHVsZShtb2R1bGVOYW1lKVxuICAucnVuKHJ1bkJsb2NrKTtcbiAgLy8gLnJ1bihjb25maWcuY29uZmlnQmxvY2subW9kYWwpO1xuIiwiLyoqXHJcbiAqIEJlbmVmaWNpYXJ5IEZvcm0gQ29tcG9uZW50IERpcmVjdGl2ZVxyXG4gKlxyXG4gKiBAbmdJbmplY3RcclxuICovXHJcbnZhciBkaXJlY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnYXBwL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlDcmVhdGVWaWV3Lmh0bWwnLFxyXG4gICAgICAgIHJlc3RyaWN0OiAnQUUnLFxyXG4gICAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgICAgIGJlbmVmaWNpYXJ5OiAnPWJlbmVmaWNpYXJ5RGV0YWlscydcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2N0cmwnLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6ICdCZW5lZmljaWFyeVZpZXdDb250cm9sbGVyJ1xyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydHMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG4iLCIvKipcclxuICogQ29tcGFueSBEZWxldGUgQ29tcG9uZW50IERpcmVjdGl2ZVxyXG4gKlxyXG4gKiBAbmdJbmplY3RcclxuICovXHJcbnZhciBkaXJlY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnYXBwL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlEZWxldGVWaWV3Lmh0bWwnLFxyXG4gICAgICAgIHJlc3RyaWN0OiAnQUUnLFxyXG4gICAgICAgIHNjb3BlOiBmYWxzZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjdHJsJyxcclxuICAgICAgICBjb250cm9sbGVyOiAnQmVuZWZpY2lhcnlWaWV3Q29udHJvbGxlcidcclxuICAgIH07XHJcbn07XHJcblxyXG5leHBvcnRzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuIiwiLyoqXHJcbiAqIEJlbmVmaWNpYXJ5IERldGFpbCBWaWV3IENvbXBvbmVudCBEaXJlY3RpdmVcclxuICpcclxuICogQHBhcmFtIHskcGFyc2V9IEFuZ3VsYXIgcGFyc2VyIHNlcnZpY2VcclxuICogQHBhcmFtIHskcm9vdFNjb3BlfSBBbmd1bGFyIHJvb3RTY29wZSBzZXJ2aWNlXHJcbiAqXHJcbiAqIEBuZ0luamVjdFxyXG4gKi9cclxudmFyIGRpcmVjdGl2ZSA9IGZ1bmN0aW9uKCRwYXJzZSwgJGNvbXBpbGUsICRyb290U2NvcGUsICR0aW1lb3V0KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnYXBwL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlEZXRhaWxWaWV3Lmh0bWwnLFxyXG4gICAgICAgIHJlc3RyaWN0OiAnQUUnLFxyXG4gICAgICAgIC8vcmVwbGFjZTogdHJ1ZSxcclxuICAgICAgICAvL3RyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgYmVuZWZpY2lhcnk6ICc9YmVuZWZpY2lhcnlEZXRhaWxzJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsLCBhdHRycykge1xyXG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRvbignZGlzYWJsZUJlbmVmaWNpYXJ5JywgZnVuY3Rpb24oZXYsIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5iZW5lZmljaWFyaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuYmVuZWZpY2lhcmllc1tpXS5pZCA9PT0gZGF0YS5iZW5lZmljaWFyeUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dEVscyA9IGFuZ3VsYXIuZWxlbWVudChlbC5maW5kKCdpbnB1dFt0eXBlPXRleHRdJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlucHV0RWxzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoaW5wdXRFbHNbal0pLmF0dHIoJ2Rpc2FibGVkJywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNvbXBpbGUoaW5wdXRFbHNbal0pKHNjb3BlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vJGNvbXBpbGUoZWwpKHNjb3BlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuZGlyZWN0aXZlLiRpbmplY3QgPSBbXCIkcGFyc2VcIiwgXCIkY29tcGlsZVwiLCBcIiRyb290U2NvcGVcIiwgXCIkdGltZW91dFwiXTtcclxuXHJcbmV4cG9ydHMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG4iLCIvKipcclxuICogQ29tcGFueSBUYWJsZSBMaXN0IENvbXBvbmVudCBEaXJlY3RpdmVcclxuICpcclxuICogQG5nSW5qZWN0XHJcbiAqL1xyXG52YXIgZGlyZWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2FwcC9jb21wb25lbnRzL2JlbmVmaWNpYXJ5L0JlbmVmaWNpYXJ5TGlzdEZyYWdtZW50Vmlldy5odG1sJyxcclxuICAgICAgICByZXN0cmljdDogJ0FFJyxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICBiZW5lZmljaWFyaWVzOiAnPScsXHJcbiAgICAgICAgICAgIGRlbHJlZjogJz0nLFxyXG4gICAgICAgICAgICBzZWFyY2hSZXF1ZXN0U3VtYml0dGVkOiAnPSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2N0cmwnLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6ICdCZW5lZmljaWFyeVZpZXdDb250cm9sbGVyJ1xyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydHMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG4iLCIvKipcclxuICogQ29tcGFueSBUYWJsZSBMaXN0IENvbXBvbmVudCBEaXJlY3RpdmVcclxuICpcclxuICogQG5nSW5qZWN0XHJcbiAqL1xyXG52YXIgZGlyZWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2FwcC9jb21wb25lbnRzL2JlbmVmaWNpYXJ5L0JlbmVmaWNpYXJ5TGlzdFZpZXcuaHRtbCcsXHJcbiAgICAgICAgcmVzdHJpY3Q6ICdBRScsXHJcbiAgICAgICAgc2NvcGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2N0cmwnLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6ICdCZW5lZmljaWFyeVZpZXdDb250cm9sbGVyJ1xyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydHMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG4iLCIvKipcclxuICogQ29tcGFueSBTZWFyY2ggQ29tcG9uZW50IERpcmVjdGl2ZVxyXG4gKlxyXG4gKiBAbmdJbmplY3RcclxuICovXHJcbnZhciBkaXJlY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnYXBwL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlTZWFyY2hWaWV3Lmh0bWwnLFxyXG4gICAgICAgIHJlc3RyaWN0OiAnQUUnLFxyXG4gICAgICAgIHNjb3BlOiBmYWxzZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjdHJsJyxcclxuICAgICAgICBjb250cm9sbGVyOiAnQmVuZWZpY2lhcnlWaWV3Q29udHJvbGxlcidcclxuICAgIH07XHJcbn07XHJcblxyXG5leHBvcnRzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuIiwiLyoqXHJcbiAqIFRoaXMgc2VydmljZSBoZWxwcyB0byBwZXJmb3JtIGh0dHAgcmVxdWVzdHMgKEdFVCwgUE9TVCwgUFVULCBERUxFVEUpIGZvciBiZW5lZmljaWFyeSB0YXNrc1xyXG4gKlxyXG4gKiBAcGFyYW0geyRodHRwfSBUaGUgQW5ndWxhckpTIGh0dHAgc2VydmljZVxyXG4gKiBAcGFyYW0geyR0aW1lb3V0fSBUaGUgQW5ndWxhckpTIHRpbWVvdXQgc2VydmljZVxyXG4gKlxyXG4gKiBAbmdJbmplY3RcclxuICovXHJcbnZhciBzZXJ2aWNlID0gZnVuY3Rpb24oJGh0dHAsICR0aW1lb3V0KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIHNlcnZpY2VJbnN0YW5jZSA9IHt9O1xyXG4gICAgc2VydmljZUluc3RhbmNlLnNlbGVjdGVkQmVuZWZpY2lhcnlJZCA9IG51bGw7XHJcbiAgICBzZXJ2aWNlSW5zdGFuY2UucG9wT25EZWxldGUgPSBudWxsO1xyXG4gICAgc2VydmljZUluc3RhbmNlLmJlbmVmaWNpYXJ5ID0gbnVsbDtcclxuICAgIHNlcnZpY2VJbnN0YW5jZS5iZW5lZmljaWFyaWVzID0gW107XHJcblxyXG4gICAgc2VydmljZUluc3RhbmNlLmdldEJlbmVmaWNpYXJ5ID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xyXG4gICAgICAgICRodHRwKHtcclxuICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbnAnXHJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdHMpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGVycm9yLnN0YXR1cyA/IGVycm9yLnN0YXR1cyA6IDUwMCxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLmRhdGEgPyBlcnJvci5kYXRhIDogJ0Vycm9yIG9jY3VyZWQgd2hpbGUgcmV0cmlldmluZyBiZW5lZmljaWFyeSBkZXRhaWxzJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvckRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZXJ2aWNlSW5zdGFuY2UuY3JlYXRlQmVuZWZpY2lhcnkgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgJGh0dHAoe1xyXG4gICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbnAnXHJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdHMpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGVycm9yLnN0YXR1cyA/IGVycm9yLnN0YXR1cyA6IDUwMCxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLmRhdGEgPyBlcnJvci5kYXRhIDogJ0Vycm9yIG9jY3VyZWQgd2hpbGUgcmV0cmlldmluZyBiZW5lZmljaWFyeSBkZXRhaWxzJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvckRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHNlcnZpY2VJbnN0YW5jZS51cGRhdGVCZW5lZmljaWFyeSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICAkaHR0cCh7XHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb25wJ1xyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHRzKTtcclxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvci5zdGF0dXMgPyBlcnJvci5zdGF0dXMgOiA1MDAsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5kYXRhID8gZXJyb3IuZGF0YSA6ICdFcnJvciBvY2N1cmVkIHdoaWxlIHJldHJpZXZpbmcgYmVuZWZpY2lhcnkgZGV0YWlscydcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3JEYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgc2VydmljZUluc3RhbmNlLmRlbGV0ZUJlbmVmaWNpYXJ5ID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xyXG4gICAgICAgICRodHRwKHtcclxuICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbnAnXHJcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdHMpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGVycm9yLnN0YXR1cyA/IGVycm9yLnN0YXR1cyA6IDUwMCxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLmRhdGEgPyBlcnJvci5kYXRhIDogJ0Vycm9yIG9jY3VyZWQgd2hpbGUgcmV0cmlldmluZyBiZW5lZmljaWFyeSBkZXRhaWxzJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvckRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gc2VydmljZUluc3RhbmNlO1xyXG59O1xyXG5zZXJ2aWNlLiRpbmplY3QgPSBbXCIkaHR0cFwiLCBcIiR0aW1lb3V0XCJdO1xyXG5cclxuZXhwb3J0cy5zZXJ2aWNlID0gc2VydmljZTtcclxuIiwiLyoqXHJcbiAqIEJlbmVmaWNpYXJ5IEZvcm0gQ29tcG9uZW50IERpcmVjdGl2ZVxyXG4gKlxyXG4gKiBAbmdJbmplY3RcclxuICovXHJcbnZhciBkaXJlY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnYXBwL2NvbXBvbmVudHMvYmVuZWZpY2lhcnkvQmVuZWZpY2lhcnlVcGRhdGVWaWV3Lmh0bWwnLFxyXG4gICAgICAgIHJlc3RyaWN0OiAnQUUnLFxyXG4gICAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgICAgIGJlbmVmaWNpYXJ5OiAnPWJlbmVmaWNpYXJ5RGV0YWlscydcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2N0cmwnLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6ICdCZW5lZmljaWFyeVZpZXdDb250cm9sbGVyJ1xyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydHMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG4iLCIvKipcclxuICogQmVuZWZpY2lhcnkgVmlldyBjb250cm9sbGVyXHJcbiAqXHJcbiAqIFRoaXMgY29udHJvbGxlciBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGluZyBiZW5lZmljaWFyeSBmb3JtIG1vZHVsZSByZWxhdGVkIGxvZ2ljXHJcbiAqXHJcbiAqIEBwYXJhbSB7JHJvb3RTY29wZX0gQW5ndWxhciByb290IHNjb3BlIHNlcnZpY2VcclxuICogQHBhcmFtIHskc2NvcGV9IEFuZ3VsYXIgc2NvcGUgc2VydmljZVxyXG4gKiBAcGFyYW0geyR0aW1lb3V0fSBBbmd1bGFyIHRpbWVvdXQgc2VydmljZVxyXG4gKiBAcGFyYW0geyR3aW5kb3d9IEFuZ3VsYXIgd2luZG93IHNlcnZpY2VcclxuICogQHBhcmFtIHskZG9jdW1lbnR9IEFuZ3VsYXIgZG9jdW1lbnQgc2VydmljZVxyXG4gKiBAcGFyYW0geyRsb2d9IEFuZ3VsYXIgbG9nZ2VyIHNlcnZpY2VcclxuICogQHBhcmFtIHskbW9kYWx9IEFuZ3VsYXIgbW9kYWwgc2VydmljZVxyXG4gKiBAcGFyYW0ge2JlbmVmaWNpYXJ5U2VydmljZX0gQmVuZWZpY2lhcnkgc2VydmljZVxyXG4gKiBAcGFyYW0ge3V0aWxTZXJ2aWNlfSBVdGlsaXR5IHNlcnZpY2VcclxuICogQHBhcmFtIHtibG9ja1VJfSBCbG9jayBVSSBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7aW5mb3JtfSBJbmZvcm0gcHJvdmlkZXIgc2VydmljZVxyXG4gKiBAcGFyYW0ge0NPTlNUQU5UU30gUHJvamVjdCBjb25zdGFudHMgdmFsdWVzXHJcbiAqXHJcbiAqIEBuZ0luamVjdFxyXG4gKlxyXG4gKi9cclxudmFyIGNvbnRyb2xsZXIgPSBmdW5jdGlvbigkcm9vdFNjb3BlLCAkc2NvcGUsICR0aW1lb3V0LCAkd2luZG93LCAkZG9jdW1lbnQsICRsb2csICRzdGF0ZSwgJG1vZGFsLCBiZW5lZmljaWFyeVNlcnZpY2UsIHV0aWxTZXJ2aWNlLCBibG9ja1VJLCBpbmZvcm0sIENPTlNUQU5UUykge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIGN0cmwgPSB0aGlzO1xyXG5cclxuICAgICRzY29wZS51c2VFeGlzdGluZ0JlbmVmaWNpYXJ5ID0gZmFsc2U7XHJcbiAgICAkc2NvcGUubWluaW11bVZhbGlkQmVuZWZpY2lhcnkgPSBmYWxzZTtcclxuICAgICRzY29wZS5iZW5lZmljaWFyeUlkID0gbnVsbDtcclxuICAgICRzY29wZS5iZW5lZmljaWFyeVNlYXJjaGVkID0gZmFsc2U7XHJcbiAgICAkc2NvcGUuYmVuZWZpY2lhcnlGb3VuZCA9IGZhbHNlO1xyXG4gICAgJHNjb3BlLnNlYXJjaFJlcXVlc3RTdW1iaXR0ZWQgPSBmYWxzZTtcclxuICAgICRzY29wZS5hZGRSZXF1ZXN0U3VibWl0dGVkID0gZmFsc2U7XHJcbiAgICAkc2NvcGUuYWRkUmVxdWVzdEF0dGVtcHRlZCA9IGZhbHNlO1xyXG4gICAgJHNjb3BlLnVwZGF0ZVJlcXVlc3RTdWJtaXR0ZWQgPSBmYWxzZTtcclxuICAgICRzY29wZS51cGRhdGVSZXF1ZXN0QXR0ZW1wdGVkID0gZmFsc2U7XHJcbiAgICAkc2NvcGUuZGVsZXRlUmVxdWVzdFN1Ym1pdHRlZCA9IGZhbHNlO1xyXG4gICAgJHNjb3BlLmRlbGV0ZVN1Y2Nlc3NmdWwgPSBmYWxzZTtcclxuICAgICRzY29wZS5zZXJ2aWNlVXJsID0gQ09OU1RBTlRTLnVybC5wYXRoO1xyXG5cclxuICAgICRzY29wZS5pbml0QmVuZWZpY2lhcnkgPSB7XHJcbiAgICAgICAgXCJmaXJzdE5hbWVcIjogbnVsbCxcclxuICAgICAgICBcImxhc3ROYW1lXCI6IG51bGxcclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLmJlbmVmaWNpYXJpZXMgPSBiZW5lZmljaWFyeVNlcnZpY2UuYmVuZWZpY2lhcmllcy5sZW5ndGggPiAwID8gYmVuZWZpY2lhcnlTZXJ2aWNlLmJlbmVmaWNpYXJpZXMgOiBbXTtcclxuICAgICRzY29wZS5iZW5lZmljaWFyeSA9IGJlbmVmaWNpYXJ5U2VydmljZS5iZW5lZmljaWFyeSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCRzdGF0ZS5jdXJyZW50Lm5hbWUgPT09ICdzdGFydC5iZW5lZmljaWFyeS51cGRhdGUnIHx8ICRzdGF0ZS5jdXJyZW50Lm5hbWUgPT09ICdzdGFydC5iZW5lZmljaWFyeS5saXN0LmRlbGV0ZScgfHwgJHN0YXRlLmN1cnJlbnQubmFtZSA9PT0gJ3N0YXJ0LmJlbmVmaWNpYXJ5LnNlYXJjaC5kZWxldGUnKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBiZW5lZmljaWFyeVNlcnZpY2UuYmVuZWZpY2lhcnkgOiAkc2NvcGUuaW5pdEJlbmVmaWNpYXJ5O1xyXG5cclxuICAgICRzY29wZS5yZXNldEJlbmVmaWNpYXJ5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5iZW5lZmljaWFyeSA9ICRzY29wZS5pbml0QmVuZWZpY2lhcnk7XHJcbiAgICAgICAgICAgICRzY29wZS5iZW5lZmljaWFyaWVzID0gW107XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgICRzY29wZS5hZGRCZW5lZmljaWFyeSA9IGZ1bmN0aW9uKCRldmVudCkge1xyXG4gICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAkc2NvcGUuYWRkUmVxdWVzdFN1Ym1pdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGJlbmVmaWNpYXJ5U2VydmljZS5iZW5lZmljaWFyeSA9ICRzY29wZS5iZW5lZmljaWFyeTtcclxuICAgICAgICBpZiAoIXV0aWxTZXJ2aWNlLmlzRm9ybVZhbGlkKCdiZW5lZmljaWFyeURldGFpbHNGb3JtJykpIHtcclxuICAgICAgICAgICAgJHNjb3BlLmFkZFJlcXVlc3RBdHRlbXB0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAkbG9nLndhcm4oJ2Zvcm0gaW52YWxpZCcpO1xyXG4gICAgICAgICAgICBpbmZvcm0uYWRkKCdJbnZhbGlkIGZvcm0uIEZpcnN0IG5hbWUgYW5kIExhc3QgbmFtZSBhcmUgcmVxdWlyZWQgdG8gY3JlYXRlIGJlbmVmaWNpYXJ5Jywge1xyXG4gICAgICAgICAgICAgICAgdHRsOiAzNTAwLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcidcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vICRzY29wZS5yZWdpc3RlclBvcG92ZXJTaG93KCcjYWRkQmVuZWZpY2lhcnknKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGJlbmVmaWNpYXJ5Q3JlYXRlQmxvY2sgPSBibG9ja1VJLmluc3RhbmNlcy5nZXQoJ2JlbmVmaWNpYXJ5Q3JlYXRlQmxvY2snKTtcclxuICAgICAgICAvLyBiZW5lZmljaWFyeUNyZWF0ZUJsb2NrLnN0YXJ0KCk7XHJcbiAgICAgICAgdmFyIHVybCA9ICRzY29wZS5zZXJ2aWNlVXJsICsgJy8nICsgQ09OU1RBTlRTLnVybC5iZW5lZmljaWFyeUNvbnRleHRQYXRoO1xyXG4gICAgICAgIGJlbmVmaWNpYXJ5U2VydmljZS5jcmVhdGVCZW5lZmljaWFyeSh1cmwsICRzY29wZS5iZW5lZmljaWFyeSwgZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLmFkZFJlcXVlc3RTdWJtaXR0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZGF0YS5pZCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mb3JtLmFkZCgnYmVuZWZpY2lhcnkgY3JlYXRlZCBzdWNjZXNzZnVsbHkuJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHRsOiAyNTAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnc3RhcnQuYmVuZWZpY2lhcnknLCB7fSwge3JlbG9hZDp0cnVlfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDI1MDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybS5hZGQoJ1JlcXVlc3QgY29tcGxldGVkLCBob3dldmVyIGJlbmVmaWNpYXJ5IGNvdWxkblxcJ3QgYmUgY3JlYXRlZC4nLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDUwMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd2FybmluZydcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmZvcm0uYWRkKHJlc3VsdCAmJiByZXN1bHQubWVzc2FnZSAmJiByZXN1bHQubWVzc2FnZS5lcnJvck1lc3NhZ2UgPyByZXN1bHQubWVzc2FnZS5lcnJvck1lc3NhZ2UgOiAnRXJyb3IgY3JlYXRpbmcgYmVuZWZpY2lhcnkuJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDUwMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkYW5nZXInXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5hZGRSZXF1ZXN0U3VibWl0dGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgNTAwMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBiZW5lZmljaWFyeUNyZWF0ZUJsb2NrLnN0b3AoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgICRzY29wZS5jYW5jZWxBZGRCZW5lZmljaWFyeSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICRzdGF0ZS5nbygnc3RhcnQuYmVuZWZpY2lhcnknKTtcclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLnVwZGF0ZUJlbmVmaWNpYXJ5ID0gZnVuY3Rpb24oJGV2ZW50KSB7XHJcbiAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICRzY29wZS51cGRhdGVSZXF1ZXN0U3VibWl0dGVkID0gZmFsc2U7XHJcbiAgICAgICAgYmVuZWZpY2lhcnlTZXJ2aWNlLmJlbmVmaWNpYXJ5ID0gJHNjb3BlLmJlbmVmaWNpYXJ5O1xyXG4gICAgICAgIGlmICghdXRpbFNlcnZpY2UuaXNGb3JtVmFsaWQoJ2JlbmVmaWNpYXJ5RGV0YWlsc0Zvcm0nKSkge1xyXG4gICAgICAgICAgICAkc2NvcGUudXBkYXRlUmVxdWVzdEF0dGVtcHRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICRsb2cud2FybignY2Nmb3JtIGludmFsaWQnKTtcclxuICAgICAgICAgICAgaW5mb3JtLmFkZCgnSW52YWxpZCBmb3JtLiBGaXJzdCBuYW1lIGFuZCBMYXN0IG5hbWUgYXJlIHJlcXVpcmVkIHRvIGNyZWF0ZSBiZW5lZmljaWFyeScsIHtcclxuICAgICAgICAgICAgICAgIHR0bDogMzUwMCxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdkYW5nZXInXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB2YXIgYmVuZWZpY2lhcnlVcGRhdGVCbG9jayA9IGJsb2NrVUkuaW5zdGFuY2VzLmdldCgnYmVuZWZpY2lhcnlVcGRhdGVCbG9jaycpO1xyXG4gICAgICAgIC8vIGJlbmVmaWNpYXJ5VXBkYXRlQmxvY2suc3RhcnQoKTtcclxuICAgICAgICB2YXIgdXJsID0gJHNjb3BlLnNlcnZpY2VVcmwgKyAnLycgKyBDT05TVEFOVFMudXJsLmJlbmVmaWNpYXJ5Q29udGV4dFBhdGg7XHJcbiAgICAgICAgYmVuZWZpY2lhcnlTZXJ2aWNlLnVwZGF0ZUJlbmVmaWNpYXJ5KHVybCwgJHNjb3BlLmJlbmVmaWNpYXJ5LCBmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUudXBkYXRlUmVxdWVzdFN1Ym1pdHRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kYXRhLnN0YXR1cyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvcm0uYWRkKCdiZW5lZmljaWFyeSB1cGRhdGVkIHN1Y2Nlc3NmdWxseS4nLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDQwMDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzdGFydC5iZW5lZmljaWFyeS5saXN0Jywge30sIHtyZWxvYWQ6IHRydWV9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgNDUwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mb3JtLmFkZCgnUmVxdWVzdCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBidXQgbm8gdXBkYXRlIHBlcmZvcm1lZCBvbiBiZW5lZmljaWFyeS4nLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDUwMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd2FybmluZydcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmZvcm0uYWRkKHJlc3VsdCAmJiByZXN1bHQubWVzc2FnZSAmJiByZXN1bHQubWVzc2FnZS5lcnJvck1lc3NhZ2UgPyByZXN1bHQubWVzc2FnZS5lcnJvck1lc3NhZ2UgOiAnYmVuZWZpY2lhcnkgY291bGRuXFwndCBiZSB1cGRhdGVkLicsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHRsOiA1MDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGFuZ2VyJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUudXBkYXRlUmVxdWVzdFN1Ym1pdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIDUwMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYmVuZWZpY2lhcnlVcGRhdGVCbG9jay5zdG9wKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAkc2NvcGUuY2FuY2VsT3JDbG9zZUJlbmVmaWNpYXJ5VXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJHN0YXRlLmdvKCdzdGFydC5iZW5lZmljaWFyeS5saXN0Jywge30sIHtyZWxvYWQ6IHRydWV9KTtcclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLmRlbGV0ZUJlbmVmaWNpYXJ5ID0gZnVuY3Rpb24oJGV2ZW50KSB7XHJcbiAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICRzY29wZS5iZW5lZmljaWFyeSA9IGJlbmVmaWNpYXJ5U2VydmljZS5iZW5lZmljaWFyeTtcclxuICAgICAgICAvLyB2YXIgYmVuZWZpY2lhcnlVcGRhdGVCbG9jayA9IGJsb2NrVUkuaW5zdGFuY2VzLmdldCgnYmVuZWZpY2lhcnlVcGRhdGVCbG9jaycpO1xyXG4gICAgICAgIC8vIGJlbmVmaWNpYXJ5VXBkYXRlQmxvY2suc3RhcnQoKTtcclxuICAgICAgICB2YXIgdXJsID0gJHNjb3BlLnNlcnZpY2VVcmwgKyAnLycgKyBDT05TVEFOVFMudXJsLmJlbmVmaWNpYXJ5Q29udGV4dFBhdGggKyAnLycgKyAkc2NvcGUuYmVuZWZpY2lhcnkuaWQ7XHJcbiAgICAgICAgYmVuZWZpY2lhcnlTZXJ2aWNlLmRlbGV0ZUJlbmVmaWNpYXJ5KHVybCwgZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlbGV0ZVJlcXVlc3RTdWJtaXR0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuZGF0YSAmJiByZXN1bHQuZGF0YS5zdGF0dXMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGVsZXRlU3VjY2Vzc2Z1bCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAkbG9nLmluZm8ocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGJlbmVmaWNpYXJ5VXBkYXRlQmxvY2suc3RvcCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLmNhbmNlbE9yQ2xvc2VCZW5lZmljaWFyeURlbGV0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICRzY29wZS4kZGlzbWlzcygpO1xyXG4gICAgICAgICRzdGF0ZS5nbygnc3RhcnQuYmVuZWZpY2lhcnkubGlzdCcsIHt9LCB7cmVsb2FkOiB0cnVlfSk7XHJcbiAgICB9O1xyXG5cclxuICAgICRzY29wZS5mZXRjaEJlbmVmaWNpYXJ5ID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICAkc2NvcGUuYmVuZWZpY2lhcmllcy5zcGxpY2UoMCwgJHNjb3BlLmJlbmVmaWNpYXJpZXMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdmFyIGlkU2VhcmNoID0gIXV0aWxTZXJ2aWNlLmlzQmxhbmsoaWQpO1xyXG4gICAgICAgIHZhciBiYXNlVXJsID0gJHNjb3BlLnNlcnZpY2VVcmwgKyAnLycgKyBDT05TVEFOVFMudXJsLmJlbmVmaWNpYXJ5Q29udGV4dFBhdGg7XHJcbiAgICAgICAgdmFyIHVybCA9IGlkU2VhcmNoID8gYmFzZVVybCArICcvJyArIGlkIDogYmFzZVVybDtcclxuICAgICAgICAvL3ZhciBiZW5lZmljaWFyeUxpc3RCbG9jayA9IGJsb2NrVUkuaW5zdGFuY2VzLmdldCgnYmVuZWZpY2lhcnlMaXN0QmxvY2snKTtcclxuICAgICAgICAvL2JlbmVmaWNpYXJ5TGlzdEJsb2NrLnN0YXJ0KCk7XHJcbiAgICAgICAgYmVuZWZpY2lhcnlTZXJ2aWNlLmdldEJlbmVmaWNpYXJ5KHVybCwgZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLnNlYXJjaFJlcXVlc3RTdW1iaXR0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZFNlYXJjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYmVuZWZpY2lhcmllcy5wdXNoKHJlc3VsdC5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYmVuZWZpY2lhcmllcyA9IHJlc3VsdC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiZW5lZmljaWFyeVNlcnZpY2UuYmVuZWZpY2lhcmllcyA9ICRzY29wZS5iZW5lZmljaWFyaWVzO1xyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5iZW5lZmljaWFyeUZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vYmVuZWZpY2lhcnlMaXN0QmxvY2suc3RvcCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLnNlYXJjaEJlbmVmaWNpYXJ5ID0gZnVuY3Rpb24oaWQsICRldmVudCkge1xyXG4gICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCF1dGlsU2VydmljZS5pc1ZhbGlkSWQoaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVyU2hvdygnI3NlYXJjaEV4aXN0aW5nQmVuZWZpY2lhcnlJZCcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICRzY29wZS5mZXRjaEJlbmVmaWNpYXJ5KGlkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLm11dGF0ZUJlbmVmaWNpYXJ5T3B0aW9ucyA9IGZ1bmN0aW9uKGJlbmVmaWNpYXJ5LCAkaW5kZXgsICRldmVudCkge1xyXG4gICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBiZW5lZmljaWFyeVNlcnZpY2Uuc2VsZWN0ZWRCZW5lZmljaWFyeUlkID0gJyNiZW5lZmljaWFyeScgKyAkaW5kZXg7XHJcbiAgICAgICAgYmVuZWZpY2lhcnlTZXJ2aWNlLmJlbmVmaWNpYXJ5ID0gYmVuZWZpY2lhcnk7XHJcbiAgICAgICAgJHNjb3BlLnJlZ2lzdGVyUG9wb3ZlclByZXAoYmVuZWZpY2lhcnlTZXJ2aWNlLnNlbGVjdGVkQmVuZWZpY2lhcnlJZCk7XHJcbiAgICAgICAgJHNjb3BlLnJlZ2lzdGVyUG9wb3ZlclNob3coYmVuZWZpY2lhcnlTZXJ2aWNlLnNlbGVjdGVkQmVuZWZpY2lhcnlJZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qIGluaXRpYWxpemUgcG9wb3ZlciAqL1xyXG5cclxuICAgICRzY29wZS5kaXNjYXJkTWVzc2FnZSA9IGZ1bmN0aW9uKCRldmVudCkge1xyXG4gICAgICAgICRldmVudCA/ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKSA6ICcnO1xyXG4gICAgICAgIGJlbmVmaWNpYXJ5U2VydmljZS5wb3BPbkRlbGV0ZSA9IFwiZGVsZXRlXCI7XHJcbiAgICAgICAgJHNjb3BlLnJlZ2lzdGVyUG9wb3ZlckhpZGUoJ1tpZCo9cG9wb3Zlcl0nKTtcclxuICAgIH07XHJcblxyXG4gICAgYmVuZWZpY2lhcnlTZXJ2aWNlLnBvcE9uRGVsZXRlID0gXCJkZWxldGVcIjtcclxuXHJcbiAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVyUHJlcCA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgYW5ndWxhci5lbGVtZW50KCRkb2N1bWVudC5maW5kKGlkKSkucG9wb3Zlcih7XHJcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgICRzY29wZS5yZWdpc3RlclBvcG92ZXJTaG93ID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICBpZiAoYmVuZWZpY2lhcnlTZXJ2aWNlLnBvcE9uRGVsZXRlICE9PSBcInBvcG92ZXJcIikge1xyXG4gICAgICAgICAgICBiZW5lZmljaWFyeVNlcnZpY2UucG9wT25EZWxldGUgPSBcInBvcG92ZXJcIjtcclxuICAgICAgICAgICAgYW5ndWxhci5lbGVtZW50KCRkb2N1bWVudC5maW5kKGlkKSkucG9wb3Zlcignc2hvdycpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLnJlZ2lzdGVyUG9wb3ZlckhpZGUgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgIHZhciBlbCA9IGFuZ3VsYXIuZWxlbWVudCgkZG9jdW1lbnQuZmluZChpZCkpO1xyXG4gICAgICAgIGVsID8gZWwucG9wb3ZlcignaGlkZScpIDogJyc7XHJcbiAgICB9O1xyXG5cclxuICAgICRzY29wZS5yZWdpc3RlclBvcG92ZXJQcmVwKCcjcmVtb3ZlQmVuZWZpY2lhcnknKTtcclxuICAgICRzY29wZS5yZWdpc3RlclBvcG92ZXJQcmVwKCcjYWRkQmVuZWZpY2lhcnknKTtcclxuICAgICRzY29wZS5yZWdpc3RlclBvcG92ZXJQcmVwKCcjdXBkYXRlQmVuZWZpY2lhcnknKTtcclxuICAgICRzY29wZS5yZWdpc3RlclBvcG92ZXJQcmVwKCcjc2VhcmNoRXhpc3RpbmdCZW5lZmljaWFyeUlkJyk7XHJcbiAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVySGlkZSgnW2lkKj1wb3BvdmVyXScpO1xyXG5cclxuICAgIC8vIGNsZWFyIGFsbCBpbmZvcm1zXHJcbiAgICBpbmZvcm0uY2xlYXIoKTtcclxufTtcclxuY29udHJvbGxlci4kaW5qZWN0ID0gW1wiJHJvb3RTY29wZVwiLCBcIiRzY29wZVwiLCBcIiR0aW1lb3V0XCIsIFwiJHdpbmRvd1wiLCBcIiRkb2N1bWVudFwiLCBcIiRsb2dcIiwgXCIkc3RhdGVcIiwgXCIkbW9kYWxcIiwgXCJiZW5lZmljaWFyeVNlcnZpY2VcIiwgXCJ1dGlsU2VydmljZVwiLCBcImJsb2NrVUlcIiwgXCJpbmZvcm1cIiwgXCJDT05TVEFOVFNcIl07XHJcblxyXG5leHBvcnRzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xyXG4iLCIvKipcclxuICogTWFpbiBCZW5lZmljaWFyeSBEaXJlY3RpdmVcclxuICpcclxuICogQG5nSW5qZWN0XHJcbiAqL1xyXG52YXIgZGlyZWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2FwcC9jb21wb25lbnRzL2JlbmVmaWNpYXJ5L0JlbmVmaWNpYXJ5Vmlldy5odG1sJyxcclxuICAgICAgICByZXN0cmljdDogJ0FFJyxcclxuICAgICAgICBzY29wZTogZmFsc2UsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnY3RybCcsXHJcbiAgICAgICAgY29udHJvbGxlcjogJ0JlbmVmaWNpYXJ5Vmlld0NvbnRyb2xsZXInXHJcbiAgICB9O1xyXG59O1xyXG5cclxuZXhwb3J0cy5kaXJlY3RpdmUgPSBkaXJlY3RpdmU7XHJcbiIsIi8qKlxyXG4gKiBNYWluIFZpZXcgY29udHJvbGxlclxyXG4gKlxyXG4gKiBUaGlzIGNvbnRyb2xsZXIgaXMgcmVzcG9uc2libGUgZm9yIGhhbmRpbmcgcmVxdWVzdCBmcm9tIG1haW4gdmlld1xyXG4gKlxyXG4gKiBAcGFyYW0geyRyb290U2NvcGV9IEFuZ3VsYXIgcm9vdCBzY29wZSBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7JHNjb3BlfSBBbmd1bGFyIHNjb3BlIHNlcnZpY2VcclxuICogQHBhcmFtIHskdGltZW91dH0gQW5ndWxhciB0aW1lb3V0IHNlcnZpY2VcclxuICogQHBhcmFtIHskd2luZG93fSBBbmd1bGFyIHdpbmRvdyBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7JGRvY3VtZW50fSBBbmd1bGFyIGRvY3VtZW50IHNlcnZpY2VcclxuICogQHBhcmFtIHskbG9nfSBBbmd1bGFyIGxvZ2dlciBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7YmVuZWZpY2lhcnlTZXJ2aWNlfSBCZW5lZmljaWFyeSBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7Y29tcGFueVNlcnZpY2V9IENvbXBhbnkgc2VydmljZVxyXG4gKlxyXG4gKiBAbmdJbmplY3RcclxuICpcclxuICovXHJcbnZhciBjb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgY3RybCA9IHRoaXM7XHJcblxyXG59O1xyXG5cclxuZXhwb3J0cy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcclxuIiwiLyoqXHJcbiAqIE1haW4gRGlyZWN0aXZlXHJcbiAqXHJcbiAqL1xyXG52YXIgZGlyZWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2FwcC9jb21wb25lbnRzL2NvbW1vbi9NYWluVmlldy5odG1sJyxcclxuICAgICAgICByZXN0cmljdDogJ0FFJyxcclxuICAgICAgICBzY29wZTogZmFsc2UsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnY3RybCcsXHJcbiAgICAgICAgY29udHJvbGxlcjogJ01haW5WaWV3Q29udHJvbGxlcidcclxuICAgIH07XHJcbn07XHJcblxyXG5leHBvcnRzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuIiwidmFyIHN0YXRlQ29uZmlnID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IHRvIDxjb21wYW55LWNyZWF0ZS12aWV3IC8+XHJcbiAgICAgKi9cclxuICAgIG1haW46IHtcclxuICAgICAgICB1cmw6ICcvJyxcclxuICAgICAgICB2aWV3czoge1xyXG4gICAgICAgICAgICAnbWFpbic6IHtcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG1haW4tdmlldz48L21haW4tdmlldz4nXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdtYWluSXRlbUBzdGFydCc6IHtcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGNvbXBhbnktY3JlYXRlLXZpZXc+PC9jb21wYW55LWNyZWF0ZS12aWV3PidcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wYW55OiB7XHJcbiAgICAgICAgaW5pdGlhbDoge1xyXG4gICAgICAgICAgICB1cmw6ICdjb21wYW55JyxcclxuICAgICAgICAgICAgdmlld3M6IHtcclxuICAgICAgICAgICAgICAgICdtYWluSXRlbUBzdGFydCc6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxjb21wYW55LXZpZXc+PC9jb21wYW55LXZpZXc+J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaXN0OiB7XHJcbiAgICAgICAgICAgIHVybDogJy9saXN0JyxcclxuICAgICAgICAgICAgdmlld3M6IHtcclxuICAgICAgICAgICAgICAgICdtYWluSXRlbUBzdGFydCc6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxjb21wYW55LWxpc3Qtdmlldz48L2NvbXBhbnktbGlzdC12aWV3PidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VhcmNoOiB7XHJcbiAgICAgICAgICAgIHVybDogJy9zZWFyY2gnLFxyXG4gICAgICAgICAgICB2aWV3czoge1xyXG4gICAgICAgICAgICAgICAgJ21haW5JdGVtQHN0YXJ0Jzoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGNvbXBhbnktc2VhcmNoLXZpZXc+PC9jb21wYW55LXNlYXJjaC12aWV3PidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlOiB7XHJcbiAgICAgICAgICAgIHVybDogJy91cGRhdGUnLFxyXG4gICAgICAgICAgICB2aWV3czoge1xyXG4gICAgICAgICAgICAgICAgJ21haW5JdGVtQHN0YXJ0Jzoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGNvbXBhbnktdXBkYXRlLXZpZXc+PC9jb21wYW55LXVwZGF0ZS12aWV3PidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVsZXRlOiB7XHJcbiAgICAgICAgICAgIC8vIHdvdWxkIGJlIHVzZWQgdW5kZXIgc3RhcnQuY29tcGFueS5saXN0IHN0YXRlLCBoZW5jZSB1cmwgcmVzb2x2ZXMgdG86ICMvY29tcGFueS9saXN0L2RlbGV0ZVxyXG4gICAgICAgICAgICB1cmw6ICcvZGVsZXRlJyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9uIHN0YXRlIGVudGVyIGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSAgeyRtb2RhbH0gTW9kYWwgc2VydmljZVxyXG4gICAgICAgICAgICAgKiBAbmdJbmplY3RcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIG9uRW50ZXI6IFtcIiRtb2RhbFwiLCBmdW5jdGlvbigkbW9kYWwpIHtcclxuICAgICAgICAgICAgICAgICRtb2RhbC5vcGVuKHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxjb21wYW55LWRlbGV0ZS12aWV3PjwvY29tcGFueS1kZWxldGUtdmlldz4nLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wOiAnc3RhdGljJyxcclxuICAgICAgICAgICAgICAgICAgICBrZXlib2FyZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q2xhc3M6ICdtb2RhbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogJ0NvbXBhbnlWaWV3Q29udHJvbGxlcidcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBiZW5lZmljaWFyeToge1xyXG4gICAgICAgIGluaXRpYWw6IHtcclxuICAgICAgICAgICAgdXJsOiAnYmVuZWZpY2lhcnknLFxyXG4gICAgICAgICAgICB2aWV3czoge1xyXG4gICAgICAgICAgICAgICAgJ21haW5JdGVtQHN0YXJ0Jzoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGJlbmVmaWNpYXJ5LXZpZXc+PC9iZW5lZmljaWFyeS12aWV3PidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGlzdDoge1xyXG4gICAgICAgICAgICB1cmw6ICcvbGlzdCcsXHJcbiAgICAgICAgICAgIHZpZXdzOiB7XHJcbiAgICAgICAgICAgICAgICAnbWFpbkl0ZW1Ac3RhcnQnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8YmVuZWZpY2lhcnktbGlzdC12aWV3PjwvYmVuZWZpY2lhcnktbGlzdC12aWV3PidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VhcmNoOiB7XHJcbiAgICAgICAgICAgIHVybDogJy9zZWFyY2gnLFxyXG4gICAgICAgICAgICB2aWV3czoge1xyXG4gICAgICAgICAgICAgICAgJ21haW5JdGVtQHN0YXJ0Jzoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGJlbmVmaWNpYXJ5LXNlYXJjaC12aWV3PjwvYmVuZWZpY2lhcnktc2VhY2gtdmlldz4nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZToge1xyXG4gICAgICAgICAgICB1cmw6ICcvdXBkYXRlJyxcclxuICAgICAgICAgICAgdmlld3M6IHtcclxuICAgICAgICAgICAgICAgICdtYWluSXRlbUBzdGFydCc6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxiZW5lZmljaWFyeS11cGRhdGUtdmlldz48L2JlbmVmaWNpYXJ5LXVwZGF0ZS12aWV3PidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVsZXRlOiB7XHJcbiAgICAgICAgICAgIC8qKiB3b3VsZCBiZSB1c2VkIHVuZGVyIHN0YXJ0LmJlbmVmaWNpYXJ5Lmxpc3Qgb3Igc3RhcnQuYmVuZWZpY2lhcnkuc2VhcmNoIHN0YXRlLFxyXG4gICAgICAgICAgICAgKiAgaGVuY2UgdXJsIHJlc29sdmVzIHRvOiAjL2JlbmVmaWNpYXJ5L2xpc3QvZGVsZXRlIG9yICAjL2JlbmVmaWNpYXJ5L3NlYXJjaC9kZWxldGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHVybDogJy9kZWxldGUnLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT24gc3RhdGUgZW50ZXIgZXZlbnQgbGlzdGVuZXJcclxuICAgICAgICAgICAgICogQHBhcmFtICB7JG1vZGFsfSBNb2RhbCBzZXJ2aWNlXHJcbiAgICAgICAgICAgICAqIEBuZ0luamVjdFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgb25FbnRlcjogW1wiJG1vZGFsXCIsIGZ1bmN0aW9uKCRtb2RhbCkge1xyXG4gICAgICAgICAgICAgICAgJG1vZGFsLm9wZW4oe1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGJlbmVmaWNpYXJ5LWRlbGV0ZS12aWV3PjwvYmVuZWZpY2lhcnktZGVsZXRlLXZpZXc+JyxcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcDogJ3N0YXRpYycsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5Ym9hcmQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NsYXNzOiAnbW9kYWwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6ICdCZW5lZmljaWFyeVZpZXdDb250cm9sbGVyJ1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1dXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0cy5zdGF0ZUNvbmZpZyA9IHN0YXRlQ29uZmlnO1xyXG4iLCIvKipcclxuICogVGhpcyBzZXJ2aWNlIHByb3ZpZGUgY3VzdG9tIHdvcmQgbG9va3VwIGZvciBjYXNlIG5vcm1hbGl6YXRpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZCBieSB0aGUgc2VydmljZSBjbGllbnRcclxuICpcclxuICogQHBhcmFtIHskd2luZG93fSBUaGUgYW5ndWxhciB3aW5kb3cgc2VydmljZVxyXG4gKiBAbmdJbmplY3RcclxuICovXHJcbnZhciBzZXJ2aWNlID0gZnVuY3Rpb24oJHdpbmRvdykge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIHNlcnZpY2VJbnN0YW5jZSA9IHt9O1xyXG5cclxuICAgIHNlcnZpY2VJbnN0YW5jZS5pc0Zvcm1WYWxpZCA9IGZ1bmN0aW9uKGZvcm1JZCkge1xyXG4gICAgICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcclxuICAgICAgICB2YXIgZm9ybUVsID0gJHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb3JtSWQpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGZvcm1FbCk7XHJcbiAgICAgICAgaWYgKCFmb3JtRWwgfHwgKGZvcm1FbCAmJiBmb3JtRWwuY2xhc3NOYW1lICYmIGZvcm1FbC5jbGFzc05hbWUuaW5kZXhPZignbmctaW52YWxpZCcpID4gLTEpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBwZXJmb3JtIHNhbml0eSBjaGVja1xyXG4gICAgICAgIHZhciBlbGVtZW50cyA9ICR3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZm9ybUlkKS5lbGVtZW50cztcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgZWxlbWVudCA9IGVsZW1lbnRzW2krK107IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoKGVsZW1lbnQudHlwZSA9PT0gJ3RleHQnIHx8IGVsZW1lbnQudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtZW50LnR5cGUgPT09ICdyYWRpbycgfHwgZWxlbWVudC50eXBlID09PSAnZGF0ZScgfHwgZWxlbWVudC50eXBlID09PSAnZGF0ZXRpbWUtbG9jYWwnIHx8IGVsZW1lbnQudHlwZSA9PT0gJ2VtYWlsJyB8fCBlbGVtZW50LnR5cGUgPT09ICdtb250aCcgfHwgZWxlbWVudC50eXBlID09PSAnbnVtYmVyJyB8fCBlbGVtZW50LnR5cGUgPT09ICd0aW1lJyB8fCBlbGVtZW50LnR5cGUgPT09ICd1cmwnIHx8IGVsZW1lbnQudHlwZSA9PT0gJ3dlZWsnIHx8IGVsZW1lbnQudHlwZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtZW50LnR5cGUgPT09ICdzZWxlY3QnKSAmJiAoZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZignbmctaW52YWxpZCcpID4gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlcnZpY2VJbnN0YW5jZS5pc0JsYW5rID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gYW5ndWxhci5pc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZXJ2aWNlSW5zdGFuY2UuaXNWYWxpZElkID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaWQpID49IDE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNlcnZpY2VJbnN0YW5jZTtcclxufTtcclxuc2VydmljZS4kaW5qZWN0ID0gW1wiJHdpbmRvd1wiXTtcclxuXHJcbmV4cG9ydHMuc2VydmljZSA9IHNlcnZpY2U7XHJcbiIsIi8qKlxyXG4gKiBDb21wYW55IENyZWF0ZSBDb21wb25lbnQgRGlyZWN0aXZlXHJcbiAqXHJcbiAqIEBuZ0luamVjdFxyXG4gKi9cclxudmFyIGRpcmVjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdhcHAvY29tcG9uZW50cy9jb21wYW55L0NvbXBhbnlDcmVhdGVWaWV3Lmh0bWwnLFxyXG4gICAgICAgIHJlc3RyaWN0OiAnQUUnLFxyXG4gICAgICAgIHNjb3BlOiBmYWxzZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjdHJsJyxcclxuICAgICAgICBjb250cm9sbGVyOiAnQ29tcGFueVZpZXdDb250cm9sbGVyJ1xyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydHMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG4iLCIvKipcclxuICogQ29tcGFueSBEZWxldGUgQ29tcG9uZW50IERpcmVjdGl2ZVxyXG4gKlxyXG4gKiBAbmdJbmplY3RcclxuICovXHJcbnZhciBkaXJlY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnYXBwL2NvbXBvbmVudHMvY29tcGFueS9Db21wYW55RGVsZXRlVmlldy5odG1sJyxcclxuICAgICAgICByZXN0cmljdDogJ0FFJyxcclxuICAgICAgICBzY29wZTogZmFsc2UsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnY3RybCcsXHJcbiAgICAgICAgY29udHJvbGxlcjogJ0NvbXBhbnlWaWV3Q29udHJvbGxlcidcclxuICAgIH07XHJcbn07XHJcblxyXG5leHBvcnRzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuIiwiLyoqXHJcbiAqIENvbXBhbnkgVGFibGUgTGlzdCBDb21wb25lbnQgRGlyZWN0aXZlXHJcbiAqXHJcbiAqIEBuZ0luamVjdFxyXG4gKi9cclxudmFyIGRpcmVjdGl2ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2FwcC9jb21wb25lbnRzL2NvbXBhbnkvQ29tcGFueUxpc3RGcmFnbWVudFZpZXcuaHRtbCcsXHJcbiAgICAgICAgcmVzdHJpY3Q6ICdBRScsXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgY29tcGFuaWVzOiAnPScsXHJcbiAgICAgICAgICAgIGRlbHJlZjogJz0nLFxyXG4gICAgICAgICAgICBzZWFyY2hSZXF1ZXN0U3VtYml0dGVkOiAnPSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2N0cmwnLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6ICdDb21wYW55Vmlld0NvbnRyb2xsZXInXHJcbiAgICB9O1xyXG59O1xyXG5cclxuZXhwb3J0cy5kaXJlY3RpdmUgPSBkaXJlY3RpdmU7XHJcbiIsIi8qKlxyXG4gKiBDb21wYW55IFRhYmxlIExpc3QgQ29tcG9uZW50IERpcmVjdGl2ZVxyXG4gKlxyXG4gKiBAbmdJbmplY3RcclxuICovXHJcbnZhciBkaXJlY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnYXBwL2NvbXBvbmVudHMvY29tcGFueS9Db21wYW55TGlzdFZpZXcuaHRtbCcsXHJcbiAgICAgICAgcmVzdHJpY3Q6ICdBRScsXHJcbiAgICAgICAgc2NvcGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2N0cmwnLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6ICdDb21wYW55Vmlld0NvbnRyb2xsZXInXHJcbiAgICB9O1xyXG59O1xyXG5cclxuZXhwb3J0cy5kaXJlY3RpdmUgPSBkaXJlY3RpdmU7XHJcbiIsIi8qKlxyXG4gKiBDb21wYW55IFNlYXJjaCBDb21wb25lbnQgRGlyZWN0aXZlXHJcbiAqXHJcbiAqIEBuZ0luamVjdFxyXG4gKi9cclxudmFyIGRpcmVjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdhcHAvY29tcG9uZW50cy9jb21wYW55L0NvbXBhbnlTZWFyY2hWaWV3Lmh0bWwnLFxyXG4gICAgICAgIHJlc3RyaWN0OiAnQUUnLFxyXG4gICAgICAgIHNjb3BlOiBmYWxzZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjdHJsJyxcclxuICAgICAgICBjb250cm9sbGVyOiAnQ29tcGFueVZpZXdDb250cm9sbGVyJ1xyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydHMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG4iLCIvKipcclxuICogVGhpcyBzZXJ2aWNlIGhlbHBzIHRvIHBlcmZvcm0gaHR0cCByZXF1ZXN0cyAoR0VULCBQT1NULCBQVVQsIERFTEVURSkgZm9yIGNvbXBhbnkgdGFza3NcclxuICpcclxuICogQHBhcmFtIHskaHR0cH0gVGhlIEFuZ3VsYXJKUyBodHRwIHNlcnZpY2VcclxuICogQHBhcmFtIHskdGltZW91dH0gVGhlIEFuZ3VsYXJKUyB0aW1lb3V0IHNlcnZpY2VcclxuICpcclxuICogQG5nSW5qZWN0XHJcbiAqL1xyXG52YXIgc2VydmljZSA9IGZ1bmN0aW9uKCRodHRwLCAkdGltZW91dCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBzZXJ2aWNlSW5zdGFuY2UgPSB7fTtcclxuICAgIHNlcnZpY2VJbnN0YW5jZS5zZWxlY3RlZENvbXBhbnlJZCA9IG51bGw7XHJcbiAgICBzZXJ2aWNlSW5zdGFuY2UucG9wT25EZWxldGUgPSBudWxsO1xyXG4gICAgc2VydmljZUluc3RhbmNlLmNvbXBhbnkgPSBudWxsO1xyXG4gICAgc2VydmljZUluc3RhbmNlLmNvbXBhbmllcyA9IFtdO1xyXG4gICAgc2VydmljZUluc3RhbmNlLnNlYXJjaFJlcXVlc3RTdW1iaXR0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICBzZXJ2aWNlSW5zdGFuY2UuZ2V0Q29tcGFueSA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcclxuICAgICAgICAkaHR0cCh7XHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb25wJ1xyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHRzKTtcclxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvci5zdGF0dXMgPyBlcnJvci5zdGF0dXMgOiA1MDAsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5kYXRhID8gZXJyb3IuZGF0YSA6ICdFcnJvciBvY2N1cmVkIHdoaWxlIHJldHJpZXZpbmcgY29tcGFueSBkZXRhaWxzJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvckRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZXJ2aWNlSW5zdGFuY2UuY3JlYXRlQ29tcGFueSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICAkaHR0cCh7XHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29ucCdcclxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0cyk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIGVycm9yRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXR1czogZXJyb3Iuc3RhdHVzID8gZXJyb3Iuc3RhdHVzIDogNTAwLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IuZGF0YSA/IGVycm9yLmRhdGEgOiAnRXJyb3Igb2NjdXJlZCB3aGlsZSByZXRyaWV2aW5nIGNvbXBhbnkgZGV0YWlscydcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3JEYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBzZXJ2aWNlSW5zdGFuY2UudXBkYXRlQ29tcGFueSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICAkaHR0cCh7XHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb25wJ1xyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHRzKTtcclxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvci5zdGF0dXMgPyBlcnJvci5zdGF0dXMgOiA1MDAsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5kYXRhID8gZXJyb3IuZGF0YSA6ICdFcnJvciBvY2N1cmVkIHdoaWxlIHJldHJpZXZpbmcgY29tcGFueSBkZXRhaWxzJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvckRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZXJ2aWNlSW5zdGFuY2UuZGVsZXRlQ29tcGFueSA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcclxuICAgICAgICAkaHR0cCh7XHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb25wJ1xyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHRzKTtcclxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvci5zdGF0dXMgPyBlcnJvci5zdGF0dXMgOiA1MDAsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5kYXRhID8gZXJyb3IuZGF0YSA6ICdFcnJvciBvY2N1cmVkIHdoaWxlIHJldHJpZXZpbmcgY29tcGFueSBkZXRhaWxzJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvckRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgcmV0dXJuIHNlcnZpY2VJbnN0YW5jZTtcclxufTtcclxuc2VydmljZS4kaW5qZWN0ID0gW1wiJGh0dHBcIiwgXCIkdGltZW91dFwiXTtcclxuXHJcbmV4cG9ydHMuc2VydmljZSA9IHNlcnZpY2U7XHJcbiIsIi8qKlxyXG4gKiBDb21wYW55IFVwZGF0ZSBDb21wb25lbnQgRGlyZWN0aXZlXHJcbiAqXHJcbiAqIEBuZ0luamVjdFxyXG4gKi9cclxudmFyIGRpcmVjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdhcHAvY29tcG9uZW50cy9jb21wYW55L0NvbXBhbnlVcGRhdGVWaWV3Lmh0bWwnLFxyXG4gICAgICAgIHJlc3RyaWN0OiAnQUUnLFxyXG4gICAgICAgIHNjb3BlOiBmYWxzZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjdHJsJyxcclxuICAgICAgICBjb250cm9sbGVyOiAnQ29tcGFueVZpZXdDb250cm9sbGVyJ1xyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydHMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG4iLCIvKipcclxuICogQ29tcGFueSBWaWV3IGNvbnRyb2xsZXJcclxuICpcclxuICogVGhpcyBjb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBoYW5kaW5nIGNvbXBhbnkgZm9ybSBtb2R1bGUgcmVsYXRlZCBsb2dpY1xyXG4gKlxyXG4gKiBAcGFyYW0geyRyb290U2NvcGV9IEFuZ3VsYXIgcm9vdCBzY29wZSBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7JHNjb3BlfSBBbmd1bGFyIHNjb3BlIHNlcnZpY2VcclxuICogQHBhcmFtIHskcX0gQW5ndWxhciBwcm9taXNlIHNlcnZpY2VcclxuICogQHBhcmFtIHskdGltZW91dH0gQW5ndWxhciB0aW1lb3V0IHNlcnZpY2VcclxuICogQHBhcmFtIHskd2luZG93fSBBbmd1bGFyIHdpbmRvdyBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7JGRvY3VtZW50fSBBbmd1bGFyIGRvY3VtZW50IHNlcnZpY2VcclxuICogQHBhcmFtIHskbG9nfSBBbmd1bGFyIGxvZ2dlciBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7JG1vZGFsfSBBbmd1bGFyIG1vZGFsIHNlcnZpY2VcclxuICogQHBhcmFtIHtiZW5lZmljaWFyeVNlcnZpY2V9IEJlbmVmaWNpYXJ5IHNlcnZpY2VcclxuICogQHBhcmFtIHtjb21wYW55U2VydmljZX0gQ29tcGFueSBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7dXRpbFNlcnZpY2V9IFV0aWxpdHkgc2VydmljZVxyXG4gKiBAcGFyYW0ge2Jsb2NrVUl9IEJsb2NrIFVJIHNlcnZpY2VcclxuICogQHBhcmFtIHtpbmZvcm19IEluZm9ybSBwcm92aWRlciBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7Q09OU1RBTlRTfSBQcm9qZWN0IGNvbnN0YW50cyB2YWx1ZXNcclxuICpcclxuICogQG5nSW5qZWN0XHJcbiAqXHJcbiAqL1xyXG52YXIgY29udHJvbGxlciA9IGZ1bmN0aW9uKCRyb290U2NvcGUsICRzY29wZSwgJHEsICR0aW1lb3V0LCAkd2luZG93LCAkZG9jdW1lbnQsICRsb2csICRzdGF0ZSwgJG1vZGFsLCBiZW5lZmljaWFyeVNlcnZpY2UsIGNvbXBhbnlTZXJ2aWNlLCB1dGlsU2VydmljZSwgYmxvY2tVSSwgaW5mb3JtLCBDT05TVEFOVFMpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBjdHJsID0gdGhpcztcclxuXHJcbiAgICAkc2NvcGUudXNlRXhpc3RpbmdCZW5lZmljaWFyeSA9IGZhbHNlO1xyXG4gICAgJHNjb3BlLm1pbmltdW1WYWxpZEJlbmVmaWNpYXJ5ID0gZmFsc2U7XHJcbiAgICAkc2NvcGUuYmVuZWZpY2lhcnlJZCA9IG51bGw7XHJcbiAgICAkc2NvcGUuYmVuZWZpY2lhcnlTZWFyY2hlZCA9IGZhbHNlO1xyXG4gICAgJHNjb3BlLmJlbmVmaWNpYXJ5Rm91bmQgPSBmYWxzZTtcclxuICAgICRzY29wZS5jb21wYW55Rm91bmQgPSBmYWxzZTtcclxuICAgICRzY29wZS5zZWFyY2hSZXF1ZXN0U3VtYml0dGVkID0gZmFsc2U7XHJcbiAgICAkc2NvcGUuYWRkUmVxdWVzdFN1Ym1pdHRlZCA9IGZhbHNlO1xyXG4gICAgJHNjb3BlLnVwZGF0ZVJlcXVlc3RTdWJtaXR0ZWQgPSBmYWxzZTtcclxuICAgICRzY29wZS5kZWxldGVSZXF1ZXN0U3VibWl0dGVkID0gZmFsc2U7XHJcbiAgICAkc2NvcGUuZGVsZXRlU3VjY2Vzc2Z1bCA9IGZhbHNlO1xyXG4gICAgJHNjb3BlLnNlcnZpY2VVcmwgPSBDT05TVEFOVFMudXJsLnBhdGg7XHJcbiAgICAkc2NvcGUuaW5pdENvbXBhbnkgPSB7XHJcbiAgICAgICAgXCJuYW1lXCI6IG51bGwsXHJcbiAgICAgICAgXCJhZGRyZXNzXCI6IG51bGwsXHJcbiAgICAgICAgXCJjaXR5XCI6IG51bGwsXHJcbiAgICAgICAgXCJjb3VudHJ5XCI6IG51bGwsXHJcbiAgICAgICAgXCJlbWFpbFwiOiBudWxsLFxyXG4gICAgICAgIFwicGhvbmVOdW1iZXJcIjogbnVsbCxcclxuICAgICAgICBcImJlbmVmaWNpYXJpZXNcIjogW3tcclxuICAgICAgICAgICAgXCJpZFwiOiAtMSxcclxuICAgICAgICAgICAgXCJmaXJzdE5hbWVcIjogbnVsbCxcclxuICAgICAgICAgICAgXCJsYXN0TmFtZVwiOiBudWxsXHJcbiAgICAgICAgfV1cclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLmNvbXBhbmllcyA9IGNvbXBhbnlTZXJ2aWNlLmNvbXBhbmllcy5sZW5ndGggPiAwID8gY29tcGFueVNlcnZpY2UuY29tcGFuaWVzIDogW107XHJcbiAgICAkc2NvcGUuY29tcGFueSA9IGNvbXBhbnlTZXJ2aWNlLmNvbXBhbnkgJiZcclxuICAgICAgICAgICAgICAgICAgICAoJHN0YXRlLmN1cnJlbnQubmFtZSA9PT0gJ3N0YXJ0LmNvbXBhbnkudXBkYXRlJyB8fCAkc3RhdGUuY3VycmVudC5uYW1lID09PSAnc3RhcnQuY29tcGFueS5saXN0LmRlbGV0ZScgfHwgJHN0YXRlLmN1cnJlbnQubmFtZSA9PT0gJ3N0YXJ0LmNvbXBhbnkuc2VhcmNoLmRlbGV0ZScpID9cclxuICAgICAgICAgICAgICAgICAgICBjb21wYW55U2VydmljZS5jb21wYW55IDogJHNjb3BlLmluaXRDb21wYW55O1xyXG5cclxuICAgICRzY29wZS52ZXJpZnlNaW5pbXVtVmFsaWRCZW5lZmljaWFyeSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHNjb3BlLmNvbXBhbnkuYmVuZWZpY2lhcmllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAkc2NvcGUubWluaW11bVZhbGlkQmVuZWZpY2lhcnkgPSAkc2NvcGUuY29tcGFueS5iZW5lZmljaWFyaWVzW2ldLmlkICE9PSAtMSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICghdXRpbFNlcnZpY2UuaXNCbGFuaygkc2NvcGUuY29tcGFueS5iZW5lZmljaWFyaWVzW2ldLmZpcnN0TmFtZSkgJiYgIXV0aWxTZXJ2aWNlLmlzQmxhbmsoJHNjb3BlLmNvbXBhbnkuYmVuZWZpY2lhcmllc1tpXS5sYXN0TmFtZSkpO1xyXG4gICAgICAgICAgICBpZiAoJHNjb3BlLm1pbmltdW1WYWxpZEJlbmVmaWNpYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLnJlc2V0Q29tcGFueSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAkc2NvcGUuY29tcGFueSA9ICRzY29wZS5pbml0Q29tcGFueTtcclxuICAgICAgICAgICAgJHNjb3BlLmNvbXBhbmllcyA9IFtdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAkc2NvcGUuYWRkQ29tcGFueSA9IGZ1bmN0aW9uKCRldmVudCkge1xyXG4gICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAkc2NvcGUuYWRkUmVxdWVzdFN1Ym1pdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbXBhbnlTZXJ2aWNlLmNvbXBhbnkgPSAkc2NvcGUuY29tcGFueTtcclxuICAgICAgICBpZiAodXRpbFNlcnZpY2UuaXNGb3JtVmFsaWQoJ2NvbXBhbnlEZXRhaWxzRm9ybScpKSB7XHJcbiAgICAgICAgICAgICRzY29wZS52ZXJpZnlNaW5pbXVtVmFsaWRCZW5lZmljaWFyeSgpO1xyXG4gICAgICAgICAgICBpZiAoISRzY29wZS5taW5pbXVtVmFsaWRCZW5lZmljaWFyeSkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlZ2lzdGVyUG9wb3ZlclNob3coJyNhZGRDb21wYW55Jyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJGxvZy5pbmZvKCd2YWxpZCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICRsb2cud2FybignZm9ybSBpbnZhbGlkJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjb21wYW55Q3JlYXRlQmxvY2sgPSBibG9ja1VJLmluc3RhbmNlcy5nZXQoJ2NvbXBhbnlDcmVhdGVCbG9jaycpO1xyXG4gICAgICAgIC8vIGNvbXBhbnlDcmVhdGVCbG9jay5zdGFydCgpO1xyXG4gICAgICAgIHZhciB1cmwgPSAkc2NvcGUuc2VydmljZVVybCArICcvJyArIENPTlNUQU5UUy51cmwuY29tcGFueUNvbnRleHRQYXRoO1xyXG4gICAgICAgIGNvbXBhbnlTZXJ2aWNlLmNyZWF0ZUNvbXBhbnkodXJsLCAkc2NvcGUuY29tcGFueSwgZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLmFkZFJlcXVlc3RTdWJtaXR0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZGF0YS5pZCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mb3JtLmFkZCgnQ29tcGFueSBjcmVhdGVkIHN1Y2Nlc3NmdWxseS4nLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDI1MDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzdGFydC5jb21wYW55Jywge30sIHtyZWxvYWQ6dHJ1ZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAyNTAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvcm0uYWRkKCdSZXF1ZXN0IGNvbXBsZXRlZCwgaG93ZXZlciBjb21wYW55IGNvdWxkblxcJ3QgYmUgY3JlYXRlZC4nLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDUwMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd2FybmluZydcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmZvcm0uYWRkKHJlc3VsdCAmJiByZXN1bHQubWVzc2FnZSAmJiByZXN1bHQubWVzc2FnZS5lcnJvck1lc3NhZ2UgPyByZXN1bHQubWVzc2FnZS5lcnJvck1lc3NhZ2UgOiAnRXJyb3IgY3JlYXRpbmcgY29tcGFueS4nLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR0bDogNTAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcidcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmFkZFJlcXVlc3RTdWJtaXR0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9LCA1MDAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNvbXBhbnlDcmVhdGVCbG9jay5zdG9wKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAkc2NvcGUuY2FuY2VsQWRkQ29tcGFueSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICRzdGF0ZS5nbygnc3RhcnQuY29tcGFueScpO1xyXG4gICAgfTtcclxuXHJcbiAgICAkc2NvcGUudXBkYXRlQ29tcGFueSA9IGZ1bmN0aW9uKCRldmVudCkge1xyXG4gICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAkc2NvcGUudXBkYXRlUmVxdWVzdFN1Ym1pdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbXBhbnlTZXJ2aWNlLmNvbXBhbnkgPSAkc2NvcGUuY29tcGFueTtcclxuICAgICAgICBpZiAodXRpbFNlcnZpY2UuaXNGb3JtVmFsaWQoJ2NvbXBhbnlVcGRhdGVGb3JtJykpIHtcclxuICAgICAgICAgICAgJHNjb3BlLnZlcmlmeU1pbmltdW1WYWxpZEJlbmVmaWNpYXJ5KCk7XHJcbiAgICAgICAgICAgIGlmICghJHNjb3BlLm1pbmltdW1WYWxpZEJlbmVmaWNpYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVyU2hvdygnI3VwZGF0ZUNvbXBhbnknKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICRsb2cud2FybignZm9ybSBpbnZhbGlkJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHZhciBjb21wYW55VXBkYXRlQmxvY2sgPSBibG9ja1VJLmluc3RhbmNlcy5nZXQoJ2NvbXBhbnlVcGRhdGVCbG9jaycpO1xyXG4gICAgICAgIC8vIGNvbXBhbnlVcGRhdGVCbG9jay5zdGFydCgpO1xyXG4gICAgICAgIHZhciB1cmwgPSAkc2NvcGUuc2VydmljZVVybCArICcvJyArIENPTlNUQU5UUy51cmwuY29tcGFueUNvbnRleHRQYXRoO1xyXG4gICAgICAgIGNvbXBhbnlTZXJ2aWNlLnVwZGF0ZUNvbXBhbnkodXJsLCAkc2NvcGUuY29tcGFueSwgZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLnVwZGF0ZVJlcXVlc3RTdWJtaXR0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZGF0YS5zdGF0dXMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mb3JtLmFkZCgnQ29tcGFueSB1cGRhdGVkIHN1Y2Nlc3NmdWxseS4nLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDQwMDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdzdGFydC5jb21wYW55Lmxpc3QnLCB7fSwge3JlbG9hZDogdHJ1ZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCA0NTAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvcm0uYWRkKCdSZXF1ZXN0IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIGJ1dCBubyB1cGRhdGUgcGVyZm9ybWVkIG9uIGNvbXBhbnkuJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHRsOiA1MDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3dhcm5pbmcnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5mb3JtLmFkZChyZXN1bHQgJiYgcmVzdWx0Lm1lc3NhZ2UgJiYgcmVzdWx0Lm1lc3NhZ2UuZXJyb3JNZXNzYWdlID8gcmVzdWx0Lm1lc3NhZ2UuZXJyb3JNZXNzYWdlIDogJ0NvbXBhbnkgY291bGRuXFwndCBiZSB1cGRhdGVkLicsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHRsOiA1MDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGFuZ2VyJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUudXBkYXRlUmVxdWVzdFN1Ym1pdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIDUwMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY29tcGFueVVwZGF0ZUJsb2NrLnN0b3AoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgICRzY29wZS5jYW5jZWxPckNsb3NlQ29tcGFueVVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICRzdGF0ZS5nbygnc3RhcnQuY29tcGFueS5saXN0Jywge30sIHtyZWxvYWQ6IHRydWV9KTtcclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLmRlbGV0ZUNvbXBhbnkgPSBmdW5jdGlvbigkZXZlbnQpIHtcclxuICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgJHNjb3BlLmNvbXBhbnkgPSBjb21wYW55U2VydmljZS5jb21wYW55O1xyXG4gICAgICAgIC8vIHZhciBjb21wYW55VXBkYXRlQmxvY2sgPSBibG9ja1VJLmluc3RhbmNlcy5nZXQoJ2NvbXBhbnlVcGRhdGVCbG9jaycpO1xyXG4gICAgICAgIC8vIGNvbXBhbnlVcGRhdGVCbG9jay5zdGFydCgpO1xyXG4gICAgICAgIHZhciB1cmwgPSAkc2NvcGUuc2VydmljZVVybCArICcvJyArIENPTlNUQU5UUy51cmwuY29tcGFueUNvbnRleHRQYXRoICsgJy8nICsgJHNjb3BlLmNvbXBhbnkuaWQ7XHJcbiAgICAgICAgY29tcGFueVNlcnZpY2UuZGVsZXRlQ29tcGFueSh1cmwsIGZ1bmN0aW9uKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICRzY29wZS5kZWxldGVSZXF1ZXN0U3VibWl0dGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmRhdGEgJiYgcmVzdWx0LmRhdGEuc3RhdHVzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRlbGV0ZVN1Y2Nlc3NmdWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY29tcGFueVVwZGF0ZUJsb2NrLnN0b3AoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgICRzY29wZS5jYW5jZWxPckNsb3NlQ29tcGFueURlbGV0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICRzY29wZS4kZGlzbWlzcygpO1xyXG4gICAgICAgICRzdGF0ZS5nbygnc3RhcnQuY29tcGFueS5saXN0Jywge30sIHtyZWxvYWQ6IHRydWV9KTtcclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLmZldGNoQ29tcGFueSA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgJHNjb3BlLmNvbXBhbmllcy5zcGxpY2UoMCwgJHNjb3BlLmNvbXBhbmllcy5sZW5ndGgpO1xyXG5cclxuICAgICAgICB2YXIgaWRTZWFyY2ggPSAhdXRpbFNlcnZpY2UuaXNCbGFuayhpZCk7XHJcbiAgICAgICAgdmFyIGJhc2VVcmwgPSAkc2NvcGUuc2VydmljZVVybCArICcvJyArIENPTlNUQU5UUy51cmwuY29tcGFueUNvbnRleHRQYXRoO1xyXG4gICAgICAgIHZhciB1cmwgPSBpZFNlYXJjaCA/IGJhc2VVcmwgKyAnLycgKyBpZCA6IGJhc2VVcmw7XHJcbiAgICAgICAgLy92YXIgY29tcGFueUxpc3RCbG9jayA9IGJsb2NrVUkuaW5zdGFuY2VzLmdldCgnY29tcGFueUxpc3RCbG9jaycpO1xyXG4gICAgICAgIC8vY29tcGFueUxpc3RCbG9jay5zdGFydCgpO1xyXG4gICAgICAgIGNvbXBhbnlTZXJ2aWNlLmdldENvbXBhbnkodXJsLCBmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2VhcmNoUmVxdWVzdFN1bWJpdHRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb21wYW55U2VydmljZS5zZWFyY2hSZXF1ZXN0U3VtYml0dGVkID0gJHNjb3BlLnNlYXJjaFJlcXVlc3RTdW1iaXR0ZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkU2VhcmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jb21wYW5pZXMucHVzaChyZXN1bHQuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbXBhbmllcyA9IHJlc3VsdC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb21wYW55U2VydmljZS5jb21wYW5pZXMgPSAkc2NvcGUuY29tcGFuaWVzO1xyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jb21wYW55Rm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9jb21wYW55TGlzdEJsb2NrLnN0b3AoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgICRzY29wZS5zZWFyY2hDb21wYW55ID0gZnVuY3Rpb24oaWQsICRldmVudCkge1xyXG4gICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCF1dGlsU2VydmljZS5pc1ZhbGlkSWQoaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVyU2hvdygnI3NlYXJjaEV4aXN0aW5nQ29tcGFueUlkJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJHNjb3BlLmZldGNoQ29tcGFueShpZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgICRzY29wZS5zZWFyY2hCZW5lZmljaWFyeSA9IGZ1bmN0aW9uKGlkLCAkZXZlbnQpIHtcclxuICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgIGlmICghdXRpbFNlcnZpY2UuaXNWYWxpZElkKGlkKSkge1xyXG4gICAgICAgICAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVyU2hvdygnI3NlYXJjaEV4aXN0aW5nQmVuZWZpY2lhcnlJZCcpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB1cmwgPSAkc2NvcGUuc2VydmljZVVybCArICcvJyArIENPTlNUQU5UUy51cmwuYmVuZWZpY2lhcnlDb250ZXh0UGF0aCArICcvJyArIGlkO1xyXG5cclxuICAgICAgICB2YXIgY29tcGFueVNlYXJjaEJsb2NrID0gYmxvY2tVSS5pbnN0YW5jZXMuZ2V0KCdjb21wYW55U2VhcmNoQmxvY2snKTtcclxuICAgICAgICBjb21wYW55U2VhcmNoQmxvY2suc3RhcnQoKTtcclxuICAgICAgICBiZW5lZmljaWFyeVNlcnZpY2UuZmluZEJlbmVmaWNpYXJ5KHVybCwgZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLmJlbmVmaWNpYXJ5U2VhcmNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS52ZXJpZnlNaW5pbXVtVmFsaWRCZW5lZmljaWFyeSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgZW1wdHkgZm9ybXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS5taW5pbXVtVmFsaWRCZW5lZmljaWFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY29tcGFueS5iZW5lZmljaWFyaWVzLnNwbGljZSgwLCAkc2NvcGUuY29tcGFueS5iZW5lZmljaWFyaWVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jb21wYW55LmJlbmVmaWNpYXJpZXMucHVzaChyZXN1bHQuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRpc2FibGVCZW5lZmljaWFyeShyZXN1bHQuZGF0YS5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm1pbmltdW1WYWxpZEJlbmVmaWNpYXJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuYmVuZWZpY2lhcnlGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmJlbmVmaWNpYXJ5SWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29tcGFueVNlYXJjaEJsb2NrLnN0b3AoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgICRzY29wZS5tdXRhdGVDb21wYW55T3B0aW9ucyA9IGZ1bmN0aW9uKGNvbXBhbnksICRpbmRleCwgJGV2ZW50KSB7XHJcbiAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGNvbXBhbnlTZXJ2aWNlLnNlbGVjdGVkQ29tcGFueUlkID0gJyNjb21wYW55JyArICRpbmRleDtcclxuICAgICAgICBjb21wYW55U2VydmljZS5jb21wYW55ID0gY29tcGFueTtcclxuICAgICAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVyUHJlcChjb21wYW55U2VydmljZS5zZWxlY3RlZENvbXBhbnlJZCk7XHJcbiAgICAgICAgJHNjb3BlLnJlZ2lzdGVyUG9wb3ZlclNob3coY29tcGFueVNlcnZpY2Uuc2VsZWN0ZWRDb21wYW55SWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAkc2NvcGUuYWRkQmVuZWZpY2lhcnkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAkc2NvcGUuY29tcGFueS5iZW5lZmljaWFyaWVzLnB1c2goe1xyXG4gICAgICAgICAgICBcImZpcnN0TmFtZVwiOiBcIlwiLFxyXG4gICAgICAgICAgICBcImxhc3ROYW1lXCI6IFwiXCJcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLnJlbW92ZUJlbmVmaWNpYXJ5ID0gZnVuY3Rpb24oJGV2ZW50LCBiZW5lZmljaWFyeSkge1xyXG4gICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBpZiAoJHNjb3BlLmNvbXBhbnkuYmVuZWZpY2lhcmllcy5pbmRleE9mKGJlbmVmaWNpYXJ5KSAhPSAtMSkge1xyXG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcGFueS5iZW5lZmljaWFyaWVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5yZWdpc3RlclBvcG92ZXJTaG93KCcjcmVtb3ZlQmVuZWZpY2lhcnknKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUuY29tcGFueS5iZW5lZmljaWFyaWVzLnNwbGljZSgkc2NvcGUuY29tcGFueS5iZW5lZmljaWFyaWVzLmluZGV4T2YoYmVuZWZpY2lhcnkpLCAxKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAkc2NvcGUuZGlzYWJsZUJlbmVmaWNpYXJ5ID0gZnVuY3Rpb24oYmVuZWZpY2lhcnlJZCkge1xyXG4gICAgICAgICRyb290U2NvcGUuJGVtaXQoJ2Rpc2FibGVCZW5lZmljaWFyeScsIHtcclxuICAgICAgICAgICAgYmVuZWZpY2lhcmllczogJHNjb3BlLmNvbXBhbnkuYmVuZWZpY2lhcmllcyxcclxuICAgICAgICAgICAgYmVuZWZpY2lhcnlJZDogYmVuZWZpY2lhcnlJZFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIGluaXRpYWxpemUgcG9wb3ZlciAqL1xyXG5cclxuICAgICRzY29wZS5kaXNjYXJkTWVzc2FnZSA9IGZ1bmN0aW9uKCRldmVudCkge1xyXG4gICAgICAgICRldmVudCA/ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKSA6ICcnO1xyXG4gICAgICAgIGNvbXBhbnlTZXJ2aWNlLnBvcE9uRGVsZXRlID0gXCJkZWxldGVcIjtcclxuICAgICAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVySGlkZSgnW2lkKj1wb3BvdmVyXScpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb21wYW55U2VydmljZS5wb3BPbkRlbGV0ZSA9IFwiZGVsZXRlXCI7XHJcblxyXG4gICAgJHNjb3BlLnJlZ2lzdGVyUG9wb3ZlclByZXAgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgIGFuZ3VsYXIuZWxlbWVudCgkZG9jdW1lbnQuZmluZChpZCkpLnBvcG92ZXIoe1xyXG4gICAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVyU2hvdyA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgaWYgKGNvbXBhbnlTZXJ2aWNlLnBvcE9uRGVsZXRlICE9PSBcInBvcG92ZXJcIikge1xyXG4gICAgICAgICAgICBjb21wYW55U2VydmljZS5wb3BPbkRlbGV0ZSA9IFwicG9wb3ZlclwiO1xyXG4gICAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoJGRvY3VtZW50LmZpbmQoaWQpKS5wb3BvdmVyKCdzaG93Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVySGlkZSA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgdmFyIGVsID0gYW5ndWxhci5lbGVtZW50KCRkb2N1bWVudC5maW5kKGlkKSk7XHJcbiAgICAgICAgZWwgPyBlbC5wb3BvdmVyKCdoaWRlJykgOiAnJztcclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLnJlZ2lzdGVyUG9wb3ZlclByZXAoJyNyZW1vdmVCZW5lZmljaWFyeScpO1xyXG4gICAgJHNjb3BlLnJlZ2lzdGVyUG9wb3ZlclByZXAoJyNhZGRDb21wYW55Jyk7XHJcbiAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVyUHJlcCgnI3VwZGF0ZUNvbXBhbnknKTtcclxuICAgICRzY29wZS5yZWdpc3RlclBvcG92ZXJQcmVwKCcjc2VhcmNoRXhpc3RpbmdCZW5lZmljaWFyeUlkJyk7XHJcbiAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVyUHJlcCgnI3NlYXJjaEV4aXN0aW5nQ29tcGFueUlkJyk7XHJcbiAgICAkc2NvcGUucmVnaXN0ZXJQb3BvdmVySGlkZSgnW2lkKj1wb3BvdmVyXScpO1xyXG5cclxuICAgIC8vIGNsZWFyIGFsbCBpbmZvcm1zXHJcbiAgICBpbmZvcm0uY2xlYXIoKTtcclxufTtcclxuY29udHJvbGxlci4kaW5qZWN0ID0gW1wiJHJvb3RTY29wZVwiLCBcIiRzY29wZVwiLCBcIiRxXCIsIFwiJHRpbWVvdXRcIiwgXCIkd2luZG93XCIsIFwiJGRvY3VtZW50XCIsIFwiJGxvZ1wiLCBcIiRzdGF0ZVwiLCBcIiRtb2RhbFwiLCBcImJlbmVmaWNpYXJ5U2VydmljZVwiLCBcImNvbXBhbnlTZXJ2aWNlXCIsIFwidXRpbFNlcnZpY2VcIiwgXCJibG9ja1VJXCIsIFwiaW5mb3JtXCIsIFwiQ09OU1RBTlRTXCJdO1xyXG5cclxuZXhwb3J0cy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcclxuIiwiLyoqXHJcbiAqIE1haW4gQ29tcGFueSBEaXJlY3RpdmVcclxuICpcclxuICogQG5nSW5qZWN0XHJcbiAqL1xyXG52YXIgZGlyZWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2FwcC9jb21wb25lbnRzL2NvbXBhbnkvQ29tcGFueVZpZXcuaHRtbCcsXHJcbiAgICAgICAgcmVzdHJpY3Q6ICdBRScsXHJcbiAgICAgICAgc2NvcGU6IGZhbHNlXHJcbiAgICB9O1xyXG59O1xyXG5cclxuZXhwb3J0cy5kaXJlY3RpdmUgPSBkaXJlY3RpdmU7XHJcbiIsIi8qKlxyXG4gKiBTaWRlIE5hdiBWaWV3IGNvbnRyb2xsZXJcclxuICpcclxuICogVGhpcyBjb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBoYW5kaW5nIHJlcXVlc3QgZnJvbSBzaWRlIG5hdlxyXG4gKlxyXG4gKiBAcGFyYW0geyRyb290U2NvcGV9IEFuZ3VsYXIgcm9vdCBzY29wZSBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7JHNjb3BlfSBBbmd1bGFyIHNjb3BlIHNlcnZpY2VcclxuICogQHBhcmFtIHskdGltZW91dH0gQW5ndWxhciB0aW1lb3V0IHNlcnZpY2VcclxuICogQHBhcmFtIHskd2luZG93fSBBbmd1bGFyIHdpbmRvdyBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7JGRvY3VtZW50fSBBbmd1bGFyIGRvY3VtZW50IHNlcnZpY2VcclxuICogQHBhcmFtIHskbG9nfSBBbmd1bGFyIGxvZ2dlciBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7YmVuZWZpY2lhcnlTZXJ2aWNlfSBCZW5lZmljaWFyeSBzZXJ2aWNlXHJcbiAqIEBwYXJhbSB7Y29tcGFueVNlcnZpY2V9IENvbXBhbnkgc2VydmljZVxyXG4gKlxyXG4gKiBAbmdJbmplY3RcclxuICpcclxuICovXHJcbnZhciBjb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgY3RybCA9IHRoaXM7XHJcblxyXG59O1xyXG5cclxuZXhwb3J0cy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcclxuIiwiLyoqXHJcbiAqIFNpZGUgTmF2IENvbXBvbmVudCBEaXJlY3RpdmVcclxuICpcclxuICogQG5nSW5qZWN0XHJcbiAqL1xyXG52YXIgZGlyZWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2FwcC9jb21wb25lbnRzL25hdi9TaWRlTmF2Vmlldy5odG1sJyxcclxuICAgICAgICByZXN0cmljdDogJ0FFJyxcclxuICAgICAgICBzY29wZTogZmFsc2UsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnY3RybCcsXHJcbiAgICAgICAgY29udHJvbGxlcjogJ1NpZGVOYXZWaWV3Q29udHJvbGxlcidcclxuICAgIH07XHJcbn07XHJcblxyXG5leHBvcnRzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuIiwidmFyIHRyYW5zbGF0aW9uc0VOID0ge1xuICAgIFwiQkVORUZJQ0lBUllcIjoge1xuICAgICAgICBcIklEXCI6IFwiSWRcIixcbiAgICAgICAgXCJGSVJTVF9OQU1FXCI6IFwiRmlyc3QgbmFtZVwiLFxuICAgICAgICBcIkxBU1RfTkFNRVwiOiBcIkxhc3QgbmFtZVwiXG4gICAgfVxufTtcblxuZXhwb3J0cy50cmFuc2xhdGlvbnNFTiA9IHRyYW5zbGF0aW9uc0VOO1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHN0YXRlcyA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9jb21tb24vU3RhdGVzJyk7XHJcbnZhciBjb25maWdCbG9jayA9IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHskbG9nUHJvdmlkZXJ9IFRoZSBsb2cgcHJvdmlkZXIgc2VydmljZVxyXG4gICAgICogQHBhcmFtIHskdHJhbnNsYXRlUHJvdmlkZXJ9IFRoZSBhbmd1bGFyIHRyYW5zbGF0ZSBzZXJ2aWNlXHJcbiAgICAgKiBAbmdJbmplY3RcclxuICAgICAqL1xyXG4gICAgc2V0dGluZ3M6IFtcIiRsb2dQcm92aWRlclwiLCBcIiR0cmFuc2xhdGVQcm92aWRlclwiLCBmdW5jdGlvbigkbG9nUHJvdmlkZXIsICR0cmFuc2xhdGVQcm92aWRlcikge1xyXG4gICAgICAgICRsb2dQcm92aWRlci5kZWJ1Z0VuYWJsZWQodHJ1ZSk7IC8vIFR1cm5zIGdsb2JhbCBsb2dnaW5nIHdpdGggJGxvZy5kZWJ1ZyBvblxyXG5cclxuICAgICAgICB2YXIgaTE4bl9lbiA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9ubHMvaTE4bi1lbicpO1xyXG4gICAgICAgICR0cmFuc2xhdGVQcm92aWRlci51c2VTYW5pdGl6ZVZhbHVlU3RyYXRlZ3koJ3Nhbml0aXplUGFyYW1ldGVycycpO1xyXG4gICAgICAgICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2VuJywgaTE4bl9lbi50cmFuc2xhdGlvbnNFTikudXNlU3RhdGljRmlsZXNMb2FkZXIoe1xyXG4gICAgICAgICAgICAgICAgZmlsZXM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiAnLi9jb21wb25lbnRzL25scy9pMThuLScsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4OiAnLmpzb24nXHJcbiAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAucHJlZmVycmVkTGFuZ3VhZ2UoJ2VuJylcclxuICAgICAgICAgICAgLmZhbGxiYWNrTGFuZ3VhZ2UoJ2VuJyk7XHJcbiAgICB9XSxcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHskc3RhdGVQcm92aWRlcn0gJHN0YXRlUHJvdmlkZXIgVGhlIFVJIHJvdXRlciBzdGF0ZVByb3ZpZGVyIHNlcnZpY2VcclxuICAgICAqIEBwYXJhbSB7JHVybFJvdXRlclByb3ZpZGVyfSBUaGUgVUkgcm91dGVyIHVybFJvdXRlclByb3ZpZGVyIHNlcnZpY2VcclxuICAgICAqIEBwYXJhbSB7JG1vZGFsU3RhdGVQcm92aWRlcn0gVGhlIGN1c3RvbSBtb2RhbCBzdGF0ZSBwcm92aWRlciBzZXJ2aWNlXHJcbiAgICAgKiBAbmdJbmplY3RcclxuICAgICAqL1xyXG4gICAgc3RhdGVzOiBbXCIkc3RhdGVQcm92aWRlclwiLCBcIiR1cmxSb3V0ZXJQcm92aWRlclwiLCBmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgJHVybFJvdXRlclByb3ZpZGVyKSB7XHJcbiAgICAgICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZSgnLycpO1xyXG4gICAgICAgICRzdGF0ZVByb3ZpZGVyXHJcbiAgICAgICAgICAgIC5zdGF0ZSgnc3RhcnQnLCBzdGF0ZXMuc3RhdGVDb25maWcubWFpbilcclxuICAgICAgICAgICAgLnN0YXRlKCdzdGFydC5jb21wYW55Jywgc3RhdGVzLnN0YXRlQ29uZmlnLmNvbXBhbnkuaW5pdGlhbClcclxuICAgICAgICAgICAgLnN0YXRlKCdzdGFydC5jb21wYW55Lmxpc3QnLCBzdGF0ZXMuc3RhdGVDb25maWcuY29tcGFueS5saXN0KVxyXG4gICAgICAgICAgICAuc3RhdGUoJ3N0YXJ0LmNvbXBhbnkubGlzdC5kZWxldGUnLCAgYW5ndWxhci5jb3B5KHN0YXRlcy5zdGF0ZUNvbmZpZy5jb21wYW55LmRlbGV0ZSkpXHJcbiAgICAgICAgICAgIC5zdGF0ZSgnc3RhcnQuY29tcGFueS5zZWFyY2gnLCBzdGF0ZXMuc3RhdGVDb25maWcuY29tcGFueS5zZWFyY2gpXHJcbiAgICAgICAgICAgIC5zdGF0ZSgnc3RhcnQuY29tcGFueS5zZWFyY2guZGVsZXRlJywgYW5ndWxhci5jb3B5KHN0YXRlcy5zdGF0ZUNvbmZpZy5jb21wYW55LmRlbGV0ZSkpXHJcbiAgICAgICAgICAgIC5zdGF0ZSgnc3RhcnQuY29tcGFueS51cGRhdGUnLCBzdGF0ZXMuc3RhdGVDb25maWcuY29tcGFueS51cGRhdGUpXHJcbiAgICAgICAgICAgIC5zdGF0ZSgnc3RhcnQuYmVuZWZpY2lhcnknLCBzdGF0ZXMuc3RhdGVDb25maWcuYmVuZWZpY2lhcnkuaW5pdGlhbClcclxuICAgICAgICAgICAgLnN0YXRlKCdzdGFydC5iZW5lZmljaWFyeS5saXN0Jywgc3RhdGVzLnN0YXRlQ29uZmlnLmJlbmVmaWNpYXJ5Lmxpc3QpXHJcbiAgICAgICAgICAgIC5zdGF0ZSgnc3RhcnQuYmVuZWZpY2lhcnkubGlzdC5kZWxldGUnLCBhbmd1bGFyLmNvcHkoc3RhdGVzLnN0YXRlQ29uZmlnLmJlbmVmaWNpYXJ5LmRlbGV0ZSkpXHJcbiAgICAgICAgICAgIC5zdGF0ZSgnc3RhcnQuYmVuZWZpY2lhcnkuc2VhcmNoJywgc3RhdGVzLnN0YXRlQ29uZmlnLmJlbmVmaWNpYXJ5LnNlYXJjaClcclxuICAgICAgICAgICAgLnN0YXRlKCdzdGFydC5iZW5lZmljaWFyeS5zZWFyY2guZGVsZXRlJywgYW5ndWxhci5jb3B5KHN0YXRlcy5zdGF0ZUNvbmZpZy5iZW5lZmljaWFyeS5kZWxldGUpKVxyXG4gICAgICAgICAgICAuc3RhdGUoJ3N0YXJ0LmJlbmVmaWNpYXJ5LnVwZGF0ZScsIHN0YXRlcy5zdGF0ZUNvbmZpZy5iZW5lZmljaWFyeS51cGRhdGUpXHJcbiAgICB9XSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSAge2Jsb2NrVUlDb25maWd9IFRoZSBibG9jayBVSSBjb25maWcgc2VydmljZVxyXG4gICAgICogQG5nSW5qZWN0XHJcbiAgICAgKi9cclxuICAgIGJsb2NrVUk6IFtcImJsb2NrVUlDb25maWdcIiwgZnVuY3Rpb24oYmxvY2tVSUNvbmZpZykge1xyXG4gICAgICAgIGJsb2NrVUlDb25maWcuZGVsYXkgPSAxMDA7XHJcbiAgICAgICAgYmxvY2tVSUNvbmZpZy5hdXRvQmxvY2sgPSBmYWxzZTtcclxuICAgICAgICBibG9ja1VJQ29uZmlnLmF1dG9JbmplY3RCb2R5QmxvY2sgPSBmYWxzZTtcclxuICAgICAgICBibG9ja1VJQ29uZmlnLnRlbXBsYXRlID0gJzxkaXY+PGltZyBzcmM9XCJkaXN0L2ltYWdlcy9hamF4LWxvYWRlci5naWZcIiAvPiBQcm9jZXNzaW5nLi4uPC9oMT4nO1xyXG4gICAgfV0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gIHtpbmZvcm1Qcm92aWRlcn0gVGhlIGluZm9ybSBwcm92aWRlciBzZXJ2aWNlXHJcbiAgICAgKiBAbmdJbmplY3RcclxuICAgICAqL1xyXG4gICAgaW5mb3JtOiBbXCJpbmZvcm1Qcm92aWRlclwiLCBmdW5jdGlvbihpbmZvcm1Qcm92aWRlcikge1xyXG4gICAgICAgIGluZm9ybVByb3ZpZGVyLmRlZmF1bHRzKHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB0aW1lIHRvIGxpdmUgZm9yIHRoZSBtZXNzYWdlIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAgICAgICAgICogRGVmYXVsdCB2YWx1ZSBpcyA1MDAwLiBTcGVjaWZ5IDwwIHRvIG1ha2UgdGhlIG1lc3NhZ2Ugc3RpY2t5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdHRsOiAtMSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgdHlwZSBvZiBtZXNzYWdlIHRvIGVuYWJsZSBzdHlsaW5nLlxyXG4gICAgICAgICAgICAgKiBWYWx1ZXMgY2FuIGJlICdkZWZhdWx0JywgJ3ByaW1hcnknLCAnc3VjY2VzcycsICdpbmZvJywgJ3dhcm5pbmcnLCAnZGFuZ2VyJyBvciBhbnkgb3RoZXIgY3VzdG9tIHJlcXVpcmVkIHR5cGUuXHJcbiAgICAgICAgICAgICAqIERlZmF1bHQgdmFsdWUgaXMgJ2luZm8nLiBJZiAnZGVmYXVsdCcgaXMgc3BlY2lmaWVkIGFzIHZhbHVlLCB0aGVuICdpbmZvJyBpcyB1c2VkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbGxvdyBodG1sIGZvcm1hdHRpbmdcclxuICAgICAgICAgICAgICogRGVmYXVsdCB2YWx1ZSBpcyBmYWxzZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaHRtbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfV0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RhbCBibG9ja1xyXG4gICAgICogQHBhcmFtICB7JHJvb3RTY29wZX0gIEFuZ3VsYXIgcm9vdCBzY29wZSBzZXJ2aWNlXHJcbiAgICAgKiBAcGFyYW0gIHskbW9kYWxTdGFja30gQW5ndWxhciBVSSBtb2RhbCBzdGFja1xyXG4gICAgICogQG5nSW5qZWN0XHJcbiAgICAgKi9cclxuICAgIG1vZGFsOiBbXCIkcm9vdFNjb3BlXCIsIFwiJG1vZGFsU3RhY2tcIiwgZnVuY3Rpb24oJHJvb3RTY29wZSwgJG1vZGFsU3RhY2spIHtcclxuICAgICAgICAkcm9vdFNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRvcCA9ICRtb2RhbFN0YWNrLmdldFRvcCgpO1xyXG4gICAgICAgICAgICBpZiAodG9wKSB7XHJcbiAgICAgICAgICAgICAgICAkbW9kYWxTdGFjay5kaXNtaXNzKHRvcC5rZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhyZWYgc2FuaXRpemF0aW9uIHdoaXRlbGlzdFxyXG4gICAgICogQHBhcmFtICB7JGNvbXBpbGVQcm92aWRlfSBBbmd1bGFyIGNvbXBpbGUgcHJvdmlkZXIgc2VydmljZVxyXG4gICAgICogQG5nSW5qZWN0XHJcbiAgICAgKi9cclxuICAgIGhyZWZTYW5pdGl6ZTogW1wiJGNvbXBpbGVQcm92aWRlclwiLCBmdW5jdGlvbigkY29tcGlsZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgJGNvbXBpbGVQcm92aWRlci5hSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdCgvXlxccyooaHR0cHM/fGZ0cHxtYWlsdG98ZmlsZXxjaHJvbWXigIzigIstZXh0ZW5zaW9ufGJsb2I6Y2hyb21lLWV4dGVuc2lvbik6Lyk7XHJcbiAgICB9XSxcclxuXHJcbiAgICBuYW1lc3BhY2U6ICdjb20uY29tcGFueXJlZ2lzdHJ5J1xyXG59O1xyXG5cclxuZXhwb3J0cy5jb25maWdCbG9jayA9IGNvbmZpZ0Jsb2NrO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLmNvbnN0YW50cyA9IHtcclxuICAgIHVybDoge1xyXG5cdFx0XHRcdC8vIHBhdGg6ICdodHRwOi8vbG9jYWxob3N0OjgwODAvY29tcGFueXJlZ2lzdHJ5JyxcclxuXHRcdFx0XHRwYXRoOiAnaHR0cHM6Ly9jb21wYW55cmVnaXN0cnkuaGVyb2t1YXBwLmNvbScsXHJcbiAgICAgICAgY29tcGFueUNvbnRleHRQYXRoOiAnY29tcGFuaWVzJyxcclxuICAgICAgICBiZW5lZmljaWFyeUNvbnRleHRQYXRoOiAnYmVuZWZpY2lhcmllcydcclxuICAgIH1cclxufTtcclxuIiwiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFySlMgdjEuNC43XG4gKiAoYykgMjAxMC0yMDE1IEdvb2dsZSwgSW5jLiBodHRwOi8vYW5ndWxhcmpzLm9yZ1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIsIHVuZGVmaW5lZCkgeyd1c2Ugc3RyaWN0JztcblxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xudmFyIG5vb3AgICAgICAgID0gYW5ndWxhci5ub29wO1xudmFyIGV4dGVuZCAgICAgID0gYW5ndWxhci5leHRlbmQ7XG52YXIganFMaXRlICAgICAgPSBhbmd1bGFyLmVsZW1lbnQ7XG52YXIgZm9yRWFjaCAgICAgPSBhbmd1bGFyLmZvckVhY2g7XG52YXIgaXNBcnJheSAgICAgPSBhbmd1bGFyLmlzQXJyYXk7XG52YXIgaXNTdHJpbmcgICAgPSBhbmd1bGFyLmlzU3RyaW5nO1xudmFyIGlzT2JqZWN0ICAgID0gYW5ndWxhci5pc09iamVjdDtcbnZhciBpc1VuZGVmaW5lZCA9IGFuZ3VsYXIuaXNVbmRlZmluZWQ7XG52YXIgaXNEZWZpbmVkICAgPSBhbmd1bGFyLmlzRGVmaW5lZDtcbnZhciBpc0Z1bmN0aW9uICA9IGFuZ3VsYXIuaXNGdW5jdGlvbjtcbnZhciBpc0VsZW1lbnQgICA9IGFuZ3VsYXIuaXNFbGVtZW50O1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBDT01NRU5UX05PREUgPSA4O1xuXG52YXIgQUREX0NMQVNTX1NVRkZJWCA9ICctYWRkJztcbnZhciBSRU1PVkVfQ0xBU1NfU1VGRklYID0gJy1yZW1vdmUnO1xudmFyIEVWRU5UX0NMQVNTX1BSRUZJWCA9ICduZy0nO1xudmFyIEFDVElWRV9DTEFTU19TVUZGSVggPSAnLWFjdGl2ZSc7XG5cbnZhciBOR19BTklNQVRFX0NMQVNTTkFNRSA9ICduZy1hbmltYXRlJztcbnZhciBOR19BTklNQVRFX0NISUxEUkVOX0RBVEEgPSAnJCRuZ0FuaW1hdGVDaGlsZHJlbic7XG5cbi8vIERldGVjdCBwcm9wZXIgdHJhbnNpdGlvbmVuZC9hbmltYXRpb25lbmQgZXZlbnQgbmFtZXMuXG52YXIgQ1NTX1BSRUZJWCA9ICcnLCBUUkFOU0lUSU9OX1BST1AsIFRSQU5TSVRJT05FTkRfRVZFTlQsIEFOSU1BVElPTl9QUk9QLCBBTklNQVRJT05FTkRfRVZFTlQ7XG5cbi8vIElmIHVucHJlZml4ZWQgZXZlbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGJ1dCB3ZWJraXQtcHJlZml4ZWQgYXJlLCB1c2UgdGhlIGxhdHRlci5cbi8vIE90aGVyd2lzZSwganVzdCB1c2UgVzNDIG5hbWVzLCBicm93c2VycyBub3Qgc3VwcG9ydGluZyB0aGVtIGF0IGFsbCB3aWxsIGp1c3QgaWdub3JlIHRoZW0uXG4vLyBOb3RlOiBDaHJvbWUgaW1wbGVtZW50cyBgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kYCBhbmQgZG9lc24ndCBpbXBsZW1lbnQgYHdpbmRvdy5vbmFuaW1hdGlvbmVuZGBcbi8vIGJ1dCBhdCB0aGUgc2FtZSB0aW1lIGRpc3BhdGNoZXMgdGhlIGBhbmltYXRpb25lbmRgIGV2ZW50IGFuZCBub3QgYHdlYmtpdEFuaW1hdGlvbkVuZGAuXG4vLyBSZWdpc3RlciBib3RoIGV2ZW50cyBpbiBjYXNlIGB3aW5kb3cub25hbmltYXRpb25lbmRgIGlzIG5vdCBzdXBwb3J0ZWQgYmVjYXVzZSBvZiB0aGF0LFxuLy8gZG8gdGhlIHNhbWUgZm9yIGB0cmFuc2l0aW9uZW5kYCBhcyBTYWZhcmkgaXMgbGlrZWx5IHRvIGV4aGliaXQgc2ltaWxhciBiZWhhdmlvci5cbi8vIEFsc28sIHRoZSBvbmx5IG1vZGVybiBicm93c2VyIHRoYXQgdXNlcyB2ZW5kb3IgcHJlZml4ZXMgZm9yIHRyYW5zaXRpb25zL2tleWZyYW1lcyBpcyB3ZWJraXRcbi8vIHRoZXJlZm9yZSB0aGVyZSBpcyBubyByZWFzb24gdG8gdGVzdCBhbnltb3JlIGZvciBvdGhlciB2ZW5kb3IgcHJlZml4ZXM6XG4vLyBodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD10cmFuc2l0aW9uXG5pZiAoaXNVbmRlZmluZWQod2luZG93Lm9udHJhbnNpdGlvbmVuZCkgJiYgaXNEZWZpbmVkKHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQpKSB7XG4gIENTU19QUkVGSVggPSAnLXdlYmtpdC0nO1xuICBUUkFOU0lUSU9OX1BST1AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gIFRSQU5TSVRJT05FTkRfRVZFTlQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCB0cmFuc2l0aW9uZW5kJztcbn0gZWxzZSB7XG4gIFRSQU5TSVRJT05fUFJPUCA9ICd0cmFuc2l0aW9uJztcbiAgVFJBTlNJVElPTkVORF9FVkVOVCA9ICd0cmFuc2l0aW9uZW5kJztcbn1cblxuaWYgKGlzVW5kZWZpbmVkKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCkgJiYgaXNEZWZpbmVkKHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCkpIHtcbiAgQ1NTX1BSRUZJWCA9ICctd2Via2l0LSc7XG4gIEFOSU1BVElPTl9QUk9QID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gIEFOSU1BVElPTkVORF9FVkVOVCA9ICd3ZWJraXRBbmltYXRpb25FbmQgYW5pbWF0aW9uZW5kJztcbn0gZWxzZSB7XG4gIEFOSU1BVElPTl9QUk9QID0gJ2FuaW1hdGlvbic7XG4gIEFOSU1BVElPTkVORF9FVkVOVCA9ICdhbmltYXRpb25lbmQnO1xufVxuXG52YXIgRFVSQVRJT05fS0VZID0gJ0R1cmF0aW9uJztcbnZhciBQUk9QRVJUWV9LRVkgPSAnUHJvcGVydHknO1xudmFyIERFTEFZX0tFWSA9ICdEZWxheSc7XG52YXIgVElNSU5HX0tFWSA9ICdUaW1pbmdGdW5jdGlvbic7XG52YXIgQU5JTUFUSU9OX0lURVJBVElPTl9DT1VOVF9LRVkgPSAnSXRlcmF0aW9uQ291bnQnO1xudmFyIEFOSU1BVElPTl9QTEFZU1RBVEVfS0VZID0gJ1BsYXlTdGF0ZSc7XG52YXIgU0FGRV9GQVNUX0ZPUldBUkRfRFVSQVRJT05fVkFMVUUgPSA5OTk5O1xuXG52YXIgQU5JTUFUSU9OX0RFTEFZX1BST1AgPSBBTklNQVRJT05fUFJPUCArIERFTEFZX0tFWTtcbnZhciBBTklNQVRJT05fRFVSQVRJT05fUFJPUCA9IEFOSU1BVElPTl9QUk9QICsgRFVSQVRJT05fS0VZO1xudmFyIFRSQU5TSVRJT05fREVMQVlfUFJPUCA9IFRSQU5TSVRJT05fUFJPUCArIERFTEFZX0tFWTtcbnZhciBUUkFOU0lUSU9OX0RVUkFUSU9OX1BST1AgPSBUUkFOU0lUSU9OX1BST1AgKyBEVVJBVElPTl9LRVk7XG5cbnZhciBpc1Byb21pc2VMaWtlID0gZnVuY3Rpb24ocCkge1xuICByZXR1cm4gcCAmJiBwLnRoZW4gPyB0cnVlIDogZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBhc3NlcnRBcmcoYXJnLCBuYW1lLCByZWFzb24pIHtcbiAgaWYgKCFhcmcpIHtcbiAgICB0aHJvdyBuZ01pbkVycignYXJlcScsIFwiQXJndW1lbnQgJ3swfScgaXMgezF9XCIsIChuYW1lIHx8ICc/JyksIChyZWFzb24gfHwgXCJyZXF1aXJlZFwiKSk7XG4gIH1cbiAgcmV0dXJuIGFyZztcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc2VzKGEsYikge1xuICBpZiAoIWEgJiYgIWIpIHJldHVybiAnJztcbiAgaWYgKCFhKSByZXR1cm4gYjtcbiAgaWYgKCFiKSByZXR1cm4gYTtcbiAgaWYgKGlzQXJyYXkoYSkpIGEgPSBhLmpvaW4oJyAnKTtcbiAgaWYgKGlzQXJyYXkoYikpIGIgPSBiLmpvaW4oJyAnKTtcbiAgcmV0dXJuIGEgKyAnICcgKyBiO1xufVxuXG5mdW5jdGlvbiBwYWNrYWdlU3R5bGVzKG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlcyA9IHt9O1xuICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy50byB8fCBvcHRpb25zLmZyb20pKSB7XG4gICAgc3R5bGVzLnRvID0gb3B0aW9ucy50bztcbiAgICBzdHlsZXMuZnJvbSA9IG9wdGlvbnMuZnJvbTtcbiAgfVxuICByZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBwZW5kQ2xhc3NlcyhjbGFzc2VzLCBmaXgsIGlzUHJlZml4KSB7XG4gIHZhciBjbGFzc05hbWUgPSAnJztcbiAgY2xhc3NlcyA9IGlzQXJyYXkoY2xhc3NlcylcbiAgICAgID8gY2xhc3Nlc1xuICAgICAgOiBjbGFzc2VzICYmIGlzU3RyaW5nKGNsYXNzZXMpICYmIGNsYXNzZXMubGVuZ3RoXG4gICAgICAgICAgPyBjbGFzc2VzLnNwbGl0KC9cXHMrLylcbiAgICAgICAgICA6IFtdO1xuICBmb3JFYWNoKGNsYXNzZXMsIGZ1bmN0aW9uKGtsYXNzLCBpKSB7XG4gICAgaWYgKGtsYXNzICYmIGtsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNsYXNzTmFtZSArPSAoaSA+IDApID8gJyAnIDogJyc7XG4gICAgICBjbGFzc05hbWUgKz0gaXNQcmVmaXggPyBmaXggKyBrbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoga2xhc3MgKyBmaXg7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnJvbUFycmF5KGFyciwgdmFsKSB7XG4gIHZhciBpbmRleCA9IGFyci5pbmRleE9mKHZhbCk7XG4gIGlmICh2YWwgPj0gMCkge1xuICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwQ29tbWVudHNGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YganFMaXRlKSB7XG4gICAgc3dpdGNoIChlbGVtZW50Lmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIHBvaW50IG9mIHN0cmlwcGluZyBhbnl0aGluZyBpZiB0aGUgZWxlbWVudFxuICAgICAgICAvLyBpcyB0aGUgb25seSBlbGVtZW50IHdpdGhpbiB0aGUganFMaXRlIHdyYXBwZXIuXG4gICAgICAgIC8vIChpdCdzIGltcG9ydGFudCB0aGF0IHdlIHJldGFpbiB0aGUgZWxlbWVudCBpbnN0YW5jZS4pXG4gICAgICAgIGlmIChlbGVtZW50WzBdLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGpxTGl0ZShleHRyYWN0RWxlbWVudE5vZGUoZWxlbWVudCkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGpxTGl0ZShlbGVtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RWxlbWVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnRbMF0pIHJldHVybiBlbGVtZW50O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxtID0gZWxlbWVudFtpXTtcbiAgICBpZiAoZWxtLm5vZGVUeXBlID09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIGVsbTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gJCRhZGRDbGFzcygkJGpxTGl0ZSwgZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGZvckVhY2goZWxlbWVudCwgZnVuY3Rpb24oZWxtKSB7XG4gICAgJCRqcUxpdGUuYWRkQ2xhc3MoZWxtLCBjbGFzc05hbWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gJCRyZW1vdmVDbGFzcygkJGpxTGl0ZSwgZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGZvckVhY2goZWxlbWVudCwgZnVuY3Rpb24oZWxtKSB7XG4gICAgJCRqcUxpdGUucmVtb3ZlQ2xhc3MoZWxtLCBjbGFzc05hbWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlBbmltYXRpb25DbGFzc2VzRmFjdG9yeSgkJGpxTGl0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmFkZENsYXNzKSB7XG4gICAgICAkJGFkZENsYXNzKCQkanFMaXRlLCBlbGVtZW50LCBvcHRpb25zLmFkZENsYXNzKTtcbiAgICAgIG9wdGlvbnMuYWRkQ2xhc3MgPSBudWxsO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZW1vdmVDbGFzcykge1xuICAgICAgJCRyZW1vdmVDbGFzcygkJGpxTGl0ZSwgZWxlbWVudCwgb3B0aW9ucy5yZW1vdmVDbGFzcyk7XG4gICAgICBvcHRpb25zLnJlbW92ZUNsYXNzID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFvcHRpb25zLiQkcHJlcGFyZWQpIHtcbiAgICB2YXIgZG9tT3BlcmF0aW9uID0gb3B0aW9ucy5kb21PcGVyYXRpb24gfHwgbm9vcDtcbiAgICBvcHRpb25zLmRvbU9wZXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgb3B0aW9ucy4kJGRvbU9wZXJhdGlvbkZpcmVkID0gdHJ1ZTtcbiAgICAgIGRvbU9wZXJhdGlvbigpO1xuICAgICAgZG9tT3BlcmF0aW9uID0gbm9vcDtcbiAgICB9O1xuICAgIG9wdGlvbnMuJCRwcmVwYXJlZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uU3R5bGVzKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgYXBwbHlBbmltYXRpb25Gcm9tU3R5bGVzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICBhcHBseUFuaW1hdGlvblRvU3R5bGVzKGVsZW1lbnQsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBhcHBseUFuaW1hdGlvbkZyb21TdHlsZXMoZWxlbWVudCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5mcm9tKSB7XG4gICAgZWxlbWVudC5jc3Mob3B0aW9ucy5mcm9tKTtcbiAgICBvcHRpb25zLmZyb20gPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uVG9TdHlsZXMoZWxlbWVudCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50bykge1xuICAgIGVsZW1lbnQuY3NzKG9wdGlvbnMudG8pO1xuICAgIG9wdGlvbnMudG8gPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlQW5pbWF0aW9uT3B0aW9ucyhlbGVtZW50LCB0YXJnZXQsIG5ld09wdGlvbnMpIHtcbiAgdmFyIHRvQWRkID0gKHRhcmdldC5hZGRDbGFzcyB8fCAnJykgKyAnICcgKyAobmV3T3B0aW9ucy5hZGRDbGFzcyB8fCAnJyk7XG4gIHZhciB0b1JlbW92ZSA9ICh0YXJnZXQucmVtb3ZlQ2xhc3MgfHwgJycpICsgJyAnICsgKG5ld09wdGlvbnMucmVtb3ZlQ2xhc3MgfHwgJycpO1xuICB2YXIgY2xhc3NlcyA9IHJlc29sdmVFbGVtZW50Q2xhc3NlcyhlbGVtZW50LmF0dHIoJ2NsYXNzJyksIHRvQWRkLCB0b1JlbW92ZSk7XG5cbiAgaWYgKG5ld09wdGlvbnMucHJlcGFyYXRpb25DbGFzc2VzKSB7XG4gICAgdGFyZ2V0LnByZXBhcmF0aW9uQ2xhc3NlcyA9IGNvbmNhdFdpdGhTcGFjZShuZXdPcHRpb25zLnByZXBhcmF0aW9uQ2xhc3NlcywgdGFyZ2V0LnByZXBhcmF0aW9uQ2xhc3Nlcyk7XG4gICAgZGVsZXRlIG5ld09wdGlvbnMucHJlcGFyYXRpb25DbGFzc2VzO1xuICB9XG5cbiAgLy8gbm9vcCBpcyBiYXNpY2FsbHkgd2hlbiB0aGVyZSBpcyBubyBjYWxsYmFjazsgb3RoZXJ3aXNlIHNvbWV0aGluZyBoYXMgYmVlbiBzZXRcbiAgdmFyIHJlYWxEb21PcGVyYXRpb24gPSB0YXJnZXQuZG9tT3BlcmF0aW9uICE9PSBub29wID8gdGFyZ2V0LmRvbU9wZXJhdGlvbiA6IG51bGw7XG5cbiAgZXh0ZW5kKHRhcmdldCwgbmV3T3B0aW9ucyk7XG5cbiAgLy8gVE9ETyhtYXRza28gb3Igc3JlZXJhbXUpOiBwcm9wZXIgZml4IGlzIHRvIG1haW50YWluIGFsbCBhbmltYXRpb24gY2FsbGJhY2sgaW4gYXJyYXkgYW5kIGNhbGwgYXQgbGFzdCxidXQgbm93IG9ubHkgbGVhdmUgaGFzIHRoZSBjYWxsYmFjayBzbyBubyBpc3N1ZSB3aXRoIHRoaXMuXG4gIGlmIChyZWFsRG9tT3BlcmF0aW9uKSB7XG4gICAgdGFyZ2V0LmRvbU9wZXJhdGlvbiA9IHJlYWxEb21PcGVyYXRpb247XG4gIH1cblxuICBpZiAoY2xhc3Nlcy5hZGRDbGFzcykge1xuICAgIHRhcmdldC5hZGRDbGFzcyA9IGNsYXNzZXMuYWRkQ2xhc3M7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmFkZENsYXNzID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjbGFzc2VzLnJlbW92ZUNsYXNzKSB7XG4gICAgdGFyZ2V0LnJlbW92ZUNsYXNzID0gY2xhc3Nlcy5yZW1vdmVDbGFzcztcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQucmVtb3ZlQ2xhc3MgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnRDbGFzc2VzKGV4aXN0aW5nLCB0b0FkZCwgdG9SZW1vdmUpIHtcbiAgdmFyIEFERF9DTEFTUyA9IDE7XG4gIHZhciBSRU1PVkVfQ0xBU1MgPSAtMTtcblxuICB2YXIgZmxhZ3MgPSB7fTtcbiAgZXhpc3RpbmcgPSBzcGxpdENsYXNzZXNUb0xvb2t1cChleGlzdGluZyk7XG5cbiAgdG9BZGQgPSBzcGxpdENsYXNzZXNUb0xvb2t1cCh0b0FkZCk7XG4gIGZvckVhY2godG9BZGQsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICBmbGFnc1trZXldID0gQUREX0NMQVNTO1xuICB9KTtcblxuICB0b1JlbW92ZSA9IHNwbGl0Q2xhc3Nlc1RvTG9va3VwKHRvUmVtb3ZlKTtcbiAgZm9yRWFjaCh0b1JlbW92ZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIGZsYWdzW2tleV0gPSBmbGFnc1trZXldID09PSBBRERfQ0xBU1MgPyBudWxsIDogUkVNT1ZFX0NMQVNTO1xuICB9KTtcblxuICB2YXIgY2xhc3NlcyA9IHtcbiAgICBhZGRDbGFzczogJycsXG4gICAgcmVtb3ZlQ2xhc3M6ICcnXG4gIH07XG5cbiAgZm9yRWFjaChmbGFncywgZnVuY3Rpb24odmFsLCBrbGFzcykge1xuICAgIHZhciBwcm9wLCBhbGxvdztcbiAgICBpZiAodmFsID09PSBBRERfQ0xBU1MpIHtcbiAgICAgIHByb3AgPSAnYWRkQ2xhc3MnO1xuICAgICAgYWxsb3cgPSAhZXhpc3Rpbmdba2xhc3NdO1xuICAgIH0gZWxzZSBpZiAodmFsID09PSBSRU1PVkVfQ0xBU1MpIHtcbiAgICAgIHByb3AgPSAncmVtb3ZlQ2xhc3MnO1xuICAgICAgYWxsb3cgPSBleGlzdGluZ1trbGFzc107XG4gICAgfVxuICAgIGlmIChhbGxvdykge1xuICAgICAgaWYgKGNsYXNzZXNbcHJvcF0ubGVuZ3RoKSB7XG4gICAgICAgIGNsYXNzZXNbcHJvcF0gKz0gJyAnO1xuICAgICAgfVxuICAgICAgY2xhc3Nlc1twcm9wXSArPSBrbGFzcztcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHNwbGl0Q2xhc3Nlc1RvTG9va3VwKGNsYXNzZXMpIHtcbiAgICBpZiAoaXNTdHJpbmcoY2xhc3NlcykpIHtcbiAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KCcgJyk7XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGZvckVhY2goY2xhc3NlcywgZnVuY3Rpb24oa2xhc3MpIHtcbiAgICAgIC8vIHNvbWV0aW1lcyB0aGUgc3BsaXQgbGVhdmVzIGVtcHR5IHN0cmluZyB2YWx1ZXNcbiAgICAgIC8vIGluY2FzZSBleHRyYSBzcGFjZXMgd2VyZSBhcHBsaWVkIHRvIHRoZSBvcHRpb25zXG4gICAgICBpZiAoa2xhc3MubGVuZ3RoKSB7XG4gICAgICAgIG9ialtrbGFzc10gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICByZXR1cm4gY2xhc3Nlcztcbn1cblxuZnVuY3Rpb24gZ2V0RG9tTm9kZShlbGVtZW50KSB7XG4gIHJldHVybiAoZWxlbWVudCBpbnN0YW5jZW9mIGFuZ3VsYXIuZWxlbWVudCkgPyBlbGVtZW50WzBdIDogZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gYXBwbHlHZW5lcmF0ZWRQcmVwYXJhdGlvbkNsYXNzZXMoZWxlbWVudCwgZXZlbnQsIG9wdGlvbnMpIHtcbiAgdmFyIGNsYXNzZXMgPSAnJztcbiAgaWYgKGV2ZW50KSB7XG4gICAgY2xhc3NlcyA9IHBlbmRDbGFzc2VzKGV2ZW50LCBFVkVOVF9DTEFTU19QUkVGSVgsIHRydWUpO1xuICB9XG4gIGlmIChvcHRpb25zLmFkZENsYXNzKSB7XG4gICAgY2xhc3NlcyA9IGNvbmNhdFdpdGhTcGFjZShjbGFzc2VzLCBwZW5kQ2xhc3NlcyhvcHRpb25zLmFkZENsYXNzLCBBRERfQ0xBU1NfU1VGRklYKSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVtb3ZlQ2xhc3MpIHtcbiAgICBjbGFzc2VzID0gY29uY2F0V2l0aFNwYWNlKGNsYXNzZXMsIHBlbmRDbGFzc2VzKG9wdGlvbnMucmVtb3ZlQ2xhc3MsIFJFTU9WRV9DTEFTU19TVUZGSVgpKTtcbiAgfVxuICBpZiAoY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICBvcHRpb25zLnByZXBhcmF0aW9uQ2xhc3NlcyA9IGNsYXNzZXM7XG4gICAgZWxlbWVudC5hZGRDbGFzcyhjbGFzc2VzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhckdlbmVyYXRlZENsYXNzZXMoZWxlbWVudCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5wcmVwYXJhdGlvbkNsYXNzZXMpIHtcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKG9wdGlvbnMucHJlcGFyYXRpb25DbGFzc2VzKTtcbiAgICBvcHRpb25zLnByZXBhcmF0aW9uQ2xhc3NlcyA9IG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWN0aXZlQ2xhc3Nlcykge1xuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3Mob3B0aW9ucy5hY3RpdmVDbGFzc2VzKTtcbiAgICBvcHRpb25zLmFjdGl2ZUNsYXNzZXMgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJsb2NrVHJhbnNpdGlvbnMobm9kZSwgZHVyYXRpb24pIHtcbiAgLy8gd2UgdXNlIGEgbmVnYXRpdmUgZGVsYXkgdmFsdWUgc2luY2UgaXQgcGVyZm9ybXMgYmxvY2tpbmdcbiAgLy8geWV0IGl0IGRvZXNuJ3Qga2lsbCBhbnkgZXhpc3RpbmcgdHJhbnNpdGlvbnMgcnVubmluZyBvbiB0aGVcbiAgLy8gc2FtZSBlbGVtZW50IHdoaWNoIG1ha2VzIHRoaXMgc2FmZSBmb3IgY2xhc3MtYmFzZWQgYW5pbWF0aW9uc1xuICB2YXIgdmFsdWUgPSBkdXJhdGlvbiA/ICctJyArIGR1cmF0aW9uICsgJ3MnIDogJyc7XG4gIGFwcGx5SW5saW5lU3R5bGUobm9kZSwgW1RSQU5TSVRJT05fREVMQVlfUFJPUCwgdmFsdWVdKTtcbiAgcmV0dXJuIFtUUkFOU0lUSU9OX0RFTEFZX1BST1AsIHZhbHVlXTtcbn1cblxuZnVuY3Rpb24gYmxvY2tLZXlmcmFtZUFuaW1hdGlvbnMobm9kZSwgYXBwbHlCbG9jaykge1xuICB2YXIgdmFsdWUgPSBhcHBseUJsb2NrID8gJ3BhdXNlZCcgOiAnJztcbiAgdmFyIGtleSA9IEFOSU1BVElPTl9QUk9QICsgQU5JTUFUSU9OX1BMQVlTVEFURV9LRVk7XG4gIGFwcGx5SW5saW5lU3R5bGUobm9kZSwgW2tleSwgdmFsdWVdKTtcbiAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbn1cblxuZnVuY3Rpb24gYXBwbHlJbmxpbmVTdHlsZShub2RlLCBzdHlsZVR1cGxlKSB7XG4gIHZhciBwcm9wID0gc3R5bGVUdXBsZVswXTtcbiAgdmFyIHZhbHVlID0gc3R5bGVUdXBsZVsxXTtcbiAgbm9kZS5zdHlsZVtwcm9wXSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb25jYXRXaXRoU3BhY2UoYSxiKSB7XG4gIGlmICghYSkgcmV0dXJuIGI7XG4gIGlmICghYikgcmV0dXJuIGE7XG4gIHJldHVybiBhICsgJyAnICsgYjtcbn1cblxudmFyICQkckFGU2NoZWR1bGVyRmFjdG9yeSA9IFsnJCRyQUYnLCBmdW5jdGlvbigkJHJBRikge1xuICB2YXIgcXVldWUsIGNhbmNlbEZuO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlcih0YXNrcykge1xuICAgIC8vIHdlIG1ha2UgYSBjb3B5IHNpbmNlIFJBRlNjaGVkdWxlciBtdXRhdGVzIHRoZSBzdGF0ZVxuICAgIC8vIG9mIHRoZSBwYXNzZWQgaW4gYXJyYXkgdmFyaWFibGUgYW5kIHRoaXMgd291bGQgYmUgZGlmZmljdWx0XG4gICAgLy8gdG8gdHJhY2sgZG93biBvbiB0aGUgb3V0c2lkZSBjb2RlXG4gICAgcXVldWUgPSBxdWV1ZS5jb25jYXQodGFza3MpO1xuICAgIG5leHRUaWNrKCk7XG4gIH1cblxuICBxdWV1ZSA9IHNjaGVkdWxlci5xdWV1ZSA9IFtdO1xuXG4gIC8qIHdhaXRVbnRpbFF1aWV0IGRvZXMgdHdvIHRoaW5nczpcbiAgICogMS4gSXQgd2lsbCBydW4gdGhlIEZJTkFMIGBmbmAgdmFsdWUgb25seSB3aGVuIGFuIHVuY2FuY2VsbGVkIFJBRiBoYXMgcGFzc2VkIHRocm91Z2hcbiAgICogMi4gSXQgd2lsbCBkZWxheSB0aGUgbmV4dCB3YXZlIG9mIHRhc2tzIGZyb20gcnVubmluZyB1bnRpbCB0aGUgcXVpZXQgYGZuYCBoYXMgcnVuLlxuICAgKlxuICAgKiBUaGUgbW90aXZhdGlvbiBoZXJlIGlzIHRoYXQgYW5pbWF0aW9uIGNvZGUgY2FuIHJlcXVlc3QgbW9yZSB0aW1lIGZyb20gdGhlIHNjaGVkdWxlclxuICAgKiBiZWZvcmUgdGhlIG5leHQgd2F2ZSBydW5zLiBUaGlzIGFsbG93cyBmb3IgY2VydGFpbiBET00gcHJvcGVydGllcyBzdWNoIGFzIGNsYXNzZXMgdG9cbiAgICogYmUgcmVzb2x2ZWQgaW4gdGltZSBmb3IgdGhlIG5leHQgYW5pbWF0aW9uIHRvIHJ1bi5cbiAgICovXG4gIHNjaGVkdWxlci53YWl0VW50aWxRdWlldCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKGNhbmNlbEZuKSBjYW5jZWxGbigpO1xuXG4gICAgY2FuY2VsRm4gPSAkJHJBRihmdW5jdGlvbigpIHtcbiAgICAgIGNhbmNlbEZuID0gbnVsbDtcbiAgICAgIGZuKCk7XG4gICAgICBuZXh0VGljaygpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBzY2hlZHVsZXI7XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHJldHVybjtcblxuICAgIHZhciBpdGVtcyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgaXRlbXNbaV0oKTtcbiAgICB9XG5cbiAgICBpZiAoIWNhbmNlbEZuKSB7XG4gICAgICAkJHJBRihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFjYW5jZWxGbikgbmV4dFRpY2soKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufV07XG5cbnZhciAkJEFuaW1hdGVDaGlsZHJlbkRpcmVjdGl2ZSA9IFtmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgIHZhciB2YWwgPSBhdHRycy5uZ0FuaW1hdGVDaGlsZHJlbjtcbiAgICBpZiAoYW5ndWxhci5pc1N0cmluZyh2YWwpICYmIHZhbC5sZW5ndGggPT09IDApIHsgLy9lbXB0eSBhdHRyaWJ1dGVcbiAgICAgIGVsZW1lbnQuZGF0YShOR19BTklNQVRFX0NISUxEUkVOX0RBVEEsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRycy4kb2JzZXJ2ZSgnbmdBbmltYXRlQ2hpbGRyZW4nLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSAnb24nIHx8IHZhbHVlID09PSAndHJ1ZSc7XG4gICAgICAgIGVsZW1lbnQuZGF0YShOR19BTklNQVRFX0NISUxEUkVOX0RBVEEsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dO1xuXG52YXIgQU5JTUFURV9USU1FUl9LRVkgPSAnJCRhbmltYXRlQ3NzJztcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJGFuaW1hdGVDc3NcbiAqIEBraW5kIG9iamVjdFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGAkYW5pbWF0ZUNzc2Agc2VydmljZSBpcyBhIHVzZWZ1bCB1dGlsaXR5IHRvIHRyaWdnZXIgY3VzdG9taXplZCBDU1MtYmFzZWQgdHJhbnNpdGlvbnMva2V5ZnJhbWVzXG4gKiBmcm9tIGEgSmF2YVNjcmlwdC1iYXNlZCBhbmltYXRpb24gb3IgZGlyZWN0bHkgZnJvbSBhIGRpcmVjdGl2ZS4gVGhlIHB1cnBvc2Ugb2YgYCRhbmltYXRlQ3NzYCBpcyBOT1RcbiAqIHRvIHNpZGUtc3RlcCBob3cgYCRhbmltYXRlYCBhbmQgbmdBbmltYXRlIHdvcmssIGJ1dCB0aGUgZ29hbCBpcyB0byBhbGxvdyBwcmUtZXhpc3RpbmcgYW5pbWF0aW9ucyBvclxuICogZGlyZWN0aXZlcyB0byBjcmVhdGUgbW9yZSBjb21wbGV4IGFuaW1hdGlvbnMgdGhhdCBjYW4gYmUgcHVyZWx5IGRyaXZlbiB1c2luZyBDU1MgY29kZS5cbiAqXG4gKiBOb3RlIHRoYXQgb25seSBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTIHRyYW5zaXRpb25zIGFuZC9vciBrZXlmcmFtZSBhbmltYXRpb25zIGFyZSBjYXBhYmxlIG9mXG4gKiByZW5kZXJpbmcgYW5pbWF0aW9ucyB0cmlnZ2VyZWQgdmlhIGAkYW5pbWF0ZUNzc2AgKGJhZCBuZXdzIGZvciBJRTkgYW5kIGxvd2VyKS5cbiAqXG4gKiAjIyBVc2FnZVxuICogT25jZSBhZ2FpbiwgYCRhbmltYXRlQ3NzYCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBhIHJlZ2lzdGVyZWQgSmF2YVNjcmlwdCBhbmltYXRpb24gdGhhdFxuICogaXMgcG93ZXJlZCBieSBuZ0FuaW1hdGUuIEl0IGlzIHBvc3NpYmxlIHRvIHVzZSBgJGFuaW1hdGVDc3NgIGRpcmVjdGx5IGluc2lkZSBvZiBhIGRpcmVjdGl2ZSwgaG93ZXZlcixcbiAqIGFueSBhdXRvbWF0aWMgY29udHJvbCBvdmVyIGNhbmNlbGxpbmcgYW5pbWF0aW9ucyBhbmQvb3IgcHJldmVudGluZyBhbmltYXRpb25zIGZyb20gYmVpbmcgcnVuIG9uXG4gKiBjaGlsZCBlbGVtZW50cyB3aWxsIG5vdCBiZSBoYW5kbGVkIGJ5IEFuZ3VsYXIuIEZvciB0aGlzIHRvIHdvcmsgYXMgZXhwZWN0ZWQsIHBsZWFzZSB1c2UgYCRhbmltYXRlYCB0b1xuICogdHJpZ2dlciB0aGUgYW5pbWF0aW9uIGFuZCB0aGVuIHNldHVwIGEgSmF2YVNjcmlwdCBhbmltYXRpb24gdGhhdCBpbmplY3RzIGAkYW5pbWF0ZUNzc2AgdG8gdHJpZ2dlclxuICogdGhlIENTUyBhbmltYXRpb24uXG4gKlxuICogVGhlIGV4YW1wbGUgYmVsb3cgc2hvd3MgaG93IHdlIGNhbiBjcmVhdGUgYSBmb2xkaW5nIGFuaW1hdGlvbiBvbiBhbiBlbGVtZW50IHVzaW5nIGBuZy1pZmA6XG4gKlxuICogYGBgaHRtbFxuICogPCEtLSBub3RpY2UgdGhlIGBmb2xkLWFuaW1hdGlvbmAgQ1NTIGNsYXNzIC0tPlxuICogPGRpdiBuZy1pZj1cIm9uT2ZmXCIgY2xhc3M9XCJmb2xkLWFuaW1hdGlvblwiPlxuICogICBUaGlzIGVsZW1lbnQgd2lsbCBnbyBCT09NXG4gKiA8L2Rpdj5cbiAqIDxidXR0b24gbmctY2xpY2s9XCJvbk9mZj10cnVlXCI+Rm9sZCBJbjwvYnV0dG9uPlxuICogYGBgXG4gKlxuICogTm93IHdlIGNyZWF0ZSB0aGUgKipKYXZhU2NyaXB0IGFuaW1hdGlvbioqIHRoYXQgd2lsbCB0cmlnZ2VyIHRoZSBDU1MgdHJhbnNpdGlvbjpcbiAqXG4gKiBgYGBqc1xuICogbmdNb2R1bGUuYW5pbWF0aW9uKCcuZm9sZC1hbmltYXRpb24nLCBbJyRhbmltYXRlQ3NzJywgZnVuY3Rpb24oJGFuaW1hdGVDc3MpIHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBlbnRlcjogZnVuY3Rpb24oZWxlbWVudCwgZG9uZUZuKSB7XG4gKiAgICAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudFswXS5vZmZzZXRIZWlnaHQ7XG4gKiAgICAgICByZXR1cm4gJGFuaW1hdGVDc3MoZWxlbWVudCwge1xuICogICAgICAgICBmcm9tOiB7IGhlaWdodDonMHB4JyB9LFxuICogICAgICAgICB0bzogeyBoZWlnaHQ6aGVpZ2h0ICsgJ3B4JyB9LFxuICogICAgICAgICBkdXJhdGlvbjogMSAvLyBvbmUgc2Vjb25kXG4gKiAgICAgICB9KTtcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1dKTtcbiAqIGBgYFxuICpcbiAqICMjIE1vcmUgQWR2YW5jZWQgVXNlc1xuICpcbiAqIGAkYW5pbWF0ZUNzc2AgaXMgdGhlIHVuZGVybHlpbmcgY29kZSB0aGF0IG5nQW5pbWF0ZSB1c2VzIHRvIHBvd2VyICoqQ1NTLWJhc2VkIGFuaW1hdGlvbnMqKiBiZWhpbmQgdGhlIHNjZW5lcy4gVGhlcmVmb3JlIENTUyBob29rc1xuICogbGlrZSBgLm5nLUVWRU5UYCwgYC5uZy1FVkVOVC1hY3RpdmVgLCBgLm5nLUVWRU5ULXN0YWdnZXJgIGFyZSBhbGwgZmVhdHVyZXMgdGhhdCBjYW4gYmUgdHJpZ2dlcmVkIHVzaW5nIGAkYW5pbWF0ZUNzc2AgdmlhIEphdmFTY3JpcHQgY29kZS5cbiAqXG4gKiBUaGlzIGFsc28gbWVhbnMgdGhhdCBqdXN0IGFib3V0IGFueSBjb21iaW5hdGlvbiBvZiBhZGRpbmcgY2xhc3NlcywgcmVtb3ZpbmcgY2xhc3Nlcywgc2V0dGluZyBzdHlsZXMsIGR5bmFtaWNhbGx5IHNldHRpbmcgYSBrZXlmcmFtZSBhbmltYXRpb24sXG4gKiBhcHBseWluZyBhIGhhcmRjb2RlZCBkdXJhdGlvbiBvciBkZWxheSB2YWx1ZSwgY2hhbmdpbmcgdGhlIGFuaW1hdGlvbiBlYXNpbmcgb3IgYXBwbHlpbmcgYSBzdGFnZ2VyIGFuaW1hdGlvbiBhcmUgYWxsIG9wdGlvbnMgdGhhdCB3b3JrIHdpdGhcbiAqIGAkYW5pbWF0ZUNzc2AuIFRoZSBzZXJ2aWNlIGl0c2VsZiBpcyBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCB0aGUgY29tYmluYXRpb24gb2Ygb3B0aW9ucyBhbmQgZXhhbWluZSB0aGUgZWxlbWVudCBzdHlsaW5nIHByb3BlcnRpZXMgaW4gb3JkZXJcbiAqIHRvIHByb3ZpZGUgYSB3b3JraW5nIGFuaW1hdGlvbiB0aGF0IHdpbGwgcnVuIGluIENTUy5cbiAqXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBzaG93Y2FzZXMgYSBtb3JlIGFkdmFuY2VkIHZlcnNpb24gb2YgdGhlIGAuZm9sZC1hbmltYXRpb25gIGZyb20gdGhlIGV4YW1wbGUgYWJvdmU6XG4gKlxuICogYGBganNcbiAqIG5nTW9kdWxlLmFuaW1hdGlvbignLmZvbGQtYW5pbWF0aW9uJywgWyckYW5pbWF0ZUNzcycsIGZ1bmN0aW9uKCRhbmltYXRlQ3NzKSB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgZW50ZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmVGbikge1xuICogICAgICAgdmFyIGhlaWdodCA9IGVsZW1lbnRbMF0ub2Zmc2V0SGVpZ2h0O1xuICogICAgICAgcmV0dXJuICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAqICAgICAgICAgYWRkQ2xhc3M6ICdyZWQgbGFyZ2UtdGV4dCBwdWxzZS10d2ljZScsXG4gKiAgICAgICAgIGVhc2luZzogJ2Vhc2Utb3V0JyxcbiAqICAgICAgICAgZnJvbTogeyBoZWlnaHQ6JzBweCcgfSxcbiAqICAgICAgICAgdG86IHsgaGVpZ2h0OmhlaWdodCArICdweCcgfSxcbiAqICAgICAgICAgZHVyYXRpb246IDEgLy8gb25lIHNlY29uZFxuICogICAgICAgfSk7XG4gKiAgICAgfVxuICogICB9XG4gKiB9XSk7XG4gKiBgYGBcbiAqXG4gKiBTaW5jZSB3ZSdyZSBhZGRpbmcvcmVtb3ZpbmcgQ1NTIGNsYXNzZXMgdGhlbiB0aGUgQ1NTIHRyYW5zaXRpb24gd2lsbCBhbHNvIHBpY2sgdGhvc2UgdXA6XG4gKlxuICogYGBgY3NzXG4gKiAvJiM0Mjsgc2luY2UgYSBoYXJkY29kZWQgZHVyYXRpb24gdmFsdWUgb2YgMSB3YXMgcHJvdmlkZWQgaW4gdGhlIEphdmFTY3JpcHQgYW5pbWF0aW9uIGNvZGUsXG4gKiB0aGUgQ1NTIGNsYXNzZXMgYmVsb3cgd2lsbCBiZSB0cmFuc2l0aW9uZWQgZGVzcGl0ZSB0aGVtIGJlaW5nIGRlZmluZWQgYXMgcmVndWxhciBDU1MgY2xhc3NlcyAmIzQyOy9cbiAqIC5yZWQgeyBiYWNrZ3JvdW5kOnJlZDsgfVxuICogLmxhcmdlLXRleHQgeyBmb250LXNpemU6MjBweDsgfVxuICpcbiAqIC8mIzQyOyB3ZSBjYW4gYWxzbyB1c2UgYSBrZXlmcmFtZSBhbmltYXRpb24gYW5kICRhbmltYXRlQ3NzIHdpbGwgbWFrZSBpdCB3b3JrIGFsb25nc2lkZSB0aGUgdHJhbnNpdGlvbiAmIzQyOy9cbiAqIC5wdWxzZS10d2ljZSB7XG4gKiAgIGFuaW1hdGlvbjogMC41cyBwdWxzZSBsaW5lYXIgMjtcbiAqICAgLXdlYmtpdC1hbmltYXRpb246IDAuNXMgcHVsc2UgbGluZWFyIDI7XG4gKiB9XG4gKlxuICogQGtleWZyYW1lcyBwdWxzZSB7XG4gKiAgIGZyb20geyB0cmFuc2Zvcm06IHNjYWxlKDAuNSk7IH1cbiAqICAgdG8geyB0cmFuc2Zvcm06IHNjYWxlKDEuNSk7IH1cbiAqIH1cbiAqXG4gKiBALXdlYmtpdC1rZXlmcmFtZXMgcHVsc2Uge1xuICogICBmcm9tIHsgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuNSk7IH1cbiAqICAgdG8geyAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMS41KTsgfVxuICogfVxuICogYGBgXG4gKlxuICogR2l2ZW4gdGhpcyBjb21wbGV4IGNvbWJpbmF0aW9uIG9mIENTUyBjbGFzc2VzLCBzdHlsZXMgYW5kIG9wdGlvbnMsIGAkYW5pbWF0ZUNzc2Agd2lsbCBmaWd1cmUgZXZlcnl0aGluZyBvdXQgYW5kIG1ha2UgdGhlIGFuaW1hdGlvbiBoYXBwZW4uXG4gKlxuICogIyMgSG93IHRoZSBPcHRpb25zIGFyZSBoYW5kbGVkXG4gKlxuICogYCRhbmltYXRlQ3NzYCBpcyB2ZXJ5IHZlcnNhdGlsZSBhbmQgaW50ZWxsaWdlbnQgd2hlbiBpdCBjb21lcyB0byBmaWd1cmluZyBvdXQgd2hhdCBjb25maWd1cmF0aW9ucyB0byBhcHBseSB0byB0aGUgZWxlbWVudCB0byBlbnN1cmUgdGhlIGFuaW1hdGlvblxuICogd29ya3Mgd2l0aCB0aGUgb3B0aW9ucyBwcm92aWRlZC4gU2F5IGZvciBleGFtcGxlIHdlIHdlcmUgYWRkaW5nIGEgY2xhc3MgdGhhdCBjb250YWluZWQgYSBrZXlmcmFtZSB2YWx1ZSBhbmQgd2Ugd2FudGVkIHRvIGFsc28gYW5pbWF0ZSBzb21lIGlubGluZVxuICogc3R5bGVzIHVzaW5nIHRoZSBgZnJvbWAgYW5kIGB0b2AgcHJvcGVydGllcy5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGFuaW1hdG9yID0gJGFuaW1hdGVDc3MoZWxlbWVudCwge1xuICogICBmcm9tOiB7IGJhY2tncm91bmQ6J3JlZCcgfSxcbiAqICAgdG86IHsgYmFja2dyb3VuZDonYmx1ZScgfVxuICogfSk7XG4gKiBhbmltYXRvci5zdGFydCgpO1xuICogYGBgXG4gKlxuICogYGBgY3NzXG4gKiAucm90YXRpbmctYW5pbWF0aW9uIHtcbiAqICAgYW5pbWF0aW9uOjAuNXMgcm90YXRlIGxpbmVhcjtcbiAqICAgLXdlYmtpdC1hbmltYXRpb246MC41cyByb3RhdGUgbGluZWFyO1xuICogfVxuICpcbiAqIEBrZXlmcmFtZXMgcm90YXRlIHtcbiAqICAgZnJvbSB7IHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9XG4gKiAgIHRvIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxuICogfVxuICpcbiAqIEAtd2Via2l0LWtleWZyYW1lcyByb3RhdGUge1xuICogICBmcm9tIHsgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxuICogICB0byB7IC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxuICogfVxuICogYGBgXG4gKlxuICogVGhlIG1pc3NpbmcgcGllY2VzIGhlcmUgYXJlIHRoYXQgd2UgZG8gbm90IGhhdmUgYSB0cmFuc2l0aW9uIHNldCAod2l0aGluIHRoZSBDU1MgY29kZSBub3Igd2l0aGluIHRoZSBgJGFuaW1hdGVDc3NgIG9wdGlvbnMpIGFuZCB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpc1xuICogZ29pbmcgdG8gYmUgZGV0ZWN0ZWQgZnJvbSB3aGF0IHRoZSBrZXlmcmFtZSBzdHlsZXMgb24gdGhlIENTUyBjbGFzcyBhcmUuIEluIHRoaXMgZXZlbnQsIGAkYW5pbWF0ZUNzc2Agd2lsbCBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBhbiBpbmxpbmUgdHJhbnNpdGlvblxuICogc3R5bGUgbWF0Y2hpbmcgdGhlIGR1cmF0aW9uIGRldGVjdGVkIGZyb20gdGhlIGtleWZyYW1lIHN0eWxlICh3aGljaCBpcyBwcmVzZW50IGluIHRoZSBDU1MgY2xhc3MgdGhhdCBpcyBiZWluZyBhZGRlZCkgYW5kIHRoZW4gcHJlcGFyZSBib3RoIHRoZSB0cmFuc2l0aW9uXG4gKiBhbmQga2V5ZnJhbWUgYW5pbWF0aW9ucyB0byBydW4gaW4gcGFyYWxsZWwgb24gdGhlIGVsZW1lbnQuIFRoZW4gd2hlbiB0aGUgYW5pbWF0aW9uIGlzIHVuZGVyd2F5IHRoZSBwcm92aWRlZCBgZnJvbWAgYW5kIGB0b2AgQ1NTIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWRcbiAqIGFuZCBzcHJlYWQgYWNyb3NzIHRoZSB0cmFuc2l0aW9uIGFuZCBrZXlmcmFtZSBhbmltYXRpb24uXG4gKlxuICogIyMgV2hhdCBpcyByZXR1cm5lZFxuICpcbiAqIGAkYW5pbWF0ZUNzc2Agd29ya3MgaW4gdHdvIHN0YWdlczogYSBwcmVwYXJhdGlvbiBwaGFzZSBhbmQgYW4gYW5pbWF0aW9uIHBoYXNlLiBUaGVyZWZvcmUgd2hlbiBgJGFuaW1hdGVDc3NgIGlzIGZpcnN0IGNhbGxlZCBpdCB3aWxsIE5PVCBhY3R1YWxseVxuICogc3RhcnQgdGhlIGFuaW1hdGlvbi4gQWxsIHRoYXQgaXMgZ29pbmcgb24gaGVyZSBpcyB0aGF0IHRoZSBlbGVtZW50IGlzIGJlaW5nIHByZXBhcmVkIGZvciB0aGUgYW5pbWF0aW9uICh3aGljaCBtZWFucyB0aGF0IHRoZSBnZW5lcmF0ZWQgQ1NTIGNsYXNzZXMgYXJlXG4gKiBhZGRlZCBhbmQgcmVtb3ZlZCBvbiB0aGUgZWxlbWVudCkuIE9uY2UgYCRhbmltYXRlQ3NzYCBpcyBjYWxsZWQgaXQgd2lsbCByZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgYW5pbWF0b3IgPSAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7IC4uLiB9KTtcbiAqIGBgYFxuICpcbiAqIE5vdyB3aGF0IGRvIHRoZSBjb250ZW50cyBvZiBvdXIgYGFuaW1hdG9yYCB2YXJpYWJsZSBsb29rIGxpa2U6XG4gKlxuICogYGBganNcbiAqIHtcbiAqICAgLy8gc3RhcnRzIHRoZSBhbmltYXRpb25cbiAqICAgc3RhcnQ6IEZ1bmN0aW9uLFxuICpcbiAqICAgLy8gZW5kcyAoYWJvcnRzKSB0aGUgYW5pbWF0aW9uXG4gKiAgIGVuZDogRnVuY3Rpb25cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRvIGFjdHVhbGx5IHN0YXJ0IHRoZSBhbmltYXRpb24gd2UgbmVlZCB0byBydW4gYGFuaW1hdGlvbi5zdGFydCgpYCB3aGljaCB3aWxsIHRoZW4gcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdlIGNhbiBob29rIGludG8gdG8gZGV0ZWN0IHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuICogSWYgd2UgY2hvb3NlIG5vdCB0byBydW4gdGhlIGFuaW1hdGlvbiB0aGVuIHdlIE1VU1QgcnVuIGBhbmltYXRpb24uZW5kKClgIHRvIHBlcmZvcm0gYSBjbGVhbnVwIG9uIHRoZSBlbGVtZW50IChzaW5jZSBzb21lIENTUyBjbGFzc2VzIGFuZCBzdGx5ZXMgbWF5IGhhdmUgYmVlblxuICogYXBwbGllZCB0byB0aGUgZWxlbWVudCBkdXJpbmcgdGhlIHByZXBhcmF0aW9uIHBoYXNlKS4gTm90ZSB0aGF0IGFsbCBvdGhlciBwcm9wZXJ0aWVzIHN1Y2ggYXMgZHVyYXRpb24sIGRlbGF5LCB0cmFuc2l0aW9ucyBhbmQga2V5ZnJhbWVzIGFyZSBqdXN0IHByb3BlcnRpZXNcbiAqIGFuZCB0aGF0IGNoYW5naW5nIHRoZW0gd2lsbCBub3QgcmVjb25maWd1cmUgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGFuaW1hdGlvbi5cbiAqXG4gKiAjIyMgcnVubmVyLmRvbmUoKSB2cyBydW5uZXIudGhlbigpXG4gKiBJdCBpcyBkb2N1bWVudGVkIHRoYXQgYGFuaW1hdGlvbi5zdGFydCgpYCB3aWxsIHJldHVybiBhIHByb21pc2Ugb2JqZWN0IGFuZCB0aGlzIGlzIHRydWUsIGhvd2V2ZXIsIHRoZXJlIGlzIGFsc28gYW4gYWRkaXRpb25hbCBtZXRob2QgYXZhaWxhYmxlIG9uIHRoZVxuICogcnVubmVyIGNhbGxlZCBgLmRvbmUoY2FsbGJhY2tGbilgLiBUaGUgZG9uZSBtZXRob2Qgd29ya3MgdGhlIHNhbWUgYXMgYC5maW5hbGx5KGNhbGxiYWNrRm4pYCwgaG93ZXZlciwgaXQgZG9lcyAqKm5vdCB0cmlnZ2VyIGEgZGlnZXN0IHRvIG9jY3VyKiouXG4gKiBUaGVyZWZvcmUsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBpdCdzIGFsd2F5cyBiZXN0IHRvIHVzZSBgcnVubmVyLmRvbmUoY2FsbGJhY2spYCBpbnN0ZWFkIG9mIGBydW5uZXIudGhlbigpYCwgYHJ1bm5lci5jYXRjaCgpYCBvciBgcnVubmVyLmZpbmFsbHkoKWBcbiAqIHVubGVzcyB5b3UgcmVhbGx5IG5lZWQgYSBkaWdlc3QgdG8ga2ljayBvZmYgYWZ0ZXJ3YXJkcy5cbiAqXG4gKiBLZWVwIGluIG1pbmQgdGhhdCwgdG8gbWFrZSB0aGlzIGVhc2llciwgbmdBbmltYXRlIGhhcyB0d2Vha2VkIHRoZSBKUyBhbmltYXRpb25zIEFQSSB0byByZWNvZ25pemUgd2hlbiBhIHJ1bm5lciBpbnN0YW5jZSBpcyByZXR1cm5lZCBmcm9tICRhbmltYXRlQ3NzXG4gKiAoc28gdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGBydW5uZXIuZG9uZShkb25lRm4pYCBpbnNpZGUgb2YgeW91ciBKYXZhU2NyaXB0IGFuaW1hdGlvbiBjb2RlKS5cbiAqIENoZWNrIHRoZSB7QGxpbmsgbmdBbmltYXRlLiRhbmltYXRlQ3NzI3VzYWdlIGFuaW1hdGlvbiBjb2RlIGFib3ZlfSB0byBzZWUgaG93IHRoaXMgd29ya3MuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSBhbmltYXRlZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgdGhlIGFuaW1hdGlvbi1yZWxhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgZHVyaW5nIHRoZSBhbmltYXRpb25cbiAqXG4gKiAqIGBldmVudGAgLSBUaGUgRE9NIGV2ZW50IChlLmcuIGVudGVyLCBsZWF2ZSwgbW92ZSkuIFdoZW4gdXNlZCwgYSBnZW5lcmF0ZWQgQ1NTIGNsYXNzIG9mIGBuZy1FVkVOVGAgYW5kIGBuZy1FVkVOVC1hY3RpdmVgIHdpbGwgYmUgYXBwbGllZFxuICogdG8gdGhlIGVsZW1lbnQgZHVyaW5nIHRoZSBhbmltYXRpb24uIE11bHRpcGxlIGV2ZW50cyBjYW4gYmUgcHJvdmlkZWQgd2hlbiBzcGFjZXMgYXJlIHVzZWQgYXMgYSBzZXBhcmF0b3IuIChOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBwZXJmb3JtIGFueSBET00gb3BlcmF0aW9uLilcbiAqICogYGVhc2luZ2AgLSBUaGUgQ1NTIGVhc2luZyB2YWx1ZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgdHJhbnNpdGlvbiBvciBrZXlmcmFtZSBhbmltYXRpb24gKG9yIGJvdGgpLlxuICogKiBgdHJhbnNpdGlvblN0eWxlYCAtIFRoZSByYXcgQ1NTIHRyYW5zaXRpb24gc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgKGUuZy4gYDFzIGxpbmVhciBhbGxgKS5cbiAqICogYGtleWZyYW1lU3R5bGVgIC0gVGhlIHJhdyBDU1Mga2V5ZnJhbWUgYW5pbWF0aW9uIHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIChlLmcuIGAxcyBteV9hbmltYXRpb24gbGluZWFyYCkuXG4gKiAqIGBmcm9tYCAtIFRoZSBzdGFydGluZyBDU1Mgc3R5bGVzIChhIGtleS92YWx1ZSBvYmplY3QpIHRoYXQgd2lsbCBiZSBhcHBsaWVkIGF0IHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uLlxuICogKiBgdG9gIC0gVGhlIGVuZGluZyBDU1Mgc3R5bGVzIChhIGtleS92YWx1ZSBvYmplY3QpIHRoYXQgd2lsbCBiZSBhcHBsaWVkIGFjcm9zcyB0aGUgYW5pbWF0aW9uIHZpYSBhIENTUyB0cmFuc2l0aW9uLlxuICogKiBgYWRkQ2xhc3NgIC0gQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBDU1MgY2xhc3NlcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVsZW1lbnQgYW5kIHNwcmVhZCBhY3Jvc3MgdGhlIGFuaW1hdGlvbi5cbiAqICogYHJlbW92ZUNsYXNzYCAtIEEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgQ1NTIGNsYXNzZXMgdGhhdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudCBhbmQgc3ByZWFkIGFjcm9zcyB0aGUgYW5pbWF0aW9uLlxuICogKiBgZHVyYXRpb25gIC0gQSBudW1iZXIgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0b3RhbCBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiBhbmQvb3Iga2V5ZnJhbWUgKG5vdGUgdGhhdCBhIHZhbHVlIG9mIDEgaXMgMTAwMG1zKS4gSWYgYSB2YWx1ZSBvZiBgMGBcbiAqIGlzIHByb3ZpZGVkIHRoZW4gdGhlIGFuaW1hdGlvbiB3aWxsIGJlIHNraXBwZWQgZW50aXJlbHkuXG4gKiAqIGBkZWxheWAgLSBBIG51bWJlciB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHRvdGFsIGRlbGF5IG9mIHRoZSB0cmFuc2l0aW9uIGFuZC9vciBrZXlmcmFtZSAobm90ZSB0aGF0IGEgdmFsdWUgb2YgMSBpcyAxMDAwbXMpLiBJZiBhIHZhbHVlIG9mIGB0cnVlYCBpc1xuICogdXNlZCB0aGVuIHdoYXRldmVyIGRlbGF5IHZhbHVlIGlzIGRldGVjdGVkIGZyb20gdGhlIENTUyBjbGFzc2VzIHdpbGwgYmUgbWlycm9yZWQgb24gdGhlIGVsZW1lbnRzIHN0eWxlcyAoZS5nLiBieSBzZXR0aW5nIGRlbGF5IHRydWUgdGhlbiB0aGUgc3R5bGUgdmFsdWVcbiAqIG9mIHRoZSBlbGVtZW50IHdpbGwgYmUgYHRyYW5zaXRpb24tZGVsYXk6IERFVEVDVEVEX1ZBTFVFYCkuIFVzaW5nIGB0cnVlYCBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0aGUgQ1NTIGNsYXNzZXMgYW5kIGlubGluZSBzdHlsZXMgdG8gYWxsIHNoYXJlIHRoZSBzYW1lXG4gKiBDU1MgZGVsYXkgdmFsdWUuXG4gKiAqIGBzdGFnZ2VyYCAtIEEgbnVtZXJpYyB0aW1lIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgZGVsYXkgYmV0d2VlbiBzdWNjZXNzaXZlbHkgYW5pbWF0ZWQgZWxlbWVudHNcbiAqICh7QGxpbmsgbmdBbmltYXRlI2Nzcy1zdGFnZ2VyaW5nLWFuaW1hdGlvbnMgQ2xpY2sgaGVyZSB0byBsZWFybiBob3cgQ1NTLWJhc2VkIHN0YWdnZXJpbmcgd29ya3MgaW4gbmdBbmltYXRlLn0pXG4gKiAqIGBzdGFnZ2VySW5kZXhgIC0gVGhlIG51bWVyaWMgaW5kZXggcmVwcmVzZW50aW5nIHRoZSBzdGFnZ2VyIGl0ZW0gKGUuZy4gYSB2YWx1ZSBvZiA1IGlzIGVxdWFsIHRvIHRoZSBzaXh0aCBpdGVtIGluIHRoZSBzdGFnZ2VyOyB0aGVyZWZvcmUgd2hlbiBhXG4gKiAqIGBzdGFnZ2VyYCBvcHRpb24gdmFsdWUgb2YgYDAuMWAgaXMgdXNlZCB0aGVuIHRoZXJlIHdpbGwgYmUgYSBzdGFnZ2VyIGRlbGF5IG9mIGA2MDBtc2ApXG4gKiAqIGBhcHBseUNsYXNzZXNFYXJseWAgLSBXaGV0aGVyIG9yIG5vdCB0aGUgY2xhc3NlcyBiZWluZyBhZGRlZCBvciByZW1vdmVkIHdpbGwgYmUgdXNlZCB3aGVuIGRldGVjdGluZyB0aGUgYW5pbWF0aW9uLiBUaGlzIGlzIHNldCBieSBgJGFuaW1hdGVgIHdoZW4gZW50ZXIvbGVhdmUvbW92ZSBhbmltYXRpb25zIGFyZSBmaXJlZCB0byBlbnN1cmUgdGhhdCB0aGUgQ1NTIGNsYXNzZXMgYXJlIHJlc29sdmVkIGluIHRpbWUuIChOb3RlIHRoYXQgdGhpcyB3aWxsIHByZXZlbnQgYW55IHRyYW5zaXRpb25zIGZyb20gb2NjdXJpbmcgb24gdGhlIGNsYXNzZXMgYmVpbmcgYWRkZWQgYW5kIHJlbW92ZWQuKVxuICogKiBgY2xlYW51cFN0eWxlc2AgLSBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgYGZyb21gIGFuZCBgdG9gIHN0eWxlcyB3aWxsIGJlIHJlbW92ZWQgb25jZVxuICogICAgdGhlIGFuaW1hdGlvbiBpcyBjbG9zZWQuIFRoaXMgaXMgdXNlZnVsIGZvciB3aGVuIHRoZSBzdHlsZXMgYXJlIHVzZWQgcHVyZWx5IGZvciB0aGUgc2FrZSBvZlxuICogICAgdGhlIGFuaW1hdGlvbiBhbmQgZG8gbm90IGhhdmUgYSBsYXN0aW5nIHZpc3VhbCBlZmZlY3Qgb24gdGhlIGVsZW1lbnQgKGUuZy4gYSBjb2xhcHNlIGFuZCBvcGVuIGFuaW1hdGlvbikuXG4gKiAgICBCeSBkZWZhdWx0IHRoaXMgdmFsdWUgaXMgc2V0IHRvIGBmYWxzZWAuXG4gKlxuICogQHJldHVybiB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBzdGFydCBhbmQgZW5kIG1ldGhvZHMgYW5kIGRldGFpbHMgYWJvdXQgdGhlIGFuaW1hdGlvbi5cbiAqXG4gKiAqIGBzdGFydGAgLSBUaGUgbWV0aG9kIHRvIHN0YXJ0IHRoZSBhbmltYXRpb24uIFRoaXMgd2lsbCByZXR1cm4gYSBgUHJvbWlzZWAgd2hlbiBjYWxsZWQuXG4gKiAqIGBlbmRgIC0gVGhpcyBtZXRob2Qgd2lsbCBjYW5jZWwgdGhlIGFuaW1hdGlvbiBhbmQgcmVtb3ZlIGFsbCBhcHBsaWVkIENTUyBjbGFzc2VzIGFuZCBzdHlsZXMuXG4gKi9cbnZhciBPTkVfU0VDT05EID0gMTAwMDtcbnZhciBCQVNFX1RFTiA9IDEwO1xuXG52YXIgRUxBUFNFRF9USU1FX01BWF9ERUNJTUFMX1BMQUNFUyA9IDM7XG52YXIgQ0xPU0lOR19USU1FX0JVRkZFUiA9IDEuNTtcblxudmFyIERFVEVDVF9DU1NfUFJPUEVSVElFUyA9IHtcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiAgICAgIFRSQU5TSVRJT05fRFVSQVRJT05fUFJPUCxcbiAgdHJhbnNpdGlvbkRlbGF5OiAgICAgICAgIFRSQU5TSVRJT05fREVMQVlfUFJPUCxcbiAgdHJhbnNpdGlvblByb3BlcnR5OiAgICAgIFRSQU5TSVRJT05fUFJPUCArIFBST1BFUlRZX0tFWSxcbiAgYW5pbWF0aW9uRHVyYXRpb246ICAgICAgIEFOSU1BVElPTl9EVVJBVElPTl9QUk9QLFxuICBhbmltYXRpb25EZWxheTogICAgICAgICAgQU5JTUFUSU9OX0RFTEFZX1BST1AsXG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiBBTklNQVRJT05fUFJPUCArIEFOSU1BVElPTl9JVEVSQVRJT05fQ09VTlRfS0VZXG59O1xuXG52YXIgREVURUNUX1NUQUdHRVJfQ1NTX1BST1BFUlRJRVMgPSB7XG4gIHRyYW5zaXRpb25EdXJhdGlvbjogICAgICBUUkFOU0lUSU9OX0RVUkFUSU9OX1BST1AsXG4gIHRyYW5zaXRpb25EZWxheTogICAgICAgICBUUkFOU0lUSU9OX0RFTEFZX1BST1AsXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAgICAgICBBTklNQVRJT05fRFVSQVRJT05fUFJPUCxcbiAgYW5pbWF0aW9uRGVsYXk6ICAgICAgICAgIEFOSU1BVElPTl9ERUxBWV9QUk9QXG59O1xuXG5mdW5jdGlvbiBnZXRDc3NLZXlmcmFtZUR1cmF0aW9uU3R5bGUoZHVyYXRpb24pIHtcbiAgcmV0dXJuIFtBTklNQVRJT05fRFVSQVRJT05fUFJPUCwgZHVyYXRpb24gKyAncyddO1xufVxuXG5mdW5jdGlvbiBnZXRDc3NEZWxheVN0eWxlKGRlbGF5LCBpc0tleWZyYW1lQW5pbWF0aW9uKSB7XG4gIHZhciBwcm9wID0gaXNLZXlmcmFtZUFuaW1hdGlvbiA/IEFOSU1BVElPTl9ERUxBWV9QUk9QIDogVFJBTlNJVElPTl9ERUxBWV9QUk9QO1xuICByZXR1cm4gW3Byb3AsIGRlbGF5ICsgJ3MnXTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNzc1N0eWxlcygkd2luZG93LCBlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBzdHlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgZGV0ZWN0ZWRTdHlsZXMgPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkgfHwge307XG4gIGZvckVhY2gocHJvcGVydGllcywgZnVuY3Rpb24oZm9ybWFsU3R5bGVOYW1lLCBhY3R1YWxTdHlsZU5hbWUpIHtcbiAgICB2YXIgdmFsID0gZGV0ZWN0ZWRTdHlsZXNbZm9ybWFsU3R5bGVOYW1lXTtcbiAgICBpZiAodmFsKSB7XG4gICAgICB2YXIgYyA9IHZhbC5jaGFyQXQoMCk7XG5cbiAgICAgIC8vIG9ubHkgbnVtZXJpY2FsLWJhc2VkIHZhbHVlcyBoYXZlIGEgbmVnYXRpdmUgc2lnbiBvciBkaWdpdCBhcyB0aGUgZmlyc3QgdmFsdWVcbiAgICAgIGlmIChjID09PSAnLScgfHwgYyA9PT0gJysnIHx8IGMgPj0gMCkge1xuICAgICAgICB2YWwgPSBwYXJzZU1heFRpbWUodmFsKTtcbiAgICAgIH1cblxuICAgICAgLy8gYnkgc2V0dGluZyB0aGlzIHRvIG51bGwgaW4gdGhlIGV2ZW50IHRoYXQgdGhlIGRlbGF5IGlzIG5vdCBzZXQgb3IgaXMgc2V0IGRpcmVjdGx5IGFzIDBcbiAgICAgIC8vIHRoZW4gd2UgY2FuIHN0aWxsIGFsbG93IGZvciB6ZWdhdGl2ZSB2YWx1ZXMgdG8gYmUgdXNlZCBsYXRlciBvbiBhbmQgbm90IG1pc3Rha2UgdGhpc1xuICAgICAgLy8gdmFsdWUgZm9yIGJlaW5nIGdyZWF0ZXIgdGhhbiBhbnkgb3RoZXIgbmVnYXRpdmUgdmFsdWUuXG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdHlsZXNbYWN0dWFsU3R5bGVOYW1lXSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWF4VGltZShzdHIpIHtcbiAgdmFyIG1heFZhbHVlID0gMDtcbiAgdmFyIHZhbHVlcyA9IHN0ci5zcGxpdCgvXFxzKixcXHMqLyk7XG4gIGZvckVhY2godmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIGl0J3MgYWx3YXlzIHNhZmUgdG8gY29uc2lkZXIgb25seSBzZWNvbmQgdmFsdWVzIGFuZCBvbWl0IGBtc2AgdmFsdWVzIHNpbmNlXG4gICAgLy8gZ2V0Q29tcHV0ZWRTdHlsZSB3aWxsIGFsd2F5cyBoYW5kbGUgdGhlIGNvbnZlcnNpb24gZm9yIHVzXG4gICAgaWYgKHZhbHVlLmNoYXJBdCh2YWx1ZS5sZW5ndGggLSAxKSA9PSAncycpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XG4gICAgbWF4VmFsdWUgPSBtYXhWYWx1ZSA/IE1hdGgubWF4KHZhbHVlLCBtYXhWYWx1ZSkgOiB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBtYXhWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1dGh5VGltaW5nVmFsdWUodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IDAgfHwgdmFsICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldENzc1RyYW5zaXRpb25EdXJhdGlvblN0eWxlKGR1cmF0aW9uLCBhcHBseU9ubHlEdXJhdGlvbikge1xuICB2YXIgc3R5bGUgPSBUUkFOU0lUSU9OX1BST1A7XG4gIHZhciB2YWx1ZSA9IGR1cmF0aW9uICsgJ3MnO1xuICBpZiAoYXBwbHlPbmx5RHVyYXRpb24pIHtcbiAgICBzdHlsZSArPSBEVVJBVElPTl9LRVk7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgKz0gJyBsaW5lYXIgYWxsJztcbiAgfVxuICByZXR1cm4gW3N0eWxlLCB2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsQ2FjaGVMb29rdXAoKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiB7XG4gICAgZmx1c2g6IGZ1bmN0aW9uKCkge1xuICAgICAgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH0sXG5cbiAgICBjb3VudDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgZW50cnkgPSBjYWNoZVtrZXldO1xuICAgICAgcmV0dXJuIGVudHJ5ID8gZW50cnkudG90YWwgOiAwO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGVudHJ5ID0gY2FjaGVba2V5XTtcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52YWx1ZTtcbiAgICB9LFxuXG4gICAgcHV0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoIWNhY2hlW2tleV0pIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHsgdG90YWw6IDEsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XS50b3RhbCsrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gd2UgZG8gbm90IHJlYXNzaWduIGFuIGFscmVhZHkgcHJlc2VudCBzdHlsZSB2YWx1ZSBzaW5jZVxuLy8gaWYgd2UgZGV0ZWN0IHRoZSBzdHlsZSBwcm9wZXJ0eSB2YWx1ZSBhZ2FpbiB3ZSBtYXkgYmVcbi8vIGRldGVjdGluZyBzdHlsZXMgdGhhdCB3ZXJlIGFkZGVkIHZpYSB0aGUgYGZyb21gIHN0eWxlcy5cbi8vIFdlIG1ha2UgdXNlIG9mIGBpc0RlZmluZWRgIGhlcmUgc2luY2UgYW4gZW1wdHkgc3RyaW5nXG4vLyBvciBudWxsIHZhbHVlICh3aGljaCBpcyB3aGF0IGdldFByb3BlcnR5VmFsdWUgd2lsbCByZXR1cm5cbi8vIGZvciBhIG5vbi1leGlzdGluZyBzdHlsZSkgd2lsbCBzdGlsbCBiZSBtYXJrZWQgYXMgYSB2YWxpZFxuLy8gdmFsdWUgZm9yIHRoZSBzdHlsZSAoYSBmYWxzeSB2YWx1ZSBpbXBsaWVzIHRoYXQgdGhlIHN0eWxlXG4vLyBpcyB0byBiZSByZW1vdmVkIGF0IHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvbikuIElmIHdlIGhhZCBhIHNpbXBsZVxuLy8gXCJPUlwiIHN0YXRlbWVudCB0aGVuIGl0IHdvdWxkIG5vdCBiZSBlbm91Z2ggdG8gY2F0Y2ggdGhhdC5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVzdG9yYWJsZVN0eWxlcyhiYWNrdXAsIG5vZGUsIHByb3BlcnRpZXMpIHtcbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgYmFja3VwW3Byb3BdID0gaXNEZWZpbmVkKGJhY2t1cFtwcm9wXSlcbiAgICAgICAgPyBiYWNrdXBbcHJvcF1cbiAgICAgICAgOiBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG4gIH0pO1xufVxuXG52YXIgJEFuaW1hdGVDc3NQcm92aWRlciA9IFsnJGFuaW1hdGVQcm92aWRlcicsIGZ1bmN0aW9uKCRhbmltYXRlUHJvdmlkZXIpIHtcbiAgdmFyIGdjc0xvb2t1cCA9IGNyZWF0ZUxvY2FsQ2FjaGVMb29rdXAoKTtcbiAgdmFyIGdjc1N0YWdnZXJMb29rdXAgPSBjcmVhdGVMb2NhbENhY2hlTG9va3VwKCk7XG5cbiAgdGhpcy4kZ2V0ID0gWyckd2luZG93JywgJyQkanFMaXRlJywgJyQkQW5pbWF0ZVJ1bm5lcicsICckdGltZW91dCcsXG4gICAgICAgICAgICAgICAnJCRmb3JjZVJlZmxvdycsICckc25pZmZlcicsICckJHJBRlNjaGVkdWxlcicsICckYW5pbWF0ZScsXG4gICAgICAgZnVuY3Rpb24oJHdpbmRvdywgICAkJGpxTGl0ZSwgICAkJEFuaW1hdGVSdW5uZXIsICAgJHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgJCRmb3JjZVJlZmxvdywgICAkc25pZmZlciwgICAkJHJBRlNjaGVkdWxlciwgJGFuaW1hdGUpIHtcblxuICAgIHZhciBhcHBseUFuaW1hdGlvbkNsYXNzZXMgPSBhcHBseUFuaW1hdGlvbkNsYXNzZXNGYWN0b3J5KCQkanFMaXRlKTtcblxuICAgIHZhciBwYXJlbnRDb3VudGVyID0gMDtcbiAgICBmdW5jdGlvbiBnY3NIYXNoRm4obm9kZSwgZXh0cmFDbGFzc2VzKSB7XG4gICAgICB2YXIgS0VZID0gXCIkJG5nQW5pbWF0ZVBhcmVudEtleVwiO1xuICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGFyZW50SUQgPSBwYXJlbnROb2RlW0tFWV0gfHwgKHBhcmVudE5vZGVbS0VZXSA9ICsrcGFyZW50Q291bnRlcik7XG4gICAgICByZXR1cm4gcGFyZW50SUQgKyAnLScgKyBub2RlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSArICctJyArIGV4dHJhQ2xhc3NlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlQ2FjaGVkQ3NzU3R5bGVzKG5vZGUsIGNsYXNzTmFtZSwgY2FjaGVLZXksIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciB0aW1pbmdzID0gZ2NzTG9va3VwLmdldChjYWNoZUtleSk7XG5cbiAgICAgIGlmICghdGltaW5ncykge1xuICAgICAgICB0aW1pbmdzID0gY29tcHV0ZUNzc1N0eWxlcygkd2luZG93LCBub2RlLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgaWYgKHRpbWluZ3MuYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgPT09ICdpbmZpbml0ZScpIHtcbiAgICAgICAgICB0aW1pbmdzLmFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB3ZSBrZWVwIHB1dHRpbmcgdGhpcyBpbiBtdWx0aXBsZSB0aW1lcyBldmVuIHRob3VnaCB0aGUgdmFsdWUgYW5kIHRoZSBjYWNoZUtleSBhcmUgdGhlIHNhbWVcbiAgICAgIC8vIGJlY2F1c2Ugd2UncmUga2VlcGluZyBhbiBpbnRlcmFsIHRhbGx5IG9mIGhvdyBtYW55IGR1cGxpY2F0ZSBhbmltYXRpb25zIGFyZSBkZXRlY3RlZC5cbiAgICAgIGdjc0xvb2t1cC5wdXQoY2FjaGVLZXksIHRpbWluZ3MpO1xuICAgICAgcmV0dXJuIHRpbWluZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUNhY2hlZENzc1N0YWdnZXJTdHlsZXMobm9kZSwgY2xhc3NOYW1lLCBjYWNoZUtleSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHN0YWdnZXI7XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgb25lIG9yIG1vcmUgZXhpc3RpbmcgbWF0Y2hlcyBvZiBtYXRjaGluZyBlbGVtZW50c1xuICAgICAgLy8gY29udGFpbmluZyB0aGUgc2FtZSBwYXJlbnQgKyBDU1Mgc3R5bGVzICh3aGljaCBpcyBob3cgY2FjaGVLZXkgd29ya3MpXG4gICAgICAvLyB0aGVuIHN0YWdnZXJpbmcgaXMgcG9zc2libGVcbiAgICAgIGlmIChnY3NMb29rdXAuY291bnQoY2FjaGVLZXkpID4gMCkge1xuICAgICAgICBzdGFnZ2VyID0gZ2NzU3RhZ2dlckxvb2t1cC5nZXQoY2FjaGVLZXkpO1xuXG4gICAgICAgIGlmICghc3RhZ2dlcikge1xuICAgICAgICAgIHZhciBzdGFnZ2VyQ2xhc3NOYW1lID0gcGVuZENsYXNzZXMoY2xhc3NOYW1lLCAnLXN0YWdnZXInKTtcblxuICAgICAgICAgICQkanFMaXRlLmFkZENsYXNzKG5vZGUsIHN0YWdnZXJDbGFzc05hbWUpO1xuXG4gICAgICAgICAgc3RhZ2dlciA9IGNvbXB1dGVDc3NTdHlsZXMoJHdpbmRvdywgbm9kZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgICAvLyBmb3JjZSB0aGUgY29udmVyc2lvbiBvZiBhIG51bGwgdmFsdWUgdG8gemVybyBpbmNhc2Ugbm90IHNldFxuICAgICAgICAgIHN0YWdnZXIuYW5pbWF0aW9uRHVyYXRpb24gPSBNYXRoLm1heChzdGFnZ2VyLmFuaW1hdGlvbkR1cmF0aW9uLCAwKTtcbiAgICAgICAgICBzdGFnZ2VyLnRyYW5zaXRpb25EdXJhdGlvbiA9IE1hdGgubWF4KHN0YWdnZXIudHJhbnNpdGlvbkR1cmF0aW9uLCAwKTtcblxuICAgICAgICAgICQkanFMaXRlLnJlbW92ZUNsYXNzKG5vZGUsIHN0YWdnZXJDbGFzc05hbWUpO1xuXG4gICAgICAgICAgZ2NzU3RhZ2dlckxvb2t1cC5wdXQoY2FjaGVLZXksIHN0YWdnZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFnZ2VyIHx8IHt9O1xuICAgIH1cblxuICAgIHZhciBjYW5jZWxMYXN0UkFGUmVxdWVzdDtcbiAgICB2YXIgcmFmV2FpdFF1ZXVlID0gW107XG4gICAgZnVuY3Rpb24gd2FpdFVudGlsUXVpZXQoY2FsbGJhY2spIHtcbiAgICAgIHJhZldhaXRRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICQkckFGU2NoZWR1bGVyLndhaXRVbnRpbFF1aWV0KGZ1bmN0aW9uKCkge1xuICAgICAgICBnY3NMb29rdXAuZmx1c2goKTtcbiAgICAgICAgZ2NzU3RhZ2dlckxvb2t1cC5mbHVzaCgpO1xuXG4gICAgICAgIC8vIERPIE5PVCBSRU1PVkUgVEhJUyBMSU5FIE9SIFJFRkFDVE9SIE9VVCBUSEUgYHBhZ2VXaWR0aGAgdmFyaWFibGUuXG4gICAgICAgIC8vIFBMRUFTRSBFWEFNSU5FIFRIRSBgJCRmb3JjZVJlZmxvd2Agc2VydmljZSB0byB1bmRlcnN0YW5kIHdoeS5cbiAgICAgICAgdmFyIHBhZ2VXaWR0aCA9ICQkZm9yY2VSZWZsb3coKTtcblxuICAgICAgICAvLyB3ZSB1c2UgYSBmb3IgbG9vcCB0byBlbnN1cmUgdGhhdCBpZiB0aGUgcXVldWUgaXMgY2hhbmdlZFxuICAgICAgICAvLyBkdXJpbmcgdGhpcyBsb29waW5nIHRoZW4gaXQgd2lsbCBjb25zaWRlciBuZXcgcmVxdWVzdHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYWZXYWl0UXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByYWZXYWl0UXVldWVbaV0ocGFnZVdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICByYWZXYWl0UXVldWUubGVuZ3RoID0gMDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVUaW1pbmdzKG5vZGUsIGNsYXNzTmFtZSwgY2FjaGVLZXkpIHtcbiAgICAgIHZhciB0aW1pbmdzID0gY29tcHV0ZUNhY2hlZENzc1N0eWxlcyhub2RlLCBjbGFzc05hbWUsIGNhY2hlS2V5LCBERVRFQ1RfQ1NTX1BST1BFUlRJRVMpO1xuICAgICAgdmFyIGFEID0gdGltaW5ncy5hbmltYXRpb25EZWxheTtcbiAgICAgIHZhciB0RCA9IHRpbWluZ3MudHJhbnNpdGlvbkRlbGF5O1xuICAgICAgdGltaW5ncy5tYXhEZWxheSA9IGFEICYmIHREXG4gICAgICAgICAgPyBNYXRoLm1heChhRCwgdEQpXG4gICAgICAgICAgOiAoYUQgfHwgdEQpO1xuICAgICAgdGltaW5ncy5tYXhEdXJhdGlvbiA9IE1hdGgubWF4KFxuICAgICAgICAgIHRpbWluZ3MuYW5pbWF0aW9uRHVyYXRpb24gKiB0aW1pbmdzLmFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50LFxuICAgICAgICAgIHRpbWluZ3MudHJhbnNpdGlvbkR1cmF0aW9uKTtcblxuICAgICAgcmV0dXJuIHRpbWluZ3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGluaXQoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlc3RvcmVTdHlsZXMgPSB7fTtcbiAgICAgIHZhciBub2RlID0gZ2V0RG9tTm9kZShlbGVtZW50KTtcbiAgICAgIGlmICghbm9kZVxuICAgICAgICAgIHx8ICFub2RlLnBhcmVudE5vZGVcbiAgICAgICAgICB8fCAhJGFuaW1hdGUuZW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiBjbG9zZUFuZFJldHVybk5vb3BBbmltYXRvcigpO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgIHZhciB0ZW1wb3JhcnlTdHlsZXMgPSBbXTtcbiAgICAgIHZhciBjbGFzc2VzID0gZWxlbWVudC5hdHRyKCdjbGFzcycpO1xuICAgICAgdmFyIHN0eWxlcyA9IHBhY2thZ2VTdHlsZXMob3B0aW9ucyk7XG4gICAgICB2YXIgYW5pbWF0aW9uQ2xvc2VkO1xuICAgICAgdmFyIGFuaW1hdGlvblBhdXNlZDtcbiAgICAgIHZhciBhbmltYXRpb25Db21wbGV0ZWQ7XG4gICAgICB2YXIgcnVubmVyO1xuICAgICAgdmFyIHJ1bm5lckhvc3Q7XG4gICAgICB2YXIgbWF4RGVsYXk7XG4gICAgICB2YXIgbWF4RGVsYXlUaW1lO1xuICAgICAgdmFyIG1heER1cmF0aW9uO1xuICAgICAgdmFyIG1heER1cmF0aW9uVGltZTtcblxuICAgICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gPT09IDAgfHwgKCEkc25pZmZlci5hbmltYXRpb25zICYmICEkc25pZmZlci50cmFuc2l0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlQW5kUmV0dXJuTm9vcEFuaW1hdG9yKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZXRob2QgPSBvcHRpb25zLmV2ZW50ICYmIGlzQXJyYXkob3B0aW9ucy5ldmVudClcbiAgICAgICAgICAgID8gb3B0aW9ucy5ldmVudC5qb2luKCcgJylcbiAgICAgICAgICAgIDogb3B0aW9ucy5ldmVudDtcblxuICAgICAgdmFyIGlzU3RydWN0dXJhbCA9IG1ldGhvZCAmJiBvcHRpb25zLnN0cnVjdHVyYWw7XG4gICAgICB2YXIgc3RydWN0dXJhbENsYXNzTmFtZSA9ICcnO1xuICAgICAgdmFyIGFkZFJlbW92ZUNsYXNzTmFtZSA9ICcnO1xuXG4gICAgICBpZiAoaXNTdHJ1Y3R1cmFsKSB7XG4gICAgICAgIHN0cnVjdHVyYWxDbGFzc05hbWUgPSBwZW5kQ2xhc3NlcyhtZXRob2QsIEVWRU5UX0NMQVNTX1BSRUZJWCwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xuICAgICAgICBzdHJ1Y3R1cmFsQ2xhc3NOYW1lID0gbWV0aG9kO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hZGRDbGFzcykge1xuICAgICAgICBhZGRSZW1vdmVDbGFzc05hbWUgKz0gcGVuZENsYXNzZXMob3B0aW9ucy5hZGRDbGFzcywgQUREX0NMQVNTX1NVRkZJWCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJlbW92ZUNsYXNzKSB7XG4gICAgICAgIGlmIChhZGRSZW1vdmVDbGFzc05hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgYWRkUmVtb3ZlQ2xhc3NOYW1lICs9ICcgJztcbiAgICAgICAgfVxuICAgICAgICBhZGRSZW1vdmVDbGFzc05hbWUgKz0gcGVuZENsYXNzZXMob3B0aW9ucy5yZW1vdmVDbGFzcywgUkVNT1ZFX0NMQVNTX1NVRkZJWCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZXJlIG1heSBiZSBhIHNpdHVhdGlvbiB3aGVyZSBhIHN0cnVjdHVyYWwgYW5pbWF0aW9uIGlzIGNvbWJpbmVkIHRvZ2V0aGVyXG4gICAgICAvLyB3aXRoIENTUyBjbGFzc2VzIHRoYXQgbmVlZCB0byByZXNvbHZlIGJlZm9yZSB0aGUgYW5pbWF0aW9uIGlzIGNvbXB1dGVkLlxuICAgICAgLy8gSG93ZXZlciB0aGlzIG1lYW5zIHRoYXQgdGhlcmUgaXMgbm8gZXhwbGljaXQgQ1NTIGNvZGUgdG8gYmxvY2sgdGhlIGFuaW1hdGlvblxuICAgICAgLy8gZnJvbSBoYXBwZW5pbmcgKGJ5IHNldHRpbmcgMHMgbm9uZSBpbiB0aGUgY2xhc3MgbmFtZSkuIElmIHRoaXMgaXMgdGhlIGNhc2VcbiAgICAgIC8vIHdlIG5lZWQgdG8gYXBwbHkgdGhlIGNsYXNzZXMgYmVmb3JlIHRoZSBmaXJzdCByQUYgc28gd2Uga25vdyB0byBjb250aW51ZSBpZlxuICAgICAgLy8gdGhlcmUgYWN0dWFsbHkgaXMgYSBkZXRlY3RlZCB0cmFuc2l0aW9uIG9yIGtleWZyYW1lIGFuaW1hdGlvblxuICAgICAgaWYgKG9wdGlvbnMuYXBwbHlDbGFzc2VzRWFybHkgJiYgYWRkUmVtb3ZlQ2xhc3NOYW1lLmxlbmd0aCkge1xuICAgICAgICBhcHBseUFuaW1hdGlvbkNsYXNzZXMoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmVwYXJhdGlvbkNsYXNzZXMgPSBbc3RydWN0dXJhbENsYXNzTmFtZSwgYWRkUmVtb3ZlQ2xhc3NOYW1lXS5qb2luKCcgJykudHJpbSgpO1xuICAgICAgdmFyIGZ1bGxDbGFzc05hbWUgPSBjbGFzc2VzICsgJyAnICsgcHJlcGFyYXRpb25DbGFzc2VzO1xuICAgICAgdmFyIGFjdGl2ZUNsYXNzZXMgPSBwZW5kQ2xhc3NlcyhwcmVwYXJhdGlvbkNsYXNzZXMsIEFDVElWRV9DTEFTU19TVUZGSVgpO1xuICAgICAgdmFyIGhhc1RvU3R5bGVzID0gc3R5bGVzLnRvICYmIE9iamVjdC5rZXlzKHN0eWxlcy50bykubGVuZ3RoID4gMDtcbiAgICAgIHZhciBjb250YWluc0tleWZyYW1lQW5pbWF0aW9uID0gKG9wdGlvbnMua2V5ZnJhbWVTdHlsZSB8fCAnJykubGVuZ3RoID4gMDtcblxuICAgICAgLy8gdGhlcmUgaXMgbm8gd2F5IHdlIGNhbiB0cmlnZ2VyIGFuIGFuaW1hdGlvbiBpZiBubyBzdHlsZXMgYW5kXG4gICAgICAvLyBubyBjbGFzc2VzIGFyZSBiZWluZyBhcHBsaWVkIHdoaWNoIHdvdWxkIHRoZW4gdHJpZ2dlciBhIHRyYW5zaXRpb24sXG4gICAgICAvLyB1bmxlc3MgdGhlcmUgYSBpcyByYXcga2V5ZnJhbWUgdmFsdWUgdGhhdCBpcyBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuICAgICAgaWYgKCFjb250YWluc0tleWZyYW1lQW5pbWF0aW9uXG4gICAgICAgICAgICYmICFoYXNUb1N0eWxlc1xuICAgICAgICAgICAmJiAhcHJlcGFyYXRpb25DbGFzc2VzKSB7XG4gICAgICAgIHJldHVybiBjbG9zZUFuZFJldHVybk5vb3BBbmltYXRvcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FjaGVLZXksIHN0YWdnZXI7XG4gICAgICBpZiAob3B0aW9ucy5zdGFnZ2VyID4gMCkge1xuICAgICAgICB2YXIgc3RhZ2dlclZhbCA9IHBhcnNlRmxvYXQob3B0aW9ucy5zdGFnZ2VyKTtcbiAgICAgICAgc3RhZ2dlciA9IHtcbiAgICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IHN0YWdnZXJWYWwsXG4gICAgICAgICAgYW5pbWF0aW9uRGVsYXk6IHN0YWdnZXJWYWwsXG4gICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAwLFxuICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZUtleSA9IGdjc0hhc2hGbihub2RlLCBmdWxsQ2xhc3NOYW1lKTtcbiAgICAgICAgc3RhZ2dlciA9IGNvbXB1dGVDYWNoZWRDc3NTdGFnZ2VyU3R5bGVzKG5vZGUsIHByZXBhcmF0aW9uQ2xhc3NlcywgY2FjaGVLZXksIERFVEVDVF9TVEFHR0VSX0NTU19QUk9QRVJUSUVTKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLiQkc2tpcFByZXBhcmF0aW9uQ2xhc3Nlcykge1xuICAgICAgICAkJGpxTGl0ZS5hZGRDbGFzcyhlbGVtZW50LCBwcmVwYXJhdGlvbkNsYXNzZXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXBwbHlPbmx5RHVyYXRpb247XG5cbiAgICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb25TdHlsZSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvblN0eWxlID0gW1RSQU5TSVRJT05fUFJPUCwgb3B0aW9ucy50cmFuc2l0aW9uU3R5bGVdO1xuICAgICAgICBhcHBseUlubGluZVN0eWxlKG5vZGUsIHRyYW5zaXRpb25TdHlsZSk7XG4gICAgICAgIHRlbXBvcmFyeVN0eWxlcy5wdXNoKHRyYW5zaXRpb25TdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmR1cmF0aW9uID49IDApIHtcbiAgICAgICAgYXBwbHlPbmx5RHVyYXRpb24gPSBub2RlLnN0eWxlW1RSQU5TSVRJT05fUFJPUF0ubGVuZ3RoID4gMDtcbiAgICAgICAgdmFyIGR1cmF0aW9uU3R5bGUgPSBnZXRDc3NUcmFuc2l0aW9uRHVyYXRpb25TdHlsZShvcHRpb25zLmR1cmF0aW9uLCBhcHBseU9ubHlEdXJhdGlvbik7XG5cbiAgICAgICAgLy8gd2Ugc2V0IHRoZSBkdXJhdGlvbiBzbyB0aGF0IGl0IHdpbGwgYmUgcGlja2VkIHVwIGJ5IGdldENvbXB1dGVkU3R5bGUgbGF0ZXJcbiAgICAgICAgYXBwbHlJbmxpbmVTdHlsZShub2RlLCBkdXJhdGlvblN0eWxlKTtcbiAgICAgICAgdGVtcG9yYXJ5U3R5bGVzLnB1c2goZHVyYXRpb25TdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmtleWZyYW1lU3R5bGUpIHtcbiAgICAgICAgdmFyIGtleWZyYW1lU3R5bGUgPSBbQU5JTUFUSU9OX1BST1AsIG9wdGlvbnMua2V5ZnJhbWVTdHlsZV07XG4gICAgICAgIGFwcGx5SW5saW5lU3R5bGUobm9kZSwga2V5ZnJhbWVTdHlsZSk7XG4gICAgICAgIHRlbXBvcmFyeVN0eWxlcy5wdXNoKGtleWZyYW1lU3R5bGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlbUluZGV4ID0gc3RhZ2dlclxuICAgICAgICAgID8gb3B0aW9ucy5zdGFnZ2VySW5kZXggPj0gMFxuICAgICAgICAgICAgICA/IG9wdGlvbnMuc3RhZ2dlckluZGV4XG4gICAgICAgICAgICAgIDogZ2NzTG9va3VwLmNvdW50KGNhY2hlS2V5KVxuICAgICAgICAgIDogMDtcblxuICAgICAgdmFyIGlzRmlyc3QgPSBpdGVtSW5kZXggPT09IDA7XG5cbiAgICAgIC8vIHRoaXMgaXMgYSBwcmUtZW1wdGl2ZSB3YXkgb2YgZm9yY2luZyB0aGUgc2V0dXAgY2xhc3NlcyB0byBiZSBhZGRlZCBhbmQgYXBwbGllZCBJTlNUQU5UTFlcbiAgICAgIC8vIHdpdGhvdXQgY2F1c2luZyBhbnkgY29tYmluYXRpb24gb2YgdHJhbnNpdGlvbnMgdG8ga2ljayBpbi4gQnkgYWRkaW5nIGEgbmVnYXRpdmUgZGVsYXkgdmFsdWVcbiAgICAgIC8vIGl0IGZvcmNlcyB0aGUgc2V0dXAgY2xhc3MnIHRyYW5zaXRpb24gdG8gZW5kIGltbWVkaWF0ZWx5LiBXZSBsYXRlciB0aGVuIHJlbW92ZSB0aGUgbmVnYXRpdmVcbiAgICAgIC8vIHRyYW5zaXRpb24gZGVsYXkgdG8gYWxsb3cgZm9yIHRoZSB0cmFuc2l0aW9uIHRvIG5hdHVyYWxseSBkbyBpdCdzIHRoaW5nLiBUaGUgYmVhdXR5IGhlcmUgaXNcbiAgICAgIC8vIHRoYXQgaWYgdGhlcmUgaXMgbm8gdHJhbnNpdGlvbiBkZWZpbmVkIHRoZW4gbm90aGluZyB3aWxsIGhhcHBlbiBhbmQgdGhpcyB3aWxsIGFsc28gYWxsb3dcbiAgICAgIC8vIG90aGVyIHRyYW5zaXRpb25zIHRvIGJlIHN0YWNrZWQgb24gdG9wIG9mIGVhY2ggb3RoZXIgd2l0aG91dCBhbnkgY2hvcHBpbmcgdGhlbSBvdXQuXG4gICAgICBpZiAoaXNGaXJzdCAmJiAhb3B0aW9ucy5za2lwQmxvY2tpbmcpIHtcbiAgICAgICAgYmxvY2tUcmFuc2l0aW9ucyhub2RlLCBTQUZFX0ZBU1RfRk9SV0FSRF9EVVJBVElPTl9WQUxVRSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aW1pbmdzID0gY29tcHV0ZVRpbWluZ3Mobm9kZSwgZnVsbENsYXNzTmFtZSwgY2FjaGVLZXkpO1xuICAgICAgdmFyIHJlbGF0aXZlRGVsYXkgPSB0aW1pbmdzLm1heERlbGF5O1xuICAgICAgbWF4RGVsYXkgPSBNYXRoLm1heChyZWxhdGl2ZURlbGF5LCAwKTtcbiAgICAgIG1heER1cmF0aW9uID0gdGltaW5ncy5tYXhEdXJhdGlvbjtcblxuICAgICAgdmFyIGZsYWdzID0ge307XG4gICAgICBmbGFncy5oYXNUcmFuc2l0aW9ucyAgICAgICAgICA9IHRpbWluZ3MudHJhbnNpdGlvbkR1cmF0aW9uID4gMDtcbiAgICAgIGZsYWdzLmhhc0FuaW1hdGlvbnMgICAgICAgICAgID0gdGltaW5ncy5hbmltYXRpb25EdXJhdGlvbiA+IDA7XG4gICAgICBmbGFncy5oYXNUcmFuc2l0aW9uQWxsICAgICAgICA9IGZsYWdzLmhhc1RyYW5zaXRpb25zICYmIHRpbWluZ3MudHJhbnNpdGlvblByb3BlcnR5ID09ICdhbGwnO1xuICAgICAgZmxhZ3MuYXBwbHlUcmFuc2l0aW9uRHVyYXRpb24gPSBoYXNUb1N0eWxlcyAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsYWdzLmhhc1RyYW5zaXRpb25zICYmICFmbGFncy5oYXNUcmFuc2l0aW9uQWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoZmxhZ3MuaGFzQW5pbWF0aW9ucyAmJiAhZmxhZ3MuaGFzVHJhbnNpdGlvbnMpKTtcbiAgICAgIGZsYWdzLmFwcGx5QW5pbWF0aW9uRHVyYXRpb24gID0gb3B0aW9ucy5kdXJhdGlvbiAmJiBmbGFncy5oYXNBbmltYXRpb25zO1xuICAgICAgZmxhZ3MuYXBwbHlUcmFuc2l0aW9uRGVsYXkgICAgPSB0cnV0aHlUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KSAmJiAoZmxhZ3MuYXBwbHlUcmFuc2l0aW9uRHVyYXRpb24gfHwgZmxhZ3MuaGFzVHJhbnNpdGlvbnMpO1xuICAgICAgZmxhZ3MuYXBwbHlBbmltYXRpb25EZWxheSAgICAgPSB0cnV0aHlUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KSAmJiBmbGFncy5oYXNBbmltYXRpb25zO1xuICAgICAgZmxhZ3MucmVjYWxjdWxhdGVUaW1pbmdTdHlsZXMgPSBhZGRSZW1vdmVDbGFzc05hbWUubGVuZ3RoID4gMDtcblxuICAgICAgaWYgKGZsYWdzLmFwcGx5VHJhbnNpdGlvbkR1cmF0aW9uIHx8IGZsYWdzLmFwcGx5QW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgbWF4RHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gcGFyc2VGbG9hdChvcHRpb25zLmR1cmF0aW9uKSA6IG1heER1cmF0aW9uO1xuXG4gICAgICAgIGlmIChmbGFncy5hcHBseVRyYW5zaXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIGZsYWdzLmhhc1RyYW5zaXRpb25zID0gdHJ1ZTtcbiAgICAgICAgICB0aW1pbmdzLnRyYW5zaXRpb25EdXJhdGlvbiA9IG1heER1cmF0aW9uO1xuICAgICAgICAgIGFwcGx5T25seUR1cmF0aW9uID0gbm9kZS5zdHlsZVtUUkFOU0lUSU9OX1BST1AgKyBQUk9QRVJUWV9LRVldLmxlbmd0aCA+IDA7XG4gICAgICAgICAgdGVtcG9yYXJ5U3R5bGVzLnB1c2goZ2V0Q3NzVHJhbnNpdGlvbkR1cmF0aW9uU3R5bGUobWF4RHVyYXRpb24sIGFwcGx5T25seUR1cmF0aW9uKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MuYXBwbHlBbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIGZsYWdzLmhhc0FuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgICAgIHRpbWluZ3MuYW5pbWF0aW9uRHVyYXRpb24gPSBtYXhEdXJhdGlvbjtcbiAgICAgICAgICB0ZW1wb3JhcnlTdHlsZXMucHVzaChnZXRDc3NLZXlmcmFtZUR1cmF0aW9uU3R5bGUobWF4RHVyYXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF4RHVyYXRpb24gPT09IDAgJiYgIWZsYWdzLnJlY2FsY3VsYXRlVGltaW5nU3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBjbG9zZUFuZFJldHVybk5vb3BBbmltYXRvcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxheSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkZWxheVN0eWxlID0gcGFyc2VGbG9hdChvcHRpb25zLmRlbGF5KTtcblxuICAgICAgICBpZiAoZmxhZ3MuYXBwbHlUcmFuc2l0aW9uRGVsYXkpIHtcbiAgICAgICAgICB0ZW1wb3JhcnlTdHlsZXMucHVzaChnZXRDc3NEZWxheVN0eWxlKGRlbGF5U3R5bGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncy5hcHBseUFuaW1hdGlvbkRlbGF5KSB7XG4gICAgICAgICAgdGVtcG9yYXJ5U3R5bGVzLnB1c2goZ2V0Q3NzRGVsYXlTdHlsZShkZWxheVN0eWxlLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgZGVsYXkgdmFsdWUgc2luY2Ugd2UgdXNlZCBhIHByZS1lbXB0aXZlIG5lZ2F0aXZlXG4gICAgICAvLyBkZWxheSB2YWx1ZSBhbmQgdGhlIGRlbGF5IHZhbHVlIGlzIHJlcXVpcmVkIGZvciB0aGUgZmluYWwgZXZlbnQgY2hlY2tpbmcuIFRoaXNcbiAgICAgIC8vIHByb3BlcnR5IHdpbGwgZW5zdXJlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbiBhZnRlciB0aGUgUkFGIHBoYXNlIGhhcyBwYXNzZWQuXG4gICAgICBpZiAob3B0aW9ucy5kdXJhdGlvbiA9PSBudWxsICYmIHRpbWluZ3MudHJhbnNpdGlvbkR1cmF0aW9uID4gMCkge1xuICAgICAgICBmbGFncy5yZWNhbGN1bGF0ZVRpbWluZ1N0eWxlcyA9IGZsYWdzLnJlY2FsY3VsYXRlVGltaW5nU3R5bGVzIHx8IGlzRmlyc3Q7XG4gICAgICB9XG5cbiAgICAgIG1heERlbGF5VGltZSA9IG1heERlbGF5ICogT05FX1NFQ09ORDtcbiAgICAgIG1heER1cmF0aW9uVGltZSA9IG1heER1cmF0aW9uICogT05FX1NFQ09ORDtcbiAgICAgIGlmICghb3B0aW9ucy5za2lwQmxvY2tpbmcpIHtcbiAgICAgICAgZmxhZ3MuYmxvY2tUcmFuc2l0aW9uID0gdGltaW5ncy50cmFuc2l0aW9uRHVyYXRpb24gPiAwO1xuICAgICAgICBmbGFncy5ibG9ja0tleWZyYW1lQW5pbWF0aW9uID0gdGltaW5ncy5hbmltYXRpb25EdXJhdGlvbiA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWdnZXIuYW5pbWF0aW9uRGVsYXkgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFnZ2VyLmFuaW1hdGlvbkR1cmF0aW9uID09PSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5mcm9tKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNsZWFudXBTdHlsZXMpIHtcbiAgICAgICAgICByZWdpc3RlclJlc3RvcmFibGVTdHlsZXMocmVzdG9yZVN0eWxlcywgbm9kZSwgT2JqZWN0LmtleXMob3B0aW9ucy5mcm9tKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHlBbmltYXRpb25Gcm9tU3R5bGVzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxhZ3MuYmxvY2tUcmFuc2l0aW9uIHx8IGZsYWdzLmJsb2NrS2V5ZnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgYXBwbHlCbG9ja2luZyhtYXhEdXJhdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKCFvcHRpb25zLnNraXBCbG9ja2luZykge1xuICAgICAgICBibG9ja1RyYW5zaXRpb25zKG5vZGUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyhtYXRza28pOiBmb3IgMS41IGNoYW5nZSB0aGlzIGNvZGUgdG8gaGF2ZSBhbiBhbmltYXRvciBvYmplY3QgZm9yIGJldHRlciBkZWJ1Z2dpbmdcbiAgICAgIHJldHVybiB7XG4gICAgICAgICQkd2lsbEFuaW1hdGU6IHRydWUsXG4gICAgICAgIGVuZDogZW5kRm4sXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uQ2xvc2VkKSByZXR1cm47XG5cbiAgICAgICAgICBydW5uZXJIb3N0ID0ge1xuICAgICAgICAgICAgZW5kOiBlbmRGbixcbiAgICAgICAgICAgIGNhbmNlbDogY2FuY2VsRm4sXG4gICAgICAgICAgICByZXN1bWU6IG51bGwsIC8vdGhpcyB3aWxsIGJlIHNldCBkdXJpbmcgdGhlIHN0YXJ0KCkgcGhhc2VcbiAgICAgICAgICAgIHBhdXNlOiBudWxsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJ1bm5lciA9IG5ldyAkJEFuaW1hdGVSdW5uZXIocnVubmVySG9zdCk7XG5cbiAgICAgICAgICB3YWl0VW50aWxRdWlldChzdGFydCk7XG5cbiAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byBwYXVzZS9yZXN1bWUgdGhlIGFuaW1hdGlvblxuICAgICAgICAgIC8vIHNpbmNlIGl0IGhhc24ndCBydW4geWV0LiBBbmltYXRlUnVubmVyIHdpbGwgdGhlcmVmb3JlXG4gICAgICAgICAgLy8gc2V0IG5vb3AgZnVuY3Rpb25zIGZvciByZXN1bWUgYW5kIHBhdXNlIGFuZCB0aGV5IHdpbGxcbiAgICAgICAgICAvLyBsYXRlciBiZSBvdmVycmlkZGVuIG9uY2UgdGhlIGFuaW1hdGlvbiBpcyB0cmlnZ2VyZWRcbiAgICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBlbmRGbigpIHtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FuY2VsRm4oKSB7XG4gICAgICAgIGNsb3NlKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbG9zZShyZWplY3RlZCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgLy8gaWYgdGhlIHByb21pc2UgaGFzIGJlZW4gY2FsbGVkIGFscmVhZHkgdGhlbiB3ZSBzaG91bGRuJ3QgY2xvc2VcbiAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBhZ2FpblxuICAgICAgICBpZiAoYW5pbWF0aW9uQ2xvc2VkIHx8IChhbmltYXRpb25Db21wbGV0ZWQgJiYgYW5pbWF0aW9uUGF1c2VkKSkgcmV0dXJuO1xuICAgICAgICBhbmltYXRpb25DbG9zZWQgPSB0cnVlO1xuICAgICAgICBhbmltYXRpb25QYXVzZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuJCRza2lwUHJlcGFyYXRpb25DbGFzc2VzKSB7XG4gICAgICAgICAgJCRqcUxpdGUucmVtb3ZlQ2xhc3MoZWxlbWVudCwgcHJlcGFyYXRpb25DbGFzc2VzKTtcbiAgICAgICAgfVxuICAgICAgICAkJGpxTGl0ZS5yZW1vdmVDbGFzcyhlbGVtZW50LCBhY3RpdmVDbGFzc2VzKTtcblxuICAgICAgICBibG9ja0tleWZyYW1lQW5pbWF0aW9ucyhub2RlLCBmYWxzZSk7XG4gICAgICAgIGJsb2NrVHJhbnNpdGlvbnMobm9kZSwgZmFsc2UpO1xuXG4gICAgICAgIGZvckVhY2godGVtcG9yYXJ5U3R5bGVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIG9ubHkgb25lIHdheSB0byByZW1vdmUgaW5saW5lIHN0eWxlIHByb3BlcnRpZXMgZW50aXJlbHkgZnJvbSBlbGVtZW50cy5cbiAgICAgICAgICAvLyBCeSB1c2luZyBgcmVtb3ZlUHJvcGVydHlgIHRoaXMgd29ya3MsIGJ1dCB3ZSBuZWVkIHRvIGNvbnZlcnQgY2FtZWwtY2FzZWQgQ1NTXG4gICAgICAgICAgLy8gc3R5bGVzIGRvd24gdG8gaHlwaGVuYXRlZCB2YWx1ZXMuXG4gICAgICAgICAgbm9kZS5zdHlsZVtlbnRyeVswXV0gPSAnJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXBwbHlBbmltYXRpb25DbGFzc2VzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBhcHBseUFuaW1hdGlvblN0eWxlcyhlbGVtZW50LCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocmVzdG9yZVN0eWxlcykubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yRWFjaChyZXN0b3JlU3R5bGVzLCBmdW5jdGlvbih2YWx1ZSwgcHJvcCkge1xuICAgICAgICAgICAgdmFsdWUgPyBub2RlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgOiBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3ApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIHJlYXNvbiB3aHkgd2UgaGF2ZSB0aGlzIG9wdGlvbiBpcyB0byBhbGxvdyBhIHN5bmNocm9ub3VzIGNsb3NpbmcgY2FsbGJhY2tcbiAgICAgICAgLy8gdGhhdCBpcyBmaXJlZCBhcyBTT09OIGFzIHRoZSBhbmltYXRpb24gZW5kcyAod2hlbiB0aGUgQ1NTIGlzIHJlbW92ZWQpIG9yIGlmXG4gICAgICAgIC8vIHRoZSBhbmltYXRpb24gbmV2ZXIgdGFrZXMgb2ZmIGF0IGFsbC4gQSBnb29kIGV4YW1wbGUgaXMgYSBsZWF2ZSBhbmltYXRpb24gc2luY2VcbiAgICAgICAgLy8gdGhlIGVsZW1lbnQgbXVzdCBiZSByZW1vdmVkIGp1c3QgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBvdmVyIG9yIGVsc2UgdGhlIGVsZW1lbnRcbiAgICAgICAgLy8gd2lsbCBhcHBlYXIgb24gc2NyZWVuIGZvciBvbmUgYW5pbWF0aW9uIGZyYW1lIGNhdXNpbmcgYW4gb3ZlcmJlYXJpbmcgZmxpY2tlci5cbiAgICAgICAgaWYgKG9wdGlvbnMub25Eb25lKSB7XG4gICAgICAgICAgb3B0aW9ucy5vbkRvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBwcmVwYXJhdGlvbiBmdW5jdGlvbiBmYWlscyB0aGVuIHRoZSBwcm9taXNlIGlzIG5vdCBzZXR1cFxuICAgICAgICBpZiAocnVubmVyKSB7XG4gICAgICAgICAgcnVubmVyLmNvbXBsZXRlKCFyZWplY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXBwbHlCbG9ja2luZyhkdXJhdGlvbikge1xuICAgICAgICBpZiAoZmxhZ3MuYmxvY2tUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgYmxvY2tUcmFuc2l0aW9ucyhub2RlLCBkdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MuYmxvY2tLZXlmcmFtZUFuaW1hdGlvbikge1xuICAgICAgICAgIGJsb2NrS2V5ZnJhbWVBbmltYXRpb25zKG5vZGUsICEhZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsb3NlQW5kUmV0dXJuTm9vcEFuaW1hdG9yKCkge1xuICAgICAgICBydW5uZXIgPSBuZXcgJCRBbmltYXRlUnVubmVyKHtcbiAgICAgICAgICBlbmQ6IGVuZEZuLFxuICAgICAgICAgIGNhbmNlbDogY2FuY2VsRm5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2hvdWxkIGZsdXNoIHRoZSBjYWNoZSBhbmltYXRpb25cbiAgICAgICAgd2FpdFVudGlsUXVpZXQobm9vcCk7XG4gICAgICAgIGNsb3NlKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAkJHdpbGxBbmltYXRlOiBmYWxzZSxcbiAgICAgICAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kOiBlbmRGblxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbkNsb3NlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoIW5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0VGltZSwgZXZlbnRzID0gW107XG5cbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggd2Ugb25seSBwYXVzZSBrZXlmcmFtZSBhbmltYXRpb25zIGhlcmUgdGhlIHBhdXNlIGZsYWdcbiAgICAgICAgLy8gd2lsbCBzdGlsbCBoYXBwZW4gd2hlbiB0cmFuc2l0aW9ucyBhcmUgdXNlZC4gT25seSB0aGUgdHJhbnNpdGlvbiB3aWxsXG4gICAgICAgIC8vIG5vdCBiZSBwYXVzZWQgc2luY2UgdGhhdCBpcyBub3QgcG9zc2libGUuIElmIHRoZSBhbmltYXRpb24gZW5kcyB3aGVuXG4gICAgICAgIC8vIHBhdXNlZCB0aGVuIGl0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHVucGF1c2VkIG9yIGNhbmNlbGxlZC5cbiAgICAgICAgdmFyIHBsYXlQYXVzZSA9IGZ1bmN0aW9uKHBsYXlBbmltYXRpb24pIHtcbiAgICAgICAgICBpZiAoIWFuaW1hdGlvbkNvbXBsZXRlZCkge1xuICAgICAgICAgICAgYW5pbWF0aW9uUGF1c2VkID0gIXBsYXlBbmltYXRpb247XG4gICAgICAgICAgICBpZiAodGltaW5ncy5hbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBibG9ja0tleWZyYW1lQW5pbWF0aW9ucyhub2RlLCBhbmltYXRpb25QYXVzZWQpO1xuICAgICAgICAgICAgICBhbmltYXRpb25QYXVzZWRcbiAgICAgICAgICAgICAgICAgID8gdGVtcG9yYXJ5U3R5bGVzLnB1c2godmFsdWUpXG4gICAgICAgICAgICAgICAgICA6IHJlbW92ZUZyb21BcnJheSh0ZW1wb3JhcnlTdHlsZXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGFuaW1hdGlvblBhdXNlZCAmJiBwbGF5QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBhbmltYXRpb25QYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNoZWNraW5nIHRoZSBzdGFnZ2VyIGR1cmF0aW9uIHByZXZlbnRzIGFuIGFjY2lkZW50bHkgY2FzY2FkZSBvZiB0aGUgQ1NTIGRlbGF5IHN0eWxlXG4gICAgICAgIC8vIGJlaW5nIGluaGVyaXRlZCBmcm9tIHRoZSBwYXJlbnQuIElmIHRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGlzIHplcm8gdGhlbiB3ZSBjYW4gc2FmZWx5XG4gICAgICAgIC8vIHJlbHkgdGhhdCB0aGUgZGVsYXkgdmFsdWUgaXMgYW4gaW50ZW50aWFsIHN0YWdnZXIgZGVsYXkgc3R5bGUuXG4gICAgICAgIHZhciBtYXhTdGFnZ2VyID0gaXRlbUluZGV4ID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICYmICgodGltaW5ncy50cmFuc2l0aW9uRHVyYXRpb24gJiYgc3RhZ2dlci50cmFuc2l0aW9uRHVyYXRpb24gPT09IDApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRpbWluZ3MuYW5pbWF0aW9uRHVyYXRpb24gJiYgc3RhZ2dlci5hbmltYXRpb25EdXJhdGlvbiA9PT0gMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5tYXgoc3RhZ2dlci5hbmltYXRpb25EZWxheSwgc3RhZ2dlci50cmFuc2l0aW9uRGVsYXkpO1xuICAgICAgICBpZiAobWF4U3RhZ2dlcikge1xuICAgICAgICAgICR0aW1lb3V0KHRyaWdnZXJBbmltYXRpb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKG1heFN0YWdnZXIgKiBpdGVtSW5kZXggKiBPTkVfU0VDT05EKSxcbiAgICAgICAgICAgICAgICAgICBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJpZ2dlckFuaW1hdGlvblN0YXJ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzIHdpbGwgZGVjb3JhdGUgdGhlIGV4aXN0aW5nIHByb21pc2UgcnVubmVyIHdpdGggcGF1c2UvcmVzdW1lIG1ldGhvZHNcbiAgICAgICAgcnVubmVySG9zdC5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBwbGF5UGF1c2UodHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcnVubmVySG9zdC5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHBsYXlQYXVzZShmYWxzZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckFuaW1hdGlvblN0YXJ0KCkge1xuICAgICAgICAgIC8vIGp1c3QgaW5jYXNlIGEgc3RhZ2dlciBhbmltYXRpb24ga2lja3MgaW4gd2hlbiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgLy8gaXRzZWxmIHdhcyBjYW5jZWxsZWQgZW50aXJlbHlcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uQ2xvc2VkKSByZXR1cm47XG5cbiAgICAgICAgICBhcHBseUJsb2NraW5nKGZhbHNlKTtcblxuICAgICAgICAgIGZvckVhY2godGVtcG9yYXJ5U3R5bGVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGVudHJ5WzBdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZW50cnlbMV07XG4gICAgICAgICAgICBub2RlLnN0eWxlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGFwcGx5QW5pbWF0aW9uQ2xhc3NlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAkJGpxTGl0ZS5hZGRDbGFzcyhlbGVtZW50LCBhY3RpdmVDbGFzc2VzKTtcblxuICAgICAgICAgIGlmIChmbGFncy5yZWNhbGN1bGF0ZVRpbWluZ1N0eWxlcykge1xuICAgICAgICAgICAgZnVsbENsYXNzTmFtZSA9IG5vZGUuY2xhc3NOYW1lICsgJyAnICsgcHJlcGFyYXRpb25DbGFzc2VzO1xuICAgICAgICAgICAgY2FjaGVLZXkgPSBnY3NIYXNoRm4obm9kZSwgZnVsbENsYXNzTmFtZSk7XG5cbiAgICAgICAgICAgIHRpbWluZ3MgPSBjb21wdXRlVGltaW5ncyhub2RlLCBmdWxsQ2xhc3NOYW1lLCBjYWNoZUtleSk7XG4gICAgICAgICAgICByZWxhdGl2ZURlbGF5ID0gdGltaW5ncy5tYXhEZWxheTtcbiAgICAgICAgICAgIG1heERlbGF5ID0gTWF0aC5tYXgocmVsYXRpdmVEZWxheSwgMCk7XG4gICAgICAgICAgICBtYXhEdXJhdGlvbiA9IHRpbWluZ3MubWF4RHVyYXRpb247XG5cbiAgICAgICAgICAgIGlmIChtYXhEdXJhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsYWdzLmhhc1RyYW5zaXRpb25zID0gdGltaW5ncy50cmFuc2l0aW9uRHVyYXRpb24gPiAwO1xuICAgICAgICAgICAgZmxhZ3MuaGFzQW5pbWF0aW9ucyA9IHRpbWluZ3MuYW5pbWF0aW9uRHVyYXRpb24gPiAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmbGFncy5hcHBseUFuaW1hdGlvbkRlbGF5KSB7XG4gICAgICAgICAgICByZWxhdGl2ZURlbGF5ID0gdHlwZW9mIG9wdGlvbnMuZGVsYXkgIT09IFwiYm9vbGVhblwiICYmIHRydXRoeVRpbWluZ1ZhbHVlKG9wdGlvbnMuZGVsYXkpXG4gICAgICAgICAgICAgICAgICA/IHBhcnNlRmxvYXQob3B0aW9ucy5kZWxheSlcbiAgICAgICAgICAgICAgICAgIDogcmVsYXRpdmVEZWxheTtcblxuICAgICAgICAgICAgbWF4RGVsYXkgPSBNYXRoLm1heChyZWxhdGl2ZURlbGF5LCAwKTtcbiAgICAgICAgICAgIHRpbWluZ3MuYW5pbWF0aW9uRGVsYXkgPSByZWxhdGl2ZURlbGF5O1xuICAgICAgICAgICAgZGVsYXlTdHlsZSA9IGdldENzc0RlbGF5U3R5bGUocmVsYXRpdmVEZWxheSwgdHJ1ZSk7XG4gICAgICAgICAgICB0ZW1wb3JhcnlTdHlsZXMucHVzaChkZWxheVN0eWxlKTtcbiAgICAgICAgICAgIG5vZGUuc3R5bGVbZGVsYXlTdHlsZVswXV0gPSBkZWxheVN0eWxlWzFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1heERlbGF5VGltZSA9IG1heERlbGF5ICogT05FX1NFQ09ORDtcbiAgICAgICAgICBtYXhEdXJhdGlvblRpbWUgPSBtYXhEdXJhdGlvbiAqIE9ORV9TRUNPTkQ7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5lYXNpbmcpIHtcbiAgICAgICAgICAgIHZhciBlYXNlUHJvcCwgZWFzZVZhbCA9IG9wdGlvbnMuZWFzaW5nO1xuICAgICAgICAgICAgaWYgKGZsYWdzLmhhc1RyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICAgIGVhc2VQcm9wID0gVFJBTlNJVElPTl9QUk9QICsgVElNSU5HX0tFWTtcbiAgICAgICAgICAgICAgdGVtcG9yYXJ5U3R5bGVzLnB1c2goW2Vhc2VQcm9wLCBlYXNlVmFsXSk7XG4gICAgICAgICAgICAgIG5vZGUuc3R5bGVbZWFzZVByb3BdID0gZWFzZVZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbGFncy5oYXNBbmltYXRpb25zKSB7XG4gICAgICAgICAgICAgIGVhc2VQcm9wID0gQU5JTUFUSU9OX1BST1AgKyBUSU1JTkdfS0VZO1xuICAgICAgICAgICAgICB0ZW1wb3JhcnlTdHlsZXMucHVzaChbZWFzZVByb3AsIGVhc2VWYWxdKTtcbiAgICAgICAgICAgICAgbm9kZS5zdHlsZVtlYXNlUHJvcF0gPSBlYXNlVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aW1pbmdzLnRyYW5zaXRpb25EdXJhdGlvbikge1xuICAgICAgICAgICAgZXZlbnRzLnB1c2goVFJBTlNJVElPTkVORF9FVkVOVCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRpbWluZ3MuYW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKEFOSU1BVElPTkVORF9FVkVOVCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB2YXIgdGltZXJUaW1lID0gbWF4RGVsYXlUaW1lICsgQ0xPU0lOR19USU1FX0JVRkZFUiAqIG1heER1cmF0aW9uVGltZTtcbiAgICAgICAgICB2YXIgZW5kVGltZSA9IHN0YXJ0VGltZSArIHRpbWVyVGltZTtcblxuICAgICAgICAgIHZhciBhbmltYXRpb25zRGF0YSA9IGVsZW1lbnQuZGF0YShBTklNQVRFX1RJTUVSX0tFWSkgfHwgW107XG4gICAgICAgICAgdmFyIHNldHVwRmFsbGJhY2tUaW1lciA9IHRydWU7XG4gICAgICAgICAgaWYgKGFuaW1hdGlvbnNEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lckRhdGEgPSBhbmltYXRpb25zRGF0YVswXTtcbiAgICAgICAgICAgIHNldHVwRmFsbGJhY2tUaW1lciA9IGVuZFRpbWUgPiBjdXJyZW50VGltZXJEYXRhLmV4cGVjdGVkRW5kVGltZTtcbiAgICAgICAgICAgIGlmIChzZXR1cEZhbGxiYWNrVGltZXIpIHtcbiAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKGN1cnJlbnRUaW1lckRhdGEudGltZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uc0RhdGEucHVzaChjbG9zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNldHVwRmFsbGJhY2tUaW1lcikge1xuICAgICAgICAgICAgdmFyIHRpbWVyID0gJHRpbWVvdXQob25BbmltYXRpb25FeHBpcmVkLCB0aW1lclRpbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGFuaW1hdGlvbnNEYXRhWzBdID0ge1xuICAgICAgICAgICAgICB0aW1lcjogdGltZXIsXG4gICAgICAgICAgICAgIGV4cGVjdGVkRW5kVGltZTogZW5kVGltZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFuaW1hdGlvbnNEYXRhLnB1c2goY2xvc2UpO1xuICAgICAgICAgICAgZWxlbWVudC5kYXRhKEFOSU1BVEVfVElNRVJfS0VZLCBhbmltYXRpb25zRGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudC5vbihldmVudHMuam9pbignICcpLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy50bykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2xlYW51cFN0eWxlcykge1xuICAgICAgICAgICAgICByZWdpc3RlclJlc3RvcmFibGVTdHlsZXMocmVzdG9yZVN0eWxlcywgbm9kZSwgT2JqZWN0LmtleXMob3B0aW9ucy50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXBwbHlBbmltYXRpb25Ub1N0eWxlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbkFuaW1hdGlvbkV4cGlyZWQoKSB7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvbnNEYXRhID0gZWxlbWVudC5kYXRhKEFOSU1BVEVfVElNRVJfS0VZKTtcblxuICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSBmYWxzZSBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgZWxlbWVudCB3YXNcbiAgICAgICAgICAvLyByZW1vdmVkIGZyb20gdGhlIERPTSAodmlhIGEgbGVhdmUgYW5pbWF0aW9uIG9yIHNvbWV0aGluZ1xuICAgICAgICAgIC8vIHNpbWlsYXIpXG4gICAgICAgICAgaWYgKGFuaW1hdGlvbnNEYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFuaW1hdGlvbnNEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbnNEYXRhW2ldKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZURhdGEoQU5JTUFURV9USU1FUl9LRVkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uQW5pbWF0aW9uUHJvZ3Jlc3MoZXZlbnQpIHtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB2YXIgZXYgPSBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50O1xuICAgICAgICAgIHZhciB0aW1lU3RhbXAgPSBldi4kbWFudWFsVGltZVN0YW1wIHx8IGV2LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgLyogRmlyZWZveCAob3IgcG9zc2libHkganVzdCBHZWNrbykgbGlrZXMgdG8gbm90IHJvdW5kIHZhbHVlcyB1cFxuICAgICAgICAgICAqIHdoZW4gYSBtcyBtZWFzdXJlbWVudCBpcyB1c2VkIGZvciB0aGUgYW5pbWF0aW9uICovXG4gICAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gcGFyc2VGbG9hdChldi5lbGFwc2VkVGltZS50b0ZpeGVkKEVMQVBTRURfVElNRV9NQVhfREVDSU1BTF9QTEFDRVMpKTtcblxuICAgICAgICAgIC8qICRtYW51YWxUaW1lU3RhbXAgaXMgYSBtb2NrZWQgdGltZVN0YW1wIHZhbHVlIHdoaWNoIGlzIHNldFxuICAgICAgICAgICAqIHdpdGhpbiBicm93c2VyVHJpZ2dlcigpLiBUaGlzIGlzIG9ubHkgaGVyZSBzbyB0aGF0IHRlc3RzIGNhblxuICAgICAgICAgICAqIG1vY2sgYW5pbWF0aW9ucyBwcm9wZXJseS4gUmVhbCBldmVudHMgZmFsbGJhY2sgdG8gZXZlbnQudGltZVN0YW1wLFxuICAgICAgICAgICAqIG9yLCBpZiB0aGV5IGRvbid0LCB0aGVuIGEgdGltZVN0YW1wIGlzIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBmb3IgdGhlbS5cbiAgICAgICAgICAgKiBXZSdyZSBjaGVja2luZyB0byBzZWUgaWYgdGhlIHRpbWVTdGFtcCBzdXJwYXNzZXMgdGhlIGV4cGVjdGVkIGRlbGF5LFxuICAgICAgICAgICAqIGJ1dCB3ZSdyZSB1c2luZyBlbGFwc2VkVGltZSBpbnN0ZWFkIG9mIHRoZSB0aW1lU3RhbXAgb24gdGhlIDJuZFxuICAgICAgICAgICAqIHByZS1jb25kaXRpb24gc2luY2UgYW5pbWF0aW9ucyBzb21ldGltZXMgY2xvc2Ugb2ZmIGVhcmx5ICovXG4gICAgICAgICAgaWYgKE1hdGgubWF4KHRpbWVTdGFtcCAtIHN0YXJ0VGltZSwgMCkgPj0gbWF4RGVsYXlUaW1lICYmIGVsYXBzZWRUaW1lID49IG1heER1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyB3ZSBzZXQgdGhpcyBmbGFnIHRvIGVuc3VyZSB0aGF0IGlmIHRoZSB0cmFuc2l0aW9uIGlzIHBhdXNlZCB0aGVuLCB3aGVuIHJlc3VtZWQsXG4gICAgICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIHdpbGwgYXV0b21hdGljYWxseSBjbG9zZSBpdHNlbGYgc2luY2UgdHJhbnNpdGlvbnMgY2Fubm90IGJlIHBhdXNlZC5cbiAgICAgICAgICAgIGFuaW1hdGlvbkNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1dO1xufV07XG5cbnZhciAkJEFuaW1hdGVDc3NEcml2ZXJQcm92aWRlciA9IFsnJCRhbmltYXRpb25Qcm92aWRlcicsIGZ1bmN0aW9uKCQkYW5pbWF0aW9uUHJvdmlkZXIpIHtcbiAgJCRhbmltYXRpb25Qcm92aWRlci5kcml2ZXJzLnB1c2goJyQkYW5pbWF0ZUNzc0RyaXZlcicpO1xuXG4gIHZhciBOR19BTklNQVRFX1NISU1fQ0xBU1NfTkFNRSA9ICduZy1hbmltYXRlLXNoaW0nO1xuICB2YXIgTkdfQU5JTUFURV9BTkNIT1JfQ0xBU1NfTkFNRSA9ICduZy1hbmNob3InO1xuXG4gIHZhciBOR19PVVRfQU5DSE9SX0NMQVNTX05BTUUgPSAnbmctYW5jaG9yLW91dCc7XG4gIHZhciBOR19JTl9BTkNIT1JfQ0xBU1NfTkFNRSA9ICduZy1hbmNob3ItaW4nO1xuXG4gIGZ1bmN0aW9uIGlzRG9jdW1lbnRGcmFnbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLnBhcmVudE5vZGUubm9kZVR5cGUgPT09IDExO1xuICB9XG5cbiAgdGhpcy4kZ2V0ID0gWyckYW5pbWF0ZUNzcycsICckcm9vdFNjb3BlJywgJyQkQW5pbWF0ZVJ1bm5lcicsICckcm9vdEVsZW1lbnQnLCAnJHNuaWZmZXInLCAnJCRqcUxpdGUnLCAnJGRvY3VtZW50JyxcbiAgICAgICBmdW5jdGlvbigkYW5pbWF0ZUNzcywgICAkcm9vdFNjb3BlLCAgICQkQW5pbWF0ZVJ1bm5lciwgICAkcm9vdEVsZW1lbnQsICAgJHNuaWZmZXIsICAgJCRqcUxpdGUsICAgJGRvY3VtZW50KSB7XG5cbiAgICAvLyBvbmx5IGJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0aGVzZSBwcm9wZXJ0aWVzIGNhbiByZW5kZXIgYW5pbWF0aW9uc1xuICAgIGlmICghJHNuaWZmZXIuYW5pbWF0aW9ucyAmJiAhJHNuaWZmZXIudHJhbnNpdGlvbnMpIHJldHVybiBub29wO1xuXG4gICAgdmFyIGJvZHlOb2RlID0gJGRvY3VtZW50WzBdLmJvZHk7XG4gICAgdmFyIHJvb3ROb2RlID0gZ2V0RG9tTm9kZSgkcm9vdEVsZW1lbnQpO1xuXG4gICAgdmFyIHJvb3RCb2R5RWxlbWVudCA9IGpxTGl0ZShcbiAgICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgdXNpbmcgc29tZXRoaW5nIHRoYXQgZXhpc3RzIG91dHNpZGUgb2YgdGhlIGJvZHlcbiAgICAgIC8vIHdlIGFsc28gc3BlY2lhbCBjYXNlIHRoZSBkb2MgZnJhZ2VtZW50IGNhc2UgYmVjYXVzZSBvdXIgdW5pdCB0ZXN0IGNvZGVcbiAgICAgIC8vIGFwcGVuZHMgdGhlICRyb290RWxlbWVudCB0byB0aGUgYm9keSBhZnRlciB0aGUgYXBwIGhhcyBiZWVuIGJvb3RzdHJhcHBlZFxuICAgICAgaXNEb2N1bWVudEZyYWdtZW50KHJvb3ROb2RlKSB8fCBib2R5Tm9kZS5jb250YWlucyhyb290Tm9kZSkgPyByb290Tm9kZSA6IGJvZHlOb2RlXG4gICAgKTtcblxuICAgIHZhciBhcHBseUFuaW1hdGlvbkNsYXNzZXMgPSBhcHBseUFuaW1hdGlvbkNsYXNzZXNGYWN0b3J5KCQkanFMaXRlKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbml0RHJpdmVyRm4oYW5pbWF0aW9uRGV0YWlscykge1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbkRldGFpbHMuZnJvbSAmJiBhbmltYXRpb25EZXRhaWxzLnRvXG4gICAgICAgICAgPyBwcmVwYXJlRnJvbVRvQW5jaG9yQW5pbWF0aW9uKGFuaW1hdGlvbkRldGFpbHMuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRGV0YWlscy50byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRGV0YWlscy5jbGFzc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25EZXRhaWxzLmFuY2hvcnMpXG4gICAgICAgICAgOiBwcmVwYXJlUmVndWxhckFuaW1hdGlvbihhbmltYXRpb25EZXRhaWxzKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZmlsdGVyQ3NzQ2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgICAvL3JlbW92ZSBhbGwgdGhlIGBuZy1gIHN0dWZmXG4gICAgICByZXR1cm4gY2xhc3Nlcy5yZXBsYWNlKC9cXGJuZy1cXFMrXFxiL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRVbmlxdWVWYWx1ZXMoYSwgYikge1xuICAgICAgaWYgKGlzU3RyaW5nKGEpKSBhID0gYS5zcGxpdCgnICcpO1xuICAgICAgaWYgKGlzU3RyaW5nKGIpKSBiID0gYi5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gYi5pbmRleE9mKHZhbCkgPT09IC0xO1xuICAgICAgfSkuam9pbignICcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVBbmNob3JlZEFuaW1hdGlvbihjbGFzc2VzLCBvdXRBbmNob3IsIGluQW5jaG9yKSB7XG4gICAgICB2YXIgY2xvbmUgPSBqcUxpdGUoZ2V0RG9tTm9kZShvdXRBbmNob3IpLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICB2YXIgc3RhcnRpbmdDbGFzc2VzID0gZmlsdGVyQ3NzQ2xhc3NlcyhnZXRDbGFzc1ZhbChjbG9uZSkpO1xuXG4gICAgICBvdXRBbmNob3IuYWRkQ2xhc3MoTkdfQU5JTUFURV9TSElNX0NMQVNTX05BTUUpO1xuICAgICAgaW5BbmNob3IuYWRkQ2xhc3MoTkdfQU5JTUFURV9TSElNX0NMQVNTX05BTUUpO1xuXG4gICAgICBjbG9uZS5hZGRDbGFzcyhOR19BTklNQVRFX0FOQ0hPUl9DTEFTU19OQU1FKTtcblxuICAgICAgcm9vdEJvZHlFbGVtZW50LmFwcGVuZChjbG9uZSk7XG5cbiAgICAgIHZhciBhbmltYXRvckluLCBhbmltYXRvck91dCA9IHByZXBhcmVPdXRBbmltYXRpb24oKTtcblxuICAgICAgLy8gdGhlIHVzZXIgbWF5IG5vdCBlbmQgdXAgdXNpbmcgdGhlIGBvdXRgIGFuaW1hdGlvbiBhbmRcbiAgICAgIC8vIG9ubHkgbWFraW5nIHVzZSBvZiB0aGUgYGluYCBhbmltYXRpb24gb3IgdmljZS12ZXJzYS5cbiAgICAgIC8vIEluIGVpdGhlciBjYXNlIHdlIHNob3VsZCBhbGxvdyB0aGlzIGFuZCBub3QgYXNzdW1lIHRoZVxuICAgICAgLy8gYW5pbWF0aW9uIGlzIG92ZXIgdW5sZXNzIGJvdGggYW5pbWF0aW9ucyBhcmUgbm90IHVzZWQuXG4gICAgICBpZiAoIWFuaW1hdG9yT3V0KSB7XG4gICAgICAgIGFuaW1hdG9ySW4gPSBwcmVwYXJlSW5BbmltYXRpb24oKTtcbiAgICAgICAgaWYgKCFhbmltYXRvckluKSB7XG4gICAgICAgICAgcmV0dXJuIGVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydGluZ0FuaW1hdG9yID0gYW5pbWF0b3JPdXQgfHwgYW5pbWF0b3JJbjtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBydW5uZXI7XG5cbiAgICAgICAgICB2YXIgY3VycmVudEFuaW1hdGlvbiA9IHN0YXJ0aW5nQW5pbWF0b3Iuc3RhcnQoKTtcbiAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghYW5pbWF0b3JJbikge1xuICAgICAgICAgICAgICBhbmltYXRvckluID0gcHJlcGFyZUluQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgIGlmIChhbmltYXRvckluKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdG9ySW4uc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGVuZCgpO1xuICAgICAgICAgICAgICAgICAgcnVubmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRBbmltYXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluIHRoZSBldmVudCB0aGF0IHRoZXJlIGlzIG5vIGBpbmAgYW5pbWF0aW9uXG4gICAgICAgICAgICBlbmQoKTtcbiAgICAgICAgICAgIHJ1bm5lci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcnVubmVyID0gbmV3ICQkQW5pbWF0ZVJ1bm5lcih7XG4gICAgICAgICAgICBlbmQ6IGVuZEZuLFxuICAgICAgICAgICAgY2FuY2VsOiBlbmRGblxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHJ1bm5lcjtcblxuICAgICAgICAgIGZ1bmN0aW9uIGVuZEZuKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgY3VycmVudEFuaW1hdGlvbi5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZUFuY2hvclN0eWxlcyhhbmNob3IpIHtcbiAgICAgICAgdmFyIHN0eWxlcyA9IHt9O1xuXG4gICAgICAgIHZhciBjb29yZHMgPSBnZXREb21Ob2RlKGFuY2hvcikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gd2UgaXRlcmF0ZSBkaXJlY3RseSBzaW5jZSBzYWZhcmkgbWVzc2VzIHVwIGFuZCBkb2Vzbid0IHJldHVyblxuICAgICAgICAvLyBhbGwgdGhlIGtleXMgZm9yIHRoZSBjb29kcyBvYmplY3Qgd2hlbiBpdGVyYXRlZFxuICAgICAgICBmb3JFYWNoKFsnd2lkdGgnLCdoZWlnaHQnLCd0b3AnLCdsZWZ0J10sIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvb3Jkc1trZXldO1xuICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICB2YWx1ZSArPSBib2R5Tm9kZS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgIHZhbHVlICs9IGJvZHlOb2RlLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZXNba2V5XSA9IE1hdGguZmxvb3IodmFsdWUpICsgJ3B4JztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByZXBhcmVPdXRBbmltYXRpb24oKSB7XG4gICAgICAgIHZhciBhbmltYXRvciA9ICRhbmltYXRlQ3NzKGNsb25lLCB7XG4gICAgICAgICAgYWRkQ2xhc3M6IE5HX09VVF9BTkNIT1JfQ0xBU1NfTkFNRSxcbiAgICAgICAgICBkZWxheTogdHJ1ZSxcbiAgICAgICAgICBmcm9tOiBjYWxjdWxhdGVBbmNob3JTdHlsZXMob3V0QW5jaG9yKVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZWFkIHRoZSBjb21tZW50IHdpdGhpbiBgcHJlcGFyZVJlZ3VsYXJBbmltYXRpb25gIHRvIHVuZGVyc3RhbmRcbiAgICAgICAgLy8gd2h5IHRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5XG4gICAgICAgIHJldHVybiBhbmltYXRvci4kJHdpbGxBbmltYXRlID8gYW5pbWF0b3IgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRDbGFzc1ZhbChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmF0dHIoJ2NsYXNzJykgfHwgJyc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByZXBhcmVJbkFuaW1hdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZGluZ0NsYXNzZXMgPSBmaWx0ZXJDc3NDbGFzc2VzKGdldENsYXNzVmFsKGluQW5jaG9yKSk7XG4gICAgICAgIHZhciB0b0FkZCA9IGdldFVuaXF1ZVZhbHVlcyhlbmRpbmdDbGFzc2VzLCBzdGFydGluZ0NsYXNzZXMpO1xuICAgICAgICB2YXIgdG9SZW1vdmUgPSBnZXRVbmlxdWVWYWx1ZXMoc3RhcnRpbmdDbGFzc2VzLCBlbmRpbmdDbGFzc2VzKTtcblxuICAgICAgICB2YXIgYW5pbWF0b3IgPSAkYW5pbWF0ZUNzcyhjbG9uZSwge1xuICAgICAgICAgIHRvOiBjYWxjdWxhdGVBbmNob3JTdHlsZXMoaW5BbmNob3IpLFxuICAgICAgICAgIGFkZENsYXNzOiBOR19JTl9BTkNIT1JfQ0xBU1NfTkFNRSArICcgJyArIHRvQWRkLFxuICAgICAgICAgIHJlbW92ZUNsYXNzOiBOR19PVVRfQU5DSE9SX0NMQVNTX05BTUUgKyAnICcgKyB0b1JlbW92ZSxcbiAgICAgICAgICBkZWxheTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZWFkIHRoZSBjb21tZW50IHdpdGhpbiBgcHJlcGFyZVJlZ3VsYXJBbmltYXRpb25gIHRvIHVuZGVyc3RhbmRcbiAgICAgICAgLy8gd2h5IHRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5XG4gICAgICAgIHJldHVybiBhbmltYXRvci4kJHdpbGxBbmltYXRlID8gYW5pbWF0b3IgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICAgIGNsb25lLnJlbW92ZSgpO1xuICAgICAgICBvdXRBbmNob3IucmVtb3ZlQ2xhc3MoTkdfQU5JTUFURV9TSElNX0NMQVNTX05BTUUpO1xuICAgICAgICBpbkFuY2hvci5yZW1vdmVDbGFzcyhOR19BTklNQVRFX1NISU1fQ0xBU1NfTkFNRSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUZyb21Ub0FuY2hvckFuaW1hdGlvbihmcm9tLCB0bywgY2xhc3NlcywgYW5jaG9ycykge1xuICAgICAgdmFyIGZyb21BbmltYXRpb24gPSBwcmVwYXJlUmVndWxhckFuaW1hdGlvbihmcm9tLCBub29wKTtcbiAgICAgIHZhciB0b0FuaW1hdGlvbiA9IHByZXBhcmVSZWd1bGFyQW5pbWF0aW9uKHRvLCBub29wKTtcblxuICAgICAgdmFyIGFuY2hvckFuaW1hdGlvbnMgPSBbXTtcbiAgICAgIGZvckVhY2goYW5jaG9ycywgZnVuY3Rpb24oYW5jaG9yKSB7XG4gICAgICAgIHZhciBvdXRFbGVtZW50ID0gYW5jaG9yWydvdXQnXTtcbiAgICAgICAgdmFyIGluRWxlbWVudCA9IGFuY2hvclsnaW4nXTtcbiAgICAgICAgdmFyIGFuaW1hdG9yID0gcHJlcGFyZUFuY2hvcmVkQW5pbWF0aW9uKGNsYXNzZXMsIG91dEVsZW1lbnQsIGluRWxlbWVudCk7XG4gICAgICAgIGlmIChhbmltYXRvcikge1xuICAgICAgICAgIGFuY2hvckFuaW1hdGlvbnMucHVzaChhbmltYXRvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBubyBwb2ludCBpbiBkb2luZyBhbnl0aGluZyB3aGVuIHRoZXJlIGFyZSBubyBlbGVtZW50cyB0byBhbmltYXRlXG4gICAgICBpZiAoIWZyb21BbmltYXRpb24gJiYgIXRvQW5pbWF0aW9uICYmIGFuY2hvckFuaW1hdGlvbnMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYW5pbWF0aW9uUnVubmVycyA9IFtdO1xuXG4gICAgICAgICAgaWYgKGZyb21BbmltYXRpb24pIHtcbiAgICAgICAgICAgIGFuaW1hdGlvblJ1bm5lcnMucHVzaChmcm9tQW5pbWF0aW9uLnN0YXJ0KCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b0FuaW1hdGlvbikge1xuICAgICAgICAgICAgYW5pbWF0aW9uUnVubmVycy5wdXNoKHRvQW5pbWF0aW9uLnN0YXJ0KCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvckVhY2goYW5jaG9yQW5pbWF0aW9ucywgZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBhbmltYXRpb25SdW5uZXJzLnB1c2goYW5pbWF0aW9uLnN0YXJ0KCkpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIHJ1bm5lciA9IG5ldyAkJEFuaW1hdGVSdW5uZXIoe1xuICAgICAgICAgICAgZW5kOiBlbmRGbixcbiAgICAgICAgICAgIGNhbmNlbDogZW5kRm4gLy8gQ1NTLWRyaXZlbiBhbmltYXRpb25zIGNhbm5vdCBiZSBjYW5jZWxsZWQsIG9ubHkgZW5kZWRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgICQkQW5pbWF0ZVJ1bm5lci5hbGwoYW5pbWF0aW9uUnVubmVycywgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICAgICAgICBydW5uZXIuY29tcGxldGUoc3RhdHVzKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBydW5uZXI7XG5cbiAgICAgICAgICBmdW5jdGlvbiBlbmRGbigpIHtcbiAgICAgICAgICAgIGZvckVhY2goYW5pbWF0aW9uUnVubmVycywgZnVuY3Rpb24ocnVubmVyKSB7XG4gICAgICAgICAgICAgIHJ1bm5lci5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlUmVndWxhckFuaW1hdGlvbihhbmltYXRpb25EZXRhaWxzKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGFuaW1hdGlvbkRldGFpbHMuZWxlbWVudDtcbiAgICAgIHZhciBvcHRpb25zID0gYW5pbWF0aW9uRGV0YWlscy5vcHRpb25zIHx8IHt9O1xuXG4gICAgICBpZiAoYW5pbWF0aW9uRGV0YWlscy5zdHJ1Y3R1cmFsKSB7XG4gICAgICAgIG9wdGlvbnMuZXZlbnQgPSBhbmltYXRpb25EZXRhaWxzLmV2ZW50O1xuICAgICAgICBvcHRpb25zLnN0cnVjdHVyYWwgPSB0cnVlO1xuICAgICAgICBvcHRpb25zLmFwcGx5Q2xhc3Nlc0Vhcmx5ID0gdHJ1ZTtcblxuICAgICAgICAvLyB3ZSBzcGVjaWFsIGNhc2UgdGhlIGxlYXZlIGFuaW1hdGlvbiBzaW5jZSB3ZSB3YW50IHRvIGVuc3VyZSB0aGF0XG4gICAgICAgIC8vIHRoZSBlbGVtZW50IGlzIHJlbW92ZWQgYXMgc29vbiBhcyB0aGUgYW5pbWF0aW9uIGlzIG92ZXIuIE90aGVyd2lzZVxuICAgICAgICAvLyBhIGZsaWNrZXIgbWlnaHQgYXBwZWFyIG9yIHRoZSBlbGVtZW50IG1heSBub3QgYmUgcmVtb3ZlZCBhdCBhbGxcbiAgICAgICAgaWYgKGFuaW1hdGlvbkRldGFpbHMuZXZlbnQgPT09ICdsZWF2ZScpIHtcbiAgICAgICAgICBvcHRpb25zLm9uRG9uZSA9IG9wdGlvbnMuZG9tT3BlcmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGFzc2lnbiB0aGUgcHJlcGFyYXRpb25DbGFzc2VzIGFzIHRoZSBhY3R1YWwgYW5pbWF0aW9uIGV2ZW50IHNpbmNlXG4gICAgICAvLyB0aGUgaW50ZXJuYWxzIG9mICRhbmltYXRlQ3NzIHdpbGwganVzdCBzdWZmaXggdGhlIGV2ZW50IHRva2VuIHZhbHVlc1xuICAgICAgLy8gd2l0aCBgLWFjdGl2ZWAgdG8gdHJpZ2dlciB0aGUgYW5pbWF0aW9uLlxuICAgICAgaWYgKG9wdGlvbnMucHJlcGFyYXRpb25DbGFzc2VzKSB7XG4gICAgICAgIG9wdGlvbnMuZXZlbnQgPSBjb25jYXRXaXRoU3BhY2Uob3B0aW9ucy5ldmVudCwgb3B0aW9ucy5wcmVwYXJhdGlvbkNsYXNzZXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5pbWF0b3IgPSAkYW5pbWF0ZUNzcyhlbGVtZW50LCBvcHRpb25zKTtcblxuICAgICAgLy8gdGhlIGRyaXZlciBsb29rdXAgY29kZSBpbnNpZGUgb2YgJCRhbmltYXRpb24gYXR0ZW1wdHMgdG8gc3Bhd24gYVxuICAgICAgLy8gZHJpdmVyIG9uZSBieSBvbmUgdW50aWwgYSBkcml2ZXIgcmV0dXJucyBhLiQkd2lsbEFuaW1hdGUgYW5pbWF0b3Igb2JqZWN0LlxuICAgICAgLy8gJGFuaW1hdGVDc3Mgd2lsbCBhbHdheXMgcmV0dXJuIGFuIG9iamVjdCwgaG93ZXZlciwgaXQgd2lsbCBwYXNzIGluXG4gICAgICAvLyBhIGZsYWcgYXMgYSBoaW50IGFzIHRvIHdoZXRoZXIgYW4gYW5pbWF0aW9uIHdhcyBkZXRlY3RlZCBvciBub3RcbiAgICAgIHJldHVybiBhbmltYXRvci4kJHdpbGxBbmltYXRlID8gYW5pbWF0b3IgOiBudWxsO1xuICAgIH1cbiAgfV07XG59XTtcblxuLy8gVE9ETyhtYXRza28pOiB1c2UgY2FjaGluZyBoZXJlIHRvIHNwZWVkIHRoaW5ncyB1cCBmb3IgZGV0ZWN0aW9uXG4vLyBUT0RPKG1hdHNrbyk6IGFkZCBkb2N1bWVudGF0aW9uXG4vLyAgYnkgdGhlIHRpbWUuLi5cblxudmFyICQkQW5pbWF0ZUpzUHJvdmlkZXIgPSBbJyRhbmltYXRlUHJvdmlkZXInLCBmdW5jdGlvbigkYW5pbWF0ZVByb3ZpZGVyKSB7XG4gIHRoaXMuJGdldCA9IFsnJGluamVjdG9yJywgJyQkQW5pbWF0ZVJ1bm5lcicsICckJGpxTGl0ZScsXG4gICAgICAgZnVuY3Rpb24oJGluamVjdG9yLCAgICQkQW5pbWF0ZVJ1bm5lciwgICAkJGpxTGl0ZSkge1xuXG4gICAgdmFyIGFwcGx5QW5pbWF0aW9uQ2xhc3NlcyA9IGFwcGx5QW5pbWF0aW9uQ2xhc3Nlc0ZhY3RvcnkoJCRqcUxpdGUpO1xuICAgICAgICAgLy8gJGFuaW1hdGVKcyhlbGVtZW50LCAnZW50ZXInKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQsIGNsYXNzZXMsIG9wdGlvbnMpIHtcbiAgICAgIC8vIHRoZSBgY2xhc3Nlc2AgYXJndW1lbnQgaXMgb3B0aW9uYWwgYW5kIGlmIGl0IGlzIG5vdCB1c2VkXG4gICAgICAvLyB0aGVuIHRoZSBjbGFzc2VzIHdpbGwgYmUgcmVzb2x2ZWQgZnJvbSB0aGUgZWxlbWVudCdzIGNsYXNzTmFtZVxuICAgICAgLy8gcHJvcGVydHkgYXMgd2VsbCBhcyBvcHRpb25zLmFkZENsYXNzL29wdGlvbnMucmVtb3ZlQ2xhc3MuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiBpc09iamVjdChjbGFzc2VzKSkge1xuICAgICAgICBvcHRpb25zID0gY2xhc3NlcztcbiAgICAgICAgY2xhc3NlcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBwcmVwYXJlQW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIGlmICghY2xhc3Nlcykge1xuICAgICAgICBjbGFzc2VzID0gZWxlbWVudC5hdHRyKCdjbGFzcycpIHx8ICcnO1xuICAgICAgICBpZiAob3B0aW9ucy5hZGRDbGFzcykge1xuICAgICAgICAgIGNsYXNzZXMgKz0gJyAnICsgb3B0aW9ucy5hZGRDbGFzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5yZW1vdmVDbGFzcykge1xuICAgICAgICAgIGNsYXNzZXMgKz0gJyAnICsgb3B0aW9ucy5yZW1vdmVDbGFzcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2xhc3Nlc1RvQWRkID0gb3B0aW9ucy5hZGRDbGFzcztcbiAgICAgIHZhciBjbGFzc2VzVG9SZW1vdmUgPSBvcHRpb25zLnJlbW92ZUNsYXNzO1xuXG4gICAgICAvLyB0aGUgbG9va3VwQW5pbWF0aW9ucyBmdW5jdGlvbiByZXR1cm5zIGEgc2VyaWVzIG9mIGFuaW1hdGlvbiBvYmplY3RzIHRoYXQgYXJlXG4gICAgICAvLyBtYXRjaGVkIHVwIHdpdGggb25lIG9yIG1vcmUgb2YgdGhlIENTUyBjbGFzc2VzLiBUaGVzZSBhbmltYXRpb24gb2JqZWN0cyBhcmVcbiAgICAgIC8vIGRlZmluZWQgdmlhIHRoZSBtb2R1bGUuYW5pbWF0aW9uIGZhY3RvcnkgZnVuY3Rpb24uIElmIG5vdGhpbmcgaXMgZGV0ZWN0ZWQgdGhlblxuICAgICAgLy8gd2UgZG9uJ3QgcmV0dXJuIGFueXRoaW5nIHdoaWNoIHRoZW4gbWFrZXMgJGFuaW1hdGlvbiBxdWVyeSB0aGUgbmV4dCBkcml2ZXIuXG4gICAgICB2YXIgYW5pbWF0aW9ucyA9IGxvb2t1cEFuaW1hdGlvbnMoY2xhc3Nlcyk7XG4gICAgICB2YXIgYmVmb3JlLCBhZnRlcjtcbiAgICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgICB2YXIgYWZ0ZXJGbiwgYmVmb3JlRm47XG4gICAgICAgIGlmIChldmVudCA9PSAnbGVhdmUnKSB7XG4gICAgICAgICAgYmVmb3JlRm4gPSAnbGVhdmUnO1xuICAgICAgICAgIGFmdGVyRm4gPSAnYWZ0ZXJMZWF2ZSc7IC8vIFRPRE8obWF0c2tvKTogZ2V0IHJpZCBvZiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmVmb3JlRm4gPSAnYmVmb3JlJyArIGV2ZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc3Vic3RyKDEpO1xuICAgICAgICAgIGFmdGVyRm4gPSBldmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudCAhPT0gJ2VudGVyJyAmJiBldmVudCAhPT0gJ21vdmUnKSB7XG4gICAgICAgICAgYmVmb3JlID0gcGFja2FnZUFuaW1hdGlvbnMoZWxlbWVudCwgZXZlbnQsIG9wdGlvbnMsIGFuaW1hdGlvbnMsIGJlZm9yZUZuKTtcbiAgICAgICAgfVxuICAgICAgICBhZnRlciAgPSBwYWNrYWdlQW5pbWF0aW9ucyhlbGVtZW50LCBldmVudCwgb3B0aW9ucywgYW5pbWF0aW9ucywgYWZ0ZXJGbik7XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIG1hdGNoaW5nIGFuaW1hdGlvbnNcbiAgICAgIGlmICghYmVmb3JlICYmICFhZnRlcikgcmV0dXJuO1xuXG4gICAgICBmdW5jdGlvbiBhcHBseU9wdGlvbnMoKSB7XG4gICAgICAgIG9wdGlvbnMuZG9tT3BlcmF0aW9uKCk7XG4gICAgICAgIGFwcGx5QW5pbWF0aW9uQ2xhc3NlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBjbG9zZUFjdGl2ZUFuaW1hdGlvbnM7XG4gICAgICAgICAgdmFyIGNoYWluID0gW107XG5cbiAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICBjaGFpbi5wdXNoKGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgIGNsb3NlQWN0aXZlQW5pbWF0aW9ucyA9IGJlZm9yZShmbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFpbi5wdXNoKGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgIGFwcGx5T3B0aW9ucygpO1xuICAgICAgICAgICAgICBmbih0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBseU9wdGlvbnMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgIGNoYWluLnB1c2goZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgY2xvc2VBY3RpdmVBbmltYXRpb25zID0gYWZ0ZXIoZm4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFuaW1hdGlvbkNsb3NlZCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBydW5uZXIgPSBuZXcgJCRBbmltYXRlUnVubmVyKHtcbiAgICAgICAgICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGVuZEFuaW1hdGlvbnMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBlbmRBbmltYXRpb25zKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgJCRBbmltYXRlUnVubmVyLmNoYWluKGNoYWluLCBvbkNvbXBsZXRlKTtcbiAgICAgICAgICByZXR1cm4gcnVubmVyO1xuXG4gICAgICAgICAgZnVuY3Rpb24gb25Db21wbGV0ZShzdWNjZXNzKSB7XG4gICAgICAgICAgICBhbmltYXRpb25DbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgYXBwbHlPcHRpb25zKCk7XG4gICAgICAgICAgICBhcHBseUFuaW1hdGlvblN0eWxlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJ1bm5lci5jb21wbGV0ZShzdWNjZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBlbmRBbmltYXRpb25zKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgaWYgKCFhbmltYXRpb25DbG9zZWQpIHtcbiAgICAgICAgICAgICAgKGNsb3NlQWN0aXZlQW5pbWF0aW9ucyB8fCBub29wKShjYW5jZWxsZWQpO1xuICAgICAgICAgICAgICBvbkNvbXBsZXRlKGNhbmNlbGxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBleGVjdXRlQW5pbWF0aW9uRm4oZm4sIGVsZW1lbnQsIGV2ZW50LCBvcHRpb25zLCBvbkRvbmUpIHtcbiAgICAgICAgdmFyIGFyZ3M7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICBjYXNlICdhbmltYXRlJzpcbiAgICAgICAgICAgIGFyZ3MgPSBbZWxlbWVudCwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvLCBvbkRvbmVdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzZXRDbGFzcyc6XG4gICAgICAgICAgICBhcmdzID0gW2VsZW1lbnQsIGNsYXNzZXNUb0FkZCwgY2xhc3Nlc1RvUmVtb3ZlLCBvbkRvbmVdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhZGRDbGFzcyc6XG4gICAgICAgICAgICBhcmdzID0gW2VsZW1lbnQsIGNsYXNzZXNUb0FkZCwgb25Eb25lXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmVtb3ZlQ2xhc3MnOlxuICAgICAgICAgICAgYXJncyA9IFtlbGVtZW50LCBjbGFzc2VzVG9SZW1vdmUsIG9uRG9uZV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhcmdzID0gW2VsZW1lbnQsIG9uRG9uZV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3MucHVzaChvcHRpb25zKTtcblxuICAgICAgICB2YXIgdmFsdWUgPSBmbi5hcHBseShmbiwgYXJncyk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlLnN0YXJ0KSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdGFydCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mICQkQW5pbWF0ZVJ1bm5lcikge1xuICAgICAgICAgICAgdmFsdWUuZG9uZShvbkRvbmUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIG9wdGlvbmFsIG9uRW5kIC8gb25DYW5jZWwgY2FsbGJhY2tcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ3JvdXBFdmVudGVkQW5pbWF0aW9ucyhlbGVtZW50LCBldmVudCwgb3B0aW9ucywgYW5pbWF0aW9ucywgZm5OYW1lKSB7XG4gICAgICAgIHZhciBvcGVyYXRpb25zID0gW107XG4gICAgICAgIGZvckVhY2goYW5pbWF0aW9ucywgZnVuY3Rpb24oYW5pKSB7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGFuaVtmbk5hbWVdO1xuICAgICAgICAgIGlmICghYW5pbWF0aW9uKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBub3RlIHRoYXQgYWxsIG9mIHRoZXNlIGFuaW1hdGlvbnMgd2lsbCBydW4gaW4gcGFyYWxsZWxcbiAgICAgICAgICBvcGVyYXRpb25zLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcnVubmVyO1xuICAgICAgICAgICAgdmFyIGVuZFByb2dyZXNzQ2I7XG5cbiAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG9uQW5pbWF0aW9uQ29tcGxldGUgPSBmdW5jdGlvbihyZWplY3RlZCkge1xuICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIChlbmRQcm9ncmVzc0NiIHx8IG5vb3ApKHJlamVjdGVkKTtcbiAgICAgICAgICAgICAgICBydW5uZXIuY29tcGxldGUoIXJlamVjdGVkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcnVubmVyID0gbmV3ICQkQW5pbWF0ZVJ1bm5lcih7XG4gICAgICAgICAgICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgb25BbmltYXRpb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG9uQW5pbWF0aW9uQ29tcGxldGUodHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBlbmRQcm9ncmVzc0NiID0gZXhlY3V0ZUFuaW1hdGlvbkZuKGFuaW1hdGlvbiwgZWxlbWVudCwgZXZlbnQsIG9wdGlvbnMsIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICB2YXIgY2FuY2VsbGVkID0gcmVzdWx0ID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgb25BbmltYXRpb25Db21wbGV0ZShjYW5jZWxsZWQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvcGVyYXRpb25zO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYWNrYWdlQW5pbWF0aW9ucyhlbGVtZW50LCBldmVudCwgb3B0aW9ucywgYW5pbWF0aW9ucywgZm5OYW1lKSB7XG4gICAgICAgIHZhciBvcGVyYXRpb25zID0gZ3JvdXBFdmVudGVkQW5pbWF0aW9ucyhlbGVtZW50LCBldmVudCwgb3B0aW9ucywgYW5pbWF0aW9ucywgZm5OYW1lKTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdmFyIGEsYjtcbiAgICAgICAgICBpZiAoZm5OYW1lID09PSAnYmVmb3JlU2V0Q2xhc3MnKSB7XG4gICAgICAgICAgICBhID0gZ3JvdXBFdmVudGVkQW5pbWF0aW9ucyhlbGVtZW50LCAncmVtb3ZlQ2xhc3MnLCBvcHRpb25zLCBhbmltYXRpb25zLCAnYmVmb3JlUmVtb3ZlQ2xhc3MnKTtcbiAgICAgICAgICAgIGIgPSBncm91cEV2ZW50ZWRBbmltYXRpb25zKGVsZW1lbnQsICdhZGRDbGFzcycsIG9wdGlvbnMsIGFuaW1hdGlvbnMsICdiZWZvcmVBZGRDbGFzcycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZm5OYW1lID09PSAnc2V0Q2xhc3MnKSB7XG4gICAgICAgICAgICBhID0gZ3JvdXBFdmVudGVkQW5pbWF0aW9ucyhlbGVtZW50LCAncmVtb3ZlQ2xhc3MnLCBvcHRpb25zLCBhbmltYXRpb25zLCAncmVtb3ZlQ2xhc3MnKTtcbiAgICAgICAgICAgIGIgPSBncm91cEV2ZW50ZWRBbmltYXRpb25zKGVsZW1lbnQsICdhZGRDbGFzcycsIG9wdGlvbnMsIGFuaW1hdGlvbnMsICdhZGRDbGFzcycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICBvcGVyYXRpb25zID0gb3BlcmF0aW9ucy5jb25jYXQoYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICBvcGVyYXRpb25zID0gb3BlcmF0aW9ucy5jb25jYXQoYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wZXJhdGlvbnMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgLy8gVE9ETyhtYXRza28pOiBhZGQgZG9jdW1lbnRhdGlvblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcnVubmVycyA9IFtdO1xuICAgICAgICAgIGlmIChvcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yRWFjaChvcGVyYXRpb25zLCBmdW5jdGlvbihhbmltYXRlRm4pIHtcbiAgICAgICAgICAgICAgcnVubmVycy5wdXNoKGFuaW1hdGVGbigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJ1bm5lcnMubGVuZ3RoID8gJCRBbmltYXRlUnVubmVyLmFsbChydW5uZXJzLCBjYWxsYmFjaykgOiBjYWxsYmFjaygpO1xuXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVuZEZuKHJlamVjdCkge1xuICAgICAgICAgICAgZm9yRWFjaChydW5uZXJzLCBmdW5jdGlvbihydW5uZXIpIHtcbiAgICAgICAgICAgICAgcmVqZWN0ID8gcnVubmVyLmNhbmNlbCgpIDogcnVubmVyLmVuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9va3VwQW5pbWF0aW9ucyhjbGFzc2VzKSB7XG4gICAgICBjbGFzc2VzID0gaXNBcnJheShjbGFzc2VzKSA/IGNsYXNzZXMgOiBjbGFzc2VzLnNwbGl0KCcgJyk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IFtdLCBmbGFnTWFwID0ge307XG4gICAgICBmb3IgKHZhciBpPTA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrbGFzcyA9IGNsYXNzZXNbaV0sXG4gICAgICAgICAgICBhbmltYXRpb25GYWN0b3J5ID0gJGFuaW1hdGVQcm92aWRlci4kJHJlZ2lzdGVyZWRBbmltYXRpb25zW2tsYXNzXTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbkZhY3RvcnkgJiYgIWZsYWdNYXBba2xhc3NdKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKCRpbmplY3Rvci5nZXQoYW5pbWF0aW9uRmFjdG9yeSkpO1xuICAgICAgICAgIGZsYWdNYXBba2xhc3NdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxuICB9XTtcbn1dO1xuXG52YXIgJCRBbmltYXRlSnNEcml2ZXJQcm92aWRlciA9IFsnJCRhbmltYXRpb25Qcm92aWRlcicsIGZ1bmN0aW9uKCQkYW5pbWF0aW9uUHJvdmlkZXIpIHtcbiAgJCRhbmltYXRpb25Qcm92aWRlci5kcml2ZXJzLnB1c2goJyQkYW5pbWF0ZUpzRHJpdmVyJyk7XG4gIHRoaXMuJGdldCA9IFsnJCRhbmltYXRlSnMnLCAnJCRBbmltYXRlUnVubmVyJywgZnVuY3Rpb24oJCRhbmltYXRlSnMsICQkQW5pbWF0ZVJ1bm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiBpbml0RHJpdmVyRm4oYW5pbWF0aW9uRGV0YWlscykge1xuICAgICAgaWYgKGFuaW1hdGlvbkRldGFpbHMuZnJvbSAmJiBhbmltYXRpb25EZXRhaWxzLnRvKSB7XG4gICAgICAgIHZhciBmcm9tQW5pbWF0aW9uID0gcHJlcGFyZUFuaW1hdGlvbihhbmltYXRpb25EZXRhaWxzLmZyb20pO1xuICAgICAgICB2YXIgdG9BbmltYXRpb24gPSBwcmVwYXJlQW5pbWF0aW9uKGFuaW1hdGlvbkRldGFpbHMudG8pO1xuICAgICAgICBpZiAoIWZyb21BbmltYXRpb24gJiYgIXRvQW5pbWF0aW9uKSByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uUnVubmVycyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoZnJvbUFuaW1hdGlvbikge1xuICAgICAgICAgICAgICBhbmltYXRpb25SdW5uZXJzLnB1c2goZnJvbUFuaW1hdGlvbi5zdGFydCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvblJ1bm5lcnMucHVzaCh0b0FuaW1hdGlvbi5zdGFydCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJCRBbmltYXRlUnVubmVyLmFsbChhbmltYXRpb25SdW5uZXJzLCBkb25lKTtcblxuICAgICAgICAgICAgdmFyIHJ1bm5lciA9IG5ldyAkJEFuaW1hdGVSdW5uZXIoe1xuICAgICAgICAgICAgICBlbmQ6IGVuZEZuRmFjdG9yeSgpLFxuICAgICAgICAgICAgICBjYW5jZWw6IGVuZEZuRmFjdG9yeSgpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5lcjtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZW5kRm5GYWN0b3J5KCkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChhbmltYXRpb25SdW5uZXJzLCBmdW5jdGlvbihydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgd2UgY2Fubm90IGNhbmNlbCBhbmltYXRpb25zIGZvciBncm91cHMganVzdCB5ZXQuIDEuNStcbiAgICAgICAgICAgICAgICAgIHJ1bm5lci5lbmQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZG9uZShzdGF0dXMpIHtcbiAgICAgICAgICAgICAgcnVubmVyLmNvbXBsZXRlKHN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByZXBhcmVBbmltYXRpb24oYW5pbWF0aW9uRGV0YWlscyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHByZXBhcmVBbmltYXRpb24oYW5pbWF0aW9uRGV0YWlscykge1xuICAgICAgLy8gVE9ETyhtYXRza28pOiBtYWtlIHN1cmUgdG8gY2hlY2sgZm9yIGdyb3VwZWQgYW5pbWF0aW9ucyBhbmQgZGVsZWdhdGUgZG93biB0byBub3JtYWwgYW5pbWF0aW9uc1xuICAgICAgdmFyIGVsZW1lbnQgPSBhbmltYXRpb25EZXRhaWxzLmVsZW1lbnQ7XG4gICAgICB2YXIgZXZlbnQgPSBhbmltYXRpb25EZXRhaWxzLmV2ZW50O1xuICAgICAgdmFyIG9wdGlvbnMgPSBhbmltYXRpb25EZXRhaWxzLm9wdGlvbnM7XG4gICAgICB2YXIgY2xhc3NlcyA9IGFuaW1hdGlvbkRldGFpbHMuY2xhc3NlcztcbiAgICAgIHJldHVybiAkJGFuaW1hdGVKcyhlbGVtZW50LCBldmVudCwgY2xhc3Nlcywgb3B0aW9ucyk7XG4gICAgfVxuICB9XTtcbn1dO1xuXG52YXIgTkdfQU5JTUFURV9BVFRSX05BTUUgPSAnZGF0YS1uZy1hbmltYXRlJztcbnZhciBOR19BTklNQVRFX1BJTl9EQVRBID0gJyRuZ0FuaW1hdGVQaW4nO1xudmFyICQkQW5pbWF0ZVF1ZXVlUHJvdmlkZXIgPSBbJyRhbmltYXRlUHJvdmlkZXInLCBmdW5jdGlvbigkYW5pbWF0ZVByb3ZpZGVyKSB7XG4gIHZhciBQUkVfRElHRVNUX1NUQVRFID0gMTtcbiAgdmFyIFJVTk5JTkdfU1RBVEUgPSAyO1xuXG4gIHZhciBydWxlcyA9IHRoaXMucnVsZXMgPSB7XG4gICAgc2tpcDogW10sXG4gICAgY2FuY2VsOiBbXSxcbiAgICBqb2luOiBbXVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzQWxsb3dlZChydWxlVHlwZSwgZWxlbWVudCwgY3VycmVudEFuaW1hdGlvbiwgcHJldmlvdXNBbmltYXRpb24pIHtcbiAgICByZXR1cm4gcnVsZXNbcnVsZVR5cGVdLnNvbWUoZnVuY3Rpb24oZm4pIHtcbiAgICAgIHJldHVybiBmbihlbGVtZW50LCBjdXJyZW50QW5pbWF0aW9uLCBwcmV2aW91c0FuaW1hdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNBbmltYXRpb25DbGFzc2VzKG9wdGlvbnMsIGFuZCkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBhID0gKG9wdGlvbnMuYWRkQ2xhc3MgfHwgJycpLmxlbmd0aCA+IDA7XG4gICAgdmFyIGIgPSAob3B0aW9ucy5yZW1vdmVDbGFzcyB8fCAnJykubGVuZ3RoID4gMDtcbiAgICByZXR1cm4gYW5kID8gYSAmJiBiIDogYSB8fCBiO1xuICB9XG5cbiAgcnVsZXMuam9pbi5wdXNoKGZ1bmN0aW9uKGVsZW1lbnQsIG5ld0FuaW1hdGlvbiwgY3VycmVudEFuaW1hdGlvbikge1xuICAgIC8vIGlmIHRoZSBuZXcgYW5pbWF0aW9uIGlzIGNsYXNzLWJhc2VkIHRoZW4gd2UgY2FuIGp1c3QgdGFjayB0aGF0IG9uXG4gICAgcmV0dXJuICFuZXdBbmltYXRpb24uc3RydWN0dXJhbCAmJiBoYXNBbmltYXRpb25DbGFzc2VzKG5ld0FuaW1hdGlvbi5vcHRpb25zKTtcbiAgfSk7XG5cbiAgcnVsZXMuc2tpcC5wdXNoKGZ1bmN0aW9uKGVsZW1lbnQsIG5ld0FuaW1hdGlvbiwgY3VycmVudEFuaW1hdGlvbikge1xuICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gYW5pbWF0ZSBhbnl0aGluZyBpZiBubyBjbGFzc2VzIGFyZSBiZWluZyBhZGRlZCBhbmRcbiAgICAvLyB0aGVyZSBpcyBubyBzdHJ1Y3R1cmFsIGFuaW1hdGlvbiB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkXG4gICAgcmV0dXJuICFuZXdBbmltYXRpb24uc3RydWN0dXJhbCAmJiAhaGFzQW5pbWF0aW9uQ2xhc3NlcyhuZXdBbmltYXRpb24ub3B0aW9ucyk7XG4gIH0pO1xuXG4gIHJ1bGVzLnNraXAucHVzaChmdW5jdGlvbihlbGVtZW50LCBuZXdBbmltYXRpb24sIGN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAvLyB3aHkgc2hvdWxkIHdlIHRyaWdnZXIgYSBuZXcgc3RydWN0dXJhbCBhbmltYXRpb24gaWYgdGhlIGVsZW1lbnQgd2lsbFxuICAgIC8vIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NIGFueXdheT9cbiAgICByZXR1cm4gY3VycmVudEFuaW1hdGlvbi5ldmVudCA9PSAnbGVhdmUnICYmIG5ld0FuaW1hdGlvbi5zdHJ1Y3R1cmFsO1xuICB9KTtcblxuICBydWxlcy5za2lwLnB1c2goZnVuY3Rpb24oZWxlbWVudCwgbmV3QW5pbWF0aW9uLCBjdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgLy8gaWYgdGhlcmUgaXMgYW4gb25nb2luZyBjdXJyZW50IGFuaW1hdGlvbiB0aGVuIGRvbid0IGV2ZW4gYm90aGVyIHJ1bm5pbmcgdGhlIGNsYXNzLWJhc2VkIGFuaW1hdGlvblxuICAgIHJldHVybiBjdXJyZW50QW5pbWF0aW9uLnN0cnVjdHVyYWwgJiYgY3VycmVudEFuaW1hdGlvbi5zdGF0ZSA9PT0gUlVOTklOR19TVEFURSAmJiAhbmV3QW5pbWF0aW9uLnN0cnVjdHVyYWw7XG4gIH0pO1xuXG4gIHJ1bGVzLmNhbmNlbC5wdXNoKGZ1bmN0aW9uKGVsZW1lbnQsIG5ld0FuaW1hdGlvbiwgY3VycmVudEFuaW1hdGlvbikge1xuICAgIC8vIHRoZXJlIGNhbiBuZXZlciBiZSB0d28gc3RydWN0dXJhbCBhbmltYXRpb25zIHJ1bm5pbmcgYXQgdGhlIHNhbWUgdGltZVxuICAgIHJldHVybiBjdXJyZW50QW5pbWF0aW9uLnN0cnVjdHVyYWwgJiYgbmV3QW5pbWF0aW9uLnN0cnVjdHVyYWw7XG4gIH0pO1xuXG4gIHJ1bGVzLmNhbmNlbC5wdXNoKGZ1bmN0aW9uKGVsZW1lbnQsIG5ld0FuaW1hdGlvbiwgY3VycmVudEFuaW1hdGlvbikge1xuICAgIC8vIGlmIHRoZSBwcmV2aW91cyBhbmltYXRpb24gaXMgYWxyZWFkeSBydW5uaW5nLCBidXQgdGhlIG5ldyBhbmltYXRpb24gd2lsbFxuICAgIC8vIGJlIHRyaWdnZXJlZCwgYnV0IHRoZSBuZXcgYW5pbWF0aW9uIGlzIHN0cnVjdHVyYWxcbiAgICByZXR1cm4gY3VycmVudEFuaW1hdGlvbi5zdGF0ZSA9PT0gUlVOTklOR19TVEFURSAmJiBuZXdBbmltYXRpb24uc3RydWN0dXJhbDtcbiAgfSk7XG5cbiAgcnVsZXMuY2FuY2VsLnB1c2goZnVuY3Rpb24oZWxlbWVudCwgbmV3QW5pbWF0aW9uLCBjdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgdmFyIG5PID0gbmV3QW5pbWF0aW9uLm9wdGlvbnM7XG4gICAgdmFyIGNPID0gY3VycmVudEFuaW1hdGlvbi5vcHRpb25zO1xuXG4gICAgLy8gaWYgdGhlIGV4YWN0IHNhbWUgQ1NTIGNsYXNzIGlzIGFkZGVkL3JlbW92ZWQgdGhlbiBpdCdzIHNhZmUgdG8gY2FuY2VsIGl0XG4gICAgcmV0dXJuIChuTy5hZGRDbGFzcyAmJiBuTy5hZGRDbGFzcyA9PT0gY08ucmVtb3ZlQ2xhc3MpIHx8IChuTy5yZW1vdmVDbGFzcyAmJiBuTy5yZW1vdmVDbGFzcyA9PT0gY08uYWRkQ2xhc3MpO1xuICB9KTtcblxuICB0aGlzLiRnZXQgPSBbJyQkckFGJywgJyRyb290U2NvcGUnLCAnJHJvb3RFbGVtZW50JywgJyRkb2N1bWVudCcsICckJEhhc2hNYXAnLFxuICAgICAgICAgICAgICAgJyQkYW5pbWF0aW9uJywgJyQkQW5pbWF0ZVJ1bm5lcicsICckdGVtcGxhdGVSZXF1ZXN0JywgJyQkanFMaXRlJywgJyQkZm9yY2VSZWZsb3cnLFxuICAgICAgIGZ1bmN0aW9uKCQkckFGLCAgICRyb290U2NvcGUsICAgJHJvb3RFbGVtZW50LCAgICRkb2N1bWVudCwgICAkJEhhc2hNYXAsXG4gICAgICAgICAgICAgICAgJCRhbmltYXRpb24sICAgJCRBbmltYXRlUnVubmVyLCAgICR0ZW1wbGF0ZVJlcXVlc3QsICAgJCRqcUxpdGUsICAgJCRmb3JjZVJlZmxvdykge1xuXG4gICAgdmFyIGFjdGl2ZUFuaW1hdGlvbnNMb29rdXAgPSBuZXcgJCRIYXNoTWFwKCk7XG4gICAgdmFyIGRpc2FibGVkRWxlbWVudHNMb29rdXAgPSBuZXcgJCRIYXNoTWFwKCk7XG4gICAgdmFyIGFuaW1hdGlvbnNFbmFibGVkID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHBvc3REaWdlc3RUYXNrRmFjdG9yeSgpIHtcbiAgICAgIHZhciBwb3N0RGlnZXN0Q2FsbGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgLy8gd2Ugb25seSBpc3N1ZSBhIGNhbGwgdG8gcG9zdERpZ2VzdCBiZWZvcmVcbiAgICAgICAgLy8gaXQgaGFzIGZpcnN0IHBhc3NlZC4gVGhpcyBwcmV2ZW50cyBhbnkgY2FsbGJhY2tzXG4gICAgICAgIC8vIGZyb20gbm90IGZpcmluZyBvbmNlIHRoZSBhbmltYXRpb24gaGFzIGNvbXBsZXRlZFxuICAgICAgICAvLyBzaW5jZSBpdCB3aWxsIGJlIG91dCBvZiB0aGUgZGlnZXN0IGN5Y2xlLlxuICAgICAgICBpZiAocG9zdERpZ2VzdENhbGxlZCkge1xuICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHJvb3RTY29wZS4kJHBvc3REaWdlc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwb3N0RGlnZXN0Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gV2FpdCB1bnRpbCBhbGwgZGlyZWN0aXZlIGFuZCByb3V0ZS1yZWxhdGVkIHRlbXBsYXRlcyBhcmUgZG93bmxvYWRlZCBhbmRcbiAgICAvLyBjb21waWxlZC4gVGhlICR0ZW1wbGF0ZVJlcXVlc3QudG90YWxQZW5kaW5nUmVxdWVzdHMgdmFyaWFibGUga2VlcHMgdHJhY2sgb2ZcbiAgICAvLyBhbGwgb2YgdGhlIHJlbW90ZSB0ZW1wbGF0ZXMgYmVpbmcgY3VycmVudGx5IGRvd25sb2FkZWQuIElmIHRoZXJlIGFyZSBub1xuICAgIC8vIHRlbXBsYXRlcyBjdXJyZW50bHkgZG93bmxvYWRpbmcgdGhlbiB0aGUgd2F0Y2hlciB3aWxsIHN0aWxsIGZpcmUgYW55d2F5LlxuICAgIHZhciBkZXJlZ2lzdGVyV2F0Y2ggPSAkcm9vdFNjb3BlLiR3YXRjaChcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gJHRlbXBsYXRlUmVxdWVzdC50b3RhbFBlbmRpbmdSZXF1ZXN0cyA9PT0gMDsgfSxcbiAgICAgIGZ1bmN0aW9uKGlzRW1wdHkpIHtcbiAgICAgICAgaWYgKCFpc0VtcHR5KSByZXR1cm47XG4gICAgICAgIGRlcmVnaXN0ZXJXYXRjaCgpO1xuXG4gICAgICAgIC8vIE5vdyB0aGF0IGFsbCB0ZW1wbGF0ZXMgaGF2ZSBiZWVuIGRvd25sb2FkZWQsICRhbmltYXRlIHdpbGwgd2FpdCB1bnRpbFxuICAgICAgICAvLyB0aGUgcG9zdCBkaWdlc3QgcXVldWUgaXMgZW1wdHkgYmVmb3JlIGVuYWJsaW5nIGFuaW1hdGlvbnMuIEJ5IGhhdmluZyB0d29cbiAgICAgICAgLy8gY2FsbHMgdG8gJHBvc3REaWdlc3QgY2FsbHMgd2UgY2FuIGVuc3VyZSB0aGF0IHRoZSBmbGFnIGlzIGVuYWJsZWQgYXQgdGhlXG4gICAgICAgIC8vIHZlcnkgZW5kIG9mIHRoZSBwb3N0IGRpZ2VzdCBxdWV1ZS4gU2luY2UgYWxsIG9mIHRoZSBhbmltYXRpb25zIGluICRhbmltYXRlXG4gICAgICAgIC8vIHVzZSAkcG9zdERpZ2VzdCwgaXQncyBpbXBvcnRhbnQgdGhhdCB0aGUgY29kZSBiZWxvdyBleGVjdXRlcyBhdCB0aGUgZW5kLlxuICAgICAgICAvLyBUaGlzIGJhc2ljYWxseSBtZWFucyB0aGF0IHRoZSBwYWdlIGlzIGZ1bGx5IGRvd25sb2FkZWQgYW5kIGNvbXBpbGVkIGJlZm9yZVxuICAgICAgICAvLyBhbnkgYW5pbWF0aW9ucyBhcmUgdHJpZ2dlcmVkLlxuICAgICAgICAkcm9vdFNjb3BlLiQkcG9zdERpZ2VzdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiQkcG9zdERpZ2VzdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHdlIGNoZWNrIGZvciBudWxsIGRpcmVjdGx5IGluIHRoZSBldmVudCB0aGF0IHRoZSBhcHBsaWNhdGlvbiBhbHJlYWR5IGNhbGxlZFxuICAgICAgICAgICAgLy8gLmVuYWJsZWQoKSB3aXRoIHdoYXRldmVyIGFyZ3VtZW50cyB0aGF0IGl0IHByb3ZpZGVkIGl0IHdpdGhcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25zRW5hYmxlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhbmltYXRpb25zRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgY2FsbGJhY2tSZWdpc3RyeSA9IHt9O1xuXG4gICAgLy8gcmVtZW1iZXIgdGhhdCB0aGUgY2xhc3NOYW1lRmlsdGVyIGlzIHNldCBkdXJpbmcgdGhlIHByb3ZpZGVyL2NvbmZpZ1xuICAgIC8vIHN0YWdlIHRoZXJlZm9yZSB3ZSBjYW4gb3B0aW1pemUgaGVyZSBhbmQgc2V0dXAgYSBoZWxwZXIgZnVuY3Rpb25cbiAgICB2YXIgY2xhc3NOYW1lRmlsdGVyID0gJGFuaW1hdGVQcm92aWRlci5jbGFzc05hbWVGaWx0ZXIoKTtcbiAgICB2YXIgaXNBbmltYXRhYmxlQ2xhc3NOYW1lID0gIWNsYXNzTmFtZUZpbHRlclxuICAgICAgICAgICAgICA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWVGaWx0ZXIudGVzdChjbGFzc05hbWUpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgdmFyIGFwcGx5QW5pbWF0aW9uQ2xhc3NlcyA9IGFwcGx5QW5pbWF0aW9uQ2xhc3Nlc0ZhY3RvcnkoJCRqcUxpdGUpO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbWVyZ2VBbmltYXRpb25PcHRpb25zKGVsZW1lbnQsIG9wdGlvbnMsIHt9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kQ2FsbGJhY2tzKGVsZW1lbnQsIGV2ZW50KSB7XG4gICAgICB2YXIgdGFyZ2V0Tm9kZSA9IGdldERvbU5vZGUoZWxlbWVudCk7XG5cbiAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICB2YXIgZW50cmllcyA9IGNhbGxiYWNrUmVnaXN0cnlbZXZlbnRdO1xuICAgICAgaWYgKGVudHJpZXMpIHtcbiAgICAgICAgZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgIGlmIChlbnRyeS5ub2RlLmNvbnRhaW5zKHRhcmdldE5vZGUpKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkuY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbjogZnVuY3Rpb24oZXZlbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG5vZGUgPSBleHRyYWN0RWxlbWVudE5vZGUoY29udGFpbmVyKTtcbiAgICAgICAgY2FsbGJhY2tSZWdpc3RyeVtldmVudF0gPSBjYWxsYmFja1JlZ2lzdHJ5W2V2ZW50XSB8fCBbXTtcbiAgICAgICAgY2FsbGJhY2tSZWdpc3RyeVtldmVudF0ucHVzaCh7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlbnRyaWVzID0gY2FsbGJhY2tSZWdpc3RyeVtldmVudF07XG4gICAgICAgIGlmICghZW50cmllcykgcmV0dXJuO1xuXG4gICAgICAgIGNhbGxiYWNrUmVnaXN0cnlbZXZlbnRdID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IGZpbHRlckZyb21SZWdpc3RyeShlbnRyaWVzLCBjb250YWluZXIsIGNhbGxiYWNrKTtcblxuICAgICAgICBmdW5jdGlvbiBmaWx0ZXJGcm9tUmVnaXN0cnkobGlzdCwgbWF0Y2hDb250YWluZXIsIG1hdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyTm9kZSA9IGV4dHJhY3RFbGVtZW50Tm9kZShtYXRjaENvbnRhaW5lcik7XG4gICAgICAgICAgcmV0dXJuIGxpc3QuZmlsdGVyKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgaXNNYXRjaCA9IGVudHJ5Lm5vZGUgPT09IGNvbnRhaW5lck5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIW1hdGNoQ2FsbGJhY2sgfHwgZW50cnkuY2FsbGJhY2sgPT09IG1hdGNoQ2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuICFpc01hdGNoO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBwaW46IGZ1bmN0aW9uKGVsZW1lbnQsIHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgYXNzZXJ0QXJnKGlzRWxlbWVudChlbGVtZW50KSwgJ2VsZW1lbnQnLCAnbm90IGFuIGVsZW1lbnQnKTtcbiAgICAgICAgYXNzZXJ0QXJnKGlzRWxlbWVudChwYXJlbnRFbGVtZW50KSwgJ3BhcmVudEVsZW1lbnQnLCAnbm90IGFuIGVsZW1lbnQnKTtcbiAgICAgICAgZWxlbWVudC5kYXRhKE5HX0FOSU1BVEVfUElOX0RBVEEsIHBhcmVudEVsZW1lbnQpO1xuICAgICAgfSxcblxuICAgICAgcHVzaDogZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQsIG9wdGlvbnMsIGRvbU9wZXJhdGlvbikge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5kb21PcGVyYXRpb24gPSBkb21PcGVyYXRpb247XG4gICAgICAgIHJldHVybiBxdWV1ZUFuaW1hdGlvbihlbGVtZW50LCBldmVudCwgb3B0aW9ucyk7XG4gICAgICB9LFxuXG4gICAgICAvLyB0aGlzIG1ldGhvZCBoYXMgZm91ciBzaWduYXR1cmVzOlxuICAgICAgLy8gICgpIC0gZ2xvYmFsIGdldHRlclxuICAgICAgLy8gIChib29sKSAtIGdsb2JhbCBzZXR0ZXJcbiAgICAgIC8vICAoZWxlbWVudCkgLSBlbGVtZW50IGdldHRlclxuICAgICAgLy8gIChlbGVtZW50LCBib29sKSAtIGVsZW1lbnQgc2V0dGVyPEYzNz5cbiAgICAgIGVuYWJsZWQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGJvb2wpIHtcbiAgICAgICAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgICBpZiAoYXJnQ291bnQgPT09IDApIHtcbiAgICAgICAgICAvLyAoKSAtIEdsb2JhbCBnZXR0ZXJcbiAgICAgICAgICBib29sID0gISFhbmltYXRpb25zRW5hYmxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaGFzRWxlbWVudCA9IGlzRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGlmICghaGFzRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gKGJvb2wpIC0gR2xvYmFsIHNldHRlclxuICAgICAgICAgICAgYm9vbCA9IGFuaW1hdGlvbnNFbmFibGVkID0gISFlbGVtZW50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGdldERvbU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgcmVjb3JkRXhpc3RzID0gZGlzYWJsZWRFbGVtZW50c0xvb2t1cC5nZXQobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChhcmdDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAvLyAoZWxlbWVudCkgLSBFbGVtZW50IGdldHRlclxuICAgICAgICAgICAgICBib29sID0gIXJlY29yZEV4aXN0cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIChlbGVtZW50LCBib29sKSAtIEVsZW1lbnQgc2V0dGVyXG4gICAgICAgICAgICAgIGJvb2wgPSAhIWJvb2w7XG4gICAgICAgICAgICAgIGlmICghYm9vbCkge1xuICAgICAgICAgICAgICAgIGRpc2FibGVkRWxlbWVudHNMb29rdXAucHV0KG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZEV4aXN0cykge1xuICAgICAgICAgICAgICAgIGRpc2FibGVkRWxlbWVudHNMb29rdXAucmVtb3ZlKG5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHF1ZXVlQW5pbWF0aW9uKGVsZW1lbnQsIGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbm9kZSwgcGFyZW50O1xuICAgICAgZWxlbWVudCA9IHN0cmlwQ29tbWVudHNGcm9tRWxlbWVudChlbGVtZW50KTtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIG5vZGUgPSBnZXREb21Ob2RlKGVsZW1lbnQpO1xuICAgICAgICBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCgpO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgIC8vIHdlIGNyZWF0ZSBhIGZha2UgcnVubmVyIHdpdGggYSB3b3JraW5nIHByb21pc2UuXG4gICAgICAvLyBUaGVzZSBtZXRob2RzIHdpbGwgYmVjb21lIGF2YWlsYWJsZSBhZnRlciB0aGUgZGlnZXN0IGhhcyBwYXNzZWRcbiAgICAgIHZhciBydW5uZXIgPSBuZXcgJCRBbmltYXRlUnVubmVyKCk7XG5cbiAgICAgIC8vIHRoaXMgaXMgdXNlZCB0byB0cmlnZ2VyIGNhbGxiYWNrcyBpbiBwb3N0RGlnZXN0IG1vZGVcbiAgICAgIHZhciBydW5Jbk5leHRQb3N0RGlnZXN0T3JOb3cgPSBwb3N0RGlnZXN0VGFza0ZhY3RvcnkoKTtcblxuICAgICAgaWYgKGlzQXJyYXkob3B0aW9ucy5hZGRDbGFzcykpIHtcbiAgICAgICAgb3B0aW9ucy5hZGRDbGFzcyA9IG9wdGlvbnMuYWRkQ2xhc3Muam9pbignICcpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hZGRDbGFzcyAmJiAhaXNTdHJpbmcob3B0aW9ucy5hZGRDbGFzcykpIHtcbiAgICAgICAgb3B0aW9ucy5hZGRDbGFzcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG9wdGlvbnMucmVtb3ZlQ2xhc3MpKSB7XG4gICAgICAgIG9wdGlvbnMucmVtb3ZlQ2xhc3MgPSBvcHRpb25zLnJlbW92ZUNsYXNzLmpvaW4oJyAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlQ2xhc3MgJiYgIWlzU3RyaW5nKG9wdGlvbnMucmVtb3ZlQ2xhc3MpKSB7XG4gICAgICAgIG9wdGlvbnMucmVtb3ZlQ2xhc3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5mcm9tICYmICFpc09iamVjdChvcHRpb25zLmZyb20pKSB7XG4gICAgICAgIG9wdGlvbnMuZnJvbSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRvICYmICFpc09iamVjdChvcHRpb25zLnRvKSkge1xuICAgICAgICBvcHRpb25zLnRvID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gdGhlcmUgYXJlIHNpdHVhdGlvbnMgd2hlcmUgYSBkaXJlY3RpdmUgaXNzdWVzIGFuIGFuaW1hdGlvbiBmb3JcbiAgICAgIC8vIGEganFMaXRlIHdyYXBwZXIgdGhhdCBjb250YWlucyBvbmx5IGNvbW1lbnQgbm9kZXMuLi4gSWYgdGhpc1xuICAgICAgLy8gaGFwcGVucyB0aGVuIHRoZXJlIGlzIG5vIHdheSB3ZSBjYW4gcGVyZm9ybSBhbiBhbmltYXRpb25cbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xhc3NOYW1lID0gW25vZGUuY2xhc3NOYW1lLCBvcHRpb25zLmFkZENsYXNzLCBvcHRpb25zLnJlbW92ZUNsYXNzXS5qb2luKCcgJyk7XG4gICAgICBpZiAoIWlzQW5pbWF0YWJsZUNsYXNzTmFtZShjbGFzc05hbWUpKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1N0cnVjdHVyYWwgPSBbJ2VudGVyJywgJ21vdmUnLCAnbGVhdmUnXS5pbmRleE9mKGV2ZW50KSA+PSAwO1xuXG4gICAgICAvLyB0aGlzIGlzIGEgaGFyZCBkaXNhYmxlIG9mIGFsbCBhbmltYXRpb25zIGZvciB0aGUgYXBwbGljYXRpb24gb3Igb25cbiAgICAgIC8vIHRoZSBlbGVtZW50IGl0c2VsZiwgdGhlcmVmb3JlICB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbnRpbnVlIGZ1cnRoZXJcbiAgICAgIC8vIHBhc3QgdGhpcyBwb2ludCBpZiBub3QgZW5hYmxlZFxuICAgICAgdmFyIHNraXBBbmltYXRpb25zID0gIWFuaW1hdGlvbnNFbmFibGVkIHx8IGRpc2FibGVkRWxlbWVudHNMb29rdXAuZ2V0KG5vZGUpO1xuICAgICAgdmFyIGV4aXN0aW5nQW5pbWF0aW9uID0gKCFza2lwQW5pbWF0aW9ucyAmJiBhY3RpdmVBbmltYXRpb25zTG9va3VwLmdldChub2RlKSkgfHwge307XG4gICAgICB2YXIgaGFzRXhpc3RpbmdBbmltYXRpb24gPSAhIWV4aXN0aW5nQW5pbWF0aW9uLnN0YXRlO1xuXG4gICAgICAvLyB0aGVyZSBpcyBubyBwb2ludCBpbiB0cmF2ZXJzaW5nIHRoZSBzYW1lIGNvbGxlY3Rpb24gb2YgcGFyZW50IGFuY2VzdG9ycyBpZiBhIGZvbGxvd3VwXG4gICAgICAvLyBhbmltYXRpb24gd2lsbCBiZSBydW4gb24gdGhlIHNhbWUgZWxlbWVudCB0aGF0IGFscmVhZHkgZGlkIGFsbCB0aGF0IGNoZWNraW5nIHdvcmtcbiAgICAgIGlmICghc2tpcEFuaW1hdGlvbnMgJiYgKCFoYXNFeGlzdGluZ0FuaW1hdGlvbiB8fCBleGlzdGluZ0FuaW1hdGlvbi5zdGF0ZSAhPSBQUkVfRElHRVNUX1NUQVRFKSkge1xuICAgICAgICBza2lwQW5pbWF0aW9ucyA9ICFhcmVBbmltYXRpb25zQWxsb3dlZChlbGVtZW50LCBwYXJlbnQsIGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNraXBBbmltYXRpb25zKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cnVjdHVyYWwpIHtcbiAgICAgICAgY2xvc2VDaGlsZEFuaW1hdGlvbnMoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdBbmltYXRpb24gPSB7XG4gICAgICAgIHN0cnVjdHVyYWw6IGlzU3RydWN0dXJhbCxcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBjbG9zZTogY2xvc2UsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIHJ1bm5lcjogcnVubmVyXG4gICAgICB9O1xuXG4gICAgICBpZiAoaGFzRXhpc3RpbmdBbmltYXRpb24pIHtcbiAgICAgICAgdmFyIHNraXBBbmltYXRpb25GbGFnID0gaXNBbGxvd2VkKCdza2lwJywgZWxlbWVudCwgbmV3QW5pbWF0aW9uLCBleGlzdGluZ0FuaW1hdGlvbik7XG4gICAgICAgIGlmIChza2lwQW5pbWF0aW9uRmxhZykge1xuICAgICAgICAgIGlmIChleGlzdGluZ0FuaW1hdGlvbi5zdGF0ZSA9PT0gUlVOTklOR19TVEFURSkge1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlQW5pbWF0aW9uT3B0aW9ucyhlbGVtZW50LCBleGlzdGluZ0FuaW1hdGlvbi5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0FuaW1hdGlvbi5ydW5uZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbmNlbEFuaW1hdGlvbkZsYWcgPSBpc0FsbG93ZWQoJ2NhbmNlbCcsIGVsZW1lbnQsIG5ld0FuaW1hdGlvbiwgZXhpc3RpbmdBbmltYXRpb24pO1xuICAgICAgICBpZiAoY2FuY2VsQW5pbWF0aW9uRmxhZykge1xuICAgICAgICAgIGlmIChleGlzdGluZ0FuaW1hdGlvbi5zdGF0ZSA9PT0gUlVOTklOR19TVEFURSkge1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGVuZCB0aGUgYW5pbWF0aW9uIHJpZ2h0IGF3YXkgYW5kIGl0IGlzIHNhZmVcbiAgICAgICAgICAgIC8vIHRvIGRvIHNvIHNpbmNlIHRoZSBhbmltYXRpb24gaXMgYWxyZWFkeSBydW5uaW5nIGFuZCB0aGVcbiAgICAgICAgICAgIC8vIHJ1bm5lciBjYWxsYmFjayBjb2RlIHdpbGwgcnVuIGluIGFzeW5jXG4gICAgICAgICAgICBleGlzdGluZ0FuaW1hdGlvbi5ydW5uZXIuZW5kKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0FuaW1hdGlvbi5zdHJ1Y3R1cmFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIGFuaW1hdGlvbiBpcyBxdWV1ZWQgaW50byBhIGRpZ2VzdCwgYnV0XG4gICAgICAgICAgICAvLyBoYXNuJ3Qgc3RhcnRlZCB5ZXQuIFRoZXJlZm9yZSBpdCBpcyBzYWZlIHRvIHJ1biB0aGUgY2xvc2VcbiAgICAgICAgICAgIC8vIG1ldGhvZCB3aGljaCB3aWxsIGNhbGwgdGhlIHJ1bm5lciBtZXRob2RzIGluIGFzeW5jLlxuICAgICAgICAgICAgZXhpc3RpbmdBbmltYXRpb24uY2xvc2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG1lcmdlIHRoZSBuZXcgYW5pbWF0aW9uIG9wdGlvbnMgaW50byBleGlzdGluZyBhbmltYXRpb24gb3B0aW9uc1xuICAgICAgICAgICAgbWVyZ2VBbmltYXRpb25PcHRpb25zKGVsZW1lbnQsIGV4aXN0aW5nQW5pbWF0aW9uLm9wdGlvbnMsIG5ld0FuaW1hdGlvbi5vcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0FuaW1hdGlvbi5ydW5uZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGEgam9pbmVkIGFuaW1hdGlvbiBtZWFucyB0aGF0IHRoaXMgYW5pbWF0aW9uIHdpbGwgdGFrZSBvdmVyIHRoZSBleGlzdGluZyBvbmVcbiAgICAgICAgICAvLyBzbyBhbiBleGFtcGxlIHdvdWxkIGludm9sdmUgYSBsZWF2ZSBhbmltYXRpb24gdGFraW5nIG92ZXIgYW4gZW50ZXIuIFRoZW4gd2hlblxuICAgICAgICAgIC8vIHRoZSBwb3N0RGlnZXN0IGtpY2tzIGluIHRoZSBlbnRlciB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICAgICAgdmFyIGpvaW5BbmltYXRpb25GbGFnID0gaXNBbGxvd2VkKCdqb2luJywgZWxlbWVudCwgbmV3QW5pbWF0aW9uLCBleGlzdGluZ0FuaW1hdGlvbik7XG4gICAgICAgICAgaWYgKGpvaW5BbmltYXRpb25GbGFnKSB7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdBbmltYXRpb24uc3RhdGUgPT09IFJVTk5JTkdfU1RBVEUpIHtcbiAgICAgICAgICAgICAgbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFwcGx5R2VuZXJhdGVkUHJlcGFyYXRpb25DbGFzc2VzKGVsZW1lbnQsIGlzU3RydWN0dXJhbCA/IGV2ZW50IDogbnVsbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgZXZlbnQgPSBuZXdBbmltYXRpb24uZXZlbnQgPSBleGlzdGluZ0FuaW1hdGlvbi5ldmVudDtcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IG1lcmdlQW5pbWF0aW9uT3B0aW9ucyhlbGVtZW50LCBleGlzdGluZ0FuaW1hdGlvbi5vcHRpb25zLCBuZXdBbmltYXRpb24ub3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgLy93ZSByZXR1cm4gdGhlIHNhbWUgcnVubmVyIHNpbmNlIG9ubHkgdGhlIG9wdGlvbiB2YWx1ZXMgb2YgdGhpcyBhbmltYXRpb24gd2lsbFxuICAgICAgICAgICAgICAvL2JlIGZlZCBpbnRvIHRoZSBgZXhpc3RpbmdBbmltYXRpb25gLlxuICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBbmltYXRpb24ucnVubmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm9ybWFsaXphdGlvbiBpbiB0aGlzIGNhc2UgbWVhbnMgdGhhdCBpdCByZW1vdmVzIHJlZHVuZGFudCBDU1MgY2xhc3NlcyB0aGF0XG4gICAgICAgIC8vIGFscmVhZHkgZXhpc3QgKGFkZENsYXNzKSBvciBkbyBub3QgZXhpc3QgKHJlbW92ZUNsYXNzKSBvbiB0aGUgZWxlbWVudFxuICAgICAgICBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyB3aGVuIHRoZSBvcHRpb25zIGFyZSBtZXJnZWQgYW5kIGNsZWFuZWQgdXAgd2UgbWF5IGVuZCB1cCBub3QgaGF2aW5nIHRvIGRvXG4gICAgICAvLyBhbiBhbmltYXRpb24gYXQgYWxsLCB0aGVyZWZvcmUgd2Ugc2hvdWxkIGNoZWNrIHRoaXMgYmVmb3JlIGlzc3VpbmcgYSBwb3N0XG4gICAgICAvLyBkaWdlc3QgY2FsbGJhY2suIFN0cnVjdHVyYWwgYW5pbWF0aW9ucyB3aWxsIGFsd2F5cyBydW4gbm8gbWF0dGVyIHdoYXQuXG4gICAgICB2YXIgaXNWYWxpZEFuaW1hdGlvbiA9IG5ld0FuaW1hdGlvbi5zdHJ1Y3R1cmFsO1xuICAgICAgaWYgKCFpc1ZhbGlkQW5pbWF0aW9uKSB7XG4gICAgICAgIC8vIGFuaW1hdGUgKGZyb20vdG8pIGNhbiBiZSBxdWlja2x5IGNoZWNrZWQgZmlyc3QsIG90aGVyd2lzZSB3ZSBjaGVjayBpZiBhbnkgY2xhc3NlcyBhcmUgcHJlc2VudFxuICAgICAgICBpc1ZhbGlkQW5pbWF0aW9uID0gKG5ld0FuaW1hdGlvbi5ldmVudCA9PT0gJ2FuaW1hdGUnICYmIE9iamVjdC5rZXlzKG5ld0FuaW1hdGlvbi5vcHRpb25zLnRvIHx8IHt9KS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGhhc0FuaW1hdGlvbkNsYXNzZXMobmV3QW5pbWF0aW9uLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzVmFsaWRBbmltYXRpb24pIHtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgY2xlYXJFbGVtZW50QW5pbWF0aW9uU3RhdGUoZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBjb3VudGVyIGtlZXBzIHRyYWNrIG9mIGNhbmNlbGxlZCBhbmltYXRpb25zXG4gICAgICB2YXIgY291bnRlciA9IChleGlzdGluZ0FuaW1hdGlvbi5jb3VudGVyIHx8IDApICsgMTtcbiAgICAgIG5ld0FuaW1hdGlvbi5jb3VudGVyID0gY291bnRlcjtcblxuICAgICAgbWFya0VsZW1lbnRBbmltYXRpb25TdGF0ZShlbGVtZW50LCBQUkVfRElHRVNUX1NUQVRFLCBuZXdBbmltYXRpb24pO1xuXG4gICAgICAkcm9vdFNjb3BlLiQkcG9zdERpZ2VzdChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbkRldGFpbHMgPSBhY3RpdmVBbmltYXRpb25zTG9va3VwLmdldChub2RlKTtcbiAgICAgICAgdmFyIGFuaW1hdGlvbkNhbmNlbGxlZCA9ICFhbmltYXRpb25EZXRhaWxzO1xuICAgICAgICBhbmltYXRpb25EZXRhaWxzID0gYW5pbWF0aW9uRGV0YWlscyB8fCB7fTtcblxuICAgICAgICAvLyBpZiBhZGRDbGFzcy9yZW1vdmVDbGFzcyBpcyBjYWxsZWQgYmVmb3JlIHNvbWV0aGluZyBsaWtlIGVudGVyIHRoZW4gdGhlXG4gICAgICAgIC8vIHJlZ2lzdGVyZWQgcGFyZW50IGVsZW1lbnQgbWF5IG5vdCBiZSBwcmVzZW50LiBUaGUgY29kZSBiZWxvdyB3aWxsIGVuc3VyZVxuICAgICAgICAvLyB0aGF0IGEgZmluYWwgdmFsdWUgZm9yIHBhcmVudCBlbGVtZW50IGlzIG9idGFpbmVkXG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gZWxlbWVudC5wYXJlbnQoKSB8fCBbXTtcblxuICAgICAgICAvLyBhbmltYXRlL3N0cnVjdHVyYWwvY2xhc3MtYmFzZWQgYW5pbWF0aW9ucyBhbGwgaGF2ZSByZXF1aXJlbWVudHMuIE90aGVyd2lzZSB0aGVyZVxuICAgICAgICAvLyBpcyBubyBwb2ludCBpbiBwZXJmb3JtaW5nIGFuIGFuaW1hdGlvbi4gVGhlIHBhcmVudCBub2RlIG11c3QgYWxzbyBiZSBzZXQuXG4gICAgICAgIHZhciBpc1ZhbGlkQW5pbWF0aW9uID0gcGFyZW50RWxlbWVudC5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChhbmltYXRpb25EZXRhaWxzLmV2ZW50ID09PSAnYW5pbWF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGFuaW1hdGlvbkRldGFpbHMuc3RydWN0dXJhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgaGFzQW5pbWF0aW9uQ2xhc3NlcyhhbmltYXRpb25EZXRhaWxzLm9wdGlvbnMpKTtcblxuICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIHByZXZpb3VzIGFuaW1hdGlvbiB3YXMgY2FuY2VsbGVkXG4gICAgICAgIC8vIGV2ZW4gaWYgdGhlIGZvbGxvdy11cCBhbmltYXRpb24gaXMgdGhlIHNhbWUgZXZlbnRcbiAgICAgICAgaWYgKGFuaW1hdGlvbkNhbmNlbGxlZCB8fCBhbmltYXRpb25EZXRhaWxzLmNvdW50ZXIgIT09IGNvdW50ZXIgfHwgIWlzVmFsaWRBbmltYXRpb24pIHtcbiAgICAgICAgICAvLyBpZiBhbm90aGVyIGFuaW1hdGlvbiBkaWQgbm90IHRha2Ugb3ZlciB0aGVuIHdlIG5lZWRcbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgdGhhdCB0aGUgZG9tT3BlcmF0aW9uIGFuZCBvcHRpb25zIGFyZVxuICAgICAgICAgIC8vIGhhbmRsZWQgYWNjb3JkaW5nbHlcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBhcHBseUFuaW1hdGlvbkNsYXNzZXMoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBhcHBseUFuaW1hdGlvblN0eWxlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGUgZXZlbnQgY2hhbmdlZCBmcm9tIHNvbWV0aGluZyBsaWtlIGVudGVyIHRvIGxlYXZlIHRoZW4gd2UgZG9cbiAgICAgICAgICAvLyBpdCwgb3RoZXJ3aXNlIGlmIGl0J3MgdGhlIHNhbWUgdGhlbiB0aGUgZW5kIHJlc3VsdCB3aWxsIGJlIHRoZSBzYW1lIHRvb1xuICAgICAgICAgIGlmIChhbmltYXRpb25DYW5jZWxsZWQgfHwgKGlzU3RydWN0dXJhbCAmJiBhbmltYXRpb25EZXRhaWxzLmV2ZW50ICE9PSBldmVudCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZG9tT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICBydW5uZXIuZW5kKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaW4gdGhlIGV2ZW50IHRoYXQgdGhlIGVsZW1lbnQgYW5pbWF0aW9uIHdhcyBub3QgY2FuY2VsbGVkIG9yIGEgZm9sbG93LXVwIGFuaW1hdGlvblxuICAgICAgICAgIC8vIGlzbid0IGFsbG93ZWQgdG8gYW5pbWF0ZSBmcm9tIGhlcmUgdGhlbiB3ZSBuZWVkIHRvIGNsZWFyIHRoZSBzdGF0ZSBvZiB0aGUgZWxlbWVudFxuICAgICAgICAgIC8vIHNvIHRoYXQgYW55IGZ1dHVyZSBhbmltYXRpb25zIHdvbid0IHJlYWQgdGhlIGV4cGlyZWQgYW5pbWF0aW9uIGRhdGEuXG4gICAgICAgICAgaWYgKCFpc1ZhbGlkQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBjbGVhckVsZW1lbnRBbmltYXRpb25TdGF0ZShlbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzIGNvbWJpbmVkIG11bHRpcGxlIGNsYXNzIHRvIGFkZENsYXNzIC8gcmVtb3ZlQ2xhc3MgaW50byBhIHNldENsYXNzIGV2ZW50XG4gICAgICAgIC8vIHNvIGxvbmcgYXMgYSBzdHJ1Y3R1cmFsIGV2ZW50IGRpZCBub3QgdGFrZSBvdmVyIHRoZSBhbmltYXRpb25cbiAgICAgICAgZXZlbnQgPSAhYW5pbWF0aW9uRGV0YWlscy5zdHJ1Y3R1cmFsICYmIGhhc0FuaW1hdGlvbkNsYXNzZXMoYW5pbWF0aW9uRGV0YWlscy5vcHRpb25zLCB0cnVlKVxuICAgICAgICAgICAgPyAnc2V0Q2xhc3MnXG4gICAgICAgICAgICA6IGFuaW1hdGlvbkRldGFpbHMuZXZlbnQ7XG5cbiAgICAgICAgbWFya0VsZW1lbnRBbmltYXRpb25TdGF0ZShlbGVtZW50LCBSVU5OSU5HX1NUQVRFKTtcbiAgICAgICAgdmFyIHJlYWxSdW5uZXIgPSAkJGFuaW1hdGlvbihlbGVtZW50LCBldmVudCwgYW5pbWF0aW9uRGV0YWlscy5vcHRpb25zKTtcblxuICAgICAgICByZWFsUnVubmVyLmRvbmUoZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICAgICAgY2xvc2UoIXN0YXR1cyk7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvbkRldGFpbHMgPSBhY3RpdmVBbmltYXRpb25zTG9va3VwLmdldChub2RlKTtcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uRGV0YWlscyAmJiBhbmltYXRpb25EZXRhaWxzLmNvdW50ZXIgPT09IGNvdW50ZXIpIHtcbiAgICAgICAgICAgIGNsZWFyRWxlbWVudEFuaW1hdGlvblN0YXRlKGdldERvbU5vZGUoZWxlbWVudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub3RpZnlQcm9ncmVzcyhydW5uZXIsIGV2ZW50LCAnY2xvc2UnLCB7fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoaXMgd2lsbCB1cGRhdGUgdGhlIHJ1bm5lcidzIGZsb3ctY29udHJvbCBldmVudHMgYmFzZWQgb25cbiAgICAgICAgLy8gdGhlIGByZWFsUnVubmVyYCBvYmplY3QuXG4gICAgICAgIHJ1bm5lci5zZXRIb3N0KHJlYWxSdW5uZXIpO1xuICAgICAgICBub3RpZnlQcm9ncmVzcyhydW5uZXIsIGV2ZW50LCAnc3RhcnQnLCB7fSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJ1bm5lcjtcblxuICAgICAgZnVuY3Rpb24gbm90aWZ5UHJvZ3Jlc3MocnVubmVyLCBldmVudCwgcGhhc2UsIGRhdGEpIHtcbiAgICAgICAgcnVuSW5OZXh0UG9zdERpZ2VzdE9yTm93KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBmaW5kQ2FsbGJhY2tzKGVsZW1lbnQsIGV2ZW50KTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gZG8gbm90IG9wdGltaXplIHRoaXMgY2FsbCBoZXJlIHRvIFJBRiBiZWNhdXNlXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBrbm93IGhvdyBoZWF2eSB0aGUgY2FsbGJhY2sgY29kZSBoZXJlIHdpbGxcbiAgICAgICAgICAgIC8vIGJlIGFuZCBpZiB0aGlzIGNvZGUgaXMgYnVmZmVyZWQgdGhlbiB0aGlzIGNhblxuICAgICAgICAgICAgLy8gbGVhZCB0byBhIHBlcmZvcm1hbmNlIHJlZ3Jlc3Npb24uXG4gICAgICAgICAgICAkJHJBRihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZm9yRWFjaChjYWxsYmFja3MsIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZWxlbWVudCwgcGhhc2UsIGRhdGEpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJ1bm5lci5wcm9ncmVzcyhldmVudCwgcGhhc2UsIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbG9zZShyZWplY3QpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgIGNsZWFyR2VuZXJhdGVkQ2xhc3NlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgYXBwbHlBbmltYXRpb25DbGFzc2VzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBhcHBseUFuaW1hdGlvblN0eWxlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5kb21PcGVyYXRpb24oKTtcbiAgICAgICAgcnVubmVyLmNvbXBsZXRlKCFyZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlQ2hpbGRBbmltYXRpb25zKGVsZW1lbnQpIHtcbiAgICAgIHZhciBub2RlID0gZ2V0RG9tTm9kZShlbGVtZW50KTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnWycgKyBOR19BTklNQVRFX0FUVFJfTkFNRSArICddJyk7XG4gICAgICBmb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBwYXJzZUludChjaGlsZC5nZXRBdHRyaWJ1dGUoTkdfQU5JTUFURV9BVFRSX05BTUUpKTtcbiAgICAgICAgdmFyIGFuaW1hdGlvbkRldGFpbHMgPSBhY3RpdmVBbmltYXRpb25zTG9va3VwLmdldChjaGlsZCk7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICBjYXNlIFJVTk5JTkdfU1RBVEU6XG4gICAgICAgICAgICBhbmltYXRpb25EZXRhaWxzLnJ1bm5lci5lbmQoKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlIFBSRV9ESUdFU1RfU1RBVEU6XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGV0YWlscykge1xuICAgICAgICAgICAgICBhY3RpdmVBbmltYXRpb25zTG9va3VwLnJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJFbGVtZW50QW5pbWF0aW9uU3RhdGUoZWxlbWVudCkge1xuICAgICAgdmFyIG5vZGUgPSBnZXREb21Ob2RlKGVsZW1lbnQpO1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoTkdfQU5JTUFURV9BVFRSX05BTUUpO1xuICAgICAgYWN0aXZlQW5pbWF0aW9uc0xvb2t1cC5yZW1vdmUobm9kZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNYXRjaGluZ0VsZW1lbnQobm9kZU9yRWxtQSwgbm9kZU9yRWxtQikge1xuICAgICAgcmV0dXJuIGdldERvbU5vZGUobm9kZU9yRWxtQSkgPT09IGdldERvbU5vZGUobm9kZU9yRWxtQik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXJlQW5pbWF0aW9uc0FsbG93ZWQoZWxlbWVudCwgcGFyZW50RWxlbWVudCwgZXZlbnQpIHtcbiAgICAgIHZhciBib2R5RWxlbWVudCA9IGpxTGl0ZSgkZG9jdW1lbnRbMF0uYm9keSk7XG4gICAgICB2YXIgYm9keUVsZW1lbnREZXRlY3RlZCA9IGlzTWF0Y2hpbmdFbGVtZW50KGVsZW1lbnQsIGJvZHlFbGVtZW50KSB8fCBlbGVtZW50WzBdLm5vZGVOYW1lID09PSAnSFRNTCc7XG4gICAgICB2YXIgcm9vdEVsZW1lbnREZXRlY3RlZCA9IGlzTWF0Y2hpbmdFbGVtZW50KGVsZW1lbnQsICRyb290RWxlbWVudCk7XG4gICAgICB2YXIgcGFyZW50QW5pbWF0aW9uRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBhbmltYXRlQ2hpbGRyZW47XG5cbiAgICAgIHZhciBwYXJlbnRIb3N0ID0gZWxlbWVudC5kYXRhKE5HX0FOSU1BVEVfUElOX0RBVEEpO1xuICAgICAgaWYgKHBhcmVudEhvc3QpIHtcbiAgICAgICAgcGFyZW50RWxlbWVudCA9IHBhcmVudEhvc3Q7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwYXJlbnRFbGVtZW50ICYmIHBhcmVudEVsZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgIGlmICghcm9vdEVsZW1lbnREZXRlY3RlZCkge1xuICAgICAgICAgIC8vIGFuZ3VsYXIgZG9lc24ndCB3YW50IHRvIGF0dGVtcHQgdG8gYW5pbWF0ZSBlbGVtZW50cyBvdXRzaWRlIG9mIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICAgIC8vIHRoZXJlZm9yZSB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZSByb290RWxlbWVudCBpcyBhbiBhbmNlc3RvciBvZiB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICAgICAgcm9vdEVsZW1lbnREZXRlY3RlZCA9IGlzTWF0Y2hpbmdFbGVtZW50KHBhcmVudEVsZW1lbnQsICRyb290RWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHBhcmVudEVsZW1lbnRbMF07XG4gICAgICAgIGlmIChwYXJlbnROb2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAvLyBubyBwb2ludCBpbiBpbnNwZWN0aW5nIHRoZSAjZG9jdW1lbnQgZWxlbWVudFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRldGFpbHMgPSBhY3RpdmVBbmltYXRpb25zTG9va3VwLmdldChwYXJlbnROb2RlKSB8fCB7fTtcbiAgICAgICAgLy8gZWl0aGVyIGFuIGVudGVyLCBsZWF2ZSBvciBtb3ZlIGFuaW1hdGlvbiB3aWxsIGNvbW1lbmNlXG4gICAgICAgIC8vIHRoZXJlZm9yZSB3ZSBjYW4ndCBhbGxvdyBhbnkgYW5pbWF0aW9ucyB0byB0YWtlIHBsYWNlXG4gICAgICAgIC8vIGJ1dCBpZiBhIHBhcmVudCBhbmltYXRpb24gaXMgY2xhc3MtYmFzZWQgdGhlbiB0aGF0J3Mgb2tcbiAgICAgICAgaWYgKCFwYXJlbnRBbmltYXRpb25EZXRlY3RlZCkge1xuICAgICAgICAgIHBhcmVudEFuaW1hdGlvbkRldGVjdGVkID0gZGV0YWlscy5zdHJ1Y3R1cmFsIHx8IGRpc2FibGVkRWxlbWVudHNMb29rdXAuZ2V0KHBhcmVudE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGFuaW1hdGVDaGlsZHJlbikgfHwgYW5pbWF0ZUNoaWxkcmVuID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcGFyZW50RWxlbWVudC5kYXRhKE5HX0FOSU1BVEVfQ0hJTERSRU5fREFUQSk7XG4gICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGFuaW1hdGVDaGlsZHJlbiA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29udGludWUgdHJhdmVyc2luZyBhdCB0aGlzIHBvaW50XG4gICAgICAgIGlmIChwYXJlbnRBbmltYXRpb25EZXRlY3RlZCAmJiBhbmltYXRlQ2hpbGRyZW4gPT09IGZhbHNlKSBicmVhaztcblxuICAgICAgICBpZiAoIXJvb3RFbGVtZW50RGV0ZWN0ZWQpIHtcbiAgICAgICAgICAvLyBhbmd1bGFyIGRvZXNuJ3Qgd2FudCB0byBhdHRlbXB0IHRvIGFuaW1hdGUgZWxlbWVudHMgb3V0c2lkZSBvZiB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgICAvLyB0aGVyZWZvcmUgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgcm9vdEVsZW1lbnQgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAgICAgIHJvb3RFbGVtZW50RGV0ZWN0ZWQgPSBpc01hdGNoaW5nRWxlbWVudChwYXJlbnRFbGVtZW50LCAkcm9vdEVsZW1lbnQpO1xuICAgICAgICAgIGlmICghcm9vdEVsZW1lbnREZXRlY3RlZCkge1xuICAgICAgICAgICAgcGFyZW50SG9zdCA9IHBhcmVudEVsZW1lbnQuZGF0YShOR19BTklNQVRFX1BJTl9EQVRBKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRIb3N0KSB7XG4gICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQgPSBwYXJlbnRIb3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYm9keUVsZW1lbnREZXRlY3RlZCkge1xuICAgICAgICAgIC8vIHdlIGFsc28gbmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgZWxlbWVudCBpcyBvciB3aWxsIGJlIGFwYXJ0IG9mIHRoZSBib2R5IGVsZW1lbnRcbiAgICAgICAgICAvLyBvdGhlcndpc2UgaXQgaXMgcG9pbnRsZXNzIHRvIGV2ZW4gaXNzdWUgYW4gYW5pbWF0aW9uIHRvIGJlIHJlbmRlcmVkXG4gICAgICAgICAgYm9keUVsZW1lbnREZXRlY3RlZCA9IGlzTWF0Y2hpbmdFbGVtZW50KHBhcmVudEVsZW1lbnQsIGJvZHlFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50LnBhcmVudCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxsb3dBbmltYXRpb24gPSAhcGFyZW50QW5pbWF0aW9uRGV0ZWN0ZWQgfHwgYW5pbWF0ZUNoaWxkcmVuO1xuICAgICAgcmV0dXJuIGFsbG93QW5pbWF0aW9uICYmIHJvb3RFbGVtZW50RGV0ZWN0ZWQgJiYgYm9keUVsZW1lbnREZXRlY3RlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXJrRWxlbWVudEFuaW1hdGlvblN0YXRlKGVsZW1lbnQsIHN0YXRlLCBkZXRhaWxzKSB7XG4gICAgICBkZXRhaWxzID0gZGV0YWlscyB8fCB7fTtcbiAgICAgIGRldGFpbHMuc3RhdGUgPSBzdGF0ZTtcblxuICAgICAgdmFyIG5vZGUgPSBnZXREb21Ob2RlKGVsZW1lbnQpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoTkdfQU5JTUFURV9BVFRSX05BTUUsIHN0YXRlKTtcblxuICAgICAgdmFyIG9sZFZhbHVlID0gYWN0aXZlQW5pbWF0aW9uc0xvb2t1cC5nZXQobm9kZSk7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBvbGRWYWx1ZVxuICAgICAgICAgID8gZXh0ZW5kKG9sZFZhbHVlLCBkZXRhaWxzKVxuICAgICAgICAgIDogZGV0YWlscztcbiAgICAgIGFjdGl2ZUFuaW1hdGlvbnNMb29rdXAucHV0KG5vZGUsIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1dO1xufV07XG5cbnZhciAkJEFuaW1hdGVBc3luY1J1bkZhY3RvcnkgPSBbJyQkckFGJywgZnVuY3Rpb24oJCRyQUYpIHtcbiAgdmFyIHdhaXRRdWV1ZSA9IFtdO1xuXG4gIGZ1bmN0aW9uIHdhaXRGb3JUaWNrKGZuKSB7XG4gICAgd2FpdFF1ZXVlLnB1c2goZm4pO1xuICAgIGlmICh3YWl0UXVldWUubGVuZ3RoID4gMSkgcmV0dXJuO1xuICAgICQkckFGKGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3YWl0UXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd2FpdFF1ZXVlW2ldKCk7XG4gICAgICB9XG4gICAgICB3YWl0UXVldWUgPSBbXTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFzc2VkID0gZmFsc2U7XG4gICAgd2FpdEZvclRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBwYXNzZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcGFzc2VkID8gY2FsbGJhY2soKSA6IHdhaXRGb3JUaWNrKGNhbGxiYWNrKTtcbiAgICB9O1xuICB9O1xufV07XG5cbnZhciAkJEFuaW1hdGVSdW5uZXJGYWN0b3J5ID0gWyckcScsICckc25pZmZlcicsICckJGFuaW1hdGVBc3luY1J1bicsXG4gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oJHEsICAgJHNuaWZmZXIsICAgJCRhbmltYXRlQXN5bmNSdW4pIHtcblxuICB2YXIgSU5JVElBTF9TVEFURSA9IDA7XG4gIHZhciBET05FX1BFTkRJTkdfU1RBVEUgPSAxO1xuICB2YXIgRE9ORV9DT01QTEVURV9TVEFURSA9IDI7XG5cbiAgQW5pbWF0ZVJ1bm5lci5jaGFpbiA9IGZ1bmN0aW9uKGNoYWluLCBjYWxsYmFjaykge1xuICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICBuZXh0KCk7XG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gY2hhaW4ubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNoYWluW2luZGV4XShmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZiAocmVzcG9uc2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCsrO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0ZVJ1bm5lci5hbGwgPSBmdW5jdGlvbihydW5uZXJzLCBjYWxsYmFjaykge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIHN0YXR1cyA9IHRydWU7XG4gICAgZm9yRWFjaChydW5uZXJzLCBmdW5jdGlvbihydW5uZXIpIHtcbiAgICAgIHJ1bm5lci5kb25lKG9uUHJvZ3Jlc3MpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25Qcm9ncmVzcyhyZXNwb25zZSkge1xuICAgICAgc3RhdHVzID0gc3RhdHVzICYmIHJlc3BvbnNlO1xuICAgICAgaWYgKCsrY291bnQgPT09IHJ1bm5lcnMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKHN0YXR1cyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEFuaW1hdGVSdW5uZXIoaG9zdCkge1xuICAgIHRoaXMuc2V0SG9zdChob3N0KTtcblxuICAgIHRoaXMuX2RvbmVDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLl9ydW5JbkFuaW1hdGlvbkZyYW1lID0gJCRhbmltYXRlQXN5bmNSdW4oKTtcbiAgICB0aGlzLl9zdGF0ZSA9IDA7XG4gIH1cblxuICBBbmltYXRlUnVubmVyLnByb3RvdHlwZSA9IHtcbiAgICBzZXRIb3N0OiBmdW5jdGlvbihob3N0KSB7XG4gICAgICB0aGlzLmhvc3QgPSBob3N0IHx8IHt9O1xuICAgIH0sXG5cbiAgICBkb25lOiBmdW5jdGlvbihmbikge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBET05FX0NPTVBMRVRFX1NUQVRFKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kb25lQ2FsbGJhY2tzLnB1c2goZm4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcm9ncmVzczogbm9vcCxcblxuICAgIGdldFByb21pc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnByb21pc2UpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnByb21pc2UgPSAkcShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBzZWxmLmRvbmUoZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICAgICAgICBzdGF0dXMgPT09IGZhbHNlID8gcmVqZWN0KCkgOiByZXNvbHZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgICB9LFxuXG4gICAgdGhlbjogZnVuY3Rpb24ocmVzb2x2ZUhhbmRsZXIsIHJlamVjdEhhbmRsZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFByb21pc2UoKS50aGVuKHJlc29sdmVIYW5kbGVyLCByZWplY3RIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpWydjYXRjaCddKGhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAnZmluYWxseSc6IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFByb21pc2UoKVsnZmluYWxseSddKGhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5ob3N0LnBhdXNlKSB7XG4gICAgICAgIHRoaXMuaG9zdC5wYXVzZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXN1bWU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaG9zdC5yZXN1bWUpIHtcbiAgICAgICAgdGhpcy5ob3N0LnJlc3VtZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaG9zdC5lbmQpIHtcbiAgICAgICAgdGhpcy5ob3N0LmVuZCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVzb2x2ZSh0cnVlKTtcbiAgICB9LFxuXG4gICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmhvc3QuY2FuY2VsKSB7XG4gICAgICAgIHRoaXMuaG9zdC5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc29sdmUoZmFsc2UpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGlmIChzZWxmLl9zdGF0ZSA9PT0gSU5JVElBTF9TVEFURSkge1xuICAgICAgICBzZWxmLl9zdGF0ZSA9IERPTkVfUEVORElOR19TVEFURTtcbiAgICAgICAgc2VsZi5fcnVuSW5BbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLl9yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9yZXNvbHZlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBET05FX0NPTVBMRVRFX1NUQVRFKSB7XG4gICAgICAgIGZvckVhY2godGhpcy5fZG9uZUNhbGxiYWNrcywgZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICBmbihyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kb25lQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gRE9ORV9DT01QTEVURV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEFuaW1hdGVSdW5uZXI7XG59XTtcblxudmFyICQkQW5pbWF0aW9uUHJvdmlkZXIgPSBbJyRhbmltYXRlUHJvdmlkZXInLCBmdW5jdGlvbigkYW5pbWF0ZVByb3ZpZGVyKSB7XG4gIHZhciBOR19BTklNQVRFX1JFRl9BVFRSID0gJ25nLWFuaW1hdGUtcmVmJztcblxuICB2YXIgZHJpdmVycyA9IHRoaXMuZHJpdmVycyA9IFtdO1xuXG4gIHZhciBSVU5ORVJfU1RPUkFHRV9LRVkgPSAnJCRhbmltYXRpb25SdW5uZXInO1xuXG4gIGZ1bmN0aW9uIHNldFJ1bm5lcihlbGVtZW50LCBydW5uZXIpIHtcbiAgICBlbGVtZW50LmRhdGEoUlVOTkVSX1NUT1JBR0VfS0VZLCBydW5uZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUnVubmVyKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnJlbW92ZURhdGEoUlVOTkVSX1NUT1JBR0VfS0VZKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJ1bm5lcihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGF0YShSVU5ORVJfU1RPUkFHRV9LRVkpO1xuICB9XG5cbiAgdGhpcy4kZ2V0ID0gWyckJGpxTGl0ZScsICckcm9vdFNjb3BlJywgJyRpbmplY3RvcicsICckJEFuaW1hdGVSdW5uZXInLCAnJCRIYXNoTWFwJywgJyQkckFGU2NoZWR1bGVyJyxcbiAgICAgICBmdW5jdGlvbigkJGpxTGl0ZSwgICAkcm9vdFNjb3BlLCAgICRpbmplY3RvciwgICAkJEFuaW1hdGVSdW5uZXIsICAgJCRIYXNoTWFwLCAgICQkckFGU2NoZWR1bGVyKSB7XG5cbiAgICB2YXIgYW5pbWF0aW9uUXVldWUgPSBbXTtcbiAgICB2YXIgYXBwbHlBbmltYXRpb25DbGFzc2VzID0gYXBwbHlBbmltYXRpb25DbGFzc2VzRmFjdG9yeSgkJGpxTGl0ZSk7XG5cbiAgICBmdW5jdGlvbiBzb3J0QW5pbWF0aW9ucyhhbmltYXRpb25zKSB7XG4gICAgICB2YXIgdHJlZSA9IHsgY2hpbGRyZW46IFtdIH07XG4gICAgICB2YXIgaSwgbG9va3VwID0gbmV3ICQkSGFzaE1hcCgpO1xuXG4gICAgICAvLyB0aGlzIGlzIGRvbmUgZmlyc3QgYmVmb3JlaGFuZCBzbyB0aGF0IHRoZSBoYXNobWFwXG4gICAgICAvLyBpcyBmaWxsZWQgd2l0aCBhIGxpc3Qgb2YgdGhlIGVsZW1lbnRzIHRoYXQgd2lsbCBiZSBhbmltYXRlZFxuICAgICAgZm9yIChpID0gMDsgaSA8IGFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaV07XG4gICAgICAgIGxvb2t1cC5wdXQoYW5pbWF0aW9uLmRvbU5vZGUsIGFuaW1hdGlvbnNbaV0gPSB7XG4gICAgICAgICAgZG9tTm9kZTogYW5pbWF0aW9uLmRvbU5vZGUsXG4gICAgICAgICAgZm46IGFuaW1hdGlvbi5mbixcbiAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb2Nlc3NOb2RlKGFuaW1hdGlvbnNbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmxhdHRlbih0cmVlKTtcblxuICAgICAgZnVuY3Rpb24gcHJvY2Vzc05vZGUoZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5LnByb2Nlc3NlZCkgcmV0dXJuIGVudHJ5O1xuICAgICAgICBlbnRyeS5wcm9jZXNzZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBlbGVtZW50Tm9kZSA9IGVudHJ5LmRvbU5vZGU7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gZWxlbWVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgbG9va3VwLnB1dChlbGVtZW50Tm9kZSwgZW50cnkpO1xuXG4gICAgICAgIHZhciBwYXJlbnRFbnRyeTtcbiAgICAgICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwYXJlbnRFbnRyeSA9IGxvb2t1cC5nZXQocGFyZW50Tm9kZSk7XG4gICAgICAgICAgaWYgKHBhcmVudEVudHJ5KSB7XG4gICAgICAgICAgICBpZiAoIXBhcmVudEVudHJ5LnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICBwYXJlbnRFbnRyeSA9IHByb2Nlc3NOb2RlKHBhcmVudEVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgKHBhcmVudEVudHJ5IHx8IHRyZWUpLmNoaWxkcmVuLnB1c2goZW50cnkpO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZsYXR0ZW4odHJlZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHF1ZXVlLnB1c2godHJlZS5jaGlsZHJlbltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVtYWluaW5nTGV2ZWxFbnRyaWVzID0gcXVldWUubGVuZ3RoO1xuICAgICAgICB2YXIgbmV4dExldmVsRW50cmllcyA9IDA7XG4gICAgICAgIHZhciByb3cgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBxdWV1ZVtpXTtcbiAgICAgICAgICBpZiAocmVtYWluaW5nTGV2ZWxFbnRyaWVzIDw9IDApIHtcbiAgICAgICAgICAgIHJlbWFpbmluZ0xldmVsRW50cmllcyA9IG5leHRMZXZlbEVudHJpZXM7XG4gICAgICAgICAgICBuZXh0TGV2ZWxFbnRyaWVzID0gMDtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJvdyk7XG4gICAgICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcm93LnB1c2goZW50cnkuZm4pO1xuICAgICAgICAgIGVudHJ5LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGRFbnRyeSkge1xuICAgICAgICAgICAgbmV4dExldmVsRW50cmllcysrO1xuICAgICAgICAgICAgcXVldWUucHVzaChjaGlsZEVudHJ5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZW1haW5pbmdMZXZlbEVudHJpZXMtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3cubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyhtYXRza28pOiBkb2N1bWVudCB0aGUgc2lnbmF0dXJlIGluIGEgYmV0dGVyIHdheVxuICAgIHJldHVybiBmdW5jdGlvbihlbGVtZW50LCBldmVudCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHByZXBhcmVBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIGlzU3RydWN0dXJhbCA9IFsnZW50ZXInLCAnbW92ZScsICdsZWF2ZSddLmluZGV4T2YoZXZlbnQpID49IDA7XG5cbiAgICAgIC8vIHRoZXJlIGlzIG5vIGFuaW1hdGlvbiBhdCB0aGUgY3VycmVudCBtb21lbnQsIGhvd2V2ZXJcbiAgICAgIC8vIHRoZXNlIHJ1bm5lciBtZXRob2RzIHdpbGwgZ2V0IGxhdGVyIHVwZGF0ZWQgd2l0aCB0aGVcbiAgICAgIC8vIG1ldGhvZHMgbGVhZGluZyBpbnRvIHRoZSBkcml2ZXIncyBlbmQvY2FuY2VsIG1ldGhvZHNcbiAgICAgIC8vIGZvciBub3cgdGhleSBqdXN0IHN0b3AgdGhlIGFuaW1hdGlvbiBmcm9tIHN0YXJ0aW5nXG4gICAgICB2YXIgcnVubmVyID0gbmV3ICQkQW5pbWF0ZVJ1bm5lcih7XG4gICAgICAgIGVuZDogZnVuY3Rpb24oKSB7IGNsb3NlKCk7IH0sXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7IGNsb3NlKHRydWUpOyB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFkcml2ZXJzLmxlbmd0aCkge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgICAgfVxuXG4gICAgICBzZXRSdW5uZXIoZWxlbWVudCwgcnVubmVyKTtcblxuICAgICAgdmFyIGNsYXNzZXMgPSBtZXJnZUNsYXNzZXMoZWxlbWVudC5hdHRyKCdjbGFzcycpLCBtZXJnZUNsYXNzZXMob3B0aW9ucy5hZGRDbGFzcywgb3B0aW9ucy5yZW1vdmVDbGFzcykpO1xuICAgICAgdmFyIHRlbXBDbGFzc2VzID0gb3B0aW9ucy50ZW1wQ2xhc3NlcztcbiAgICAgIGlmICh0ZW1wQ2xhc3Nlcykge1xuICAgICAgICBjbGFzc2VzICs9ICcgJyArIHRlbXBDbGFzc2VzO1xuICAgICAgICBvcHRpb25zLnRlbXBDbGFzc2VzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uUXVldWUucHVzaCh7XG4gICAgICAgIC8vIHRoaXMgZGF0YSBpcyB1c2VkIGJ5IHRoZSBwb3N0RGlnZXN0IGNvZGUgYW5kIHBhc3NlZCBpbnRvXG4gICAgICAgIC8vIHRoZSBkcml2ZXIgc3RlcCBmdW5jdGlvblxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBjbGFzc2VzOiBjbGFzc2VzLFxuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIHN0cnVjdHVyYWw6IGlzU3RydWN0dXJhbCxcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgYmVmb3JlU3RhcnQ6IGJlZm9yZVN0YXJ0LFxuICAgICAgICBjbG9zZTogY2xvc2VcbiAgICAgIH0pO1xuXG4gICAgICBlbGVtZW50Lm9uKCckZGVzdHJveScsIGhhbmRsZURlc3Ryb3llZEVsZW1lbnQpO1xuXG4gICAgICAvLyB3ZSBvbmx5IHdhbnQgdGhlcmUgdG8gYmUgb25lIGZ1bmN0aW9uIGNhbGxlZCB3aXRoaW4gdGhlIHBvc3QgZGlnZXN0XG4gICAgICAvLyBibG9jay4gVGhpcyB3YXkgd2UgY2FuIGdyb3VwIGFuaW1hdGlvbnMgZm9yIGFsbCB0aGUgYW5pbWF0aW9ucyB0aGF0XG4gICAgICAvLyB3ZXJlIGFwYXJ0IG9mIHRoZSBzYW1lIHBvc3REaWdlc3QgZmx1c2ggY2FsbC5cbiAgICAgIGlmIChhbmltYXRpb25RdWV1ZS5sZW5ndGggPiAxKSByZXR1cm4gcnVubmVyO1xuXG4gICAgICAkcm9vdFNjb3BlLiQkcG9zdERpZ2VzdChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yRWFjaChhbmltYXRpb25RdWV1ZSwgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAvLyB0aGUgZWxlbWVudCB3YXMgZGVzdHJveWVkIGVhcmx5IG9uIHdoaWNoIHJlbW92ZWQgdGhlIHJ1bm5lclxuICAgICAgICAgIC8vIGZvcm0gaXRzIHN0b3JhZ2UuIFRoaXMgbWVhbnMgd2UgY2FuJ3QgYW5pbWF0ZSB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAvLyBhdCBhbGwgYW5kIGl0IGFscmVhZHkgaGFzIGJlZW4gY2xvc2VkIGR1ZSB0byBkZXN0cnVjdGlvbi5cbiAgICAgICAgICBpZiAoZ2V0UnVubmVyKGVudHJ5LmVsZW1lbnQpKSB7XG4gICAgICAgICAgICBhbmltYXRpb25zLnB1c2goZW50cnkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnRyeS5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbm93IGFueSBmdXR1cmUgYW5pbWF0aW9ucyB3aWxsIGJlIGluIGFub3RoZXIgcG9zdERpZ2VzdFxuICAgICAgICBhbmltYXRpb25RdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgICAgIHZhciBncm91cGVkQW5pbWF0aW9ucyA9IGdyb3VwQW5pbWF0aW9ucyhhbmltYXRpb25zKTtcbiAgICAgICAgdmFyIHRvQmVTb3J0ZWRBbmltYXRpb25zID0gW107XG5cbiAgICAgICAgZm9yRWFjaChncm91cGVkQW5pbWF0aW9ucywgZnVuY3Rpb24oYW5pbWF0aW9uRW50cnkpIHtcbiAgICAgICAgICB0b0JlU29ydGVkQW5pbWF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGRvbU5vZGU6IGdldERvbU5vZGUoYW5pbWF0aW9uRW50cnkuZnJvbSA/IGFuaW1hdGlvbkVudHJ5LmZyb20uZWxlbWVudCA6IGFuaW1hdGlvbkVudHJ5LmVsZW1lbnQpLFxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIHRyaWdnZXJBbmltYXRpb25TdGFydCgpIHtcbiAgICAgICAgICAgICAgLy8gaXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBhcHBseSB0aGUgYG5nLWFuaW1hdGVgIENTUyBjbGFzcyBhbmQgdGhlXG4gICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBjbGFzc2VzIGJlZm9yZSB3ZSBkbyBhbnkgZHJpdmVyIGludm9raW5nIHNpbmNlIHRoZXNlXG4gICAgICAgICAgICAgIC8vIENTUyBjbGFzc2VzIG1heSBiZSByZXF1aXJlZCBmb3IgcHJvcGVyIENTUyBkZXRlY3Rpb24uXG4gICAgICAgICAgICAgIGFuaW1hdGlvbkVudHJ5LmJlZm9yZVN0YXJ0KCk7XG5cbiAgICAgICAgICAgICAgdmFyIHN0YXJ0QW5pbWF0aW9uRm4sIGNsb3NlRm4gPSBhbmltYXRpb25FbnRyeS5jbG9zZTtcblxuICAgICAgICAgICAgICAvLyBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgZWxlbWVudCB3YXMgcmVtb3ZlZCBiZWZvcmUgdGhlIGRpZ2VzdCBydW5zIG9yXG4gICAgICAgICAgICAgIC8vIGR1cmluZyB0aGUgUkFGIHNlcXVlbmNpbmcgdGhlbiB3ZSBzaG91bGQgbm90IHRyaWdnZXIgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSBhbmltYXRpb25FbnRyeS5hbmNob3JzXG4gICAgICAgICAgICAgICAgICA/IChhbmltYXRpb25FbnRyeS5mcm9tLmVsZW1lbnQgfHwgYW5pbWF0aW9uRW50cnkudG8uZWxlbWVudClcbiAgICAgICAgICAgICAgICAgIDogYW5pbWF0aW9uRW50cnkuZWxlbWVudDtcblxuICAgICAgICAgICAgICBpZiAoZ2V0UnVubmVyKHRhcmdldEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IGludm9rZUZpcnN0RHJpdmVyKGFuaW1hdGlvbkVudHJ5KTtcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydEFuaW1hdGlvbkZuID0gb3BlcmF0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghc3RhcnRBbmltYXRpb25Gbikge1xuICAgICAgICAgICAgICAgIGNsb3NlRm4oKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uUnVubmVyID0gc3RhcnRBbmltYXRpb25GbigpO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvblJ1bm5lci5kb25lKGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgY2xvc2VGbighc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1cGRhdGVBbmltYXRpb25SdW5uZXJzKGFuaW1hdGlvbkVudHJ5LCBhbmltYXRpb25SdW5uZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc29ydCBlYWNoIG9mIHRoZSBhbmltYXRpb25zIGluIG9yZGVyIG9mIHBhcmVudCB0byBjaGlsZFxuICAgICAgICAvLyByZWxhdGlvbnNoaXBzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgY2hpbGQgY2xhc3NlcyBhcmUgYXBwbGllZCBhdCB0aGVcbiAgICAgICAgLy8gcmlnaHQgdGltZS5cbiAgICAgICAgJCRyQUZTY2hlZHVsZXIoc29ydEFuaW1hdGlvbnModG9CZVNvcnRlZEFuaW1hdGlvbnMpKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcnVubmVyO1xuXG4gICAgICAvLyBUT0RPKG1hdHNrbyk6IGNoYW5nZSB0byByZWZlcmVuY2Ugbm9kZXNcbiAgICAgIGZ1bmN0aW9uIGdldEFuY2hvck5vZGVzKG5vZGUpIHtcbiAgICAgICAgdmFyIFNFTEVDVE9SID0gJ1snICsgTkdfQU5JTUFURV9SRUZfQVRUUiArICddJztcbiAgICAgICAgdmFyIGl0ZW1zID0gbm9kZS5oYXNBdHRyaWJ1dGUoTkdfQU5JTUFURV9SRUZfQVRUUilcbiAgICAgICAgICAgICAgPyBbbm9kZV1cbiAgICAgICAgICAgICAgOiBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1IpO1xuICAgICAgICB2YXIgYW5jaG9ycyA9IFtdO1xuICAgICAgICBmb3JFYWNoKGl0ZW1zLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSBub2RlLmdldEF0dHJpYnV0ZShOR19BTklNQVRFX1JFRl9BVFRSKTtcbiAgICAgICAgICBpZiAoYXR0ciAmJiBhdHRyLmxlbmd0aCkge1xuICAgICAgICAgICAgYW5jaG9ycy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhbmNob3JzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBncm91cEFuaW1hdGlvbnMoYW5pbWF0aW9ucykge1xuICAgICAgICB2YXIgcHJlcGFyZWRBbmltYXRpb25zID0gW107XG4gICAgICAgIHZhciByZWZMb29rdXAgPSB7fTtcbiAgICAgICAgZm9yRWFjaChhbmltYXRpb25zLCBmdW5jdGlvbihhbmltYXRpb24sIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBhbmltYXRpb24uZWxlbWVudDtcbiAgICAgICAgICB2YXIgbm9kZSA9IGdldERvbU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgdmFyIGV2ZW50ID0gYW5pbWF0aW9uLmV2ZW50O1xuICAgICAgICAgIHZhciBlbnRlck9yTW92ZSA9IFsnZW50ZXInLCAnbW92ZSddLmluZGV4T2YoZXZlbnQpID49IDA7XG4gICAgICAgICAgdmFyIGFuY2hvck5vZGVzID0gYW5pbWF0aW9uLnN0cnVjdHVyYWwgPyBnZXRBbmNob3JOb2Rlcyhub2RlKSA6IFtdO1xuXG4gICAgICAgICAgaWYgKGFuY2hvck5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGVudGVyT3JNb3ZlID8gJ3RvJyA6ICdmcm9tJztcblxuICAgICAgICAgICAgZm9yRWFjaChhbmNob3JOb2RlcywgZnVuY3Rpb24oYW5jaG9yKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBhbmNob3IuZ2V0QXR0cmlidXRlKE5HX0FOSU1BVEVfUkVGX0FUVFIpO1xuICAgICAgICAgICAgICByZWZMb29rdXBba2V5XSA9IHJlZkxvb2t1cFtrZXldIHx8IHt9O1xuICAgICAgICAgICAgICByZWZMb29rdXBba2V5XVtkaXJlY3Rpb25dID0ge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbklEOiBpbmRleCxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBqcUxpdGUoYW5jaG9yKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXBhcmVkQW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdXNlZEluZGljZXNMb29rdXAgPSB7fTtcbiAgICAgICAgdmFyIGFuY2hvckdyb3VwcyA9IHt9O1xuICAgICAgICBmb3JFYWNoKHJlZkxvb2t1cCwgZnVuY3Rpb24ob3BlcmF0aW9ucywga2V5KSB7XG4gICAgICAgICAgdmFyIGZyb20gPSBvcGVyYXRpb25zLmZyb207XG4gICAgICAgICAgdmFyIHRvID0gb3BlcmF0aW9ucy50bztcblxuICAgICAgICAgIGlmICghZnJvbSB8fCAhdG8pIHtcbiAgICAgICAgICAgIC8vIG9ubHkgb25lIG9mIHRoZXNlIGlzIHNldCB0aGVyZWZvcmUgd2UgY2FuJ3QgaGF2ZSBhblxuICAgICAgICAgICAgLy8gYW5jaG9yIGFuaW1hdGlvbiBzaW5jZSBhbGwgdGhyZWUgcGllY2VzIGFyZSByZXF1aXJlZFxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZnJvbSA/IGZyb20uYW5pbWF0aW9uSUQgOiB0by5hbmltYXRpb25JRDtcbiAgICAgICAgICAgIHZhciBpbmRleEtleSA9IGluZGV4LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoIXVzZWRJbmRpY2VzTG9va3VwW2luZGV4S2V5XSkge1xuICAgICAgICAgICAgICB1c2VkSW5kaWNlc0xvb2t1cFtpbmRleEtleV0gPSB0cnVlO1xuICAgICAgICAgICAgICBwcmVwYXJlZEFuaW1hdGlvbnMucHVzaChhbmltYXRpb25zW2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGZyb21BbmltYXRpb24gPSBhbmltYXRpb25zW2Zyb20uYW5pbWF0aW9uSURdO1xuICAgICAgICAgIHZhciB0b0FuaW1hdGlvbiA9IGFuaW1hdGlvbnNbdG8uYW5pbWF0aW9uSURdO1xuICAgICAgICAgIHZhciBsb29rdXBLZXkgPSBmcm9tLmFuaW1hdGlvbklELnRvU3RyaW5nKCk7XG4gICAgICAgICAgaWYgKCFhbmNob3JHcm91cHNbbG9va3VwS2V5XSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gYW5jaG9yR3JvdXBzW2xvb2t1cEtleV0gPSB7XG4gICAgICAgICAgICAgIHN0cnVjdHVyYWw6IHRydWUsXG4gICAgICAgICAgICAgIGJlZm9yZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmcm9tQW5pbWF0aW9uLmJlZm9yZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgdG9BbmltYXRpb24uYmVmb3JlU3RhcnQoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZyb21BbmltYXRpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0b0FuaW1hdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjbGFzc2VzOiBjc3NDbGFzc2VzSW50ZXJzZWN0aW9uKGZyb21BbmltYXRpb24uY2xhc3NlcywgdG9BbmltYXRpb24uY2xhc3NlcyksXG4gICAgICAgICAgICAgIGZyb206IGZyb21BbmltYXRpb24sXG4gICAgICAgICAgICAgIHRvOiB0b0FuaW1hdGlvbixcbiAgICAgICAgICAgICAgYW5jaG9yczogW10gLy8gVE9ETyhtYXRza28pOiBjaGFuZ2UgdG8gcmVmZXJlbmNlIG5vZGVzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyB0aGUgYW5jaG9yIGFuaW1hdGlvbnMgcmVxdWlyZSB0aGF0IHRoZSBmcm9tIGFuZCB0byBlbGVtZW50cyBib3RoIGhhdmUgYXQgbGVhc3RcbiAgICAgICAgICAgIC8vIG9uZSBzaGFyZWQgQ1NTIGNsYXNzIHdoaWNoIGVmZmljdGl2ZWx5IG1hcnJpZXMgdGhlIHR3byBlbGVtZW50cyB0b2dldGhlciB0byB1c2VcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIGFuaW1hdGlvbiBkcml2ZXIgYW5kIHRvIHByb3Blcmx5IHNlcXVlbmNlIHRoZSBhbmNob3IgYW5pbWF0aW9uLlxuICAgICAgICAgICAgaWYgKGdyb3VwLmNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHByZXBhcmVkQW5pbWF0aW9ucy5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByZXBhcmVkQW5pbWF0aW9ucy5wdXNoKGZyb21BbmltYXRpb24pO1xuICAgICAgICAgICAgICBwcmVwYXJlZEFuaW1hdGlvbnMucHVzaCh0b0FuaW1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5jaG9yR3JvdXBzW2xvb2t1cEtleV0uYW5jaG9ycy5wdXNoKHtcbiAgICAgICAgICAgICdvdXQnOiBmcm9tLmVsZW1lbnQsICdpbic6IHRvLmVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHByZXBhcmVkQW5pbWF0aW9ucztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3NzQ2xhc3Nlc0ludGVyc2VjdGlvbihhLGIpIHtcbiAgICAgICAgYSA9IGEuc3BsaXQoJyAnKTtcbiAgICAgICAgYiA9IGIuc3BsaXQoJyAnKTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgYWEgPSBhW2ldO1xuICAgICAgICAgIGlmIChhYS5zdWJzdHJpbmcoMCwzKSA9PT0gJ25nLScpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoYWEgPT09IGJbal0pIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGFhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoZXMuam9pbignICcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VGaXJzdERyaXZlcihhbmltYXRpb25EZXRhaWxzKSB7XG4gICAgICAgIC8vIHdlIGxvb3AgaW4gcmV2ZXJzZSBvcmRlciBzaW5jZSB0aGUgbW9yZSBnZW5lcmFsIGRyaXZlcnMgKGxpa2UgQ1NTIGFuZCBKUylcbiAgICAgICAgLy8gbWF5IGF0dGVtcHQgbW9yZSBlbGVtZW50cywgYnV0IGN1c3RvbSBkcml2ZXJzIGFyZSBtb3JlIHBhcnRpY3VsYXJcbiAgICAgICAgZm9yICh2YXIgaSA9IGRyaXZlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgZHJpdmVyTmFtZSA9IGRyaXZlcnNbaV07XG4gICAgICAgICAgaWYgKCEkaW5qZWN0b3IuaGFzKGRyaXZlck5hbWUpKSBjb250aW51ZTsgLy8gVE9ETyhtYXRza28pOiByZW1vdmUgdGhpcyBjaGVja1xuXG4gICAgICAgICAgdmFyIGZhY3RvcnkgPSAkaW5qZWN0b3IuZ2V0KGRyaXZlck5hbWUpO1xuICAgICAgICAgIHZhciBkcml2ZXIgPSBmYWN0b3J5KGFuaW1hdGlvbkRldGFpbHMpO1xuICAgICAgICAgIGlmIChkcml2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBkcml2ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJlZm9yZVN0YXJ0KCkge1xuICAgICAgICBlbGVtZW50LmFkZENsYXNzKE5HX0FOSU1BVEVfQ0xBU1NOQU1FKTtcbiAgICAgICAgaWYgKHRlbXBDbGFzc2VzKSB7XG4gICAgICAgICAgJCRqcUxpdGUuYWRkQ2xhc3MoZWxlbWVudCwgdGVtcENsYXNzZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUFuaW1hdGlvblJ1bm5lcnMoYW5pbWF0aW9uLCBuZXdSdW5uZXIpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbi5mcm9tICYmIGFuaW1hdGlvbi50bykge1xuICAgICAgICAgIHVwZGF0ZShhbmltYXRpb24uZnJvbS5lbGVtZW50KTtcbiAgICAgICAgICB1cGRhdGUoYW5pbWF0aW9uLnRvLmVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwZGF0ZShhbmltYXRpb24uZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGUoZWxlbWVudCkge1xuICAgICAgICAgIGdldFJ1bm5lcihlbGVtZW50KS5zZXRIb3N0KG5ld1J1bm5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlRGVzdHJveWVkRWxlbWVudCgpIHtcbiAgICAgICAgdmFyIHJ1bm5lciA9IGdldFJ1bm5lcihlbGVtZW50KTtcbiAgICAgICAgaWYgKHJ1bm5lciAmJiAoZXZlbnQgIT09ICdsZWF2ZScgfHwgIW9wdGlvbnMuJCRkb21PcGVyYXRpb25GaXJlZCkpIHtcbiAgICAgICAgICBydW5uZXIuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xvc2UocmVqZWN0ZWQpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgIGVsZW1lbnQub2ZmKCckZGVzdHJveScsIGhhbmRsZURlc3Ryb3llZEVsZW1lbnQpO1xuICAgICAgICByZW1vdmVSdW5uZXIoZWxlbWVudCk7XG5cbiAgICAgICAgYXBwbHlBbmltYXRpb25DbGFzc2VzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBhcHBseUFuaW1hdGlvblN0eWxlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5kb21PcGVyYXRpb24oKTtcblxuICAgICAgICBpZiAodGVtcENsYXNzZXMpIHtcbiAgICAgICAgICAkJGpxTGl0ZS5yZW1vdmVDbGFzcyhlbGVtZW50LCB0ZW1wQ2xhc3Nlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKE5HX0FOSU1BVEVfQ0xBU1NOQU1FKTtcbiAgICAgICAgcnVubmVyLmNvbXBsZXRlKCFyZWplY3RlZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfV07XG59XTtcblxuLyogZ2xvYmFsIGFuZ3VsYXJBbmltYXRlTW9kdWxlOiB0cnVlLFxuXG4gICAkJEFuaW1hdGVBc3luY1J1bkZhY3RvcnksXG4gICAkJHJBRlNjaGVkdWxlckZhY3RvcnksXG4gICAkJEFuaW1hdGVDaGlsZHJlbkRpcmVjdGl2ZSxcbiAgICQkQW5pbWF0ZVJ1bm5lckZhY3RvcnksXG4gICAkJEFuaW1hdGVRdWV1ZVByb3ZpZGVyLFxuICAgJCRBbmltYXRpb25Qcm92aWRlcixcbiAgICRBbmltYXRlQ3NzUHJvdmlkZXIsXG4gICAkJEFuaW1hdGVDc3NEcml2ZXJQcm92aWRlcixcbiAgICQkQW5pbWF0ZUpzUHJvdmlkZXIsXG4gICAkJEFuaW1hdGVKc0RyaXZlclByb3ZpZGVyLFxuKi9cblxuLyoqXG4gKiBAbmdkb2MgbW9kdWxlXG4gKiBAbmFtZSBuZ0FuaW1hdGVcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFRoZSBgbmdBbmltYXRlYCBtb2R1bGUgcHJvdmlkZXMgc3VwcG9ydCBmb3IgQ1NTLWJhc2VkIGFuaW1hdGlvbnMgKGtleWZyYW1lcyBhbmQgdHJhbnNpdGlvbnMpIGFzIHdlbGwgYXMgSmF2YVNjcmlwdC1iYXNlZCBhbmltYXRpb25zIHZpYVxuICogY2FsbGJhY2sgaG9va3MuIEFuaW1hdGlvbnMgYXJlIG5vdCBlbmFibGVkIGJ5IGRlZmF1bHQsIGhvd2V2ZXIsIGJ5IGluY2x1ZGluZyBgbmdBbmltYXRlYCB0aGUgYW5pbWF0aW9uIGhvb2tzIGFyZSBlbmFibGVkIGZvciBhbiBBbmd1bGFyIGFwcC5cbiAqXG4gKiA8ZGl2IGRvYy1tb2R1bGUtY29tcG9uZW50cz1cIm5nQW5pbWF0ZVwiPjwvZGl2PlxuICpcbiAqICMgVXNhZ2VcbiAqIFNpbXBseSBwdXQsIHRoZXJlIGFyZSB0d28gd2F5cyB0byBtYWtlIHVzZSBvZiBhbmltYXRpb25zIHdoZW4gbmdBbmltYXRlIGlzIHVzZWQ6IGJ5IHVzaW5nICoqQ1NTKiogYW5kICoqSmF2YVNjcmlwdCoqLiBUaGUgZm9ybWVyIHdvcmtzIHB1cmVseSBiYXNlZFxuICogdXNpbmcgQ1NTIChieSB1c2luZyBtYXRjaGluZyBDU1Mgc2VsZWN0b3JzL3N0eWxlcykgYW5kIHRoZSBsYXR0ZXIgdHJpZ2dlcnMgYW5pbWF0aW9ucyB0aGF0IGFyZSByZWdpc3RlcmVkIHZpYSBgbW9kdWxlLmFuaW1hdGlvbigpYC4gRm9yXG4gKiBib3RoIENTUyBhbmQgSlMgYW5pbWF0aW9ucyB0aGUgc29sZSByZXF1aXJlbWVudCBpcyB0byBoYXZlIGEgbWF0Y2hpbmcgYENTUyBjbGFzc2AgdGhhdCBleGlzdHMgYm90aCBpbiB0aGUgcmVnaXN0ZXJlZCBhbmltYXRpb24gYW5kIHdpdGhpblxuICogdGhlIEhUTUwgZWxlbWVudCB0aGF0IHRoZSBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQgb24uXG4gKlxuICogIyMgRGlyZWN0aXZlIFN1cHBvcnRcbiAqIFRoZSBmb2xsb3dpbmcgZGlyZWN0aXZlcyBhcmUgXCJhbmltYXRpb24gYXdhcmVcIjpcbiAqXG4gKiB8IERpcmVjdGl2ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgU3VwcG9ydGVkIEFuaW1hdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nUmVwZWF0I2FuaW1hdGlvbnMgbmdSZXBlYXR9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVudGVyLCBsZWF2ZSBhbmQgbW92ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IHtAbGluayBuZ1JvdXRlLmRpcmVjdGl2ZTpuZ1ZpZXcjYW5pbWF0aW9ucyBuZ1ZpZXd9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZW50ZXIgYW5kIGxlYXZlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0luY2x1ZGUjYW5pbWF0aW9ucyBuZ0luY2x1ZGV9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlbnRlciBhbmQgbGVhdmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nU3dpdGNoI2FuaW1hdGlvbnMgbmdTd2l0Y2h9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVudGVyIGFuZCBsZWF2ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IHtAbGluayBuZy5kaXJlY3RpdmU6bmdJZiNhbmltYXRpb25zIG5nSWZ9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZW50ZXIgYW5kIGxlYXZlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NsYXNzI2FuaW1hdGlvbnMgbmdDbGFzc30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhZGQgYW5kIHJlbW92ZSAodGhlIENTUyBjbGFzcyhlcykgcHJlc2VudCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nU2hvdyNhbmltYXRpb25zIG5nU2hvd30gJiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nSGlkZSNhbmltYXRpb25zIG5nSGlkZX0gICAgICAgICAgICB8IGFkZCBhbmQgcmVtb3ZlICh0aGUgbmctaGlkZSBjbGFzcyB2YWx1ZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IHtAbGluayBuZy5kaXJlY3RpdmU6Zm9ybSNhbmltYXRpb24taG9va3MgZm9ybX0gJiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nTW9kZWwjYW5pbWF0aW9uLWhvb2tzIG5nTW9kZWx9ICAgIHwgYWRkIGFuZCByZW1vdmUgKGRpcnR5LCBwcmlzdGluZSwgdmFsaWQsIGludmFsaWQgJiBhbGwgb3RoZXIgdmFsaWRhdGlvbnMpIHxcbiAqIHwge0BsaW5rIG1vZHVsZTpuZ01lc3NhZ2VzI2FuaW1hdGlvbnMgbmdNZXNzYWdlc30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhZGQgYW5kIHJlbW92ZSAobmctYWN0aXZlICYgbmctaW5hY3RpdmUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCB7QGxpbmsgbW9kdWxlOm5nTWVzc2FnZXMjYW5pbWF0aW9ucyBuZ01lc3NhZ2V9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVudGVyIGFuZCBsZWF2ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKlxuICogKE1vcmUgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGJ5IHZpc2l0aW5nIGVhY2ggdGhlIGRvY3VtZW50YXRpb24gYXNzb2NpYXRlZCB3aXRoIGVhY2ggZGlyZWN0aXZlLilcbiAqXG4gKiAjIyBDU1MtYmFzZWQgQW5pbWF0aW9uc1xuICpcbiAqIENTUy1iYXNlZCBhbmltYXRpb25zIHdpdGggbmdBbmltYXRlIGFyZSB1bmlxdWUgc2luY2UgdGhleSByZXF1aXJlIG5vIEphdmFTY3JpcHQgY29kZSBhdCBhbGwuIEJ5IHVzaW5nIGEgQ1NTIGNsYXNzIHRoYXQgd2UgcmVmZXJlbmNlIGJldHdlZW4gb3VyIEhUTUxcbiAqIGFuZCBDU1MgY29kZSB3ZSBjYW4gY3JlYXRlIGFuIGFuaW1hdGlvbiB0aGF0IHdpbGwgYmUgcGlja2VkIHVwIGJ5IEFuZ3VsYXIgd2hlbiBhbiB0aGUgdW5kZXJseWluZyBkaXJlY3RpdmUgcGVyZm9ybXMgYW4gb3BlcmF0aW9uLlxuICpcbiAqIFRoZSBleGFtcGxlIGJlbG93IHNob3dzIGhvdyBhbiBgZW50ZXJgIGFuaW1hdGlvbiBjYW4gYmUgbWFkZSBwb3NzaWJsZSBvbiBhbiBlbGVtZW50IHVzaW5nIGBuZy1pZmA6XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiBuZy1pZj1cImJvb2xcIiBjbGFzcz1cImZhZGVcIj5cbiAqICAgIEZhZGUgbWUgaW4gb3V0XG4gKiA8L2Rpdj5cbiAqIDxidXR0b24gbmctY2xpY2s9XCJib29sPXRydWVcIj5GYWRlIEluITwvYnV0dG9uPlxuICogPGJ1dHRvbiBuZy1jbGljaz1cImJvb2w9ZmFsc2VcIj5GYWRlIE91dCE8L2J1dHRvbj5cbiAqIGBgYFxuICpcbiAqIE5vdGljZSB0aGUgQ1NTIGNsYXNzICoqZmFkZSoqPyBXZSBjYW4gbm93IGNyZWF0ZSB0aGUgQ1NTIHRyYW5zaXRpb24gY29kZSB0aGF0IHJlZmVyZW5jZXMgdGhpcyBjbGFzczpcbiAqXG4gKiBgYGBjc3NcbiAqIC8mIzQyOyBUaGUgc3RhcnRpbmcgQ1NTIHN0eWxlcyBmb3IgdGhlIGVudGVyIGFuaW1hdGlvbiAmIzQyOy9cbiAqIC5mYWRlLm5nLWVudGVyIHtcbiAqICAgdHJhbnNpdGlvbjowLjVzIGxpbmVhciBhbGw7XG4gKiAgIG9wYWNpdHk6MDtcbiAqIH1cbiAqXG4gKiAvJiM0MjsgVGhlIGZpbmlzaGluZyBDU1Mgc3R5bGVzIGZvciB0aGUgZW50ZXIgYW5pbWF0aW9uICYjNDI7L1xuICogLmZhZGUubmctZW50ZXIubmctZW50ZXItYWN0aXZlIHtcbiAqICAgb3BhY2l0eToxO1xuICogfVxuICogYGBgXG4gKlxuICogVGhlIGtleSB0aGluZyB0byByZW1lbWJlciBoZXJlIGlzIHRoYXQsIGRlcGVuZGluZyBvbiB0aGUgYW5pbWF0aW9uIGV2ZW50ICh3aGljaCBlYWNoIG9mIHRoZSBkaXJlY3RpdmVzIGFib3ZlIHRyaWdnZXIgZGVwZW5kaW5nIG9uIHdoYXQncyBnb2luZyBvbikgdHdvXG4gKiBnZW5lcmF0ZWQgQ1NTIGNsYXNzZXMgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50OyBpbiB0aGUgZXhhbXBsZSBhYm92ZSB3ZSBoYXZlIGAubmctZW50ZXJgIGFuZCBgLm5nLWVudGVyLWFjdGl2ZWAuIEZvciBDU1MgdHJhbnNpdGlvbnMsIHRoZSB0cmFuc2l0aW9uXG4gKiBjb2RlICoqbXVzdCoqIGJlIGRlZmluZWQgd2l0aGluIHRoZSBzdGFydGluZyBDU1MgY2xhc3MgKGluIHRoaXMgY2FzZSBgLm5nLWVudGVyYCkuIFRoZSBkZXN0aW5hdGlvbiBjbGFzcyBpcyB3aGF0IHRoZSB0cmFuc2l0aW9uIHdpbGwgYW5pbWF0ZSB0b3dhcmRzLlxuICpcbiAqIElmIGZvciBleGFtcGxlIHdlIHdhbnRlZCB0byBjcmVhdGUgYW5pbWF0aW9ucyBmb3IgYGxlYXZlYCBhbmQgYG1vdmVgIChuZ1JlcGVhdCB0cmlnZ2VycyBtb3ZlKSB0aGVuIHdlIGNhbiBkbyBzbyB1c2luZyB0aGUgc2FtZSBDU1MgbmFtaW5nIGNvbnZlbnRpb25zOlxuICpcbiAqIGBgYGNzc1xuICogLyYjNDI7IG5vdyB0aGUgZWxlbWVudCB3aWxsIGZhZGUgb3V0IGJlZm9yZSBpdCBpcyByZW1vdmVkIGZyb20gdGhlIERPTSAmIzQyOy9cbiAqIC5mYWRlLm5nLWxlYXZlIHtcbiAqICAgdHJhbnNpdGlvbjowLjVzIGxpbmVhciBhbGw7XG4gKiAgIG9wYWNpdHk6MTtcbiAqIH1cbiAqIC5mYWRlLm5nLWxlYXZlLm5nLWxlYXZlLWFjdGl2ZSB7XG4gKiAgIG9wYWNpdHk6MDtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdlIGNhbiBhbHNvIG1ha2UgdXNlIG9mICoqQ1NTIEtleWZyYW1lcyoqIGJ5IHJlZmVyZW5jaW5nIHRoZSBrZXlmcmFtZSBhbmltYXRpb24gd2l0aGluIHRoZSBzdGFydGluZyBDU1MgY2xhc3M6XG4gKlxuICogYGBgY3NzXG4gKiAvJiM0MjsgdGhlcmUgaXMgbm8gbmVlZCB0byBkZWZpbmUgYW55dGhpbmcgaW5zaWRlIG9mIHRoZSBkZXN0aW5hdGlvblxuICogQ1NTIGNsYXNzIHNpbmNlIHRoZSBrZXlmcmFtZSB3aWxsIHRha2UgY2hhcmdlIG9mIHRoZSBhbmltYXRpb24gJiM0MjsvXG4gKiAuZmFkZS5uZy1sZWF2ZSB7XG4gKiAgIGFuaW1hdGlvbjogbXlfZmFkZV9hbmltYXRpb24gMC41cyBsaW5lYXI7XG4gKiAgIC13ZWJraXQtYW5pbWF0aW9uOiBteV9mYWRlX2FuaW1hdGlvbiAwLjVzIGxpbmVhcjtcbiAqIH1cbiAqXG4gKiBAa2V5ZnJhbWVzIG15X2ZhZGVfYW5pbWF0aW9uIHtcbiAqICAgZnJvbSB7IG9wYWNpdHk6MTsgfVxuICogICB0byB7IG9wYWNpdHk6MDsgfVxuICogfVxuICpcbiAqIEAtd2Via2l0LWtleWZyYW1lcyBteV9mYWRlX2FuaW1hdGlvbiB7XG4gKiAgIGZyb20geyBvcGFjaXR5OjE7IH1cbiAqICAgdG8geyBvcGFjaXR5OjA7IH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEZlZWwgZnJlZSBhbHNvIG1peCB0cmFuc2l0aW9ucyBhbmQga2V5ZnJhbWVzIHRvZ2V0aGVyIGFzIHdlbGwgYXMgYW55IG90aGVyIENTUyBjbGFzc2VzIG9uIHRoZSBzYW1lIGVsZW1lbnQuXG4gKlxuICogIyMjIENTUyBDbGFzcy1iYXNlZCBBbmltYXRpb25zXG4gKlxuICogQ2xhc3MtYmFzZWQgYW5pbWF0aW9ucyAoYW5pbWF0aW9ucyB0aGF0IGFyZSB0cmlnZ2VyZWQgdmlhIGBuZ0NsYXNzYCwgYG5nU2hvd2AsIGBuZ0hpZGVgIGFuZCBzb21lIG90aGVyIGRpcmVjdGl2ZXMpIGhhdmUgYSBzbGlnaHRseSBkaWZmZXJlbnRcbiAqIG5hbWluZyBjb252ZW50aW9uLiBDbGFzcy1iYXNlZCBhbmltYXRpb25zIGFyZSBiYXNpYyBlbm91Z2ggdGhhdCBhIHN0YW5kYXJkIHRyYW5zaXRpb24gb3Iga2V5ZnJhbWUgY2FuIGJlIHJlZmVyZW5jZWQgb24gdGhlIGNsYXNzIGJlaW5nIGFkZGVkXG4gKiBhbmQgcmVtb3ZlZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBpZiB3ZSB3YW50ZWQgdG8gZG8gYSBDU1MgYW5pbWF0aW9uIGZvciBgbmdIaWRlYCB0aGVuIHdlIHBsYWNlIGFuIGFuaW1hdGlvbiBvbiB0aGUgYC5uZy1oaWRlYCBDU1MgY2xhc3M6XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiBuZy1zaG93PVwiYm9vbFwiIGNsYXNzPVwiZmFkZVwiPlxuICogICBTaG93IGFuZCBoaWRlIG1lXG4gKiA8L2Rpdj5cbiAqIDxidXR0b24gbmctY2xpY2s9XCJib29sPXRydWVcIj5Ub2dnbGU8L2J1dHRvbj5cbiAqXG4gKiA8c3R5bGU+XG4gKiAuZmFkZS5uZy1oaWRlIHtcbiAqICAgdHJhbnNpdGlvbjowLjVzIGxpbmVhciBhbGw7XG4gKiAgIG9wYWNpdHk6MDtcbiAqIH1cbiAqIDwvc3R5bGU+XG4gKiBgYGBcbiAqXG4gKiBBbGwgdGhhdCBpcyBnb2luZyBvbiBoZXJlIHdpdGggbmdTaG93L25nSGlkZSBiZWhpbmQgdGhlIHNjZW5lcyBpcyB0aGUgYC5uZy1oaWRlYCBjbGFzcyBpcyBhZGRlZC9yZW1vdmVkICh3aGVuIHRoZSBoaWRkZW4gc3RhdGUgaXMgdmFsaWQpLiBTaW5jZVxuICogbmdTaG93IGFuZCBuZ0hpZGUgYXJlIGFuaW1hdGlvbiBhd2FyZSB0aGVuIHdlIGNhbiBtYXRjaCB1cCBhIHRyYW5zaXRpb24gYW5kIG5nQW5pbWF0ZSBoYW5kbGVzIHRoZSByZXN0LlxuICpcbiAqIEluIGFkZGl0aW9uIHRoZSBhZGRpdGlvbiBhbmQgcmVtb3ZhbCBvZiB0aGUgQ1NTIGNsYXNzLCBuZ0FuaW1hdGUgYWxzbyBwcm92aWRlcyB0d28gaGVscGVyIG1ldGhvZHMgdGhhdCB3ZSBjYW4gdXNlIHRvIGZ1cnRoZXIgZGVjb3JhdGUgdGhlIGFuaW1hdGlvblxuICogd2l0aCBDU1Mgc3R5bGVzLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgbmctY2xhc3M9XCJ7b246b25PZmZ9XCIgY2xhc3M9XCJoaWdobGlnaHRcIj5cbiAqICAgSGlnaGxpZ2h0IHRoaXMgYm94XG4gKiA8L2Rpdj5cbiAqIDxidXR0b24gbmctY2xpY2s9XCJvbk9mZj0hb25PZmZcIj5Ub2dnbGU8L2J1dHRvbj5cbiAqXG4gKiA8c3R5bGU+XG4gKiAuaGlnaGxpZ2h0IHtcbiAqICAgdHJhbnNpdGlvbjowLjVzIGxpbmVhciBhbGw7XG4gKiB9XG4gKiAuaGlnaGxpZ2h0Lm9uLWFkZCB7XG4gKiAgIGJhY2tncm91bmQ6d2hpdGU7XG4gKiB9XG4gKiAuaGlnaGxpZ2h0Lm9uIHtcbiAqICAgYmFja2dyb3VuZDp5ZWxsb3c7XG4gKiB9XG4gKiAuaGlnaGxpZ2h0Lm9uLXJlbW92ZSB7XG4gKiAgIGJhY2tncm91bmQ6YmxhY2s7XG4gKiB9XG4gKiA8L3N0eWxlPlxuICogYGBgXG4gKlxuICogV2UgY2FuIGFsc28gbWFrZSB1c2Ugb2YgQ1NTIGtleWZyYW1lcyBieSBwbGFjaW5nIHRoZW0gd2l0aGluIHRoZSBDU1MgY2xhc3Nlcy5cbiAqXG4gKlxuICogIyMjIENTUyBTdGFnZ2VyaW5nIEFuaW1hdGlvbnNcbiAqIEEgU3RhZ2dlcmluZyBhbmltYXRpb24gaXMgYSBjb2xsZWN0aW9uIG9mIGFuaW1hdGlvbnMgdGhhdCBhcmUgaXNzdWVkIHdpdGggYSBzbGlnaHQgZGVsYXkgaW4gYmV0d2VlbiBlYWNoIHN1Y2Nlc3NpdmUgb3BlcmF0aW9uIHJlc3VsdGluZyBpbiBhXG4gKiBjdXJ0YWluLWxpa2UgZWZmZWN0LiBUaGUgbmdBbmltYXRlIG1vZHVsZSAodmVyc2lvbnMgPj0xLjIpIHN1cHBvcnRzIHN0YWdnZXJpbmcgYW5pbWF0aW9ucyBhbmQgdGhlIHN0YWdnZXIgZWZmZWN0IGNhbiBiZVxuICogcGVyZm9ybWVkIGJ5IGNyZWF0aW5nIGEgKipuZy1FVkVOVC1zdGFnZ2VyKiogQ1NTIGNsYXNzIGFuZCBhdHRhY2hpbmcgdGhhdCBjbGFzcyB0byB0aGUgYmFzZSBDU1MgY2xhc3MgdXNlZCBmb3JcbiAqIHRoZSBhbmltYXRpb24uIFRoZSBzdHlsZSBwcm9wZXJ0eSBleHBlY3RlZCB3aXRoaW4gdGhlIHN0YWdnZXIgY2xhc3MgY2FuIGVpdGhlciBiZSBhICoqdHJhbnNpdGlvbi1kZWxheSoqIG9yIGFuXG4gKiAqKmFuaW1hdGlvbi1kZWxheSoqIHByb3BlcnR5IChvciBib3RoIGlmIHlvdXIgYW5pbWF0aW9uIGNvbnRhaW5zIGJvdGggdHJhbnNpdGlvbnMgYW5kIGtleWZyYW1lIGFuaW1hdGlvbnMpLlxuICpcbiAqIGBgYGNzc1xuICogLm15LWFuaW1hdGlvbi5uZy1lbnRlciB7XG4gKiAgIC8mIzQyOyBzdGFuZGFyZCB0cmFuc2l0aW9uIGNvZGUgJiM0MjsvXG4gKiAgIHRyYW5zaXRpb246IDFzIGxpbmVhciBhbGw7XG4gKiAgIG9wYWNpdHk6MDtcbiAqIH1cbiAqIC5teS1hbmltYXRpb24ubmctZW50ZXItc3RhZ2dlciB7XG4gKiAgIC8mIzQyOyB0aGlzIHdpbGwgaGF2ZSBhIDEwMG1zIGRlbGF5IGJldHdlZW4gZWFjaCBzdWNjZXNzaXZlIGxlYXZlIGFuaW1hdGlvbiAmIzQyOy9cbiAqICAgdHJhbnNpdGlvbi1kZWxheTogMC4xcztcbiAqXG4gKiAgIC8mIzQyOyBBcyBvZiAxLjQuNCwgdGhpcyBtdXN0IGFsd2F5cyBiZSBzZXQ6IGl0IHNpZ25hbHMgbmdBbmltYXRlXG4gKiAgICAgdG8gbm90IGFjY2lkZW50YWxseSBpbmhlcml0IGEgZGVsYXkgcHJvcGVydHkgZnJvbSBhbm90aGVyIENTUyBjbGFzcyAmIzQyOy9cbiAqICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMHM7XG4gKiB9XG4gKiAubXktYW5pbWF0aW9uLm5nLWVudGVyLm5nLWVudGVyLWFjdGl2ZSB7XG4gKiAgIC8mIzQyOyBzdGFuZGFyZCB0cmFuc2l0aW9uIHN0eWxlcyAmIzQyOy9cbiAqICAgb3BhY2l0eToxO1xuICogfVxuICogYGBgXG4gKlxuICogU3RhZ2dlcmluZyBhbmltYXRpb25zIHdvcmsgYnkgZGVmYXVsdCBpbiBuZ1JlcGVhdCAoc28gbG9uZyBhcyB0aGUgQ1NTIGNsYXNzIGlzIGRlZmluZWQpLiBPdXRzaWRlIG9mIG5nUmVwZWF0LCB0byB1c2Ugc3RhZ2dlcmluZyBhbmltYXRpb25zXG4gKiBvbiB5b3VyIG93biwgdGhleSBjYW4gYmUgdHJpZ2dlcmVkIGJ5IGZpcmluZyBtdWx0aXBsZSBjYWxscyB0byB0aGUgc2FtZSBldmVudCBvbiAkYW5pbWF0ZS4gSG93ZXZlciwgdGhlIHJlc3RyaWN0aW9ucyBzdXJyb3VuZGluZyB0aGlzXG4gKiBhcmUgdGhhdCBlYWNoIG9mIHRoZSBlbGVtZW50cyBtdXN0IGhhdmUgdGhlIHNhbWUgQ1NTIGNsYXNzTmFtZSB2YWx1ZSBhcyB3ZWxsIGFzIHRoZSBzYW1lIHBhcmVudCBlbGVtZW50LiBBIHN0YWdnZXIgb3BlcmF0aW9uXG4gKiB3aWxsIGFsc28gYmUgcmVzZXQgaWYgb25lIG9yIG1vcmUgYW5pbWF0aW9uIGZyYW1lcyBoYXZlIHBhc3NlZCBzaW5jZSB0aGUgbXVsdGlwbGUgY2FsbHMgdG8gYCRhbmltYXRlYCB3ZXJlIGZpcmVkLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgY29kZSB3aWxsIGlzc3VlIHRoZSAqKm5nLWxlYXZlLXN0YWdnZXIqKiBldmVudCBvbiB0aGUgZWxlbWVudCBwcm92aWRlZDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGtpZHMgPSBwYXJlbnQuY2hpbGRyZW4oKTtcbiAqXG4gKiAkYW5pbWF0ZS5sZWF2ZShraWRzWzBdKTsgLy9zdGFnZ2VyIGluZGV4PTBcbiAqICRhbmltYXRlLmxlYXZlKGtpZHNbMV0pOyAvL3N0YWdnZXIgaW5kZXg9MVxuICogJGFuaW1hdGUubGVhdmUoa2lkc1syXSk7IC8vc3RhZ2dlciBpbmRleD0yXG4gKiAkYW5pbWF0ZS5sZWF2ZShraWRzWzNdKTsgLy9zdGFnZ2VyIGluZGV4PTNcbiAqICRhbmltYXRlLmxlYXZlKGtpZHNbNF0pOyAvL3N0YWdnZXIgaW5kZXg9NFxuICpcbiAqIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gKiAgIC8vc3RhZ2dlciBoYXMgcmVzZXQgaXRzZWxmXG4gKiAgICRhbmltYXRlLmxlYXZlKGtpZHNbNV0pOyAvL3N0YWdnZXIgaW5kZXg9MFxuICogICAkYW5pbWF0ZS5sZWF2ZShraWRzWzZdKTsgLy9zdGFnZ2VyIGluZGV4PTFcbiAqXG4gKiAgICRzY29wZS4kZGlnZXN0KCk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFN0YWdnZXIgYW5pbWF0aW9ucyBhcmUgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIHdpdGhpbiBDU1MtZGVmaW5lZCBhbmltYXRpb25zLlxuICpcbiAqICMjIyBUaGUgYG5nLWFuaW1hdGVgIENTUyBjbGFzc1xuICpcbiAqIFdoZW4gbmdBbmltYXRlIGlzIGFuaW1hdGluZyBhbiBlbGVtZW50IGl0IHdpbGwgYXBwbHkgdGhlIGBuZy1hbmltYXRlYCBDU1MgY2xhc3MgdG8gdGhlIGVsZW1lbnQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuICogVGhpcyBpcyBhIHRlbXBvcmFyeSBDU1MgY2xhc3MgYW5kIGl0IHdpbGwgYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmltYXRpb24gaXMgb3ZlciAoZm9yIGJvdGggSmF2YVNjcmlwdCBhbmQgQ1NTLWJhc2VkIGFuaW1hdGlvbnMpLlxuICpcbiAqIFRoZXJlZm9yZSwgYW5pbWF0aW9ucyBjYW4gYmUgYXBwbGllZCB0byBhbiBlbGVtZW50IHVzaW5nIHRoaXMgdGVtcG9yYXJ5IGNsYXNzIGRpcmVjdGx5IHZpYSBDU1MuXG4gKlxuICogYGBgY3NzXG4gKiAuemlwcGVyLm5nLWFuaW1hdGUge1xuICogICB0cmFuc2l0aW9uOjAuNXMgbGluZWFyIGFsbDtcbiAqIH1cbiAqIC56aXBwZXIubmctZW50ZXIge1xuICogICBvcGFjaXR5OjA7XG4gKiB9XG4gKiAuemlwcGVyLm5nLWVudGVyLm5nLWVudGVyLWFjdGl2ZSB7XG4gKiAgIG9wYWNpdHk6MTtcbiAqIH1cbiAqIC56aXBwZXIubmctbGVhdmUge1xuICogICBvcGFjaXR5OjE7XG4gKiB9XG4gKiAuemlwcGVyLm5nLWxlYXZlLm5nLWxlYXZlLWFjdGl2ZSB7XG4gKiAgIG9wYWNpdHk6MDtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIChOb3RlIHRoYXQgdGhlIGBuZy1hbmltYXRlYCBDU1MgY2xhc3MgaXMgcmVzZXJ2ZWQgYW5kIGl0IGNhbm5vdCBiZSBhcHBsaWVkIG9uIGFuIGVsZW1lbnQgZGlyZWN0bHkgc2luY2UgbmdBbmltYXRlIHdpbGwgYWx3YXlzIHJlbW92ZVxuICogdGhlIENTUyBjbGFzcyBvbmNlIGFuIGFuaW1hdGlvbiBoYXMgY29tcGxldGVkLilcbiAqXG4gKlxuICogIyMgSmF2YVNjcmlwdC1iYXNlZCBBbmltYXRpb25zXG4gKlxuICogbmdBbmltYXRlIGFsc28gYWxsb3dzIGZvciBhbmltYXRpb25zIHRvIGJlIGNvbnN1bWVkIGJ5IEphdmFTY3JpcHQgY29kZS4gVGhlIGFwcHJvYWNoIGlzIHNpbWlsYXIgdG8gQ1NTLWJhc2VkIGFuaW1hdGlvbnMgKHdoZXJlIHRoZXJlIGlzIGEgc2hhcmVkXG4gKiBDU1MgY2xhc3MgdGhhdCBpcyByZWZlcmVuY2VkIGluIG91ciBIVE1MIGNvZGUpIGJ1dCBpbiBhZGRpdGlvbiB3ZSBuZWVkIHRvIHJlZ2lzdGVyIHRoZSBKYXZhU2NyaXB0IGFuaW1hdGlvbiBvbiB0aGUgbW9kdWxlLiBCeSBtYWtpbmcgdXNlIG9mIHRoZVxuICogYG1vZHVsZS5hbmltYXRpb24oKWAgbW9kdWxlIGZ1bmN0aW9uIHdlIGNhbiByZWdpc3RlciB0aGUgYWlubWF0aW9uLlxuICpcbiAqIExldCdzIHNlZSBhbiBleGFtcGxlIG9mIGEgZW50ZXIvbGVhdmUgYW5pbWF0aW9uIHVzaW5nIGBuZ1JlcGVhdGA6XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiBuZy1yZXBlYXQ9XCJpdGVtIGluIGl0ZW1zXCIgY2xhc3M9XCJzbGlkZVwiPlxuICogICB7eyBpdGVtIH19XG4gKiA8L2Rpdj5cbiAqIGBgYFxuICpcbiAqIFNlZSB0aGUgKipzbGlkZSoqIENTUyBjbGFzcz8gTGV0J3MgdXNlIHRoYXQgY2xhc3MgdG8gZGVmaW5lIGFuIGFuaW1hdGlvbiB0aGF0IHdlJ2xsIHN0cnVjdHVyZSBpbiBvdXIgbW9kdWxlIGNvZGUgYnkgdXNpbmcgYG1vZHVsZS5hbmltYXRpb25gOlxuICpcbiAqIGBgYGpzXG4gKiBteU1vZHVsZS5hbmltYXRpb24oJy5zbGlkZScsIFtmdW5jdGlvbigpIHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICAvLyBtYWtlIG5vdGUgdGhhdCBvdGhlciBldmVudHMgKGxpa2UgYWRkQ2xhc3MvcmVtb3ZlQ2xhc3MpXG4gKiAgICAgLy8gaGF2ZSBkaWZmZXJlbnQgZnVuY3Rpb24gaW5wdXQgcGFyYW1ldGVyc1xuICogICAgIGVudGVyOiBmdW5jdGlvbihlbGVtZW50LCBkb25lRm4pIHtcbiAqICAgICAgIGpRdWVyeShlbGVtZW50KS5mYWRlSW4oMTAwMCwgZG9uZUZuKTtcbiAqXG4gKiAgICAgICAvLyByZW1lbWJlciB0byBjYWxsIGRvbmVGbiBzbyB0aGF0IGFuZ3VsYXJcbiAqICAgICAgIC8vIGtub3dzIHRoYXQgdGhlIGFuaW1hdGlvbiBoYXMgY29uY2x1ZGVkXG4gKiAgICAgfSxcbiAqXG4gKiAgICAgbW92ZTogZnVuY3Rpb24oZWxlbWVudCwgZG9uZUZuKSB7XG4gKiAgICAgICBqUXVlcnkoZWxlbWVudCkuZmFkZUluKDEwMDAsIGRvbmVGbik7XG4gKiAgICAgfSxcbiAqXG4gKiAgICAgbGVhdmU6IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmVGbikge1xuICogICAgICAgalF1ZXJ5KGVsZW1lbnQpLmZhZGVPdXQoMTAwMCwgZG9uZUZuKTtcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1dXG4gKiBgYGBcbiAqXG4gKiBUaGUgbmljZSB0aGluZyBhYm91dCBKUy1iYXNlZCBhbmltYXRpb25zIGlzIHRoYXQgd2UgY2FuIGluamVjdCBvdGhlciBzZXJ2aWNlcyBhbmQgbWFrZSB1c2Ugb2YgYWR2YW5jZWQgYW5pbWF0aW9uIGxpYnJhcmllcyBzdWNoIGFzXG4gKiBncmVlbnNvY2suanMgYW5kIHZlbG9jaXR5LmpzLlxuICpcbiAqIElmIG91ciBhbmltYXRpb24gY29kZSBjbGFzcy1iYXNlZCAobWVhbmluZyB0aGF0IHNvbWV0aGluZyBsaWtlIGBuZ0NsYXNzYCwgYG5nSGlkZWAgYW5kIGBuZ1Nob3dgIHRyaWdnZXJzIGl0KSB0aGVuIHdlIGNhbiBzdGlsbCBkZWZpbmVcbiAqIG91ciBhbmltYXRpb25zIGluc2lkZSBvZiB0aGUgc2FtZSByZWdpc3RlcmVkIGFuaW1hdGlvbiwgaG93ZXZlciwgdGhlIGZ1bmN0aW9uIGlucHV0IGFyZ3VtZW50cyBhcmUgYSBiaXQgZGlmZmVyZW50OlxuICpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgbmctY2xhc3M9XCJjb2xvclwiIGNsYXNzPVwiY29sb3JmdWxcIj5cbiAqICAgdGhpcyBib3ggaXMgbW9vZHlcbiAqIDwvZGl2PlxuICogPGJ1dHRvbiBuZy1jbGljaz1cImNvbG9yPSdyZWQnXCI+Q2hhbmdlIHRvIHJlZDwvYnV0dG9uPlxuICogPGJ1dHRvbiBuZy1jbGljaz1cImNvbG9yPSdibHVlJ1wiPkNoYW5nZSB0byBibHVlPC9idXR0b24+XG4gKiA8YnV0dG9uIG5nLWNsaWNrPVwiY29sb3I9J2dyZWVuJ1wiPkNoYW5nZSB0byBncmVlbjwvYnV0dG9uPlxuICogYGBgXG4gKlxuICogYGBganNcbiAqIG15TW9kdWxlLmFuaW1hdGlvbignLmNvbG9yZnVsJywgW2Z1bmN0aW9uKCkge1xuICogICByZXR1cm4ge1xuICogICAgIGFkZENsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUsIGRvbmVGbikge1xuICogICAgICAgLy8gZG8gc29tZSBjb29sIGFuaW1hdGlvbiBhbmQgY2FsbCB0aGUgZG9uZUZuXG4gKiAgICAgfSxcbiAqICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lLCBkb25lRm4pIHtcbiAqICAgICAgIC8vIGRvIHNvbWUgY29vbCBhbmltYXRpb24gYW5kIGNhbGwgdGhlIGRvbmVGblxuICogICAgIH0sXG4gKiAgICAgc2V0Q2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGFkZGVkQ2xhc3MsIHJlbW92ZWRDbGFzcywgZG9uZUZuKSB7XG4gKiAgICAgICAvLyBkbyBzb21lIGNvb2wgYW5pbWF0aW9uIGFuZCBjYWxsIHRoZSBkb25lRm5cbiAqICAgICB9XG4gKiAgIH1cbiAqIH1dXG4gKiBgYGBcbiAqXG4gKiAjIyBDU1MgKyBKUyBBbmltYXRpb25zIFRvZ2V0aGVyXG4gKlxuICogQW5ndWxhckpTIDEuNCBhbmQgaGlnaGVyIGhhcyB0YWtlbiBzdGVwcyB0byBtYWtlIHRoZSBhbWFsZ2FtYXRpb24gb2YgQ1NTIGFuZCBKUyBhbmltYXRpb25zIG1vcmUgZmxleGlibGUuIEhvd2V2ZXIsIHVubGlrZSBlYXJsaWVyIHZlcnNpb25zIG9mIEFuZ3VsYXIsXG4gKiBkZWZpbmluZyBDU1MgYW5kIEpTIGFuaW1hdGlvbnMgdG8gd29yayBvZmYgb2YgdGhlIHNhbWUgQ1NTIGNsYXNzIHdpbGwgbm90IHdvcmsgYW55bW9yZS4gVGhlcmVmb3JlIHRoZSBleGFtcGxlIGJlbG93IHdpbGwgb25seSByZXN1bHQgaW4gKipKUyBhbmltYXRpb25zIHRha2luZ1xuICogY2hhcmdlIG9mIHRoZSBhbmltYXRpb24qKjpcbiAqXG4gKiBgYGBodG1sXG4gKiA8ZGl2IG5nLWlmPVwiYm9vbFwiIGNsYXNzPVwic2xpZGVcIj5cbiAqICAgU2xpZGUgaW4gYW5kIG91dFxuICogPC9kaXY+XG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogbXlNb2R1bGUuYW5pbWF0aW9uKCcuc2xpZGUnLCBbZnVuY3Rpb24oKSB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgZW50ZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmVGbikge1xuICogICAgICAgalF1ZXJ5KGVsZW1lbnQpLnNsaWRlSW4oMTAwMCwgZG9uZUZuKTtcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1dXG4gKiBgYGBcbiAqXG4gKiBgYGBjc3NcbiAqIC5zbGlkZS5uZy1lbnRlciB7XG4gKiAgIHRyYW5zaXRpb246MC41cyBsaW5lYXIgYWxsO1xuICogICB0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTAwcHgpO1xuICogfVxuICogLnNsaWRlLm5nLWVudGVyLm5nLWVudGVyLWFjdGl2ZSB7XG4gKiAgIHRyYW5zZm9ybTp0cmFuc2xhdGVZKDApO1xuICogfVxuICogYGBgXG4gKlxuICogRG9lcyB0aGlzIG1lYW4gdGhhdCBDU1MgYW5kIEpTIGFuaW1hdGlvbnMgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXI/IERvIEpTLWJhc2VkIGFuaW1hdGlvbnMgYWx3YXlzIGhhdmUgaGlnaGVyIHByaW9yaXR5PyBXZSBjYW4gbWFrZSB1cCBmb3IgdGhlXG4gKiBsYWNrIG9mIENTUyBhbmltYXRpb25zIGJ5IHVzaW5nIHRoZSBgJGFuaW1hdGVDc3NgIHNlcnZpY2UgdG8gdHJpZ2dlciBvdXIgb3duIHR3ZWFrZWQtb3V0LCBDU1MtYmFzZWQgYW5pbWF0aW9ucyBkaXJlY3RseSBmcm9tXG4gKiBvdXIgb3duIEpTLWJhc2VkIGFuaW1hdGlvbiBjb2RlOlxuICpcbiAqIGBgYGpzXG4gKiBteU1vZHVsZS5hbmltYXRpb24oJy5zbGlkZScsIFsnJGFuaW1hdGVDc3MnLCBmdW5jdGlvbigkYW5pbWF0ZUNzcykge1xuICogICByZXR1cm4ge1xuICogICAgIGVudGVyOiBmdW5jdGlvbihlbGVtZW50LCBkb25lRm4pIHtcbiogICAgICAgIC8vIHRoaXMgd2lsbCB0cmlnZ2VyIGAuc2xpZGUubmctZW50ZXJgIGFuZCBgLnNsaWRlLm5nLWVudGVyLWFjdGl2ZWAuXG4gKiAgICAgICB2YXIgcnVubmVyID0gJGFuaW1hdGVDc3MoZWxlbWVudCwge1xuICogICAgICAgICBldmVudDogJ2VudGVyJyxcbiAqICAgICAgICAgc3RydWN0dXJhbDogdHJ1ZVxuICogICAgICAgfSkuc3RhcnQoKTtcbiogICAgICAgIHJ1bm5lci5kb25lKGRvbmVGbik7XG4gKiAgICAgfVxuICogICB9XG4gKiB9XVxuICogYGBgXG4gKlxuICogVGhlIG5pY2UgdGhpbmcgaGVyZSBpcyB0aGF0IHdlIGNhbiBzYXZlIGJhbmR3aWR0aCBieSBzdGlja2luZyB0byBvdXIgQ1NTLWJhc2VkIGFuaW1hdGlvbiBjb2RlIGFuZCB3ZSBkb24ndCBuZWVkIHRvIHJlbHkgb24gYSAzcmQtcGFydHkgYW5pbWF0aW9uIGZyYW1ld29yay5cbiAqXG4gKiBUaGUgYCRhbmltYXRlQ3NzYCBzZXJ2aWNlIGlzIHZlcnkgcG93ZXJmdWwgc2luY2Ugd2UgY2FuIGZlZWQgaW4gYWxsIGtpbmRzIG9mIGV4dHJhIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGV2YWx1YXRlZCBhbmQgZmVkIGludG8gYSBDU1MgdHJhbnNpdGlvbiBvclxuICoga2V5ZnJhbWUgYW5pbWF0aW9uLiBGb3IgZXhhbXBsZSBpZiB3ZSB3YW50ZWQgdG8gYW5pbWF0ZSB0aGUgaGVpZ2h0IG9mIGFuIGVsZW1lbnQgd2hpbGUgYWRkaW5nIGFuZCByZW1vdmluZyBjbGFzc2VzIHRoZW4gd2UgY2FuIGRvIHNvIGJ5IHByb3ZpZGluZyB0aGF0XG4gKiBkYXRhIGludG8gYCRhbmltYXRlQ3NzYCBkaXJlY3RseTpcbiAqXG4gKiBgYGBqc1xuICogbXlNb2R1bGUuYW5pbWF0aW9uKCcuc2xpZGUnLCBbJyRhbmltYXRlQ3NzJywgZnVuY3Rpb24oJGFuaW1hdGVDc3MpIHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBlbnRlcjogZnVuY3Rpb24oZWxlbWVudCwgZG9uZUZuKSB7XG4gKiAgICAgICB2YXIgcnVubmVyID0gJGFuaW1hdGVDc3MoZWxlbWVudCwge1xuICogICAgICAgICBldmVudDogJ2VudGVyJyxcbiAqICAgICAgICAgc3RydWN0dXJhbDogdHJ1ZSxcbiAqICAgICAgICAgYWRkQ2xhc3M6ICdtYXJvb24tc2V0dGluZycsXG4gKiAgICAgICAgIGZyb206IHsgaGVpZ2h0OjAgfSxcbiAqICAgICAgICAgdG86IHsgaGVpZ2h0OiAyMDAgfVxuICogICAgICAgfSkuc3RhcnQoKTtcbiAqXG4gKiAgICAgICBydW5uZXIuZG9uZShkb25lRm4pO1xuICogICAgIH1cbiAqICAgfVxuICogfV1cbiAqIGBgYFxuICpcbiAqIE5vdyB3ZSBjYW4gZmlsbCBpbiB0aGUgcmVzdCB2aWEgb3VyIHRyYW5zaXRpb24gQ1NTIGNvZGU6XG4gKlxuICogYGBgY3NzXG4gKiAvJiM0MjsgdGhlIHRyYW5zaXRpb24gdGVsbHMgbmdBbmltYXRlIHRvIG1ha2UgdGhlIGFuaW1hdGlvbiBoYXBwZW4gJiM0MjsvXG4gKiAuc2xpZGUubmctZW50ZXIgeyB0cmFuc2l0aW9uOjAuNXMgbGluZWFyIGFsbDsgfVxuICpcbiAqIC8mIzQyOyB0aGlzIGV4dHJhIENTUyBjbGFzcyB3aWxsIGJlIGFic29yYmVkIGludG8gdGhlIHRyYW5zaXRpb25cbiAqIHNpbmNlIHRoZSAkYW5pbWF0ZUNzcyBjb2RlIGlzIGFkZGluZyB0aGUgY2xhc3MgJiM0MjsvXG4gKiAubWFyb29uLXNldHRpbmcgeyBiYWNrZ3JvdW5kOnJlZDsgfVxuICogYGBgXG4gKlxuICogQW5kIGAkYW5pbWF0ZUNzc2Agd2lsbCBmaWd1cmUgb3V0IHRoZSByZXN0LiBKdXN0IG1ha2Ugc3VyZSB0byBoYXZlIHRoZSBgZG9uZSgpYCBjYWxsYmFjayBmaXJlIHRoZSBgZG9uZUZuYCBmdW5jdGlvbiB0byBzaWduYWwgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIG92ZXIuXG4gKlxuICogVG8gbGVhcm4gbW9yZSBhYm91dCB3aGF0J3MgcG9zc2libGUgYmUgc3VyZSB0byB2aXNpdCB0aGUge0BsaW5rIG5nQW5pbWF0ZS4kYW5pbWF0ZUNzcyAkYW5pbWF0ZUNzcyBzZXJ2aWNlfS5cbiAqXG4gKiAjIyBBbmltYXRpb24gQW5jaG9yaW5nICh2aWEgYG5nLWFuaW1hdGUtcmVmYClcbiAqXG4gKiBuZ0FuaW1hdGUgaW4gQW5ndWxhckpTIDEuNCBjb21lcyBwYWNrZWQgd2l0aCB0aGUgYWJpbGl0eSB0byBjcm9zcy1hbmltYXRlIGVsZW1lbnRzIGJldHdlZW5cbiAqIHN0cnVjdHVyYWwgYXJlYXMgb2YgYW4gYXBwbGljYXRpb24gKGxpa2Ugdmlld3MpIGJ5IHBhaXJpbmcgdXAgZWxlbWVudHMgdXNpbmcgYW4gYXR0cmlidXRlXG4gKiBjYWxsZWQgYG5nLWFuaW1hdGUtcmVmYC5cbiAqXG4gKiBMZXQncyBzYXkgZm9yIGV4YW1wbGUgd2UgaGF2ZSB0d28gdmlld3MgdGhhdCBhcmUgbWFuYWdlZCBieSBgbmctdmlld2AgYW5kIHdlIHdhbnQgdG8gc2hvd1xuICogdGhhdCB0aGVyZSBpcyBhIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHR3byBjb21wb25lbnRzIHNpdHVhdGVkIGluIHdpdGhpbiB0aGVzZSB2aWV3cy4gQnkgdXNpbmcgdGhlXG4gKiBgbmctYW5pbWF0ZS1yZWZgIGF0dHJpYnV0ZSB3ZSBjYW4gaWRlbnRpZnkgdGhhdCB0aGUgdHdvIGNvbXBvbmVudHMgYXJlIHBhaXJlZCB0b2dldGhlciBhbmQgd2VcbiAqIGNhbiB0aGVuIGF0dGFjaCBhbiBhbmltYXRpb24sIHdoaWNoIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB2aWV3IGNoYW5nZXMuXG4gKlxuICogU2F5IGZvciBleGFtcGxlIHdlIGhhdmUgdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZSBjb2RlOlxuICpcbiAqIGBgYGh0bWxcbiAqIDwhLS0gaW5kZXguaHRtbCAtLT5cbiAqIDxkaXYgbmctdmlldyBjbGFzcz1cInZpZXctYW5pbWF0aW9uXCI+XG4gKiA8L2Rpdj5cbiAqXG4gKiA8IS0tIGhvbWUuaHRtbCAtLT5cbiAqIDxhIGhyZWY9XCIjL2Jhbm5lci1wYWdlXCI+XG4gKiAgIDxpbWcgc3JjPVwiLi9iYW5uZXIuanBnXCIgY2xhc3M9XCJiYW5uZXJcIiBuZy1hbmltYXRlLXJlZj1cImJhbm5lclwiPlxuICogPC9hPlxuICpcbiAqIDwhLS0gYmFubmVyLXBhZ2UuaHRtbCAtLT5cbiAqIDxpbWcgc3JjPVwiLi9iYW5uZXIuanBnXCIgY2xhc3M9XCJiYW5uZXJcIiBuZy1hbmltYXRlLXJlZj1cImJhbm5lclwiPlxuICogYGBgXG4gKlxuICogTm93LCB3aGVuIHRoZSB2aWV3IGNoYW5nZXMgKG9uY2UgdGhlIGxpbmsgaXMgY2xpY2tlZCksIG5nQW5pbWF0ZSB3aWxsIGV4YW1pbmUgdGhlXG4gKiBIVE1MIGNvbnRlbnRzIHRvIHNlZSBpZiB0aGVyZSBpcyBhIG1hdGNoIHJlZmVyZW5jZSBiZXR3ZWVuIGFueSBjb21wb25lbnRzIGluIHRoZSB2aWV3XG4gKiB0aGF0IGlzIGxlYXZpbmcgYW5kIHRoZSB2aWV3IHRoYXQgaXMgZW50ZXJpbmcuIEl0IHdpbGwgc2NhbiBib3RoIHRoZSB2aWV3IHdoaWNoIGlzIGJlaW5nXG4gKiByZW1vdmVkIChsZWF2ZSkgYW5kIGluc2VydGVkIChlbnRlcikgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgcGFpcmVkIERPTSBlbGVtZW50cyB0aGF0XG4gKiBjb250YWluIGEgbWF0Y2hpbmcgcmVmIHZhbHVlLlxuICpcbiAqIFRoZSB0d28gaW1hZ2VzIG1hdGNoIHNpbmNlIHRoZXkgc2hhcmUgdGhlIHNhbWUgcmVmIHZhbHVlLiBuZ0FuaW1hdGUgd2lsbCBub3cgY3JlYXRlIGFcbiAqIHRyYW5zcG9ydCBlbGVtZW50ICh3aGljaCBpcyBhIGNsb25lIG9mIHRoZSBmaXJzdCBpbWFnZSBlbGVtZW50KSBhbmQgaXQgd2lsbCB0aGVuIGF0dGVtcHRcbiAqIHRvIGFuaW1hdGUgdG8gdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgaW1hZ2UgZWxlbWVudCBpbiB0aGUgbmV4dCB2aWV3LiBGb3IgdGhlIGFuaW1hdGlvbiB0b1xuICogd29yayBhIHNwZWNpYWwgQ1NTIGNsYXNzIGNhbGxlZCBgbmctYW5jaG9yYCB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0cmFuc3BvcnRlZCBlbGVtZW50LlxuICpcbiAqIFdlIGNhbiBub3cgYXR0YWNoIGEgdHJhbnNpdGlvbiBvbnRvIHRoZSBgLmJhbm5lci5uZy1hbmNob3JgIENTUyBjbGFzcyBhbmQgdGhlblxuICogbmdBbmltYXRlIHdpbGwgaGFuZGxlIHRoZSBlbnRpcmUgdHJhbnNpdGlvbiBmb3IgdXMgYXMgd2VsbCBhcyB0aGUgYWRkaXRpb24gYW5kIHJlbW92YWwgb2ZcbiAqIGFueSBjaGFuZ2VzIG9mIENTUyBjbGFzc2VzIGJldHdlZW4gdGhlIGVsZW1lbnRzOlxuICpcbiAqIGBgYGNzc1xuICogLmJhbm5lci5uZy1hbmNob3Ige1xuICogICAvJiM0MjsgdGhpcyBhbmltYXRpb24gd2lsbCBsYXN0IGZvciAxIHNlY29uZCBzaW5jZSB0aGVyZSBhcmVcbiAqICAgICAgICAgIHR3byBwaGFzZXMgdG8gdGhlIGFuaW1hdGlvbiAoYW4gYGluYCBhbmQgYW4gYG91dGAgcGhhc2UpICYjNDI7L1xuICogICB0cmFuc2l0aW9uOjAuNXMgbGluZWFyIGFsbDtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdlIGFsc28gKiptdXN0KiogaW5jbHVkZSBhbmltYXRpb25zIGZvciB0aGUgdmlld3MgdGhhdCBhcmUgYmVpbmcgZW50ZXJlZCBhbmQgcmVtb3ZlZFxuICogKG90aGVyd2lzZSBhbmNob3Jpbmcgd291bGRuJ3QgYmUgcG9zc2libGUgc2luY2UgdGhlIG5ldyB2aWV3IHdvdWxkIGJlIGluc2VydGVkIHJpZ2h0IGF3YXkpLlxuICpcbiAqIGBgYGNzc1xuICogLnZpZXctYW5pbWF0aW9uLm5nLWVudGVyLCAudmlldy1hbmltYXRpb24ubmctbGVhdmUge1xuICogICB0cmFuc2l0aW9uOjAuNXMgbGluZWFyIGFsbDtcbiAqICAgcG9zaXRpb246Zml4ZWQ7XG4gKiAgIGxlZnQ6MDtcbiAqICAgdG9wOjA7XG4gKiAgIHdpZHRoOjEwMCU7XG4gKiB9XG4gKiAudmlldy1hbmltYXRpb24ubmctZW50ZXIge1xuICogICB0cmFuc2Zvcm06dHJhbnNsYXRlWCgxMDAlKTtcbiAqIH1cbiAqIC52aWV3LWFuaW1hdGlvbi5uZy1sZWF2ZSxcbiAqIC52aWV3LWFuaW1hdGlvbi5uZy1lbnRlci5uZy1lbnRlci1hY3RpdmUge1xuICogICB0cmFuc2Zvcm06dHJhbnNsYXRlWCgwJSk7XG4gKiB9XG4gKiAudmlldy1hbmltYXRpb24ubmctbGVhdmUubmctbGVhdmUtYWN0aXZlIHtcbiAqICAgdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpO1xuICogfVxuICogYGBgXG4gKlxuICogTm93IHdlIGNhbiBqdW1wIGJhY2sgdG8gdGhlIGFuY2hvciBhbmltYXRpb24uIFdoZW4gdGhlIGFuaW1hdGlvbiBoYXBwZW5zLCB0aGVyZSBhcmUgdHdvIHN0YWdlcyB0aGF0IG9jY3VyOlxuICogYW4gYG91dGAgYW5kIGFuIGBpbmAgc3RhZ2UuIFRoZSBgb3V0YCBzdGFnZSBoYXBwZW5zIGZpcnN0IGFuZCB0aGF0IGlzIHdoZW4gdGhlIGVsZW1lbnQgaXMgYW5pbWF0ZWQgYXdheVxuICogZnJvbSBpdHMgb3JpZ2luLiBPbmNlIHRoYXQgYW5pbWF0aW9uIGlzIG92ZXIgdGhlbiB0aGUgYGluYCBzdGFnZSBvY2N1cnMgd2hpY2ggYW5pbWF0ZXMgdGhlXG4gKiBlbGVtZW50IHRvIGl0cyBkZXN0aW5hdGlvbi4gVGhlIHJlYXNvbiB3aHkgdGhlcmUgYXJlIHR3byBhbmltYXRpb25zIGlzIHRvIGdpdmUgZW5vdWdoIHRpbWVcbiAqIGZvciB0aGUgZW50ZXIgYW5pbWF0aW9uIG9uIHRoZSBuZXcgZWxlbWVudCB0byBiZSByZWFkeS5cbiAqXG4gKiBUaGUgZXhhbXBsZSBhYm92ZSBzZXRzIHVwIGEgdHJhbnNpdGlvbiBmb3IgYm90aCB0aGUgaW4gYW5kIG91dCBwaGFzZXMsIGJ1dCB3ZSBjYW4gYWxzbyB0YXJnZXQgdGhlIG91dCBvclxuICogaW4gcGhhc2VzIGRpcmVjdGx5IHZpYSBgbmctYW5jaG9yLW91dGAgYW5kIGBuZy1hbmNob3ItaW5gLlxuICpcbiAqIGBgYGNzc1xuICogLmJhbm5lci5uZy1hbmNob3Itb3V0IHtcbiAqICAgdHJhbnNpdGlvbjogMC41cyBsaW5lYXIgYWxsO1xuICpcbiAqICAgLyYjNDI7IHRoZSBzY2FsZSB3aWxsIGJlIGFwcGxpZWQgZHVyaW5nIHRoZSBvdXQgYW5pbWF0aW9uLFxuICogICAgICAgICAgYnV0IHdpbGwgYmUgYW5pbWF0ZWQgYXdheSB3aGVuIHRoZSBpbiBhbmltYXRpb24gcnVucyAmIzQyOy9cbiAqICAgdHJhbnNmb3JtOiBzY2FsZSgxLjIpO1xuICogfVxuICpcbiAqIC5iYW5uZXIubmctYW5jaG9yLWluIHtcbiAqICAgdHJhbnNpdGlvbjogMXMgbGluZWFyIGFsbDtcbiAqIH1cbiAqIGBgYFxuICpcbiAqXG4gKlxuICpcbiAqICMjIyBBbmNob3JpbmcgRGVtb1xuICpcbiAgPGV4YW1wbGUgbW9kdWxlPVwiYW5jaG9yaW5nRXhhbXBsZVwiXG4gICAgICAgICAgIG5hbWU9XCJhbmNob3JpbmdFeGFtcGxlXCJcbiAgICAgICAgICAgaWQ9XCJhbmNob3JpbmdFeGFtcGxlXCJcbiAgICAgICAgICAgZGVwcz1cImFuZ3VsYXItYW5pbWF0ZS5qczthbmd1bGFyLXJvdXRlLmpzXCJcbiAgICAgICAgICAgYW5pbWF0aW9ucz1cInRydWVcIj5cbiAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgICAgPGEgaHJlZj1cIiMvXCI+SG9tZTwvYT5cbiAgICAgIDxociAvPlxuICAgICAgPGRpdiBjbGFzcz1cInZpZXctY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgbmctdmlldyBjbGFzcz1cInZpZXdcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZmlsZT5cbiAgICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XG4gICAgICBhbmd1bGFyLm1vZHVsZSgnYW5jaG9yaW5nRXhhbXBsZScsIFsnbmdBbmltYXRlJywgJ25nUm91dGUnXSlcbiAgICAgICAgLmNvbmZpZyhbJyRyb3V0ZVByb3ZpZGVyJywgZnVuY3Rpb24oJHJvdXRlUHJvdmlkZXIpIHtcbiAgICAgICAgICAkcm91dGVQcm92aWRlci53aGVuKCcvJywge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdob21lLmh0bWwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogJ0hvbWVDb250cm9sbGVyIGFzIGhvbWUnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgJHJvdXRlUHJvdmlkZXIud2hlbignL3Byb2ZpbGUvOmlkJywge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdwcm9maWxlLmh0bWwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogJ1Byb2ZpbGVDb250cm9sbGVyIGFzIHByb2ZpbGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1dKVxuICAgICAgICAucnVuKFsnJHJvb3RTY29wZScsIGZ1bmN0aW9uKCRyb290U2NvcGUpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLnJlY29yZHMgPSBbXG4gICAgICAgICAgICB7IGlkOjEsIHRpdGxlOiBcIk1pc3MgQmV1bGFoIFJvb2JcIiB9LFxuICAgICAgICAgICAgeyBpZDoyLCB0aXRsZTogXCJUcmVudCBNb3Jpc3NldHRlXCIgfSxcbiAgICAgICAgICAgIHsgaWQ6MywgdGl0bGU6IFwiTWlzcyBBdmEgUG91cm9zXCIgfSxcbiAgICAgICAgICAgIHsgaWQ6NCwgdGl0bGU6IFwiUm9kIFBvdXJvc1wiIH0sXG4gICAgICAgICAgICB7IGlkOjUsIHRpdGxlOiBcIkFiZHVsIFJpY2VcIiB9LFxuICAgICAgICAgICAgeyBpZDo2LCB0aXRsZTogXCJMYXVyaWUgUnV0aGVyZm9yZCBTci5cIiB9LFxuICAgICAgICAgICAgeyBpZDo3LCB0aXRsZTogXCJOYWtpYSBNY0xhdWdobGluXCIgfSxcbiAgICAgICAgICAgIHsgaWQ6OCwgdGl0bGU6IFwiSm9yZG9uIEJsYW5kYSBEVk1cIiB9LFxuICAgICAgICAgICAgeyBpZDo5LCB0aXRsZTogXCJSaG9kYSBIYW5kXCIgfSxcbiAgICAgICAgICAgIHsgaWQ6MTAsIHRpdGxlOiBcIkFsZXhhbmRyZWEgU2F1ZXJcIiB9XG4gICAgICAgICAgXTtcbiAgICAgICAgfV0pXG4gICAgICAgIC5jb250cm9sbGVyKCdIb21lQ29udHJvbGxlcicsIFtmdW5jdGlvbigpIHtcbiAgICAgICAgICAvL2VtcHR5XG4gICAgICAgIH1dKVxuICAgICAgICAuY29udHJvbGxlcignUHJvZmlsZUNvbnRyb2xsZXInLCBbJyRyb290U2NvcGUnLCAnJHJvdXRlUGFyYW1zJywgZnVuY3Rpb24oJHJvb3RTY29wZSwgJHJvdXRlUGFyYW1zKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoJHJvdXRlUGFyYW1zLmlkLCAxMCk7XG4gICAgICAgICAgdmFyIHJlY29yZCA9ICRyb290U2NvcGUucmVjb3Jkc1tpbmRleCAtIDFdO1xuXG4gICAgICAgICAgdGhpcy50aXRsZSA9IHJlY29yZC50aXRsZTtcbiAgICAgICAgICB0aGlzLmlkID0gcmVjb3JkLmlkO1xuICAgICAgICB9XSk7XG4gICAgPC9maWxlPlxuICAgIDxmaWxlIG5hbWU9XCJob21lLmh0bWxcIj5cbiAgICAgIDxoMj5XZWxjb21lIHRvIHRoZSBob21lIHBhZ2U8L2gxPlxuICAgICAgPHA+UGxlYXNlIGNsaWNrIG9uIGFuIGVsZW1lbnQ8L3A+XG4gICAgICA8YSBjbGFzcz1cInJlY29yZFwiXG4gICAgICAgICBuZy1ocmVmPVwiIy9wcm9maWxlL3t7IHJlY29yZC5pZCB9fVwiXG4gICAgICAgICBuZy1hbmltYXRlLXJlZj1cInt7IHJlY29yZC5pZCB9fVwiXG4gICAgICAgICBuZy1yZXBlYXQ9XCJyZWNvcmQgaW4gcmVjb3Jkc1wiPlxuICAgICAgICB7eyByZWNvcmQudGl0bGUgfX1cbiAgICAgIDwvYT5cbiAgICA8L2ZpbGU+XG4gICAgPGZpbGUgbmFtZT1cInByb2ZpbGUuaHRtbFwiPlxuICAgICAgPGRpdiBjbGFzcz1cInByb2ZpbGUgcmVjb3JkXCIgbmctYW5pbWF0ZS1yZWY9XCJ7eyBwcm9maWxlLmlkIH19XCI+XG4gICAgICAgIHt7IHByb2ZpbGUudGl0bGUgfX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZmlsZT5cbiAgICA8ZmlsZSBuYW1lPVwiYW5pbWF0aW9ucy5jc3NcIj5cbiAgICAgIC5yZWNvcmQge1xuICAgICAgICBkaXNwbGF5OmJsb2NrO1xuICAgICAgICBmb250LXNpemU6MjBweDtcbiAgICAgIH1cbiAgICAgIC5wcm9maWxlIHtcbiAgICAgICAgYmFja2dyb3VuZDpibGFjaztcbiAgICAgICAgY29sb3I6d2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZToxMDBweDtcbiAgICAgIH1cbiAgICAgIC52aWV3LWNvbnRhaW5lciB7XG4gICAgICAgIHBvc2l0aW9uOnJlbGF0aXZlO1xuICAgICAgfVxuICAgICAgLnZpZXctY29udGFpbmVyID4gLnZpZXcubmctYW5pbWF0ZSB7XG4gICAgICAgIHBvc2l0aW9uOmFic29sdXRlO1xuICAgICAgICB0b3A6MDtcbiAgICAgICAgbGVmdDowO1xuICAgICAgICB3aWR0aDoxMDAlO1xuICAgICAgICBtaW4taGVpZ2h0OjUwMHB4O1xuICAgICAgfVxuICAgICAgLnZpZXcubmctZW50ZXIsIC52aWV3Lm5nLWxlYXZlLFxuICAgICAgLnJlY29yZC5uZy1hbmNob3Ige1xuICAgICAgICB0cmFuc2l0aW9uOjAuNXMgbGluZWFyIGFsbDtcbiAgICAgIH1cbiAgICAgIC52aWV3Lm5nLWVudGVyIHtcbiAgICAgICAgdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTAwJSk7XG4gICAgICB9XG4gICAgICAudmlldy5uZy1lbnRlci5uZy1lbnRlci1hY3RpdmUsIC52aWV3Lm5nLWxlYXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCUpO1xuICAgICAgfVxuICAgICAgLnZpZXcubmctbGVhdmUubmctbGVhdmUtYWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpO1xuICAgICAgfVxuICAgICAgLnJlY29yZC5uZy1hbmNob3Itb3V0IHtcbiAgICAgICAgYmFja2dyb3VuZDpyZWQ7XG4gICAgICB9XG4gICAgPC9maWxlPlxuICA8L2V4YW1wbGU+XG4gKlxuICogIyMjIEhvdyBpcyB0aGUgZWxlbWVudCB0cmFuc3BvcnRlZD9cbiAqXG4gKiBXaGVuIGFuIGFuY2hvciBhbmltYXRpb24gb2NjdXJzLCBuZ0FuaW1hdGUgd2lsbCBjbG9uZSB0aGUgc3RhcnRpbmcgZWxlbWVudCBhbmQgcG9zaXRpb24gaXQgZXhhY3RseSB3aGVyZSB0aGUgc3RhcnRpbmdcbiAqIGVsZW1lbnQgaXMgbG9jYXRlZCBvbiBzY3JlZW4gdmlhIGFic29sdXRlIHBvc2l0aW9uaW5nLiBUaGUgY2xvbmVkIGVsZW1lbnQgd2lsbCBiZSBwbGFjZWQgaW5zaWRlIG9mIHRoZSByb290IGVsZW1lbnRcbiAqIG9mIHRoZSBhcHBsaWNhdGlvbiAod2hlcmUgbmctYXBwIHdhcyBkZWZpbmVkKSBhbmQgYWxsIG9mIHRoZSBDU1MgY2xhc3NlcyBvZiB0aGUgc3RhcnRpbmcgZWxlbWVudCB3aWxsIGJlIGFwcGxpZWQuIFRoZVxuICogZWxlbWVudCB3aWxsIHRoZW4gYW5pbWF0ZSBpbnRvIHRoZSBgb3V0YCBhbmQgYGluYCBhbmltYXRpb25zIGFuZCB3aWxsIGV2ZW50dWFsbHkgcmVhY2ggdGhlIGNvb3JkaW5hdGVzIGFuZCBtYXRjaFxuICogdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGRlc3RpbmF0aW9uIGVsZW1lbnQuIER1cmluZyB0aGUgZW50aXJlIGFuaW1hdGlvbiBhIENTUyBjbGFzcyBvZiBgLm5nLWFuaW1hdGUtc2hpbWAgd2lsbCBiZSBhcHBsaWVkXG4gKiB0byBib3RoIHRoZSBzdGFydGluZyBhbmQgZGVzdGluYXRpb24gZWxlbWVudHMgaW4gb3JkZXIgdG8gaGlkZSB0aGVtIGZyb20gYmVpbmcgdmlzaWJsZSAodGhlIENTUyBzdHlsaW5nIGZvciB0aGUgY2xhc3NcbiAqIGlzOiBgdmlzaWJpbGl0eTpoaWRkZW5gKS4gT25jZSB0aGUgYW5jaG9yIHJlYWNoZXMgaXRzIGRlc3RpbmF0aW9uIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkIGFuZCB0aGUgZGVzdGluYXRpb24gZWxlbWVudFxuICogd2lsbCBiZWNvbWUgdmlzaWJsZSBzaW5jZSB0aGUgc2hpbSBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuXG4gKlxuICogIyMjIEhvdyBpcyB0aGUgbW9ycGhpbmcgaGFuZGxlZD9cbiAqXG4gKiBDU1MgQW5jaG9yaW5nIHJlbGllcyBvbiB0cmFuc2l0aW9ucyBhbmQga2V5ZnJhbWVzIGFuZCB0aGUgaW50ZXJuYWwgY29kZSBpcyBpbnRlbGxpZ2VudCBlbm91Z2ggdG8gZmlndXJlIG91dFxuICogd2hhdCBDU1MgY2xhc3NlcyBkaWZmZXIgYmV0d2VlbiB0aGUgc3RhcnRpbmcgZWxlbWVudCBhbmQgdGhlIGRlc3RpbmF0aW9uIGVsZW1lbnQuIFRoZXNlIGRpZmZlcmVudCBDU1MgY2xhc3Nlc1xuICogd2lsbCBiZSBhZGRlZC9yZW1vdmVkIG9uIHRoZSBhbmNob3IgZWxlbWVudCBhbmQgYSB0cmFuc2l0aW9uIHdpbGwgYmUgYXBwbGllZCAodGhlIHRyYW5zaXRpb24gdGhhdCBpcyBwcm92aWRlZFxuICogaW4gdGhlIGFuY2hvciBjbGFzcykuIExvbmcgc3Rvcnkgc2hvcnQsIG5nQW5pbWF0ZSB3aWxsIGZpZ3VyZSBvdXQgd2hhdCBjbGFzc2VzIHRvIGFkZCBhbmQgcmVtb3ZlIHdoaWNoIHdpbGxcbiAqIG1ha2UgdGhlIHRyYW5zaXRpb24gb2YgdGhlIGVsZW1lbnQgYXMgc21vb3RoIGFuZCBhdXRvbWF0aWMgYXMgcG9zc2libGUuIEJlIHN1cmUgdG8gdXNlIHNpbXBsZSBDU1MgY2xhc3NlcyB0aGF0XG4gKiBkbyBub3QgcmVseSBvbiBET00gbmVzdGluZyBzdHJ1Y3R1cmUgc28gdGhhdCB0aGUgYW5jaG9yIGVsZW1lbnQgYXBwZWFycyB0aGUgc2FtZSBhcyB0aGUgc3RhcnRpbmcgZWxlbWVudCAoc2luY2VcbiAqIHRoZSBjbG9uZWQgZWxlbWVudCBpcyBwbGFjZWQgaW5zaWRlIG9mIHJvb3QgZWxlbWVudCB3aGljaCBpcyBsaWtlbHkgY2xvc2UgdG8gdGhlIGJvZHkgZWxlbWVudCkuXG4gKlxuICogTm90ZSB0aGF0IGlmIHRoZSByb290IGVsZW1lbnQgaXMgb24gdGhlIGA8aHRtbD5gIGVsZW1lbnQgdGhlbiB0aGUgY2xvbmVkIG5vZGUgd2lsbCBiZSBwbGFjZWQgaW5zaWRlIG9mIGJvZHkuXG4gKlxuICpcbiAqICMjIFVzaW5nICRhbmltYXRlIGluIHlvdXIgZGlyZWN0aXZlIGNvZGVcbiAqXG4gKiBTbyBmYXIgd2UndmUgZXhwbG9yZWQgaG93IHRvIGZlZWQgaW4gYW5pbWF0aW9ucyBpbnRvIGFuIEFuZ3VsYXIgYXBwbGljYXRpb24sIGJ1dCBob3cgZG8gd2UgdHJpZ2dlciBhbmltYXRpb25zIHdpdGhpbiBvdXIgb3duIGRpcmVjdGl2ZXMgaW4gb3VyIGFwcGxpY2F0aW9uP1xuICogQnkgaW5qZWN0aW5nIHRoZSBgJGFuaW1hdGVgIHNlcnZpY2UgaW50byBvdXIgZGlyZWN0aXZlIGNvZGUsIHdlIGNhbiB0cmlnZ2VyIHN0cnVjdHVyYWwgYW5kIGNsYXNzLWJhc2VkIGhvb2tzIHdoaWNoIGNhbiB0aGVuIGJlIGNvbnN1bWVkIGJ5IGFuaW1hdGlvbnMuIExldCdzXG4gKiBpbWFnaW5lIHdlIGhhdmUgYSBncmVldGluZyBib3ggdGhhdCBzaG93cyBhbmQgaGlkZXMgaXRzZWxmIHdoZW4gdGhlIGRhdGEgY2hhbmdlc1xuICpcbiAqIGBgYGh0bWxcbiAqIDxncmVldGluZy1ib3ggYWN0aXZlPVwib25Pck9mZlwiPkhpIHRoZXJlPC9ncmVldGluZy1ib3g+XG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogbmdNb2R1bGUuZGlyZWN0aXZlKCdncmVldGluZ0JveCcsIFsnJGFuaW1hdGUnLCBmdW5jdGlvbigkYW5pbWF0ZSkge1xuICogICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gKiAgICAgYXR0cnMuJG9ic2VydmUoJ2FjdGl2ZScsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgICAgICB2YWx1ZSA/ICRhbmltYXRlLmFkZENsYXNzKGVsZW1lbnQsICdvbicpIDogJGFuaW1hdGUucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ29uJyk7XG4gKiAgICAgfSk7XG4gKiAgIH0pO1xuICogfV0pO1xuICogYGBgXG4gKlxuICogTm93IHRoZSBgb25gIENTUyBjbGFzcyBpcyBhZGRlZCBhbmQgcmVtb3ZlZCBvbiB0aGUgZ3JlZXRpbmcgYm94IGNvbXBvbmVudC4gTm93IGlmIHdlIGFkZCBhIENTUyBjbGFzcyBvbiB0b3Agb2YgdGhlIGdyZWV0aW5nIGJveCBlbGVtZW50XG4gKiBpbiBvdXIgSFRNTCBjb2RlIHRoZW4gd2UgY2FuIHRyaWdnZXIgYSBDU1Mgb3IgSlMgYW5pbWF0aW9uIHRvIGhhcHBlbi5cbiAqXG4gKiBgYGBjc3NcbiAqIC8mIzQyOyBub3JtYWxseSB3ZSB3b3VsZCBjcmVhdGUgYSBDU1MgY2xhc3MgdG8gcmVmZXJlbmNlIG9uIHRoZSBlbGVtZW50ICYjNDI7L1xuICogZ3JlZXRpbmctYm94Lm9uIHsgdHJhbnNpdGlvbjowLjVzIGxpbmVhciBhbGw7IGJhY2tncm91bmQ6Z3JlZW47IGNvbG9yOndoaXRlOyB9XG4gKiBgYGBcbiAqXG4gKiBUaGUgYCRhbmltYXRlYCBzZXJ2aWNlIGNvbnRhaW5zIGEgdmFyaWV0eSBvZiBvdGhlciBtZXRob2RzIGxpa2UgYGVudGVyYCwgYGxlYXZlYCwgYGFuaW1hdGVgIGFuZCBgc2V0Q2xhc3NgLiBUbyBsZWFybiBtb3JlIGFib3V0IHdoYXQnc1xuICogcG9zc2libGUgYmUgc3VyZSB0byB2aXNpdCB0aGUge0BsaW5rIG5nLiRhbmltYXRlICRhbmltYXRlIHNlcnZpY2UgQVBJIHBhZ2V9LlxuICpcbiAqXG4gKiAjIyMgUHJldmVudGluZyBDb2xsaXNpb25zIFdpdGggVGhpcmQgUGFydHkgTGlicmFyaWVzXG4gKlxuICogU29tZSB0aGlyZC1wYXJ0eSBmcmFtZXdvcmtzIHBsYWNlIGFuaW1hdGlvbiBkdXJhdGlvbiBkZWZhdWx0cyBhY3Jvc3MgbWFueSBlbGVtZW50IG9yIGNsYXNzTmFtZVxuICogc2VsZWN0b3JzIGluIG9yZGVyIHRvIG1ha2UgdGhlaXIgY29kZSBzbWFsbCBhbmQgcmV1c2VhYmxlLiBUaGlzIGNhbiBsZWFkIHRvIGlzc3VlcyB3aXRoIG5nQW5pbWF0ZSwgd2hpY2hcbiAqIGlzIGV4cGVjdGluZyBhY3R1YWwgYW5pbWF0aW9ucyBvbiB0aGVzZSBlbGVtZW50cyBhbmQgaGFzIHRvIHdhaXQgZm9yIHRoZWlyIGNvbXBsZXRpb24uXG4gKlxuICogWW91IGNhbiBwcmV2ZW50IHRoaXMgdW53YW50ZWQgYmVoYXZpb3IgYnkgdXNpbmcgYSBwcmVmaXggb24gYWxsIHlvdXIgYW5pbWF0aW9uIGNsYXNzZXM6XG4gKlxuICogYGBgY3NzXG4gKiAvJiM0MjsgcHJlZml4ZWQgd2l0aCBhbmltYXRlLSAmIzQyOy9cbiAqIC5hbmltYXRlLWZhZGUtYWRkLmFuaW1hdGUtZmFkZS1hZGQtYWN0aXZlIHtcbiAqICAgdHJhbnNpdGlvbjoxcyBsaW5lYXIgYWxsO1xuICogICBvcGFjaXR5OjA7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBZb3UgdGhlbiBjb25maWd1cmUgYCRhbmltYXRlYCB0byBlbmZvcmNlIHRoaXMgcHJlZml4OlxuICpcbiAqIGBgYGpzXG4gKiAkYW5pbWF0ZVByb3ZpZGVyLmNsYXNzTmFtZUZpbHRlcigvYW5pbWF0ZS0vKTtcbiAqIGBgYFxuICpcbiAqIFRoaXMgYWxzbyBtYXkgcHJvdmlkZSB5b3VyIGFwcGxpY2F0aW9uIHdpdGggYSBzcGVlZCBib29zdCBzaW5jZSBvbmx5IHNwZWNpZmljIGVsZW1lbnRzIGNvbnRhaW5pbmcgQ1NTIGNsYXNzIHByZWZpeFxuICogd2lsbCBiZSBldmFsdWF0ZWQgZm9yIGFuaW1hdGlvbiB3aGVuIGFueSBET00gY2hhbmdlcyBvY2N1ciBpbiB0aGUgYXBwbGljYXRpb24uXG4gKlxuICogIyMgQ2FsbGJhY2tzIGFuZCBQcm9taXNlc1xuICpcbiAqIFdoZW4gYCRhbmltYXRlYCBpcyBjYWxsZWQgaXQgcmV0dXJucyBhIHByb21pc2UgdGhhdCBjYW4gYmUgdXNlZCB0byBjYXB0dXJlIHdoZW4gdGhlIGFuaW1hdGlvbiBoYXMgZW5kZWQuIFRoZXJlZm9yZSBpZiB3ZSB3ZXJlIHRvIHRyaWdnZXJcbiAqIGFuIGFuaW1hdGlvbiAod2l0aGluIG91ciBkaXJlY3RpdmUgY29kZSkgdGhlbiB3ZSBjYW4gY29udGludWUgcGVyZm9ybWluZyBkaXJlY3RpdmUgYW5kIHNjb3BlIHJlbGF0ZWQgYWN0aXZpdGllcyBhZnRlciB0aGUgYW5pbWF0aW9uIGhhc1xuICogZW5kZWQgYnkgY2hhaW5pbmcgb250byB0aGUgcmV0dXJuZWQgcHJvbWlzZSB0aGF0IGFuaW1hdGlvbiBtZXRob2QgcmV0dXJucy5cbiAqXG4gKiBgYGBqc1xuICogLy8gc29tZXdoZXJlIHdpdGhpbiB0aGUgZGVwdGhzIG9mIHRoZSBkaXJlY3RpdmVcbiAqICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIHBhcmVudCkudGhlbihmdW5jdGlvbigpIHtcbiAqICAgLy90aGUgYW5pbWF0aW9uIGhhcyBjb21wbGV0ZWRcbiAqIH0pO1xuICogYGBgXG4gKlxuICogKE5vdGUgdGhhdCBlYXJsaWVyIHZlcnNpb25zIG9mIEFuZ3VsYXIgcHJpb3IgdG8gdjEuNCByZXF1aXJlZCB0aGUgcHJvbWlzZSBjb2RlIHRvIGJlIHdyYXBwZWQgdXNpbmcgYCRzY29wZS4kYXBwbHkoLi4uKWAuIFRoaXMgaXMgbm90IHRoZSBjYXNlXG4gKiBhbnltb3JlLilcbiAqXG4gKiBJbiBhZGRpdGlvbiB0byB0aGUgYW5pbWF0aW9uIHByb21pc2UsIHdlIGNhbiBhbHNvIG1ha2UgdXNlIG9mIGFuaW1hdGlvbi1yZWxhdGVkIGNhbGxiYWNrcyB3aXRoaW4gb3VyIGRpcmVjdGl2ZXMgYW5kIGNvbnRyb2xsZXIgY29kZSBieSByZWdpc3RlcmluZ1xuICogYW4gZXZlbnQgbGlzdGVuZXIgdXNpbmcgdGhlIGAkYW5pbWF0ZWAgc2VydmljZS4gTGV0J3Mgc2F5IGZvciBleGFtcGxlIHRoYXQgYW4gYW5pbWF0aW9uIHdhcyB0cmlnZ2VyZWQgb24gb3VyIHZpZXdcbiAqIHJvdXRpbmcgY29udHJvbGxlciB0byBob29rIGludG8gdGhhdDpcbiAqXG4gKiBgYGBqc1xuICogbmdNb2R1bGUuY29udHJvbGxlcignSG9tZVBhZ2VDb250cm9sbGVyJywgWyckYW5pbWF0ZScsIGZ1bmN0aW9uKCRhbmltYXRlKSB7XG4gKiAgICRhbmltYXRlLm9uKCdlbnRlcicsIG5nVmlld0VsZW1lbnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAqICAgICAvLyB0aGUgYW5pbWF0aW9uIGZvciB0aGlzIHJvdXRlIGhhcyBjb21wbGV0ZWRcbiAqICAgfV0pO1xuICogfV0pXG4gKiBgYGBcbiAqXG4gKiAoTm90ZSB0aGF0IHlvdSB3aWxsIG5lZWQgdG8gdHJpZ2dlciBhIGRpZ2VzdCB3aXRoaW4gdGhlIGNhbGxiYWNrIHRvIGdldCBhbmd1bGFyIHRvIG5vdGljZSBhbnkgc2NvcGUtcmVsYXRlZCBjaGFuZ2VzLilcbiAqL1xuXG4vKipcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSAkYW5pbWF0ZVxuICogQGtpbmQgb2JqZWN0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgbmdBbmltYXRlIGAkYW5pbWF0ZWAgc2VydmljZSBkb2N1bWVudGF0aW9uIGlzIHRoZSBzYW1lIGZvciB0aGUgY29yZSBgJGFuaW1hdGVgIHNlcnZpY2UuXG4gKlxuICogQ2xpY2sgaGVyZSB7QGxpbmsgbmcuJGFuaW1hdGUgdG8gbGVhcm4gbW9yZSBhYm91dCBhbmltYXRpb25zIHdpdGggYCRhbmltYXRlYH0uXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCduZ0FuaW1hdGUnLCBbXSlcbiAgLmRpcmVjdGl2ZSgnbmdBbmltYXRlQ2hpbGRyZW4nLCAkJEFuaW1hdGVDaGlsZHJlbkRpcmVjdGl2ZSlcbiAgLmZhY3RvcnkoJyQkckFGU2NoZWR1bGVyJywgJCRyQUZTY2hlZHVsZXJGYWN0b3J5KVxuXG4gIC5mYWN0b3J5KCckJEFuaW1hdGVSdW5uZXInLCAkJEFuaW1hdGVSdW5uZXJGYWN0b3J5KVxuICAuZmFjdG9yeSgnJCRhbmltYXRlQXN5bmNSdW4nLCAkJEFuaW1hdGVBc3luY1J1bkZhY3RvcnkpXG5cbiAgLnByb3ZpZGVyKCckJGFuaW1hdGVRdWV1ZScsICQkQW5pbWF0ZVF1ZXVlUHJvdmlkZXIpXG4gIC5wcm92aWRlcignJCRhbmltYXRpb24nLCAkJEFuaW1hdGlvblByb3ZpZGVyKVxuXG4gIC5wcm92aWRlcignJGFuaW1hdGVDc3MnLCAkQW5pbWF0ZUNzc1Byb3ZpZGVyKVxuICAucHJvdmlkZXIoJyQkYW5pbWF0ZUNzc0RyaXZlcicsICQkQW5pbWF0ZUNzc0RyaXZlclByb3ZpZGVyKVxuXG4gIC5wcm92aWRlcignJCRhbmltYXRlSnMnLCAkJEFuaW1hdGVKc1Byb3ZpZGVyKVxuICAucHJvdmlkZXIoJyQkYW5pbWF0ZUpzRHJpdmVyJywgJCRBbmltYXRlSnNEcml2ZXJQcm92aWRlcik7XG5cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iLCJyZXF1aXJlKCcuL2FuZ3VsYXItYW5pbWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSAnbmdBbmltYXRlJztcbiIsIi8qIVxuICAgYW5ndWxhci1ibG9jay11aSB2MC4yLjBcbiAgIChjKSAyMDE1IChudWxsKSBNY051bGwgaHR0cHM6Ly9naXRodWIuY29tL01jTnVsbC9hbmd1bGFyLWJsb2NrLXVpXG4gICBMaWNlbnNlOiBNSVRcbiovXG4oZnVuY3Rpb24oYW5ndWxhcikge1xuXG52YXIgYmxrVUkgPSBhbmd1bGFyLm1vZHVsZSgnYmxvY2tVSScsIFtdKTtcblxuYmxrVUkuY29uZmlnKFtcIiRwcm92aWRlXCIsIFwiJGh0dHBQcm92aWRlclwiLCBmdW5jdGlvbiAoJHByb3ZpZGUsICRodHRwUHJvdmlkZXIpIHtcblxuICAkcHJvdmlkZS5kZWNvcmF0b3IoJyRleGNlcHRpb25IYW5kbGVyJywgWyckZGVsZWdhdGUnLCAnJGluamVjdG9yJyxcbiAgICBmdW5jdGlvbiAoJGRlbGVnYXRlLCAkaW5qZWN0b3IpIHtcbiAgICAgIHZhciBibG9ja1VJLCBibG9ja1VJQ29uZmlnO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGV4Y2VwdGlvbiwgY2F1c2UpIHtcblxuICAgICAgICBibG9ja1VJQ29uZmlnID0gYmxvY2tVSUNvbmZpZyB8fCAkaW5qZWN0b3IuZ2V0KCdibG9ja1VJQ29uZmlnJyk7XG5cbiAgICAgICAgaWYgKGJsb2NrVUlDb25maWcucmVzZXRPbkV4Y2VwdGlvbikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBibG9ja1VJID0gYmxvY2tVSSB8fCAkaW5qZWN0b3IuZ2V0KCdibG9ja1VJJyk7XG4gICAgICAgICAgICBibG9ja1VJLmluc3RhbmNlcy5yZXNldCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnJGV4Y2VwdGlvbkhhbmRsZXInLCBleGNlcHRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICRkZWxlZ2F0ZShleGNlcHRpb24sIGNhdXNlKTtcbiAgICAgIH07XG4gICAgfVxuICBdKTtcblxuICAkaHR0cFByb3ZpZGVyLmludGVyY2VwdG9ycy5wdXNoKCdibG9ja1VJSHR0cEludGVyY2VwdG9yJyk7XG59XSk7XG5cbmJsa1VJLnJ1bihbXCIkZG9jdW1lbnRcIiwgXCJibG9ja1VJQ29uZmlnXCIsIFwiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCRkb2N1bWVudCwgYmxvY2tVSUNvbmZpZywgJHRlbXBsYXRlQ2FjaGUpIHtcbiAgaWYgKGJsb2NrVUlDb25maWcuYXV0b0luamVjdEJvZHlCbG9jaykge1xuICAgICRkb2N1bWVudC5maW5kKCdib2R5JykuYXR0cignYmxvY2stdWknLCAnbWFpbicpO1xuICB9XG5cbiAgaWYgKGJsb2NrVUlDb25maWcudGVtcGxhdGUpIHtcblxuICAgIC8vIFN3YXAgdGhlIGJ1aWx0aW4gdGVtcGxhdGUgd2l0aCB0aGUgY3VzdG9tIHRlbXBsYXRlLlxuICAgIC8vIENyZWF0ZSBhIG1hZ2ljIGNhY2hlIGtleSBhbmQgcGxhY2UgdGhlIHRlbXBsYXRlIGluIHRoZSBjYWNoZS5cblxuICAgIGJsb2NrVUlDb25maWcudGVtcGxhdGVVcmwgPSAnJCRibG9jay11aS10ZW1wbGF0ZSQkJztcbiAgICAkdGVtcGxhdGVDYWNoZS5wdXQoYmxvY2tVSUNvbmZpZy50ZW1wbGF0ZVVybCwgYmxvY2tVSUNvbmZpZy50ZW1wbGF0ZSk7XG4gIH1cbn1dKTtcblxuZnVuY3Rpb24gbW9kdWxlTG9hZGVkKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICBhbmd1bGFyLm1vZHVsZShuYW1lKTtcbiAgfSBjYXRjaChleCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmJsa1VJLmNvbmZpZyhbXCIkcHJvdmlkZVwiLCBmdW5jdGlvbiAoJHByb3ZpZGUpIHtcbiAgJHByb3ZpZGUuZGVjb3JhdG9yKCckbG9jYXRpb24nLCBkZWNvcmF0ZUxvY2F0aW9uKTtcbn1dKTtcblxudmFyIGRlY29yYXRlTG9jYXRpb24gPSBbXG4gICckZGVsZWdhdGUnLCAnYmxvY2tVSScsICdibG9ja1VJQ29uZmlnJyxcbiAgZnVuY3Rpb24gKCRkZWxlZ2F0ZSwgYmxvY2tVSSwgYmxvY2tVSUNvbmZpZykge1xuXG4gICAgaWYgKGJsb2NrVUlDb25maWcuYmxvY2tCcm93c2VyTmF2aWdhdGlvbikge1xuXG4gICAgICBibG9ja1VJLiRfYmxvY2tMb2NhdGlvbkNoYW5nZSA9IHRydWU7XG5cbiAgICAgIHZhciBvdmVycmlkZXMgPSBbJ3VybCcsICdwYXRoJywgJ3NlYXJjaCcsICdoYXNoJywgJ3N0YXRlJ107XG5cbiAgICAgIGZ1bmN0aW9uIGhvb2soZikge1xuICAgICAgICB2YXIgcyA9ICRkZWxlZ2F0ZVtmXTtcbiAgICAgICAgJGRlbGVnYXRlW2ZdID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgLy8gICAgICAgIGNvbnNvbGUubG9nKGYsIERhdGUubm93KCksIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcy5hcHBseSgkZGVsZWdhdGUsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAvLyBUaGUgY2FsbCB3YXMgYSBzZXR0ZXIgaWYgdGhlICRsb2NhdGlvbiBzZXJ2aWNlIGlzIHJldHVybmVkLlxuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gJGRlbGVnYXRlKSB7XG5cbiAgICAgICAgICAgIC8vIE1hcmsgdGhlIG1haW5ibG9jayB1aSB0byBhbGxvdyB0aGUgbG9jYXRpb24gY2hhbmdlLlxuXG4gICAgICAgICAgICBibG9ja1VJLiRfYmxvY2tMb2NhdGlvbkNoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGFuZ3VsYXIuZm9yRWFjaChvdmVycmlkZXMsIGhvb2spO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuICRkZWxlZ2F0ZTtcbn1dO1xuXG4vLyBDYWxsZWQgZnJvbSBibG9jay11aS1kaXJlY3RpdmUgZm9yIHRoZSAnbWFpbicgaW5zdGFuY2UuXG5cbmZ1bmN0aW9uIGJsb2NrTmF2aWdhdGlvbigkc2NvcGUsIG1haW5CbG9ja1VJLCBibG9ja1VJQ29uZmlnKSB7XG5cbiAgaWYgKGJsb2NrVUlDb25maWcuYmxvY2tCcm93c2VyTmF2aWdhdGlvbikge1xuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJMb2NhdGlvbkNoYW5nZSgpIHtcblxuICAgICAgJHNjb3BlLiRvbignJGxvY2F0aW9uQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAvLyAgICAgICAgY29uc29sZS5sb2coJyRsb2NhdGlvbkNoYW5nZVN0YXJ0JywgbWFpbkJsb2NrVUkuJF9ibG9ja0xvY2F0aW9uQ2hhbmdlICsgJyAnICsgbWFpbkJsb2NrVUkuc3RhdGUoKS5ibG9ja0NvdW50KTtcblxuICAgICAgICBpZiAobWFpbkJsb2NrVUkuJF9ibG9ja0xvY2F0aW9uQ2hhbmdlICYmIG1haW5CbG9ja1VJLnN0YXRlKCkuYmxvY2tDb3VudCA+IDApIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgJHNjb3BlLiRvbignJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWFpbkJsb2NrVUkuJF9ibG9ja0xvY2F0aW9uQ2hhbmdlID0gYmxvY2tVSUNvbmZpZy5ibG9ja0Jyb3dzZXJOYXZpZ2F0aW9uO1xuXG4gICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZygnJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsIG1haW5CbG9ja1VJLiRfYmxvY2tMb2NhdGlvbkNoYW5nZSArICcgJyArIG1haW5CbG9ja1VJLnN0YXRlKCkuYmxvY2tDb3VudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobW9kdWxlTG9hZGVkKCduZ1JvdXRlJykpIHtcblxuICAgICAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgY29udGVudCBoYXMgYmVlbiBsb2FkZWQgd2UnbGwgc3B5IG9uIGFueSBsb2NhdGlvblxuICAgICAgLy8gY2hhbmdlcyBhbmQgZGlzY2FyZCB0aGVtIHdoZW4gbmVlZGVkLlxuXG4gICAgICB2YXIgZm4gPSAkc2NvcGUuJG9uKCckdmlld0NvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLy8gVW5ob29rIHRoZSB2aWV3IGxvYWRlZCBhbmQgaG9vayBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBwcmV2ZW50XG4gICAgICAgIC8vIGxvY2F0aW9uIGNoYW5nZXMgd2hpbGUgdGhlIGJsb2NrIGlzIGFjdGl2ZS5cblxuICAgICAgICBmbigpO1xuICAgICAgICByZWdpc3RlckxvY2F0aW9uQ2hhbmdlKCk7XG5cbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZ2lzdGVyTG9jYXRpb25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgfVxufVxuYmxrVUkuZGlyZWN0aXZlKCdibG9ja1VpQ29udGFpbmVyJywgW1wiYmxvY2tVSUNvbmZpZ1wiLCBcImJsb2NrVWlDb250YWluZXJMaW5rRm5cIiwgZnVuY3Rpb24gKGJsb2NrVUlDb25maWcsIGJsb2NrVWlDb250YWluZXJMaW5rRm4pIHtcbiAgcmV0dXJuIHtcbiAgICBzY29wZTogdHJ1ZSxcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHRlbXBsYXRlVXJsOiBibG9ja1VJQ29uZmlnLnRlbXBsYXRlVXJsLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uKCRlbGVtZW50KSB7XG4gICAgICByZXR1cm4gYmxvY2tVaUNvbnRhaW5lckxpbmtGbjtcbiAgICB9XG4gIH07XG59XSkuZmFjdG9yeSgnYmxvY2tVaUNvbnRhaW5lckxpbmtGbicsIFtcImJsb2NrVUlcIiwgXCJibG9ja1VJVXRpbHNcIiwgZnVuY3Rpb24gKGJsb2NrVUksIGJsb2NrVUlVdGlscykge1xuXG4gIHJldHVybiBmdW5jdGlvbiAoJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzKSB7XG5cbiAgICB2YXIgc3J2SW5zdGFuY2UgPSAkZWxlbWVudC5pbmhlcml0ZWREYXRhKCdibG9jay11aScpO1xuXG4gICAgaWYgKCFzcnZJbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwYXJlbnQgYmxvY2stdWkgc2VydmljZSBpbnN0YW5jZSBsb2NhdGVkLicpO1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSB0aGUgc3RhdGUgb24gdGhlIHNjb3BlXG5cbiAgICAkc2NvcGUuc3RhdGUgPSBzcnZJbnN0YW5jZS5zdGF0ZSgpO1xuXG4vLyAgICAkc2NvcGUuJHdhdGNoKCdzdGF0ZS5ibG9ja2luZycsIGZ1bmN0aW9uKHZhbHVlKSB7XG4vLyAgICAgICRlbGVtZW50LnRvZ2dsZUNsYXNzKCdibG9jay11aS12aXNpYmxlJywgISF2YWx1ZSk7XG4vLyAgICB9KTtcbi8vXG4vLyAgICAkc2NvcGUuJHdhdGNoKCdzdGF0ZS5ibG9ja0NvdW50ID4gMCcsIGZ1bmN0aW9uKHZhbHVlKSB7XG4vLyAgICAgICRlbGVtZW50LnRvZ2dsZUNsYXNzKCdibG9jay11aS1hY3RpdmUnLCAhIXZhbHVlKTtcbi8vICAgIH0pO1xuICB9O1xufV0pO1xuYmxrVUkuZGlyZWN0aXZlKCdibG9ja1VpJywgW1wiYmxvY2tVaUNvbXBpbGVGblwiLCBmdW5jdGlvbiAoYmxvY2tVaUNvbXBpbGVGbikge1xuXG4gIHJldHVybiB7XG4gICAgc2NvcGU6IHRydWUsXG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBjb21waWxlOiBibG9ja1VpQ29tcGlsZUZuXG4gIH07XG5cbn1dKS5mYWN0b3J5KCdibG9ja1VpQ29tcGlsZUZuJywgW1wiYmxvY2tVaVByZUxpbmtGblwiLCBmdW5jdGlvbiAoYmxvY2tVaVByZUxpbmtGbikge1xuXG4gIHJldHVybiBmdW5jdGlvbiAoJGVsZW1lbnQsICRhdHRycykge1xuXG4gICAgLy8gQ2xhc3Mgc2hvdWxkIGJlIGFkZGVkIGhlcmUgdG8gcHJldmVudCBhbiBhbmltYXRpb24gZGVsYXkgZXJyb3IuXG5cbiAgICAkZWxlbWVudC5hcHBlbmQoJzxkaXYgYmxvY2stdWktY29udGFpbmVyIGNsYXNzPVwiYmxvY2stdWktY29udGFpbmVyXCI+PC9kaXY+Jyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHJlOiBibG9ja1VpUHJlTGlua0ZuXG4gICAgfTtcblxuICB9O1xuXG59XSkuZmFjdG9yeSgnYmxvY2tVaVByZUxpbmtGbicsIFtcImJsb2NrVUlcIiwgXCJibG9ja1VJVXRpbHNcIiwgXCJibG9ja1VJQ29uZmlnXCIsIGZ1bmN0aW9uIChibG9ja1VJLCBibG9ja1VJVXRpbHMsIGJsb2NrVUlDb25maWcpIHtcblxuICByZXR1cm4gZnVuY3Rpb24gKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycykge1xuXG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSB0aGUgY2xhc3MgXCJibG9jay11aVwiIHNldCwgd2Ugc2V0IHRoZVxuICAgIC8vIGRlZmF1bHQgY3NzIGNsYXNzZXMgZnJvbSB0aGUgY29uZmlnLlxuXG4gICAgaWYgKCEkZWxlbWVudC5oYXNDbGFzcygnYmxvY2stdWknKSkge1xuICAgICAgJGVsZW1lbnQuYWRkQ2xhc3MoYmxvY2tVSUNvbmZpZy5jc3NDbGFzcyk7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIHRoZSBibG9ja1VpTWVzc2FnZUNsYXNzIGF0dHJpYnV0ZSB2YWx1ZSBvbiB0aGUgc2NvcGVcblxuICAgICRhdHRycy4kb2JzZXJ2ZSgnYmxvY2tVaU1lc3NhZ2VDbGFzcycsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgJHNjb3BlLiRfYmxvY2tVaU1lc3NhZ2VDbGFzcyA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBibG9ja1VJIGluc3RhbmNlXG4gICAgLy8gUHJlZml4IHVuZGVyc2NvcmUgdG8gcHJldmVudCBpbnRlZ2VyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWNOdWxsL2FuZ3VsYXItYmxvY2stdWkvcHVsbC84XG5cbiAgICB2YXIgaW5zdGFuY2VJZCA9ICRhdHRycy5ibG9ja1VpIHx8ICdfJyArICRzY29wZS4kaWQ7XG4gICAgdmFyIHNydkluc3RhbmNlID0gYmxvY2tVSS5pbnN0YW5jZXMuZ2V0KGluc3RhbmNlSWQpO1xuXG4gICAgLy8gSWYgdGhpcyBpcyB0aGUgbWFpbiAodG9wbW9zdCkgYmxvY2sgZWxlbWVudCB3ZSdsbCBhbHNvIG5lZWQgdG8gYmxvY2sgYW55XG4gICAgLy8gbG9jYXRpb24gY2hhbmdlcyB3aGlsZSB0aGUgYmxvY2sgaXMgYWN0aXZlLlxuXG4gICAgaWYgKGluc3RhbmNlSWQgPT09ICdtYWluJykge1xuICAgICAgYmxvY2tOYXZpZ2F0aW9uKCRzY29wZSwgc3J2SW5zdGFuY2UsIGJsb2NrVUlDb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMb2NhdGUgdGhlIHBhcmVudCBibG9ja1VJIGluc3RhbmNlXG4gICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSAkZWxlbWVudC5pbmhlcml0ZWREYXRhKCdibG9jay11aScpO1xuXG4gICAgICBpZiAocGFyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgLy8gVE9ETzogYXNzZXJ0IGlmIHBhcmVudCBpcyBhbHJlYWR5IHNldCB0byBzb21ldGhpbmcgZWxzZVxuICAgICAgICBzcnZJbnN0YW5jZS5fcGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnN0YW5jZSBpcyByZWxlYXNlZCB3aGVuIHRoZSBzY29wZSBpcyBkZXN0cm95ZWRcblxuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgc3J2SW5zdGFuY2UucmVsZWFzZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gSW5jcmVhc2UgdGhlIHJlZmVyZW5jZSBjb3VudFxuXG4gICAgc3J2SW5zdGFuY2UuYWRkUmVmKCk7XG5cbiAgICAvLyBFeHBvc2UgdGhlIHN0YXRlIG9uIHRoZSBzY29wZVxuXG4gICAgJHNjb3BlLiRfYmxvY2tVaVN0YXRlID0gc3J2SW5zdGFuY2Uuc3RhdGUoKTtcblxuICAgICRzY29wZS4kd2F0Y2goJyRfYmxvY2tVaVN0YXRlLmJsb2NraW5nJywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBTZXQgdGhlIGFyaWEtYnVzeSBhdHRyaWJ1dGUgaWYgbmVlZGVkXG4gICAgICAkZWxlbWVudC5hdHRyKCdhcmlhLWJ1c3knLCAhIXZhbHVlKTtcbiAgICAgICRlbGVtZW50LnRvZ2dsZUNsYXNzKCdibG9jay11aS12aXNpYmxlJywgISF2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUuJHdhdGNoKCckX2Jsb2NrVWlTdGF0ZS5ibG9ja0NvdW50ID4gMCcsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgJGVsZW1lbnQudG9nZ2xlQ2xhc3MoJ2Jsb2NrLXVpLWFjdGl2ZScsICEhdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLy8gSWYgYSBwYXR0ZXJuIGlzIHByb3ZpZGVkIGFzc2lnbiBpdCB0byB0aGUgc3RhdGVcblxuICAgIHZhciBwYXR0ZXJuID0gJGF0dHJzLmJsb2NrVWlQYXR0ZXJuO1xuXG4gICAgaWYgKHBhdHRlcm4pIHtcbiAgICAgIHZhciByZWdFeHAgPSBibG9ja1VJVXRpbHMuYnVpbGRSZWdFeHAocGF0dGVybik7XG4gICAgICBzcnZJbnN0YW5jZS5wYXR0ZXJuKHJlZ0V4cCk7XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIHNlcnZpY2UgaW5zdGFuY2Ugb24gdGhlIGVsZW1lbnRcblxuICAgICRlbGVtZW50LmRhdGEoJ2Jsb2NrLXVpJywgc3J2SW5zdGFuY2UpO1xuXG4gIH07XG5cbn1dKTtcbi8vLmZhY3RvcnkoJ2Jsb2NrVWlQb3N0TGlua0ZuJywgZnVuY3Rpb24oYmxvY2tVSVV0aWxzKSB7XG4vL1xuLy8gIHJldHVybiBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMpIHtcbi8vXG4vLyAgICB2YXIgJG1lc3NhZ2U7XG4vL1xuLy8gICAgJGF0dHJzLiRvYnNlcnZlKCdibG9ja1VpTWVzc2FnZUNsYXNzJywgZnVuY3Rpb24odmFsdWUpIHtcbi8vXG4vLyAgICAgICRtZXNzYWdlID0gJG1lc3NhZ2UgfHwgYmxvY2tVSVV0aWxzLmZpbmRFbGVtZW50KCRlbGVtZW50LCBmdW5jdGlvbigkZSkge1xuLy8gICAgICAgIHJldHVybiAkZS5oYXNDbGFzcygnYmxvY2stdWktbWVzc2FnZScpO1xuLy8gICAgICB9KTtcbi8vXG4vLyAgICAgICRtZXNzYWdlLmFkZENsYXNzKHZhbHVlKTtcbi8vXG4vLyAgICB9KTtcbi8vICB9O1xuLy9cbi8vfSk7XG5ibGtVSS5jb25zdGFudCgnYmxvY2tVSUNvbmZpZycsIHtcbiAgICB0ZW1wbGF0ZVVybDogJ2FuZ3VsYXItYmxvY2stdWkvYW5ndWxhci1ibG9jay11aS5uZy5odG1sJyxcbiAgICBkZWxheTogMjUwLFxuICAgIG1lc3NhZ2U6IFwiTG9hZGluZyAuLi5cIixcbiAgICBhdXRvQmxvY2s6IHRydWUsXG4gICAgcmVzZXRPbkV4Y2VwdGlvbjogdHJ1ZSxcbiAgICByZXF1ZXN0RmlsdGVyOiBhbmd1bGFyLm5vb3AsXG4gICAgYXV0b0luamVjdEJvZHlCbG9jazogdHJ1ZSxcbiAgICBjc3NDbGFzczogJ2Jsb2NrLXVpIGJsb2NrLXVpLWFuaW0tZmFkZScsXG4gICAgYmxvY2tCcm93c2VyTmF2aWdhdGlvbjogZmFsc2Vcbn0pO1xuXG5cbmJsa1VJLmZhY3RvcnkoJ2Jsb2NrVUlIdHRwSW50ZXJjZXB0b3InLCBbXCIkcVwiLCBcIiRpbmplY3RvclwiLCBcImJsb2NrVUlDb25maWdcIiwgXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkcSwgJGluamVjdG9yLCBibG9ja1VJQ29uZmlnLCAkdGVtcGxhdGVDYWNoZSkge1xuXG4gIHZhciBibG9ja1VJO1xuXG4gIGZ1bmN0aW9uIGluamVjdEJsb2NrVUkoKSB7XG4gICAgYmxvY2tVSSA9IGJsb2NrVUkgfHwgJGluamVjdG9yLmdldCgnYmxvY2tVSScpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RvcEJsb2NrVUkoY29uZmlnKSB7XG4gICAgaWYgKGJsb2NrVUlDb25maWcuYXV0b0Jsb2NrICYmIChjb25maWcgJiYgIWNvbmZpZy4kX25vQmxvY2sgJiYgY29uZmlnLiRfYmxvY2tzKSkge1xuICAgICAgaW5qZWN0QmxvY2tVSSgpO1xuICAgICAgY29uZmlnLiRfYmxvY2tzLnN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvcihyZWplY3Rpb24pIHtcblxuICAgIHRyeSB7XG4gICAgICBzdG9wQmxvY2tVSShyZWplY3Rpb24uY29uZmlnKTtcbiAgICB9IGNhdGNoKGV4KSB7XG4gICAgICBjb25zb2xlLmxvZygnaHR0cFJlcXVlc3RFcnJvcicsIGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gJHEucmVqZWN0KHJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uKGNvbmZpZykge1xuXG4gICAgICAvLyBPbmx5IGJsb2NrIHdoZW4gYXV0b0Jsb2NrIGlzIGVuYWJsZWQgLi4uXG4gICAgICAvLyAuLi4gYW5kIHRoZSByZXF1ZXN0IGRvZXNuJ3QgbWF0Y2ggYSBjYWNoZWQgdGVtcGxhdGUuXG5cbiAgICAgIGlmIChibG9ja1VJQ29uZmlnLmF1dG9CbG9jayAmJlxuICAgICAgICAhKGNvbmZpZy5tZXRob2QgPT0gJ0dFVCcgJiYgJHRlbXBsYXRlQ2FjaGUuZ2V0KGNvbmZpZy51cmwpKSkge1xuXG4gICAgICAgIC8vIERvbid0IGJsb2NrIGV4Y2x1ZGVkIHJlcXVlc3RzXG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGJsb2NrVUlDb25maWcucmVxdWVzdEZpbHRlcihjb25maWcpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gVGFnIHRoZSBjb25maWcgc28gd2UgZG9uJ3QgdW5ibG9jayB0aGlzIHJlcXVlc3RcbiAgICAgICAgICBjb25maWcuJF9ub0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGluamVjdEJsb2NrVUkoKTtcblxuICAgICAgICAgIGNvbmZpZy4kX2Jsb2NrcyA9IGJsb2NrVUkuaW5zdGFuY2VzLmxvY2F0ZShjb25maWcpO1xuICAgICAgICAgIGNvbmZpZy4kX2Jsb2Nrcy5zdGFydChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfSxcblxuICAgIHJlcXVlc3RFcnJvcjogZXJyb3IsXG5cbiAgICByZXNwb25zZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcblxuICAgICAgLy8gSWYgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHdlYnNpdGUgZ29lcyBkb3duIHRoZSByZXNwb25zZSBpbnRlcmNlcHRvciBnZXRzIGFuZCBlcnJvciB3aXRoIFwiY2Fubm90IHJlYWQgcHJvcGVydHkgY29uZmlnIG9mIG51bGxcIi5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NY051bGwvYW5ndWxhci1ibG9jay11aS9pc3N1ZXMvNTNcblxuICAgICAgaWYocmVzcG9uc2UpIHtcbiAgICAgICAgc3RvcEJsb2NrVUkocmVzcG9uc2UuY29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG5cbiAgICByZXNwb25zZUVycm9yOiBlcnJvclxuICB9O1xuXG59XSk7XG5cbmJsa1VJLmZhY3RvcnkoJ2Jsb2NrVUknLCBbXCJibG9ja1VJQ29uZmlnXCIsIFwiJHRpbWVvdXRcIiwgXCJibG9ja1VJVXRpbHNcIiwgXCIkZG9jdW1lbnRcIiwgZnVuY3Rpb24oYmxvY2tVSUNvbmZpZywgJHRpbWVvdXQsIGJsb2NrVUlVdGlscywgJGRvY3VtZW50KSB7XG5cbiAgdmFyICRib2R5ID0gJGRvY3VtZW50LmZpbmQoJ2JvZHknKTtcblxuICBmdW5jdGlvbiBCbG9ja1VJKGlkKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBibG9ja0NvdW50OiAwLFxuICAgICAgbWVzc2FnZTogYmxvY2tVSUNvbmZpZy5tZXNzYWdlLFxuICAgICAgYmxvY2tpbmc6IGZhbHNlXG4gICAgfSwgc3RhcnRQcm9taXNlLCBkb25lQ2FsbGJhY2tzID0gW107XG5cbiAgICB0aGlzLl9pZCA9IGlkO1xuXG4gICAgdGhpcy5fcmVmcyA9IDA7XG5cbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXG4gICAgICBpZihzdGF0ZS5ibG9ja0NvdW50ID4gMCkge1xuICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBzdGF0ZS5tZXNzYWdlIHx8IGJsb2NrVUlDb25maWcubWVzc2FnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGJsb2NrVUlDb25maWcubWVzc2FnZTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUubWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgICAgIHN0YXRlLmJsb2NrQ291bnQrKztcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZvY3VzZWQgZWxlbWVudCBpcyBwYXJ0IG9mIHRoZSBibG9jayBzY29wZVxuXG4gICAgICB2YXIgJGFlID0gYW5ndWxhci5lbGVtZW50KCRkb2N1bWVudFswXS5hY3RpdmVFbGVtZW50KTtcblxuICAgICAgaWYoJGFlLmxlbmd0aCAmJiBibG9ja1VJVXRpbHMuaXNFbGVtZW50SW5CbG9ja1Njb3BlKCRhZSwgc2VsZikpIHtcblxuICAgICAgICAvLyBMZXQgdGhlIGFjdGl2ZSBlbGVtZW50IGxvc2UgZm9jdXMgYW5kIHN0b3JlIGEgcmVmZXJlbmNlIFxuICAgICAgICAvLyB0byByZXN0b3JlIGZvY3VzIHdoZW4gd2UncmUgZG9uZSAocmVzZXQpXG5cbiAgICAgICAgc2VsZi5fcmVzdG9yZUZvY3VzID0gJGFlWzBdO1xuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NY051bGwvYW5ndWxhci1ibG9jay11aS9pc3N1ZXMvMTNcbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMjY5ODA1OC9hcHBseS1hbHJlYWR5LWluLXByb2dyZXNzLWVycm9yLXdoZW4tdXNpbmctdHlwZWFoZWFkLXBsdWdpbi1mb3VuZC10by1iZS1yZWxhdGVcbiAgICAgICAgLy8gUXVldWUgdGhlIGJsdXIgYWZ0ZXIgYW55IG5nLWJsdXIgZXhwcmVzc2lvbi5cblxuICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgd2Ugc3RpbGwgbmVlZCB0byBibHVyXG4gICAgICAgICAgaWYoc2VsZi5fcmVzdG9yZUZvY3VzKSB7XG4gICAgICAgICAgICBzZWxmLl9yZXN0b3JlRm9jdXMuYmx1cigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3RhcnRQcm9taXNlKSB7XG4gICAgICAgIHN0YXJ0UHJvbWlzZSA9ICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN0YXJ0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgc3RhdGUuYmxvY2tpbmcgPSB0cnVlO1xuICAgICAgICB9LCBibG9ja1VJQ29uZmlnLmRlbGF5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fY2FuY2VsU3RhcnRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc3RhcnRQcm9taXNlKSB7XG4gICAgICAgICR0aW1lb3V0LmNhbmNlbChzdGFydFByb21pc2UpO1xuICAgICAgICBzdGFydFByb21pc2UgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIHN0YXRlLmJsb2NrQ291bnQgPSBNYXRoLm1heCgwLCAtLXN0YXRlLmJsb2NrQ291bnQpO1xuXG4gICAgICBpZiAoc3RhdGUuYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBzZWxmLnJlc2V0KHRydWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm1lc3NhZ2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgc3RhdGUubWVzc2FnZSA9IHZhbHVlO1xuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBmdW5jdGlvbihyZWdleHApIHtcbiAgICAgIGlmIChyZWdleHAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLl9wYXR0ZXJuID0gcmVnZXhwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5fcGF0dGVybjtcbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKGV4ZWN1dGVDYWxsYmFja3MpIHtcbiAgICAgIFxuICAgICAgc2VsZi5fY2FuY2VsU3RhcnRUaW1lb3V0KCk7XG4gICAgICBzdGF0ZS5ibG9ja0NvdW50ID0gMDtcbiAgICAgIHN0YXRlLmJsb2NraW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIFJlc3RvcmUgdGhlIGZvY3VzIHRvIHRoZSBlbGVtZW50IHRoYXQgd2FzIGFjdGl2ZVxuICAgICAgLy8gYmVmb3JlIHRoZSBibG9jayBzdGFydCwgYnV0IG5vdCBpZiB0aGUgdXNlciBoYXMgXG4gICAgICAvLyBmb2N1c2VkIHNvbWV0aGluZyBlbHNlIHdoaWxlIHRoZSBibG9jayB3YXMgYWN0aXZlLlxuXG4gICAgICBpZihzZWxmLl9yZXN0b3JlRm9jdXMgJiYgXG4gICAgICAgICAoISRkb2N1bWVudFswXS5hY3RpdmVFbGVtZW50IHx8ICRkb2N1bWVudFswXS5hY3RpdmVFbGVtZW50ID09PSAkYm9keVswXSkpIHtcbiAgICAgICAgc2VsZi5fcmVzdG9yZUZvY3VzLmZvY3VzKCk7XG4gICAgICAgIHNlbGYuX3Jlc3RvcmVGb2N1cyA9IG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChleGVjdXRlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRvbmVDYWxsYmFja3MsIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkb25lQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZG9uZSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICBkb25lQ2FsbGJhY2tzLnB1c2goZm4pO1xuICAgIH07XG5cbiAgICB0aGlzLnN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkUmVmID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9yZWZzICs9IDE7XG4gICAgfTtcblxuICAgIHRoaXMucmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYoLS1zZWxmLl9yZWZzIDw9IDApIHtcbiAgICAgICAgbWFpbkJsb2NrLmluc3RhbmNlcy5fZGVzdHJveShzZWxmKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGluc3RhbmNlcyA9IFtdO1xuXG4gIGluc3RhbmNlcy5nZXQgPSBmdW5jdGlvbihpZCkge1xuXG4gICAgaWYoIWlzTmFOKGlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbG9ja1VJIGlkIGNhbm5vdCBiZSBhIG51bWJlcicpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1tpZF07XG5cbiAgICBpZighaW5zdGFuY2UpIHtcbiAgICAgIC8vIFRPRE86IGVuc3VyZSBubyBhcnJheSBpbnN0YW5jZSB0cmFzaGluZyBbeHh4XSAtLSBjdXJyZW50IHdvcmthcm91bmQ6ICdfJyArICRzY29wZS4kaWRcbiAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzW2lkXSA9IG5ldyBCbG9ja1VJKGlkKTtcbiAgICAgIGluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgaW5zdGFuY2VzLl9kZXN0cm95ID0gZnVuY3Rpb24oaWRPckluc3RhbmNlKSB7XG4gICAgaWYgKGFuZ3VsYXIuaXNTdHJpbmcoaWRPckluc3RhbmNlKSkge1xuICAgICAgaWRPckluc3RhbmNlID0gaW5zdGFuY2VzW2lkT3JJbnN0YW5jZV07XG4gICAgfVxuXG4gICAgaWYgKGlkT3JJbnN0YW5jZSkge1xuICAgICAgaWRPckluc3RhbmNlLnJlc2V0KCk7XG5cbiAgICAgIHZhciBpID0gYmxvY2tVSVV0aWxzLmluZGV4T2YoaW5zdGFuY2VzLCBpZE9ySW5zdGFuY2UpO1xuICAgICAgaW5zdGFuY2VzLnNwbGljZShpLCAxKTtcblxuICAgICAgZGVsZXRlIGluc3RhbmNlc1tpZE9ySW5zdGFuY2Uuc3RhdGUoKS5pZF07XG4gICAgfVxuICB9O1xuICBcbiAgaW5zdGFuY2VzLmxvY2F0ZSA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcblxuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbiB3cmFwcGVycyB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgb24gZXZlcnkgaXRlbVxuICAgIC8vIGluIHRoZSBhcnJheS5cbiAgICBcbiAgICBibG9ja1VJVXRpbHMuZm9yRWFjaEZuSG9vayhyZXN1bHQsICdzdGFydCcpO1xuICAgIGJsb2NrVUlVdGlscy5mb3JFYWNoRm5Ib29rKHJlc3VsdCwgJ3N0b3AnKTtcblxuICAgIHZhciBpID0gaW5zdGFuY2VzLmxlbmd0aDtcblxuICAgIHdoaWxlKGktLSkge1xuICAgICAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VzW2ldO1xuICAgICAgdmFyIHBhdHRlcm4gPSBpbnN0YW5jZS5fcGF0dGVybjtcblxuICAgICAgaWYocGF0dGVybiAmJiBwYXR0ZXJuLnRlc3QocmVxdWVzdC51cmwpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChtYWluQmxvY2spO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvcGFnYXRlIHRoZSByZXNldCB0byBhbGwgaW5zdGFuY2VzXG5cbiAgYmxvY2tVSVV0aWxzLmZvckVhY2hGbkhvb2soaW5zdGFuY2VzLCAncmVzZXQnKTtcblxuICB2YXIgbWFpbkJsb2NrID0gaW5zdGFuY2VzLmdldCgnbWFpbicpO1xuXG4gIG1haW5CbG9jay5hZGRSZWYoKTtcbiAgbWFpbkJsb2NrLmluc3RhbmNlcyA9IGluc3RhbmNlcztcblxuICByZXR1cm4gbWFpbkJsb2NrO1xufV0pO1xuXG5cbmJsa1VJLmZhY3RvcnkoJ2Jsb2NrVUlVdGlscycsIGZ1bmN0aW9uKCkge1xuXG4gIHZhciAkID0gYW5ndWxhci5lbGVtZW50O1xuXG4gIHZhciB1dGlscyA9IHtcbiAgICBidWlsZFJlZ0V4cDogZnVuY3Rpb24ocGF0dGVybikge1xuICAgICAgdmFyIG1hdGNoID0gcGF0dGVybi5tYXRjaCgvXlxcLyguKilcXC8oW2dpbV0qKSQvKSwgcmVnRXhwO1xuXG4gICAgICBpZihtYXRjaCkge1xuICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKG1hdGNoWzFdLCBtYXRjaFsyXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignSW5jb3JyZWN0IHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3JtYXQ6ICcgKyBwYXR0ZXJuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ0V4cDtcbiAgICB9LFxuICAgIGZvckVhY2hGbjogZnVuY3Rpb24oYXJyLCBmbk5hbWUsIGFyZ3MpIHtcbiAgICAgIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgICAgIHdoaWxlKGktLSkge1xuICAgICAgICB2YXIgdCA9IGFycltpXTtcbiAgICAgICAgdFtmbk5hbWVdLmFwcGx5KHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZm9yRWFjaEZuSG9vazogZnVuY3Rpb24oYXJyLCBmbk5hbWUpIHtcbiAgICAgIGFycltmbk5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHV0aWxzLmZvckVhY2hGbih0aGlzLCBmbk5hbWUsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0VsZW1lbnRJbkJsb2NrU2NvcGU6IGZ1bmN0aW9uKCRlbGVtZW50LCBibG9ja1Njb3BlKSB7XG4gICAgICB2YXIgYyA9ICRlbGVtZW50LmluaGVyaXRlZERhdGEoJ2Jsb2NrLXVpJyk7XG5cbiAgICAgIHdoaWxlKGMpIHtcbiAgICAgICAgaWYoYyA9PT0gYmxvY2tTY29wZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYyA9IGMuX3BhcmVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZmluZEVsZW1lbnQ6IGZ1bmN0aW9uICgkZWxlbWVudCwgcHJlZGljYXRlRm4sIHRyYXZlcnNlKSB7XG4gICAgICB2YXIgcmV0ID0gbnVsbDtcblxuICAgICAgaWYgKHByZWRpY2F0ZUZuKCRlbGVtZW50KSkge1xuICAgICAgICByZXQgPSAkZWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyICRlbGVtZW50cztcblxuICAgICAgICBpZiAodHJhdmVyc2UpIHtcbiAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5jaGlsZHJlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAkZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIXJldCAmJiBpLS0pIHtcbiAgICAgICAgICByZXQgPSB1dGlscy5maW5kRWxlbWVudCgkKCRlbGVtZW50c1tpXSksIHByZWRpY2F0ZUZuLCB0cmF2ZXJzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uKGFyciwgb2JqLCBzdGFydCkge1xuLy8gICAgICBpZihBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuLy8gICAgICAgIHJldHVybiBhcnIuaW5kZXhPZihvYmosIHN0YXJ0KTtcbi8vICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gKHN0YXJ0IHx8IDApLCBqID0gYXJyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICBpZiAoYXJyW2ldID09PSBvYmopIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB1dGlscztcblxufSk7XG4vLyBBdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbi8vIFRoaXMgZmlsZSBpcyBhbHJlYWR5IGVtYmVkZGVkIGluIHlvdXIgbWFpbiBqYXZhc2NyaXB0IG91dHB1dCwgdGhlcmUncyBubyBuZWVkIHRvIGluY2x1ZGUgdGhpcyBmaWxlXG4vLyBtYW51YWxseSBpbiB0aGUgaW5kZXguaHRtbC4gVGhpcyBmaWxlIGlzIG9ubHkgaGVyZSBmb3IgeW91ciBkZWJ1Z2dpbmcgcGxlYXN1cmVzLlxuYW5ndWxhci5tb2R1bGUoJ2Jsb2NrVUknKS5ydW4oWyckdGVtcGxhdGVDYWNoZScsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKXtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KCdhbmd1bGFyLWJsb2NrLXVpL2FuZ3VsYXItYmxvY2stdWkubmcuaHRtbCcsICc8ZGl2IGNsYXNzPVxcXCJibG9jay11aS1vdmVybGF5XFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJibG9jay11aS1tZXNzYWdlLWNvbnRhaW5lclxcXCIgYXJpYS1saXZlPVxcXCJhc3NlcnRpdmVcXFwiIGFyaWEtYXRvbWljPVxcXCJ0cnVlXFxcIj48ZGl2IGNsYXNzPVxcXCJibG9jay11aS1tZXNzYWdlXFxcIiBuZy1jbGFzcz1cXFwiJF9ibG9ja1VpTWVzc2FnZUNsYXNzXFxcIj57eyBzdGF0ZS5tZXNzYWdlIH19PC9kaXY+PC9kaXY+Jyk7XG59XSk7XG59KShhbmd1bGFyKTtcbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGUuZXhwb3J0cyA9IFwiYmxvY2tVSVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5ndWxhci1ibG9jay11aS5qcy5tYXBcbiIsInZhciBjc3MgPSBcIi8qIVxcbiAgIGFuZ3VsYXItYmxvY2stdWkgdjAuMi4wXFxuICAgKGMpIDIwMTUgKG51bGwpIE1jTnVsbCBodHRwczovL2dpdGh1Yi5jb20vTWNOdWxsL2FuZ3VsYXItYmxvY2stdWlcXG4gICBMaWNlbnNlOiBNSVRcXG4qL1xcbi5ibG9jay11aSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbmJvZHkuYmxvY2stdWkge1xcbiAgcG9zaXRpb246IHN0YXRpYztcXG59XFxuLmJsb2NrLXVpLW1haW4+LmJsb2NrLXVpLWNvbnRhaW5lcixcXG5ib2R5LmJsb2NrLXVpPi5ibG9jay11aS1jb250YWluZXIge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbn1cXG4uYmxvY2stdWktY29udGFpbmVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDEwMDAwO1xcbiAgdG9wOiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgaGVpZ2h0OiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIG9wYWNpdHk6IDA7XFxuICBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9MDApO1xcbn1cXG4uYmxvY2stdWktYWN0aXZlPi5ibG9jay11aS1jb250YWluZXIge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgY3Vyc29yOiB3YWl0O1xcbn1cXG4uYmxvY2stdWktYWN0aXZlIC5ibG9jay11aS1hY3RpdmU+LmJsb2NrLXVpLWNvbnRhaW5lciB7XFxuICBoZWlnaHQ6IDA7XFxufVxcbi5ibG9jay11aS12aXNpYmxlPi5ibG9jay11aS1jb250YWluZXIge1xcbiAgb3BhY2l0eTogMTtcXG4gIGZpbHRlcjogYWxwaGEob3BhY2l0eT0xMDApO1xcbn1cXG4uYmxvY2stdWktb3ZlcmxheSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIG9wYWNpdHk6IC41O1xcbiAgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTUwKTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxufVxcbi5ibG9jay11aS1tZXNzYWdlLWNvbnRhaW5lciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDM1JTtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIGhlaWdodDogMDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHotaW5kZXg6IDEwMDAxO1xcbn1cXG4uYmxvY2stdWktbWVzc2FnZSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzMzMztcXG4gIGNvbG9yOiAjZjVmNWY1O1xcbiAgcGFkZGluZzogMjBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIGZvbnQtc2l6ZTogMjBweDtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9MTAwKTtcXG59XFxuLmJsb2NrLXVpLWFuaW0tZmFkZT4uYmxvY2stdWktY29udGFpbmVyIHtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogaGVpZ2h0IDBzIGxpbmVhciAyMDBtcyxvcGFjaXR5IDIwMG1zIGVhc2UgMHM7XFxuICB0cmFuc2l0aW9uOiBoZWlnaHQgMHMgbGluZWFyIDIwMG1zLG9wYWNpdHkgMjAwbXMgZWFzZSAwcztcXG59XFxuLmJsb2NrLXVpLWFuaW0tZmFkZS5ibG9jay11aS1hY3RpdmU+LmJsb2NrLXVpLWNvbnRhaW5lciB7XFxuICAtd2Via2l0LXRyYW5zaXRpb24tZGVsYXk6IDBzO1xcbiAgdHJhbnNpdGlvbi1kZWxheTogMHM7XFxufVxcblwiOyAocmVxdWlyZShcImJyb3dzZXJpZnktY3NzXCIpLmNyZWF0ZVN0eWxlKGNzcywgeyBcImhyZWZcIjogXCJub2RlX21vZHVsZXNcXFxcYW5ndWxhci1ibG9jay11aVxcXFxkaXN0XFxcXGFuZ3VsYXItYmxvY2stdWkubWluLmNzc1wifSkpOyBtb2R1bGUuZXhwb3J0cyA9IGNzczsiLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXJKUyB2MS40LjdcbiAqIChjKSAyMDEwLTIwMTUgR29vZ2xlLCBJbmMuIGh0dHA6Ly9hbmd1bGFyanMub3JnXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhciwgdW5kZWZpbmVkKSB7J3VzZSBzdHJpY3QnO1xuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgQW55IGNvbW1pdHMgdG8gdGhpcyBmaWxlIHNob3VsZCBiZSByZXZpZXdlZCB3aXRoIHNlY3VyaXR5IGluIG1pbmQuICAqXG4gKiAgIENoYW5nZXMgdG8gdGhpcyBmaWxlIGNhbiBwb3RlbnRpYWxseSBjcmVhdGUgc2VjdXJpdHkgdnVsbmVyYWJpbGl0aWVzLiAqXG4gKiAgICAgICAgICBBbiBhcHByb3ZhbCBmcm9tIDIgQ29yZSBtZW1iZXJzIHdpdGggaGlzdG9yeSBvZiBtb2RpZnlpbmcgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGZpbGUgaXMgcmVxdWlyZWQuICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgRG9lcyB0aGUgY2hhbmdlIHNvbWVob3cgYWxsb3cgZm9yIGFyYml0cmFyeSBqYXZhc2NyaXB0IHRvIGJlIGV4ZWN1dGVkPyAqXG4gKiAgICBPciBhbGxvd3MgZm9yIHNvbWVvbmUgdG8gY2hhbmdlIHRoZSBwcm90b3R5cGUgb2YgYnVpbHQtaW4gb2JqZWN0cz8gICAqXG4gKiAgICAgT3IgZ2l2ZXMgdW5kZXNpcmVkIGFjY2VzcyB0byB2YXJpYWJsZXMgbGlrZXMgZG9jdW1lbnQgb3Igd2luZG93PyAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG52YXIgJHNhbml0aXplTWluRXJyID0gYW5ndWxhci4kJG1pbkVycignJHNhbml0aXplJyk7XG5cbi8qKlxuICogQG5nZG9jIG1vZHVsZVxuICogQG5hbWUgbmdTYW5pdGl6ZVxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogIyBuZ1Nhbml0aXplXG4gKlxuICogVGhlIGBuZ1Nhbml0aXplYCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byBzYW5pdGl6ZSBIVE1MLlxuICpcbiAqXG4gKiA8ZGl2IGRvYy1tb2R1bGUtY29tcG9uZW50cz1cIm5nU2FuaXRpemVcIj48L2Rpdj5cbiAqXG4gKiBTZWUge0BsaW5rIG5nU2FuaXRpemUuJHNhbml0aXplIGAkc2FuaXRpemVgfSBmb3IgdXNhZ2UuXG4gKi9cblxuLypcbiAqIEhUTUwgUGFyc2VyIEJ5IE1pc2tvIEhldmVyeSAobWlza29AaGV2ZXJ5LmNvbSlcbiAqIGJhc2VkIG9uOiAgSFRNTCBQYXJzZXIgQnkgSm9obiBSZXNpZyAoZWpvaG4ub3JnKVxuICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcbiAqXG4gKiAvLyBVc2UgbGlrZSBzbzpcbiAqIGh0bWxQYXJzZXIoaHRtbFN0cmluZywge1xuICogICAgIHN0YXJ0OiBmdW5jdGlvbih0YWcsIGF0dHJzLCB1bmFyeSkge30sXG4gKiAgICAgZW5kOiBmdW5jdGlvbih0YWcpIHt9LFxuICogICAgIGNoYXJzOiBmdW5jdGlvbih0ZXh0KSB7fSxcbiAqICAgICBjb21tZW50OiBmdW5jdGlvbih0ZXh0KSB7fVxuICogfSk7XG4gKlxuICovXG5cblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJHNhbml0aXplXG4gKiBAa2luZCBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogICBUaGUgaW5wdXQgaXMgc2FuaXRpemVkIGJ5IHBhcnNpbmcgdGhlIEhUTUwgaW50byB0b2tlbnMuIEFsbCBzYWZlIHRva2VucyAoZnJvbSBhIHdoaXRlbGlzdCkgYXJlXG4gKiAgIHRoZW4gc2VyaWFsaXplZCBiYWNrIHRvIHByb3Blcmx5IGVzY2FwZWQgaHRtbCBzdHJpbmcuIFRoaXMgbWVhbnMgdGhhdCBubyB1bnNhZmUgaW5wdXQgY2FuIG1ha2VcbiAqICAgaXQgaW50byB0aGUgcmV0dXJuZWQgc3RyaW5nLCBob3dldmVyLCBzaW5jZSBvdXIgcGFyc2VyIGlzIG1vcmUgc3RyaWN0IHRoYW4gYSB0eXBpY2FsIGJyb3dzZXJcbiAqICAgcGFyc2VyLCBpdCdzIHBvc3NpYmxlIHRoYXQgc29tZSBvYnNjdXJlIGlucHV0LCB3aGljaCB3b3VsZCBiZSByZWNvZ25pemVkIGFzIHZhbGlkIEhUTUwgYnkgYVxuICogICBicm93c2VyLCB3b24ndCBtYWtlIGl0IHRocm91Z2ggdGhlIHNhbml0aXplci4gVGhlIGlucHV0IG1heSBhbHNvIGNvbnRhaW4gU1ZHIG1hcmt1cC5cbiAqICAgVGhlIHdoaXRlbGlzdCBpcyBjb25maWd1cmVkIHVzaW5nIHRoZSBmdW5jdGlvbnMgYGFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0YCBhbmRcbiAqICAgYGltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdGAgb2Yge0BsaW5rIG5nLiRjb21waWxlUHJvdmlkZXIgYCRjb21waWxlUHJvdmlkZXJgfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBIVE1MIGlucHV0LlxuICogQHJldHVybnMge3N0cmluZ30gU2FuaXRpemVkIEhUTUwuXG4gKlxuICogQGV4YW1wbGVcbiAgIDxleGFtcGxlIG1vZHVsZT1cInNhbml0aXplRXhhbXBsZVwiIGRlcHM9XCJhbmd1bGFyLXNhbml0aXplLmpzXCI+XG4gICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgICA8c2NyaXB0PlxuICAgICAgICAgYW5ndWxhci5tb2R1bGUoJ3Nhbml0aXplRXhhbXBsZScsIFsnbmdTYW5pdGl6ZSddKVxuICAgICAgICAgICAuY29udHJvbGxlcignRXhhbXBsZUNvbnRyb2xsZXInLCBbJyRzY29wZScsICckc2NlJywgZnVuY3Rpb24oJHNjb3BlLCAkc2NlKSB7XG4gICAgICAgICAgICAgJHNjb3BlLnNuaXBwZXQgPVxuICAgICAgICAgICAgICAgJzxwIHN0eWxlPVwiY29sb3I6Ymx1ZVwiPmFuIGh0bWxcXG4nICtcbiAgICAgICAgICAgICAgICc8ZW0gb25tb3VzZW92ZXI9XCJ0aGlzLnRleHRDb250ZW50PVxcJ1BXTjNEIVxcJ1wiPmNsaWNrIGhlcmU8L2VtPlxcbicgK1xuICAgICAgICAgICAgICAgJ3NuaXBwZXQ8L3A+JztcbiAgICAgICAgICAgICAkc2NvcGUuZGVsaWJlcmF0ZWx5VHJ1c3REYW5nZXJvdXNTbmlwcGV0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gJHNjZS50cnVzdEFzSHRtbCgkc2NvcGUuc25pcHBldCk7XG4gICAgICAgICAgICAgfTtcbiAgICAgICAgICAgfV0pO1xuICAgICA8L3NjcmlwdD5cbiAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiRXhhbXBsZUNvbnRyb2xsZXJcIj5cbiAgICAgICAgU25pcHBldDogPHRleHRhcmVhIG5nLW1vZGVsPVwic25pcHBldFwiIGNvbHM9XCI2MFwiIHJvd3M9XCIzXCI+PC90ZXh0YXJlYT5cbiAgICAgICA8dGFibGU+XG4gICAgICAgICA8dHI+XG4gICAgICAgICAgIDx0ZD5EaXJlY3RpdmU8L3RkPlxuICAgICAgICAgICA8dGQ+SG93PC90ZD5cbiAgICAgICAgICAgPHRkPlNvdXJjZTwvdGQ+XG4gICAgICAgICAgIDx0ZD5SZW5kZXJlZDwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwiYmluZC1odG1sLXdpdGgtc2FuaXRpemVcIj5cbiAgICAgICAgICAgPHRkPm5nLWJpbmQtaHRtbDwvdGQ+XG4gICAgICAgICAgIDx0ZD5BdXRvbWF0aWNhbGx5IHVzZXMgJHNhbml0aXplPC90ZD5cbiAgICAgICAgICAgPHRkPjxwcmU+Jmx0O2RpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0XCImZ3Q7PGJyLz4mbHQ7L2RpdiZndDs8L3ByZT48L3RkPlxuICAgICAgICAgICA8dGQ+PGRpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0XCI+PC9kaXY+PC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJiaW5kLWh0bWwtd2l0aC10cnVzdFwiPlxuICAgICAgICAgICA8dGQ+bmctYmluZC1odG1sPC90ZD5cbiAgICAgICAgICAgPHRkPkJ5cGFzcyAkc2FuaXRpemUgYnkgZXhwbGljaXRseSB0cnVzdGluZyB0aGUgZGFuZ2Vyb3VzIHZhbHVlPC90ZD5cbiAgICAgICAgICAgPHRkPlxuICAgICAgICAgICA8cHJlPiZsdDtkaXYgbmctYmluZC1odG1sPVwiZGVsaWJlcmF0ZWx5VHJ1c3REYW5nZXJvdXNTbmlwcGV0KClcIiZndDtcbiZsdDsvZGl2Jmd0OzwvcHJlPlxuICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICA8dGQ+PGRpdiBuZy1iaW5kLWh0bWw9XCJkZWxpYmVyYXRlbHlUcnVzdERhbmdlcm91c1NuaXBwZXQoKVwiPjwvZGl2PjwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwiYmluZC1kZWZhdWx0XCI+XG4gICAgICAgICAgIDx0ZD5uZy1iaW5kPC90ZD5cbiAgICAgICAgICAgPHRkPkF1dG9tYXRpY2FsbHkgZXNjYXBlczwvdGQ+XG4gICAgICAgICAgIDx0ZD48cHJlPiZsdDtkaXYgbmctYmluZD1cInNuaXBwZXRcIiZndDs8YnIvPiZsdDsvZGl2Jmd0OzwvcHJlPjwvdGQ+XG4gICAgICAgICAgIDx0ZD48ZGl2IG5nLWJpbmQ9XCJzbmlwcGV0XCI+PC9kaXY+PC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgPC90YWJsZT5cbiAgICAgICA8L2Rpdj5cbiAgIDwvZmlsZT5cbiAgIDxmaWxlIG5hbWU9XCJwcm90cmFjdG9yLmpzXCIgdHlwZT1cInByb3RyYWN0b3JcIj5cbiAgICAgaXQoJ3Nob3VsZCBzYW5pdGl6ZSB0aGUgaHRtbCBzbmlwcGV0IGJ5IGRlZmF1bHQnLCBmdW5jdGlvbigpIHtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC1zYW5pdGl6ZSBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLlxuICAgICAgICAgdG9CZSgnPHA+YW4gaHRtbFxcbjxlbT5jbGljayBoZXJlPC9lbT5cXG5zbmlwcGV0PC9wPicpO1xuICAgICB9KTtcblxuICAgICBpdCgnc2hvdWxkIGlubGluZSByYXcgc25pcHBldCBpZiBib3VuZCB0byBhIHRydXN0ZWQgdmFsdWUnLCBmdW5jdGlvbigpIHtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC10cnVzdCBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLlxuICAgICAgICAgdG9CZShcIjxwIHN0eWxlPVxcXCJjb2xvcjpibHVlXFxcIj5hbiBodG1sXFxuXCIgK1xuICAgICAgICAgICAgICBcIjxlbSBvbm1vdXNlb3Zlcj1cXFwidGhpcy50ZXh0Q29udGVudD0nUFdOM0QhJ1xcXCI+Y2xpY2sgaGVyZTwvZW0+XFxuXCIgK1xuICAgICAgICAgICAgICBcInNuaXBwZXQ8L3A+XCIpO1xuICAgICB9KTtcblxuICAgICBpdCgnc2hvdWxkIGVzY2FwZSBzbmlwcGV0IHdpdGhvdXQgYW55IGZpbHRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtZGVmYXVsdCBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLlxuICAgICAgICAgdG9CZShcIiZsdDtwIHN0eWxlPVxcXCJjb2xvcjpibHVlXFxcIiZndDthbiBodG1sXFxuXCIgK1xuICAgICAgICAgICAgICBcIiZsdDtlbSBvbm1vdXNlb3Zlcj1cXFwidGhpcy50ZXh0Q29udGVudD0nUFdOM0QhJ1xcXCImZ3Q7Y2xpY2sgaGVyZSZsdDsvZW0mZ3Q7XFxuXCIgK1xuICAgICAgICAgICAgICBcInNuaXBwZXQmbHQ7L3AmZ3Q7XCIpO1xuICAgICB9KTtcblxuICAgICBpdCgnc2hvdWxkIHVwZGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgIGVsZW1lbnQoYnkubW9kZWwoJ3NuaXBwZXQnKSkuY2xlYXIoKTtcbiAgICAgICBlbGVtZW50KGJ5Lm1vZGVsKCdzbmlwcGV0JykpLnNlbmRLZXlzKCduZXcgPGIgb25jbGljaz1cImFsZXJ0KDEpXCI+dGV4dDwvYj4nKTtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC1zYW5pdGl6ZSBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLlxuICAgICAgICAgdG9CZSgnbmV3IDxiPnRleHQ8L2I+Jyk7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1odG1sLXdpdGgtdHJ1c3QgZGl2JykpLmdldElubmVySHRtbCgpKS50b0JlKFxuICAgICAgICAgJ25ldyA8YiBvbmNsaWNrPVwiYWxlcnQoMSlcIj50ZXh0PC9iPicpO1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtZGVmYXVsdCBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLnRvQmUoXG4gICAgICAgICBcIm5ldyAmbHQ7YiBvbmNsaWNrPVxcXCJhbGVydCgxKVxcXCImZ3Q7dGV4dCZsdDsvYiZndDtcIik7XG4gICAgIH0pO1xuICAgPC9maWxlPlxuICAgPC9leGFtcGxlPlxuICovXG5mdW5jdGlvbiAkU2FuaXRpemVQcm92aWRlcigpIHtcbiAgdGhpcy4kZ2V0ID0gWyckJHNhbml0aXplVXJpJywgZnVuY3Rpb24oJCRzYW5pdGl6ZVVyaSkge1xuICAgIHJldHVybiBmdW5jdGlvbihodG1sKSB7XG4gICAgICB2YXIgYnVmID0gW107XG4gICAgICBodG1sUGFyc2VyKGh0bWwsIGh0bWxTYW5pdGl6ZVdyaXRlcihidWYsIGZ1bmN0aW9uKHVyaSwgaXNJbWFnZSkge1xuICAgICAgICByZXR1cm4gIS9edW5zYWZlLy50ZXN0KCQkc2FuaXRpemVVcmkodXJpLCBpc0ltYWdlKSk7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gYnVmLmpvaW4oJycpO1xuICAgIH07XG4gIH1dO1xufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZVRleHQoY2hhcnMpIHtcbiAgdmFyIGJ1ZiA9IFtdO1xuICB2YXIgd3JpdGVyID0gaHRtbFNhbml0aXplV3JpdGVyKGJ1ZiwgYW5ndWxhci5ub29wKTtcbiAgd3JpdGVyLmNoYXJzKGNoYXJzKTtcbiAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn1cblxuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBTVEFSVF9UQUdfUkVHRVhQID1cbiAgICAgICAvXjwoKD86W2EtekEtWl0pW1xcdzotXSopKCg/OlxccytbXFx3Oi1dKyg/Olxccyo9XFxzKig/Oig/OlwiW15cIl0qXCIpfCg/OidbXiddKicpfFtePlxcc10rKSk/KSopXFxzKihcXC8/KVxccyooPj8pLyxcbiAgRU5EX1RBR19SRUdFWFAgPSAvXjxcXC9cXHMqKFtcXHc6LV0rKVtePl0qPi8sXG4gIEFUVFJfUkVHRVhQID0gLyhbXFx3Oi1dKykoPzpcXHMqPVxccyooPzooPzpcIigoPzpbXlwiXSkqKVwiKXwoPzonKCg/OlteJ10pKiknKXwoW14+XFxzXSspKSk/L2csXG4gIEJFR0lOX1RBR19SRUdFWFAgPSAvXjwvLFxuICBCRUdJTkdfRU5EX1RBR0VfUkVHRVhQID0gL148XFwvLyxcbiAgQ09NTUVOVF9SRUdFWFAgPSAvPCEtLSguKj8pLS0+L2csXG4gIERPQ1RZUEVfUkVHRVhQID0gLzwhRE9DVFlQRShbXj5dKj8pPi9pLFxuICBDREFUQV9SRUdFWFAgPSAvPCFcXFtDREFUQVxcWyguKj8pXV0+L2csXG4gIFNVUlJPR0FURV9QQUlSX1JFR0VYUCA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csXG4gIC8vIE1hdGNoIGV2ZXJ5dGhpbmcgb3V0c2lkZSBvZiBub3JtYWwgY2hhcnMgYW5kIFwiIChxdW90ZSBjaGFyYWN0ZXIpXG4gIE5PTl9BTFBIQU5VTUVSSUNfUkVHRVhQID0gLyhbXlxcIy1+fCB8IV0pL2c7XG5cblxuLy8gR29vZCBzb3VyY2Ugb2YgaW5mbyBhYm91dCBlbGVtZW50cyBhbmQgYXR0cmlidXRlc1xuLy8gaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy9PdmVydmlldy5odG1sI3NlbWFudGljc1xuLy8gaHR0cDovL3NpbW9uLmh0bWw1Lm9yZy9odG1sLWVsZW1lbnRzXG5cbi8vIFNhZmUgVm9pZCBFbGVtZW50cyAtIEhUTUw1XG4vLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjdm9pZC1lbGVtZW50c1xudmFyIHZvaWRFbGVtZW50cyA9IG1ha2VNYXAoXCJhcmVhLGJyLGNvbCxocixpbWcsd2JyXCIpO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW4gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxuLy8gaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy9PdmVydmlldy5odG1sI29wdGlvbmFsLXRhZ3NcbnZhciBvcHRpb25hbEVuZFRhZ0Jsb2NrRWxlbWVudHMgPSBtYWtlTWFwKFwiY29sZ3JvdXAsZGQsZHQsbGkscCx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCx0clwiKSxcbiAgICBvcHRpb25hbEVuZFRhZ0lubGluZUVsZW1lbnRzID0gbWFrZU1hcChcInJwLHJ0XCIpLFxuICAgIG9wdGlvbmFsRW5kVGFnRWxlbWVudHMgPSBhbmd1bGFyLmV4dGVuZCh7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxFbmRUYWdJbmxpbmVFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxFbmRUYWdCbG9ja0VsZW1lbnRzKTtcblxuLy8gU2FmZSBCbG9jayBFbGVtZW50cyAtIEhUTUw1XG52YXIgYmxvY2tFbGVtZW50cyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBvcHRpb25hbEVuZFRhZ0Jsb2NrRWxlbWVudHMsIG1ha2VNYXAoXCJhZGRyZXNzLGFydGljbGUsXCIgK1xuICAgICAgICBcImFzaWRlLGJsb2NrcXVvdGUsY2FwdGlvbixjZW50ZXIsZGVsLGRpcixkaXYsZGwsZmlndXJlLGZpZ2NhcHRpb24sZm9vdGVyLGgxLGgyLGgzLGg0LGg1LFwiICtcbiAgICAgICAgXCJoNixoZWFkZXIsaGdyb3VwLGhyLGlucyxtYXAsbWVudSxuYXYsb2wscHJlLHNjcmlwdCxzZWN0aW9uLHRhYmxlLHVsXCIpKTtcblxuLy8gSW5saW5lIEVsZW1lbnRzIC0gSFRNTDVcbnZhciBpbmxpbmVFbGVtZW50cyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBvcHRpb25hbEVuZFRhZ0lubGluZUVsZW1lbnRzLCBtYWtlTWFwKFwiYSxhYmJyLGFjcm9ueW0sYixcIiArXG4gICAgICAgIFwiYmRpLGJkbyxiaWcsYnIsY2l0ZSxjb2RlLGRlbCxkZm4sZW0sZm9udCxpLGltZyxpbnMsa2JkLGxhYmVsLG1hcCxtYXJrLHEscnVieSxycCxydCxzLFwiICtcbiAgICAgICAgXCJzYW1wLHNtYWxsLHNwYW4sc3RyaWtlLHN0cm9uZyxzdWIsc3VwLHRpbWUsdHQsdSx2YXJcIikpO1xuXG4vLyBTVkcgRWxlbWVudHNcbi8vIGh0dHBzOi8vd2lraS53aGF0d2cub3JnL3dpa2kvU2FuaXRpemF0aW9uX3J1bGVzI3N2Z19FbGVtZW50c1xuLy8gTm90ZTogdGhlIGVsZW1lbnRzIGFuaW1hdGUsYW5pbWF0ZUNvbG9yLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxzZXQgYXJlIGludGVudGlvbmFsbHkgb21pdHRlZC5cbi8vIFRoZXkgY2FuIHBvdGVudGlhbGx5IGFsbG93IGZvciBhcmJpdHJhcnkgamF2YXNjcmlwdCB0byBiZSBleGVjdXRlZC4gU2VlICMxMTI5MFxudmFyIHN2Z0VsZW1lbnRzID0gbWFrZU1hcChcImNpcmNsZSxkZWZzLGRlc2MsZWxsaXBzZSxmb250LWZhY2UsZm9udC1mYWNlLW5hbWUsZm9udC1mYWNlLXNyYyxnLGdseXBoLFwiICtcbiAgICAgICAgXCJoa2VybixpbWFnZSxsaW5lYXJHcmFkaWVudCxsaW5lLG1hcmtlcixtZXRhZGF0YSxtaXNzaW5nLWdseXBoLG1wYXRoLHBhdGgscG9seWdvbixwb2x5bGluZSxcIiArXG4gICAgICAgIFwicmFkaWFsR3JhZGllbnQscmVjdCxzdG9wLHN2Zyxzd2l0Y2gsdGV4dCx0aXRsZSx0c3Bhbix1c2VcIik7XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIHNwZWNpYWxFbGVtZW50cyA9IG1ha2VNYXAoXCJzY3JpcHQsc3R5bGVcIik7XG5cbnZhciB2YWxpZEVsZW1lbnRzID0gYW5ndWxhci5leHRlbmQoe30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWRFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5saW5lRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsRW5kVGFnRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Z0VsZW1lbnRzKTtcblxuLy9BdHRyaWJ1dGVzIHRoYXQgaGF2ZSBocmVmIGFuZCBoZW5jZSBuZWVkIHRvIGJlIHNhbml0aXplZFxudmFyIHVyaUF0dHJzID0gbWFrZU1hcChcImJhY2tncm91bmQsY2l0ZSxocmVmLGxvbmdkZXNjLHNyYyx1c2VtYXAseGxpbms6aHJlZlwiKTtcblxudmFyIGh0bWxBdHRycyA9IG1ha2VNYXAoJ2FiYnIsYWxpZ24sYWx0LGF4aXMsYmdjb2xvcixib3JkZXIsY2VsbHBhZGRpbmcsY2VsbHNwYWNpbmcsY2xhc3MsY2xlYXIsJyArXG4gICAgJ2NvbG9yLGNvbHMsY29sc3Bhbixjb21wYWN0LGNvb3JkcyxkaXIsZmFjZSxoZWFkZXJzLGhlaWdodCxocmVmbGFuZyxoc3BhY2UsJyArXG4gICAgJ2lzbWFwLGxhbmcsbGFuZ3VhZ2Usbm9ocmVmLG5vd3JhcCxyZWwscmV2LHJvd3Mscm93c3BhbixydWxlcywnICtcbiAgICAnc2NvcGUsc2Nyb2xsaW5nLHNoYXBlLHNpemUsc3BhbixzdGFydCxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0eXBlLCcgK1xuICAgICd2YWxpZ24sdmFsdWUsdnNwYWNlLHdpZHRoJyk7XG5cbi8vIFNWRyBhdHRyaWJ1dGVzICh3aXRob3V0IFwiaWRcIiBhbmQgXCJuYW1lXCIgYXR0cmlidXRlcylcbi8vIGh0dHBzOi8vd2lraS53aGF0d2cub3JnL3dpa2kvU2FuaXRpemF0aW9uX3J1bGVzI3N2Z19BdHRyaWJ1dGVzXG52YXIgc3ZnQXR0cnMgPSBtYWtlTWFwKCdhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxwaGFiZXRpYyxhcmFiaWMtZm9ybSxhc2NlbnQsJyArXG4gICAgJ2Jhc2VQcm9maWxlLGJib3gsYmVnaW4sYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxjb2xvcixjb2xvci1yZW5kZXJpbmcsY29udGVudCwnICtcbiAgICAnY3gsY3ksZCxkeCxkeSxkZXNjZW50LGRpc3BsYXksZHVyLGVuZCxmaWxsLGZpbGwtcnVsZSxmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zdHJldGNoLCcgK1xuICAgICdmb250LXN0eWxlLGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmcm9tLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsZ3JhZGllbnRVbml0cyxoYW5naW5nLCcgK1xuICAgICdoZWlnaHQsaG9yaXotYWR2LXgsaG9yaXotb3JpZ2luLXgsaWRlb2dyYXBoaWMsayxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxsYW5nLCcgK1xuICAgICdtYXJrZXItZW5kLG1hcmtlci1taWQsbWFya2VyLXN0YXJ0LG1hcmtlckhlaWdodCxtYXJrZXJVbml0cyxtYXJrZXJXaWR0aCxtYXRoZW1hdGljYWwsJyArXG4gICAgJ21heCxtaW4sb2Zmc2V0LG9wYWNpdHksb3JpZW50LG9yaWdpbixvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEsJyArXG4gICAgJ3BhdGgscGF0aExlbmd0aCxwb2ludHMscHJlc2VydmVBc3BlY3RSYXRpbyxyLHJlZlgscmVmWSxyZXBlYXRDb3VudCxyZXBlYXREdXIsJyArXG4gICAgJ3JlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLHJlc3RhcnQscm90YXRlLHJ4LHJ5LHNsb3BlLHN0ZW1oLHN0ZW12LHN0b3AtY29sb3IsJyArXG4gICAgJ3N0b3Atb3BhY2l0eSxzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cm9rZSxzdHJva2UtZGFzaGFycmF5LCcgK1xuICAgICdzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksJyArXG4gICAgJ3N0cm9rZS13aWR0aCxzeXN0ZW1MYW5ndWFnZSx0YXJnZXQsdGV4dC1hbmNob3IsdG8sdHJhbnNmb3JtLHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLCcgK1xuICAgICd1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdmFsdWVzLHZlcnNpb24sdmlld0JveCx2aXNpYmlsaXR5LCcgK1xuICAgICd3aWR0aCx3aWR0aHMseCx4LWhlaWdodCx4MSx4Mix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLCcgK1xuICAgICd4bGluazp0eXBlLHhtbDpiYXNlLHhtbDpsYW5nLHhtbDpzcGFjZSx4bWxucyx4bWxuczp4bGluayx5LHkxLHkyLHpvb21BbmRQYW4nLCB0cnVlKTtcblxudmFyIHZhbGlkQXR0cnMgPSBhbmd1bGFyLmV4dGVuZCh7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJpQXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Z0F0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sQXR0cnMpO1xuXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgbG93ZXJjYXNlS2V5cykge1xuICB2YXIgb2JqID0ge30sIGl0ZW1zID0gc3RyLnNwbGl0KCcsJyksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIG9ialtsb3dlcmNhc2VLZXlzID8gYW5ndWxhci5sb3dlcmNhc2UoaXRlbXNbaV0pIDogaXRlbXNbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogQGV4YW1wbGVcbiAqIGh0bWxQYXJzZXIoaHRtbFN0cmluZywge1xuICogICAgIHN0YXJ0OiBmdW5jdGlvbih0YWcsIGF0dHJzLCB1bmFyeSkge30sXG4gKiAgICAgZW5kOiBmdW5jdGlvbih0YWcpIHt9LFxuICogICAgIGNoYXJzOiBmdW5jdGlvbih0ZXh0KSB7fSxcbiAqICAgICBjb21tZW50OiBmdW5jdGlvbih0ZXh0KSB7fVxuICogfSk7XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgc3RyaW5nXG4gKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlclxuICovXG5mdW5jdGlvbiBodG1sUGFyc2VyKGh0bWwsIGhhbmRsZXIpIHtcbiAgaWYgKHR5cGVvZiBodG1sICE9PSAnc3RyaW5nJykge1xuICAgIGlmIChodG1sID09PSBudWxsIHx8IHR5cGVvZiBodG1sID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaHRtbCA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBodG1sID0gJycgKyBodG1sO1xuICAgIH1cbiAgfVxuICB2YXIgaW5kZXgsIGNoYXJzLCBtYXRjaCwgc3RhY2sgPSBbXSwgbGFzdCA9IGh0bWwsIHRleHQ7XG4gIHN0YWNrLmxhc3QgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdOyB9O1xuXG4gIHdoaWxlIChodG1sKSB7XG4gICAgdGV4dCA9ICcnO1xuICAgIGNoYXJzID0gdHJ1ZTtcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBzY3JpcHQgb3Igc3R5bGUgZWxlbWVudFxuICAgIGlmICghc3RhY2subGFzdCgpIHx8ICFzcGVjaWFsRWxlbWVudHNbc3RhY2subGFzdCgpXSkge1xuXG4gICAgICAvLyBDb21tZW50XG4gICAgICBpZiAoaHRtbC5pbmRleE9mKFwiPCEtLVwiKSA9PT0gMCkge1xuICAgICAgICAvLyBjb21tZW50cyBjb250YWluaW5nIC0tIGFyZSBub3QgYWxsb3dlZCB1bmxlc3MgdGhleSB0ZXJtaW5hdGUgdGhlIGNvbW1lbnRcbiAgICAgICAgaW5kZXggPSBodG1sLmluZGV4T2YoXCItLVwiLCA0KTtcblxuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBodG1sLmxhc3RJbmRleE9mKFwiLS0+XCIsIGluZGV4KSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICBpZiAoaGFuZGxlci5jb21tZW50KSBoYW5kbGVyLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgaW5kZXgpKTtcbiAgICAgICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcoaW5kZXggKyAzKTtcbiAgICAgICAgICBjaGFycyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAvLyBET0NUWVBFXG4gICAgICB9IGVsc2UgaWYgKERPQ1RZUEVfUkVHRVhQLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgbWF0Y2ggPSBodG1sLm1hdGNoKERPQ1RZUEVfUkVHRVhQKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKG1hdGNoWzBdLCAnJyk7XG4gICAgICAgICAgY2hhcnMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgLy8gZW5kIHRhZ1xuICAgICAgfSBlbHNlIGlmIChCRUdJTkdfRU5EX1RBR0VfUkVHRVhQLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgbWF0Y2ggPSBodG1sLm1hdGNoKEVORF9UQUdfUkVHRVhQKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKEVORF9UQUdfUkVHRVhQLCBwYXJzZUVuZFRhZyk7XG4gICAgICAgICAgY2hhcnMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBzdGFydCB0YWdcbiAgICAgIH0gZWxzZSBpZiAoQkVHSU5fVEFHX1JFR0VYUC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIG1hdGNoID0gaHRtbC5tYXRjaChTVEFSVF9UQUdfUkVHRVhQKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAvLyBXZSBvbmx5IGhhdmUgYSB2YWxpZCBzdGFydC10YWcgaWYgdGhlcmUgaXMgYSAnPicuXG4gICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2UoU1RBUlRfVEFHX1JFR0VYUCwgcGFyc2VTdGFydFRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYXJzID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gZW5kaW5nIHRhZyBmb3VuZCAtLS0gdGhpcyBwaWVjZSBzaG91bGQgYmUgZW5jb2RlZCBhcyBhbiBlbnRpdHkuXG4gICAgICAgICAgdGV4dCArPSAnPCc7XG4gICAgICAgICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFycykge1xuICAgICAgICBpbmRleCA9IGh0bWwuaW5kZXhPZihcIjxcIik7XG5cbiAgICAgICAgdGV4dCArPSBpbmRleCA8IDAgPyBodG1sIDogaHRtbC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICBodG1sID0gaW5kZXggPCAwID8gXCJcIiA6IGh0bWwuc3Vic3RyaW5nKGluZGV4KTtcblxuICAgICAgICBpZiAoaGFuZGxlci5jaGFycykgaGFuZGxlci5jaGFycyhkZWNvZGVFbnRpdGllcyh0ZXh0KSk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUUgdmVyc2lvbnMgOSBhbmQgMTAgZG8gbm90IHVuZGVyc3RhbmQgdGhlIHJlZ2V4ICdbXl0nLCBzbyB1c2luZyBhIHdvcmthcm91bmQgd2l0aCBbXFxXXFx3XS5cbiAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UobmV3IFJlZ0V4cChcIihbXFxcXFdcXFxcd10qKTxcXFxccypcXFxcL1xcXFxzKlwiICsgc3RhY2subGFzdCgpICsgXCJbXj5dKj5cIiwgJ2knKSxcbiAgICAgICAgZnVuY3Rpb24oYWxsLCB0ZXh0KSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShDT01NRU5UX1JFR0VYUCwgXCIkMVwiKS5yZXBsYWNlKENEQVRBX1JFR0VYUCwgXCIkMVwiKTtcblxuICAgICAgICAgIGlmIChoYW5kbGVyLmNoYXJzKSBoYW5kbGVyLmNoYXJzKGRlY29kZUVudGl0aWVzKHRleHQpKTtcblxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfSk7XG5cbiAgICAgIHBhcnNlRW5kVGFnKFwiXCIsIHN0YWNrLmxhc3QoKSk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT0gbGFzdCkge1xuICAgICAgdGhyb3cgJHNhbml0aXplTWluRXJyKCdiYWRwYXJzZScsIFwiVGhlIHNhbml0aXplciB3YXMgdW5hYmxlIHRvIHBhcnNlIHRoZSBmb2xsb3dpbmcgYmxvY2sgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib2YgaHRtbDogezB9XCIsIGh0bWwpO1xuICAgIH1cbiAgICBsYXN0ID0gaHRtbDtcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcodGFnLCB0YWdOYW1lLCByZXN0LCB1bmFyeSkge1xuICAgIHRhZ05hbWUgPSBhbmd1bGFyLmxvd2VyY2FzZSh0YWdOYW1lKTtcbiAgICBpZiAoYmxvY2tFbGVtZW50c1t0YWdOYW1lXSkge1xuICAgICAgd2hpbGUgKHN0YWNrLmxhc3QoKSAmJiBpbmxpbmVFbGVtZW50c1tzdGFjay5sYXN0KCldKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKFwiXCIsIHN0YWNrLmxhc3QoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbmFsRW5kVGFnRWxlbWVudHNbdGFnTmFtZV0gJiYgc3RhY2subGFzdCgpID09IHRhZ05hbWUpIHtcbiAgICAgIHBhcnNlRW5kVGFnKFwiXCIsIHRhZ05hbWUpO1xuICAgIH1cblxuICAgIHVuYXJ5ID0gdm9pZEVsZW1lbnRzW3RhZ05hbWVdIHx8ICEhdW5hcnk7XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHRhZ05hbWUpO1xuICAgIH1cblxuICAgIHZhciBhdHRycyA9IHt9O1xuXG4gICAgcmVzdC5yZXBsYWNlKEFUVFJfUkVHRVhQLFxuICAgICAgZnVuY3Rpb24obWF0Y2gsIG5hbWUsIGRvdWJsZVF1b3RlZFZhbHVlLCBzaW5nbGVRdW90ZWRWYWx1ZSwgdW5xdW90ZWRWYWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkb3VibGVRdW90ZWRWYWx1ZVxuICAgICAgICAgIHx8IHNpbmdsZVF1b3RlZFZhbHVlXG4gICAgICAgICAgfHwgdW5xdW90ZWRWYWx1ZVxuICAgICAgICAgIHx8ICcnO1xuXG4gICAgICAgIGF0dHJzW25hbWVdID0gZGVjb2RlRW50aXRpZXModmFsdWUpO1xuICAgIH0pO1xuICAgIGlmIChoYW5kbGVyLnN0YXJ0KSBoYW5kbGVyLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyh0YWcsIHRhZ05hbWUpIHtcbiAgICB2YXIgcG9zID0gMCwgaTtcbiAgICB0YWdOYW1lID0gYW5ndWxhci5sb3dlcmNhc2UodGFnTmFtZSk7XG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXSA9PSB0YWdOYW1lKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKVxuICAgICAgICBpZiAoaGFuZGxlci5lbmQpIGhhbmRsZXIuZW5kKHN0YWNrW2ldKTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgfVxuICB9XG59XG5cbnZhciBoaWRkZW5QcmU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcbi8qKlxuICogZGVjb2RlcyBhbGwgZW50aXRpZXMgaW50byByZWd1bGFyIHN0cmluZ1xuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyB3aXRoIGRlY29kZWQgZW50aXRpZXMuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUVudGl0aWVzKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHsgcmV0dXJuICcnOyB9XG5cbiAgaGlkZGVuUHJlLmlubmVySFRNTCA9IHZhbHVlLnJlcGxhY2UoLzwvZyxcIiZsdDtcIik7XG4gIC8vIGlubmVyVGV4dCBkZXBlbmRzIG9uIHN0eWxpbmcgYXMgaXQgZG9lc24ndCBkaXNwbGF5IGhpZGRlbiBlbGVtZW50cy5cbiAgLy8gVGhlcmVmb3JlLCBpdCdzIGJldHRlciB0byB1c2UgdGV4dENvbnRlbnQgbm90IHRvIGNhdXNlIHVubmVjZXNzYXJ5IHJlZmxvd3MuXG4gIHJldHVybiBoaWRkZW5QcmUudGV4dENvbnRlbnQ7XG59XG5cbi8qKlxuICogRXNjYXBlcyBhbGwgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIGNoYXJhY3RlcnMsIHNvIHRoYXQgdGhlXG4gKiByZXN1bHRpbmcgc3RyaW5nIGNhbiBiZSBzYWZlbHkgaW5zZXJ0ZWQgaW50byBhdHRyaWJ1dGUgb3JcbiAqIGVsZW1lbnQgdGV4dC5cbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCB0ZXh0XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUVudGl0aWVzKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5cbiAgICByZXBsYWNlKC8mL2csICcmYW1wOycpLlxuICAgIHJlcGxhY2UoU1VSUk9HQVRFX1BBSVJfUkVHRVhQLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGhpID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICAgIHZhciBsb3cgPSB2YWx1ZS5jaGFyQ29kZUF0KDEpO1xuICAgICAgcmV0dXJuICcmIycgKyAoKChoaSAtIDB4RDgwMCkgKiAweDQwMCkgKyAobG93IC0gMHhEQzAwKSArIDB4MTAwMDApICsgJzsnO1xuICAgIH0pLlxuICAgIHJlcGxhY2UoTk9OX0FMUEhBTlVNRVJJQ19SRUdFWFAsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gJyYjJyArIHZhbHVlLmNoYXJDb2RlQXQoMCkgKyAnOyc7XG4gICAgfSkuXG4gICAgcmVwbGFjZSgvPC9nLCAnJmx0OycpLlxuICAgIHJlcGxhY2UoLz4vZywgJyZndDsnKTtcbn1cblxuLyoqXG4gKiBjcmVhdGUgYW4gSFRNTC9YTUwgd3JpdGVyIHdoaWNoIHdyaXRlcyB0byBidWZmZXJcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZiB1c2UgYnVmLmphaW4oJycpIHRvIGdldCBvdXQgc2FuaXRpemVkIGh0bWwgc3RyaW5nXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBpbiB0aGUgZm9ybSBvZiB7XG4gKiAgICAgc3RhcnQ6IGZ1bmN0aW9uKHRhZywgYXR0cnMsIHVuYXJ5KSB7fSxcbiAqICAgICBlbmQ6IGZ1bmN0aW9uKHRhZykge30sXG4gKiAgICAgY2hhcnM6IGZ1bmN0aW9uKHRleHQpIHt9LFxuICogICAgIGNvbW1lbnQ6IGZ1bmN0aW9uKHRleHQpIHt9XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGh0bWxTYW5pdGl6ZVdyaXRlcihidWYsIHVyaVZhbGlkYXRvcikge1xuICB2YXIgaWdub3JlID0gZmFsc2U7XG4gIHZhciBvdXQgPSBhbmd1bGFyLmJpbmQoYnVmLCBidWYucHVzaCk7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICB0YWcgPSBhbmd1bGFyLmxvd2VyY2FzZSh0YWcpO1xuICAgICAgaWYgKCFpZ25vcmUgJiYgc3BlY2lhbEVsZW1lbnRzW3RhZ10pIHtcbiAgICAgICAgaWdub3JlID0gdGFnO1xuICAgICAgfVxuICAgICAgaWYgKCFpZ25vcmUgJiYgdmFsaWRFbGVtZW50c1t0YWddID09PSB0cnVlKSB7XG4gICAgICAgIG91dCgnPCcpO1xuICAgICAgICBvdXQodGFnKTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGF0dHJzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgdmFyIGxrZXk9YW5ndWxhci5sb3dlcmNhc2Uoa2V5KTtcbiAgICAgICAgICB2YXIgaXNJbWFnZSA9ICh0YWcgPT09ICdpbWcnICYmIGxrZXkgPT09ICdzcmMnKSB8fCAobGtleSA9PT0gJ2JhY2tncm91bmQnKTtcbiAgICAgICAgICBpZiAodmFsaWRBdHRyc1tsa2V5XSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgKHVyaUF0dHJzW2xrZXldICE9PSB0cnVlIHx8IHVyaVZhbGlkYXRvcih2YWx1ZSwgaXNJbWFnZSkpKSB7XG4gICAgICAgICAgICBvdXQoJyAnKTtcbiAgICAgICAgICAgIG91dChrZXkpO1xuICAgICAgICAgICAgb3V0KCc9XCInKTtcbiAgICAgICAgICAgIG91dChlbmNvZGVFbnRpdGllcyh2YWx1ZSkpO1xuICAgICAgICAgICAgb3V0KCdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG91dCh1bmFyeSA/ICcvPicgOiAnPicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgdGFnID0gYW5ndWxhci5sb3dlcmNhc2UodGFnKTtcbiAgICAgICAgaWYgKCFpZ25vcmUgJiYgdmFsaWRFbGVtZW50c1t0YWddID09PSB0cnVlKSB7XG4gICAgICAgICAgb3V0KCc8LycpO1xuICAgICAgICAgIG91dCh0YWcpO1xuICAgICAgICAgIG91dCgnPicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gaWdub3JlKSB7XG4gICAgICAgICAgaWdub3JlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgY2hhcnM6IGZ1bmN0aW9uKGNoYXJzKSB7XG4gICAgICAgIGlmICghaWdub3JlKSB7XG4gICAgICAgICAgb3V0KGVuY29kZUVudGl0aWVzKGNoYXJzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfTtcbn1cblxuXG4vLyBkZWZpbmUgbmdTYW5pdGl6ZSBtb2R1bGUgYW5kIHJlZ2lzdGVyICRzYW5pdGl6ZSBzZXJ2aWNlXG5hbmd1bGFyLm1vZHVsZSgnbmdTYW5pdGl6ZScsIFtdKS5wcm92aWRlcignJHNhbml0aXplJywgJFNhbml0aXplUHJvdmlkZXIpO1xuXG4vKiBnbG9iYWwgc2FuaXRpemVUZXh0OiBmYWxzZSAqL1xuXG4vKipcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIGxpbmt5XG4gKiBAa2luZCBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRmluZHMgbGlua3MgaW4gdGV4dCBpbnB1dCBhbmQgdHVybnMgdGhlbSBpbnRvIGh0bWwgbGlua3MuIFN1cHBvcnRzIGh0dHAvaHR0cHMvZnRwL21haWx0byBhbmRcbiAqIHBsYWluIGVtYWlsIGFkZHJlc3MgbGlua3MuXG4gKlxuICogUmVxdWlyZXMgdGhlIHtAbGluayBuZ1Nhbml0aXplIGBuZ1Nhbml0aXplYH0gbW9kdWxlIHRvIGJlIGluc3RhbGxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBJbnB1dCB0ZXh0LlxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBXaW5kb3cgKF9ibGFua3xfc2VsZnxfcGFyZW50fF90b3ApIG9yIG5hbWVkIGZyYW1lIHRvIG9wZW4gbGlua3MgaW4uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIdG1sLWxpbmtpZmllZCB0ZXh0LlxuICpcbiAqIEB1c2FnZVxuICAgPHNwYW4gbmctYmluZC1odG1sPVwibGlua3lfZXhwcmVzc2lvbiB8IGxpbmt5XCI+PC9zcGFuPlxuICpcbiAqIEBleGFtcGxlXG4gICA8ZXhhbXBsZSBtb2R1bGU9XCJsaW5reUV4YW1wbGVcIiBkZXBzPVwiYW5ndWxhci1zYW5pdGl6ZS5qc1wiPlxuICAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgICAgIDxzY3JpcHQ+XG4gICAgICAgICBhbmd1bGFyLm1vZHVsZSgnbGlua3lFeGFtcGxlJywgWyduZ1Nhbml0aXplJ10pXG4gICAgICAgICAgIC5jb250cm9sbGVyKCdFeGFtcGxlQ29udHJvbGxlcicsIFsnJHNjb3BlJywgZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICAgICAgJHNjb3BlLnNuaXBwZXQgPVxuICAgICAgICAgICAgICAgJ1ByZXR0eSB0ZXh0IHdpdGggc29tZSBsaW5rczpcXG4nK1xuICAgICAgICAgICAgICAgJ2h0dHA6Ly9hbmd1bGFyanMub3JnLyxcXG4nK1xuICAgICAgICAgICAgICAgJ21haWx0bzp1c0Bzb21ld2hlcmUub3JnLFxcbicrXG4gICAgICAgICAgICAgICAnYW5vdGhlckBzb21ld2hlcmUub3JnLFxcbicrXG4gICAgICAgICAgICAgICAnYW5kIG9uZSBtb3JlOiBmdHA6Ly8xMjcuMC4wLjEvLic7XG4gICAgICAgICAgICAgJHNjb3BlLnNuaXBwZXRXaXRoVGFyZ2V0ID0gJ2h0dHA6Ly9hbmd1bGFyanMub3JnLyc7XG4gICAgICAgICAgIH1dKTtcbiAgICAgICA8L3NjcmlwdD5cbiAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJFeGFtcGxlQ29udHJvbGxlclwiPlxuICAgICAgIFNuaXBwZXQ6IDx0ZXh0YXJlYSBuZy1tb2RlbD1cInNuaXBwZXRcIiBjb2xzPVwiNjBcIiByb3dzPVwiM1wiPjwvdGV4dGFyZWE+XG4gICAgICAgPHRhYmxlPlxuICAgICAgICAgPHRyPlxuICAgICAgICAgICA8dGQ+RmlsdGVyPC90ZD5cbiAgICAgICAgICAgPHRkPlNvdXJjZTwvdGQ+XG4gICAgICAgICAgIDx0ZD5SZW5kZXJlZDwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwibGlua3ktZmlsdGVyXCI+XG4gICAgICAgICAgIDx0ZD5saW5reSBmaWx0ZXI8L3RkPlxuICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgPHByZT4mbHQ7ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXQgfCBsaW5reVwiJmd0Ozxicj4mbHQ7L2RpdiZndDs8L3ByZT5cbiAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgIDxkaXYgbmctYmluZC1odG1sPVwic25pcHBldCB8IGxpbmt5XCI+PC9kaXY+XG4gICAgICAgICAgIDwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgICAgPHRyIGlkPVwibGlua3ktdGFyZ2V0XCI+XG4gICAgICAgICAgPHRkPmxpbmt5IHRhcmdldDwvdGQ+XG4gICAgICAgICAgPHRkPlxuICAgICAgICAgICAgPHByZT4mbHQ7ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRXaXRoVGFyZ2V0IHwgbGlua3k6J19ibGFuaydcIiZndDs8YnI+Jmx0Oy9kaXYmZ3Q7PC9wcmU+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICA8ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRXaXRoVGFyZ2V0IHwgbGlua3k6J19ibGFuaydcIj48L2Rpdj5cbiAgICAgICAgICA8L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImVzY2FwZWQtaHRtbFwiPlxuICAgICAgICAgICA8dGQ+bm8gZmlsdGVyPC90ZD5cbiAgICAgICAgICAgPHRkPjxwcmU+Jmx0O2RpdiBuZy1iaW5kPVwic25pcHBldFwiJmd0Ozxicj4mbHQ7L2RpdiZndDs8L3ByZT48L3RkPlxuICAgICAgICAgICA8dGQ+PGRpdiBuZy1iaW5kPVwic25pcHBldFwiPjwvZGl2PjwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgIDwvdGFibGU+XG4gICAgIDwvZmlsZT5cbiAgICAgPGZpbGUgbmFtZT1cInByb3RyYWN0b3IuanNcIiB0eXBlPVwicHJvdHJhY3RvclwiPlxuICAgICAgIGl0KCdzaG91bGQgbGlua2lmeSB0aGUgc25pcHBldCB3aXRoIHVybHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdsaW5reS1maWx0ZXInKSkuZWxlbWVudChieS5iaW5kaW5nKCdzbmlwcGV0IHwgbGlua3knKSkuZ2V0VGV4dCgpKS5cbiAgICAgICAgICAgICB0b0JlKCdQcmV0dHkgdGV4dCB3aXRoIHNvbWUgbGlua3M6IGh0dHA6Ly9hbmd1bGFyanMub3JnLywgdXNAc29tZXdoZXJlLm9yZywgJyArXG4gICAgICAgICAgICAgICAgICAnYW5vdGhlckBzb21ld2hlcmUub3JnLCBhbmQgb25lIG1vcmU6IGZ0cDovLzEyNy4wLjAuMS8uJyk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudC5hbGwoYnkuY3NzKCcjbGlua3ktZmlsdGVyIGEnKSkuY291bnQoKSkudG9FcXVhbCg0KTtcbiAgICAgICB9KTtcblxuICAgICAgIGl0KCdzaG91bGQgbm90IGxpbmtpZnkgc25pcHBldCB3aXRob3V0IHRoZSBsaW5reSBmaWx0ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdlc2NhcGVkLWh0bWwnKSkuZWxlbWVudChieS5iaW5kaW5nKCdzbmlwcGV0JykpLmdldFRleHQoKSkuXG4gICAgICAgICAgICAgdG9CZSgnUHJldHR5IHRleHQgd2l0aCBzb21lIGxpbmtzOiBodHRwOi8vYW5ndWxhcmpzLm9yZy8sIG1haWx0bzp1c0Bzb21ld2hlcmUub3JnLCAnICtcbiAgICAgICAgICAgICAgICAgICdhbm90aGVyQHNvbWV3aGVyZS5vcmcsIGFuZCBvbmUgbW9yZTogZnRwOi8vMTI3LjAuMC4xLy4nKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50LmFsbChieS5jc3MoJyNlc2NhcGVkLWh0bWwgYScpKS5jb3VudCgpKS50b0VxdWFsKDApO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGVsZW1lbnQoYnkubW9kZWwoJ3NuaXBwZXQnKSkuY2xlYXIoKTtcbiAgICAgICAgIGVsZW1lbnQoYnkubW9kZWwoJ3NuaXBwZXQnKSkuc2VuZEtleXMoJ25ldyBodHRwOi8vbGluay4nKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdsaW5reS1maWx0ZXInKSkuZWxlbWVudChieS5iaW5kaW5nKCdzbmlwcGV0IHwgbGlua3knKSkuZ2V0VGV4dCgpKS5cbiAgICAgICAgICAgICB0b0JlKCduZXcgaHR0cDovL2xpbmsuJyk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudC5hbGwoYnkuY3NzKCcjbGlua3ktZmlsdGVyIGEnKSkuY291bnQoKSkudG9FcXVhbCgxKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdlc2NhcGVkLWh0bWwnKSkuZWxlbWVudChieS5iaW5kaW5nKCdzbmlwcGV0JykpLmdldFRleHQoKSlcbiAgICAgICAgICAgICAudG9CZSgnbmV3IGh0dHA6Ly9saW5rLicpO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCB3b3JrIHdpdGggdGhlIHRhcmdldCBwcm9wZXJ0eScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoZWxlbWVudChieS5pZCgnbGlua3ktdGFyZ2V0JykpLlxuICAgICAgICAgICAgZWxlbWVudChieS5iaW5kaW5nKFwic25pcHBldFdpdGhUYXJnZXQgfCBsaW5reTonX2JsYW5rJ1wiKSkuZ2V0VGV4dCgpKS5cbiAgICAgICAgICAgIHRvQmUoJ2h0dHA6Ly9hbmd1bGFyanMub3JnLycpO1xuICAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNsaW5reS10YXJnZXQgYScpKS5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpKS50b0VxdWFsKCdfYmxhbmsnKTtcbiAgICAgICB9KTtcbiAgICAgPC9maWxlPlxuICAgPC9leGFtcGxlPlxuICovXG5hbmd1bGFyLm1vZHVsZSgnbmdTYW5pdGl6ZScpLmZpbHRlcignbGlua3knLCBbJyRzYW5pdGl6ZScsIGZ1bmN0aW9uKCRzYW5pdGl6ZSkge1xuICB2YXIgTElOS1lfVVJMX1JFR0VYUCA9XG4gICAgICAgIC8oKGZ0cHxodHRwcz8pOlxcL1xcL3wod3d3XFwuKXwobWFpbHRvOik/W0EtWmEtejAtOS5fJSstXStAKVxcUypbXlxccy47LCgpe308PlwiXFx1MjAxZFxcdTIwMTldL2ksXG4gICAgICBNQUlMVE9fUkVHRVhQID0gL15tYWlsdG86L2k7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHRleHQsIHRhcmdldCkge1xuICAgIGlmICghdGV4dCkgcmV0dXJuIHRleHQ7XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciByYXcgPSB0ZXh0O1xuICAgIHZhciBodG1sID0gW107XG4gICAgdmFyIHVybDtcbiAgICB2YXIgaTtcbiAgICB3aGlsZSAoKG1hdGNoID0gcmF3Lm1hdGNoKExJTktZX1VSTF9SRUdFWFApKSkge1xuICAgICAgLy8gV2UgY2FuIG5vdCBlbmQgaW4gdGhlc2UgYXMgdGhleSBhcmUgc29tZXRpbWVzIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIHNlbnRlbmNlXG4gICAgICB1cmwgPSBtYXRjaFswXTtcbiAgICAgIC8vIGlmIHdlIGRpZCBub3QgbWF0Y2ggZnRwL2h0dHAvd3d3L21haWx0byB0aGVuIGFzc3VtZSBtYWlsdG9cbiAgICAgIGlmICghbWF0Y2hbMl0gJiYgIW1hdGNoWzRdKSB7XG4gICAgICAgIHVybCA9IChtYXRjaFszXSA/ICdodHRwOi8vJyA6ICdtYWlsdG86JykgKyB1cmw7XG4gICAgICB9XG4gICAgICBpID0gbWF0Y2guaW5kZXg7XG4gICAgICBhZGRUZXh0KHJhdy5zdWJzdHIoMCwgaSkpO1xuICAgICAgYWRkTGluayh1cmwsIG1hdGNoWzBdLnJlcGxhY2UoTUFJTFRPX1JFR0VYUCwgJycpKTtcbiAgICAgIHJhdyA9IHJhdy5zdWJzdHJpbmcoaSArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgfVxuICAgIGFkZFRleHQocmF3KTtcbiAgICByZXR1cm4gJHNhbml0aXplKGh0bWwuam9pbignJykpO1xuXG4gICAgZnVuY3Rpb24gYWRkVGV4dCh0ZXh0KSB7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaHRtbC5wdXNoKHNhbml0aXplVGV4dCh0ZXh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGluayh1cmwsIHRleHQpIHtcbiAgICAgIGh0bWwucHVzaCgnPGEgJyk7XG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQodGFyZ2V0KSkge1xuICAgICAgICBodG1sLnB1c2goJ3RhcmdldD1cIicsXG4gICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAnXCIgJyk7XG4gICAgICB9XG4gICAgICBodG1sLnB1c2goJ2hyZWY9XCInLFxuICAgICAgICAgICAgICAgIHVybC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JyksXG4gICAgICAgICAgICAgICAgJ1wiPicpO1xuICAgICAgYWRkVGV4dCh0ZXh0KTtcbiAgICAgIGh0bWwucHVzaCgnPC9hPicpO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsInJlcXVpcmUoJy4vYW5ndWxhci1zYW5pdGl6ZScpO1xubW9kdWxlLmV4cG9ydHMgPSAnbmdTYW5pdGl6ZSc7XG4iLCIvKiFcbiAqIGFuZ3VsYXItdHJhbnNsYXRlIC0gdjIuMTAuMCAtIDIwMTYtMDItMjhcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBhbmd1bGFyLXRyYW5zbGF0ZSB0ZWFtLCBQYXNjYWwgUHJlY2h0OyBMaWNlbnNlZCBNSVRcbiAqL1xuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUgdW5sZXNzIGFtZE1vZHVsZUlkIGlzIHNldFxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChmYWN0b3J5KCkpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgIC8vIGxpa2UgTm9kZS5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG4vKipcbiAqIEBuZ2RvYyBvdmVydmlld1xuICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIG1haW4gbW9kdWxlIHdoaWNoIGhvbGRzIGV2ZXJ5dGhpbmcgdG9nZXRoZXIuXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCdwYXNjYWxwcmVjaHQudHJhbnNsYXRlJywgWyduZyddKVxuICAucnVuKHJ1blRyYW5zbGF0ZSk7XG5cbmZ1bmN0aW9uIHJ1blRyYW5zbGF0ZSgkdHJhbnNsYXRlKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBrZXkgPSAkdHJhbnNsYXRlLnN0b3JhZ2VLZXkoKSxcbiAgICBzdG9yYWdlID0gJHRyYW5zbGF0ZS5zdG9yYWdlKCk7XG5cbiAgdmFyIGZhbGxiYWNrRnJvbUluY29ycmVjdFN0b3JhZ2VWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJlZmVycmVkID0gJHRyYW5zbGF0ZS5wcmVmZXJyZWRMYW5ndWFnZSgpO1xuICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKHByZWZlcnJlZCkpIHtcbiAgICAgICR0cmFuc2xhdGUudXNlKHByZWZlcnJlZCk7XG4gICAgICAvLyAkdHJhbnNsYXRlLnVzZSgpIHdpbGwgYWxzbyByZW1lbWJlciB0aGUgbGFuZ3VhZ2UuXG4gICAgICAvLyBTbywgd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHN0b3JhZ2UucHV0KCkgaGVyZS5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcmFnZS5wdXQoa2V5LCAkdHJhbnNsYXRlLnVzZSgpKTtcbiAgICB9XG4gIH07XG5cbiAgZmFsbGJhY2tGcm9tSW5jb3JyZWN0U3RvcmFnZVZhbHVlLmRpc3BsYXlOYW1lID0gJ2ZhbGxiYWNrRnJvbUluY29ycmVjdFN0b3JhZ2VWYWx1ZSc7XG5cbiAgaWYgKHN0b3JhZ2UpIHtcbiAgICBpZiAoIXN0b3JhZ2UuZ2V0KGtleSkpIHtcbiAgICAgIGZhbGxiYWNrRnJvbUluY29ycmVjdFN0b3JhZ2VWYWx1ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkdHJhbnNsYXRlLnVzZShzdG9yYWdlLmdldChrZXkpKVsnY2F0Y2gnXShmYWxsYmFja0Zyb21JbmNvcnJlY3RTdG9yYWdlVmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKCR0cmFuc2xhdGUucHJlZmVycmVkTGFuZ3VhZ2UoKSkpIHtcbiAgICAkdHJhbnNsYXRlLnVzZSgkdHJhbnNsYXRlLnByZWZlcnJlZExhbmd1YWdlKCkpO1xuICB9XG59XG5ydW5UcmFuc2xhdGUuJGluamVjdCA9IFsnJHRyYW5zbGF0ZSddO1xuXG5ydW5UcmFuc2xhdGUuZGlzcGxheU5hbWUgPSAncnVuVHJhbnNsYXRlJztcblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVTYW5pdGl6YXRpb25Qcm92aWRlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIENvbmZpZ3VyYXRpb25zIGZvciAkdHJhbnNsYXRlU2FuaXRpemF0aW9uXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCdwYXNjYWxwcmVjaHQudHJhbnNsYXRlJykucHJvdmlkZXIoJyR0cmFuc2xhdGVTYW5pdGl6YXRpb24nLCAkdHJhbnNsYXRlU2FuaXRpemF0aW9uUHJvdmlkZXIpO1xuXG5mdW5jdGlvbiAkdHJhbnNsYXRlU2FuaXRpemF0aW9uUHJvdmlkZXIgKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgJHNhbml0aXplLFxuICAgICAgY3VycmVudFN0cmF0ZWd5ID0gbnVsbCwgLy8gVE9ETyBjaGFuZ2UgdG8gZWl0aGVyICdzYW5pdGl6ZScsICdlc2NhcGUnIG9yIFsnc2FuaXRpemUnLCAnZXNjYXBlUGFyYW1ldGVycyddIGluIDMuMC5cbiAgICAgIGhhc0NvbmZpZ3VyZWRTdHJhdGVneSA9IGZhbHNlLFxuICAgICAgaGFzU2hvd25Ob1N0cmF0ZWd5Q29uZmlndXJlZFdhcm5pbmcgPSBmYWxzZSxcbiAgICAgIHN0cmF0ZWdpZXM7XG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgYSBzYW5pdGl6YXRpb24gc3RyYXRlZ3kgZnVuY3Rpb25cbiAgICogQGNhbGxiYWNrIFN0cmF0ZWd5RnVuY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSB2YWx1ZSAtIHZhbHVlIHRvIGJlIHNhbml0aXplZCAoZWl0aGVyIGEgc3RyaW5nIG9yIGFuIGludGVycG9sYXRlZCB2YWx1ZSBtYXApXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIC0gZWl0aGVyICd0ZXh0JyBmb3IgYSBzdHJpbmcgKHRyYW5zbGF0aW9uKSBvciAncGFyYW1zJyBmb3IgdGhlIGludGVycG9sYXRlZCBwYXJhbXNcbiAgICogQHJldHVybiB7c3RyaW5nfG9iamVjdH1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBwcm9wZXJ0eVxuICAgKiBAbmFtZSBzdHJhdGVnaWVzXG4gICAqIEBwcm9wZXJ0eU9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVNhbml0aXphdGlvblByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBGb2xsb3dpbmcgc3RyYXRlZ2llcyBhcmUgYnVpbHQtaW46XG4gICAqIDxkbD5cbiAgICogICA8ZHQ+c2FuaXRpemU8L2R0PlxuICAgKiAgIDxkZD5TYW5pdGl6ZXMgSFRNTCBpbiB0aGUgdHJhbnNsYXRpb24gdGV4dCB1c2luZyAkc2FuaXRpemU8L2RkPlxuICAgKiAgIDxkdD5lc2NhcGU8L2R0PlxuICAgKiAgIDxkZD5Fc2NhcGVzIEhUTUwgaW4gdGhlIHRyYW5zbGF0aW9uPC9kZD5cbiAgICogICA8ZHQ+c2FuaXRpemVQYXJhbWV0ZXJzPC9kdD5cbiAgICogICA8ZGQ+U2FuaXRpemVzIEhUTUwgaW4gdGhlIHZhbHVlcyBvZiB0aGUgaW50ZXJwb2xhdGlvbiBwYXJhbWV0ZXJzIHVzaW5nICRzYW5pdGl6ZTwvZGQ+XG4gICAqICAgPGR0PmVzY2FwZVBhcmFtZXRlcnM8L2R0PlxuICAgKiAgIDxkZD5Fc2NhcGVzIEhUTUwgaW4gdGhlIHZhbHVlcyBvZiB0aGUgaW50ZXJwb2xhdGlvbiBwYXJhbWV0ZXJzPC9kZD5cbiAgICogICA8ZHQ+ZXNjYXBlZDwvZHQ+XG4gICAqICAgPGRkPlN1cHBvcnQgbGVnYWN5IHN0cmF0ZWd5IG5hbWUgJ2VzY2FwZWQnIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAod2lsbCBiZSByZW1vdmVkIGluIDMuMCk8L2RkPlxuICAgKiA8L2RsPlxuICAgKlxuICAgKi9cblxuICBzdHJhdGVnaWVzID0ge1xuICAgIHNhbml0aXplOiBmdW5jdGlvbiAodmFsdWUsIG1vZGUpIHtcbiAgICAgIGlmIChtb2RlID09PSAndGV4dCcpIHtcbiAgICAgICAgdmFsdWUgPSBodG1sU2FuaXRpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBlc2NhcGU6IGZ1bmN0aW9uICh2YWx1ZSwgbW9kZSkge1xuICAgICAgaWYgKG1vZGUgPT09ICd0ZXh0Jykge1xuICAgICAgICB2YWx1ZSA9IGh0bWxFc2NhcGVWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzYW5pdGl6ZVBhcmFtZXRlcnM6IGZ1bmN0aW9uICh2YWx1ZSwgbW9kZSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdwYXJhbXMnKSB7XG4gICAgICAgIHZhbHVlID0gbWFwSW50ZXJwb2xhdGlvblBhcmFtZXRlcnModmFsdWUsIGh0bWxTYW5pdGl6ZVZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGVzY2FwZVBhcmFtZXRlcnM6IGZ1bmN0aW9uICh2YWx1ZSwgbW9kZSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdwYXJhbXMnKSB7XG4gICAgICAgIHZhbHVlID0gbWFwSW50ZXJwb2xhdGlvblBhcmFtZXRlcnModmFsdWUsIGh0bWxFc2NhcGVWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9O1xuICAvLyBTdXBwb3J0IGxlZ2FjeSBzdHJhdGVneSBuYW1lICdlc2NhcGVkJyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIC8vIFRPRE8gc2hvdWxkIGJlIHJlbW92ZWQgaW4gMy4wXG4gIHN0cmF0ZWdpZXMuZXNjYXBlZCA9IHN0cmF0ZWdpZXMuZXNjYXBlUGFyYW1ldGVycztcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVNhbml0aXphdGlvblByb3ZpZGVyI2FkZFN0cmF0ZWd5XG4gICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVTYW5pdGl6YXRpb25Qcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQWRkcyBhIHNhbml0aXphdGlvbiBzdHJhdGVneSB0byB0aGUgbGlzdCBvZiBrbm93biBzdHJhdGVnaWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyYXRlZ3lOYW1lIC0gdW5pcXVlIGtleSBmb3IgYSBzdHJhdGVneVxuICAgKiBAcGFyYW0ge1N0cmF0ZWd5RnVuY3Rpb259IHN0cmF0ZWd5RnVuY3Rpb24gLSBzdHJhdGVneSBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGlzXG4gICAqL1xuICB0aGlzLmFkZFN0cmF0ZWd5ID0gZnVuY3Rpb24gKHN0cmF0ZWd5TmFtZSwgc3RyYXRlZ3lGdW5jdGlvbikge1xuICAgIHN0cmF0ZWdpZXNbc3RyYXRlZ3lOYW1lXSA9IHN0cmF0ZWd5RnVuY3Rpb247XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVTYW5pdGl6YXRpb25Qcm92aWRlciNyZW1vdmVTdHJhdGVneVxuICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlU2FuaXRpemF0aW9uUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJlbW92ZXMgYSBzYW5pdGl6YXRpb24gc3RyYXRlZ3kgZnJvbSB0aGUgbGlzdCBvZiBrbm93biBzdHJhdGVnaWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyYXRlZ3lOYW1lIC0gdW5pcXVlIGtleSBmb3IgYSBzdHJhdGVneVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGlzXG4gICAqL1xuICB0aGlzLnJlbW92ZVN0cmF0ZWd5ID0gZnVuY3Rpb24gKHN0cmF0ZWd5TmFtZSkge1xuICAgIGRlbGV0ZSBzdHJhdGVnaWVzW3N0cmF0ZWd5TmFtZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVTYW5pdGl6YXRpb25Qcm92aWRlciN1c2VTdHJhdGVneVxuICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlU2FuaXRpemF0aW9uUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNlbGVjdHMgYSBzYW5pdGl6YXRpb24gc3RyYXRlZ3kuIFdoZW4gYW4gYXJyYXkgaXMgcHJvdmlkZWQgdGhlIHN0cmF0ZWdpZXMgd2lsbCBiZSBleGVjdXRlZCBpbiBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8U3RyYXRlZ3lGdW5jdGlvbnxhcnJheX0gc3RyYXRlZ3kgVGhlIHNhbml0aXphdGlvbiBzdHJhdGVneSAvIHN0cmF0ZWdpZXMgd2hpY2ggc2hvdWxkIGJlIHVzZWQuIEVpdGhlciBhIG5hbWUgb2YgYW4gZXhpc3Rpbmcgc3RyYXRlZ3ksIGEgY3VzdG9tIHN0cmF0ZWd5IGZ1bmN0aW9uLCBvciBhbiBhcnJheSBjb25zaXN0aW5nIG9mIG11bHRpcGxlIG5hbWVzIGFuZCAvIG9yIGN1c3RvbSBmdW5jdGlvbnMuXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IHRoaXNcbiAgICovXG4gIHRoaXMudXNlU3RyYXRlZ3kgPSBmdW5jdGlvbiAoc3RyYXRlZ3kpIHtcbiAgICBoYXNDb25maWd1cmVkU3RyYXRlZ3kgPSB0cnVlO1xuICAgIGN1cnJlbnRTdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2Mgb2JqZWN0XG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVNhbml0aXphdGlvblxuICAgKiBAcmVxdWlyZXMgJGluamVjdG9yXG4gICAqIEByZXF1aXJlcyAkbG9nXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTYW5pdGl6ZXMgaW50ZXJwb2xhdGlvbiBwYXJhbWV0ZXJzIGFuZCB0cmFuc2xhdGVkIHRleHRzLlxuICAgKlxuICAgKi9cbiAgdGhpcy4kZ2V0ID0gWyckaW5qZWN0b3InLCAnJGxvZycsIGZ1bmN0aW9uICgkaW5qZWN0b3IsICRsb2cpIHtcblxuICAgIHZhciBjYWNoZWRTdHJhdGVneU1hcCA9IHt9O1xuXG4gICAgdmFyIGFwcGx5U3RyYXRlZ2llcyA9IGZ1bmN0aW9uICh2YWx1ZSwgbW9kZSwgc2VsZWN0ZWRTdHJhdGVnaWVzKSB7XG4gICAgICBhbmd1bGFyLmZvckVhY2goc2VsZWN0ZWRTdHJhdGVnaWVzLCBmdW5jdGlvbiAoc2VsZWN0ZWRTdHJhdGVneSkge1xuICAgICAgICBpZiAoYW5ndWxhci5pc0Z1bmN0aW9uKHNlbGVjdGVkU3RyYXRlZ3kpKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxlY3RlZFN0cmF0ZWd5KHZhbHVlLCBtb2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24oc3RyYXRlZ2llc1tzZWxlY3RlZFN0cmF0ZWd5XSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHN0cmF0ZWdpZXNbc2VsZWN0ZWRTdHJhdGVneV0odmFsdWUsIG1vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcoc3RyYXRlZ2llc1tzZWxlY3RlZFN0cmF0ZWd5XSkpIHtcbiAgICAgICAgICBpZiAoIWNhY2hlZFN0cmF0ZWd5TWFwW3N0cmF0ZWdpZXNbc2VsZWN0ZWRTdHJhdGVneV1dKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjYWNoZWRTdHJhdGVneU1hcFtzdHJhdGVnaWVzW3NlbGVjdGVkU3RyYXRlZ3ldXSA9ICRpbmplY3Rvci5nZXQoc3RyYXRlZ2llc1tzZWxlY3RlZFN0cmF0ZWd5XSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNhY2hlZFN0cmF0ZWd5TWFwW3N0cmF0ZWdpZXNbc2VsZWN0ZWRTdHJhdGVneV1dID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVTYW5pdGl6YXRpb246IFVua25vd24gc2FuaXRpemF0aW9uIHN0cmF0ZWd5OiBcXCcnICsgc2VsZWN0ZWRTdHJhdGVneSArICdcXCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBjYWNoZWRTdHJhdGVneU1hcFtzdHJhdGVnaWVzW3NlbGVjdGVkU3RyYXRlZ3ldXSh2YWx1ZSwgbW9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVTYW5pdGl6YXRpb246IFVua25vd24gc2FuaXRpemF0aW9uIHN0cmF0ZWd5OiBcXCcnICsgc2VsZWN0ZWRTdHJhdGVneSArICdcXCcnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IHNob3VsZCBiZSByZW1vdmVkIGluIDMuMFxuICAgIHZhciBzaG93Tm9TdHJhdGVneUNvbmZpZ3VyZWRXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFoYXNDb25maWd1cmVkU3RyYXRlZ3kgJiYgIWhhc1Nob3duTm9TdHJhdGVneUNvbmZpZ3VyZWRXYXJuaW5nKSB7XG4gICAgICAgICRsb2cud2FybigncGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlU2FuaXRpemF0aW9uOiBObyBzYW5pdGl6YXRpb24gc3RyYXRlZ3kgaGFzIGJlZW4gY29uZmlndXJlZC4gVGhpcyBjYW4gaGF2ZSBzZXJpb3VzIHNlY3VyaXR5IGltcGxpY2F0aW9ucy4gU2VlIGh0dHA6Ly9hbmd1bGFyLXRyYW5zbGF0ZS5naXRodWIuaW8vZG9jcy8jL2d1aWRlLzE5X3NlY3VyaXR5IGZvciBkZXRhaWxzLicpO1xuICAgICAgICBoYXNTaG93bk5vU3RyYXRlZ3lDb25maWd1cmVkV2FybmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICgkaW5qZWN0b3IuaGFzKCckc2FuaXRpemUnKSkge1xuICAgICAgJHNhbml0aXplID0gJGluamVjdG9yLmdldCgnJHNhbml0aXplJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVTYW5pdGl6YXRpb24jdXNlU3RyYXRlZ3lcbiAgICAgICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVTYW5pdGl6YXRpb25cbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFNlbGVjdHMgYSBzYW5pdGl6YXRpb24gc3RyYXRlZ3kuIFdoZW4gYW4gYXJyYXkgaXMgcHJvdmlkZWQgdGhlIHN0cmF0ZWdpZXMgd2lsbCBiZSBleGVjdXRlZCBpbiBvcmRlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ3xTdHJhdGVneUZ1bmN0aW9ufGFycmF5fSBzdHJhdGVneSBUaGUgc2FuaXRpemF0aW9uIHN0cmF0ZWd5IC8gc3RyYXRlZ2llcyB3aGljaCBzaG91bGQgYmUgdXNlZC4gRWl0aGVyIGEgbmFtZSBvZiBhbiBleGlzdGluZyBzdHJhdGVneSwgYSBjdXN0b20gc3RyYXRlZ3kgZnVuY3Rpb24sIG9yIGFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgbXVsdGlwbGUgbmFtZXMgYW5kIC8gb3IgY3VzdG9tIGZ1bmN0aW9ucy5cbiAgICAgICAqL1xuICAgICAgdXNlU3RyYXRlZ3k6IChmdW5jdGlvbiAoc2VsZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cmF0ZWd5KSB7XG4gICAgICAgICAgc2VsZi51c2VTdHJhdGVneShzdHJhdGVneSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVNhbml0aXphdGlvbiNzYW5pdGl6ZVxuICAgICAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVNhbml0aXphdGlvblxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogU2FuaXRpemVzIGEgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggc2hvdWxkIGJlIHNhbml0aXplZC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIFRoZSBjdXJyZW50IHNhbml0aXphdGlvbiBtb2RlLCBlaXRoZXIgJ3BhcmFtcycgb3IgJ3RleHQnLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd8U3RyYXRlZ3lGdW5jdGlvbnxhcnJheX0gW3N0cmF0ZWd5XSBPcHRpb25hbCBjdXN0b20gc3RyYXRlZ3kgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHN0cmF0ZWd5LlxuICAgICAgICogQHJldHVybnMge3N0cmluZ3xvYmplY3R9IHNhbml0aXplZCB2YWx1ZVxuICAgICAgICovXG4gICAgICBzYW5pdGl6ZTogZnVuY3Rpb24gKHZhbHVlLCBtb2RlLCBzdHJhdGVneSkge1xuICAgICAgICBpZiAoIWN1cnJlbnRTdHJhdGVneSkge1xuICAgICAgICAgIHNob3dOb1N0cmF0ZWd5Q29uZmlndXJlZFdhcm5pbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICAgIHN0cmF0ZWd5ID0gY3VycmVudFN0cmF0ZWd5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdHJhdGVneSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxlY3RlZFN0cmF0ZWdpZXMgPSBhbmd1bGFyLmlzQXJyYXkoc3RyYXRlZ3kpID8gc3RyYXRlZ3kgOiBbc3RyYXRlZ3ldO1xuICAgICAgICByZXR1cm4gYXBwbHlTdHJhdGVnaWVzKHZhbHVlLCBtb2RlLCBzZWxlY3RlZFN0cmF0ZWdpZXMpO1xuICAgICAgfVxuICAgIH07XG4gIH1dO1xuXG4gIHZhciBodG1sRXNjYXBlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdj48L2Rpdj4nKTtcbiAgICBlbGVtZW50LnRleHQodmFsdWUpOyAvLyBub3QgY2hhaW5hYmxlLCBzZWUgIzEwNDRcbiAgICByZXR1cm4gZWxlbWVudC5odG1sKCk7XG4gIH07XG5cbiAgdmFyIGh0bWxTYW5pdGl6ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCEkc2FuaXRpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlU2FuaXRpemF0aW9uOiBFcnJvciBjYW5ub3QgZmluZCAkc2FuaXRpemUgc2VydmljZS4gRWl0aGVyIGluY2x1ZGUgdGhlIG5nU2FuaXRpemUgbW9kdWxlIChodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmdTYW5pdGl6ZSkgb3IgdXNlIGEgc2FuaXRpemF0aW9uIHN0cmF0ZWd5IHdoaWNoIGRvZXMgbm90IGRlcGVuZCBvbiAkc2FuaXRpemUsIHN1Y2ggYXMgXFwnZXNjYXBlXFwnLicpO1xuICAgIH1cbiAgICByZXR1cm4gJHNhbml0aXplKHZhbHVlKTtcbiAgfTtcblxuICB2YXIgbWFwSW50ZXJwb2xhdGlvblBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodmFsdWUsIGl0ZXJhdGVlLCBzdGFjaykge1xuICAgIGlmIChhbmd1bGFyLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGFuZ3VsYXIuaXNBcnJheSh2YWx1ZSkgPyBbXSA6IHt9O1xuXG4gICAgICBpZiAoIXN0YWNrKSB7XG4gICAgICAgIHN0YWNrID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgPiAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlU2FuaXRpemF0aW9uOiBFcnJvciBjYW5ub3QgaW50ZXJwb2xhdGUgcGFyYW1ldGVyIGR1ZSByZWN1cnNpdmUgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICBhbmd1bGFyLmZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eVZhbHVlLCBwcm9wZXJ0eUtleSkge1xuICAgICAgICByZXN1bHRbcHJvcGVydHlLZXldID0gbWFwSW50ZXJwb2xhdGlvblBhcmFtZXRlcnMocHJvcGVydHlWYWx1ZSwgaXRlcmF0ZWUsIHN0YWNrKTtcbiAgICAgIH0pO1xuICAgICAgc3RhY2suc3BsaWNlKC0xLCAxKTsgLy8gcmVtb3ZlIGxhc3RcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiAkdHJhbnNsYXRlUHJvdmlkZXIgYWxsb3dzIGRldmVsb3BlcnMgdG8gcmVnaXN0ZXIgdHJhbnNsYXRpb24tdGFibGVzLCBhc3luY2hyb25vdXMgbG9hZGVyc1xuICogYW5kIHNpbWlsYXIgdG8gY29uZmlndXJlIHRyYW5zbGF0aW9uIGJlaGF2aW9yIGRpcmVjdGx5IGluc2lkZSBvZiBhIG1vZHVsZS5cbiAqXG4gKi9cbmFuZ3VsYXIubW9kdWxlKCdwYXNjYWxwcmVjaHQudHJhbnNsYXRlJylcbi5jb25zdGFudCgncGFzY2FscHJlY2h0VHJhbnNsYXRlT3ZlcnJpZGVyJywge30pXG4ucHJvdmlkZXIoJyR0cmFuc2xhdGUnLCAkdHJhbnNsYXRlKTtcblxuZnVuY3Rpb24gJHRyYW5zbGF0ZSgkU1RPUkFHRV9LRVksICR3aW5kb3dQcm92aWRlciwgJHRyYW5zbGF0ZVNhbml0aXphdGlvblByb3ZpZGVyLCBwYXNjYWxwcmVjaHRUcmFuc2xhdGVPdmVycmlkZXIpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyICR0cmFuc2xhdGlvblRhYmxlID0ge30sXG4gICAgICAkcHJlZmVycmVkTGFuZ3VhZ2UsXG4gICAgICAkYXZhaWxhYmxlTGFuZ3VhZ2VLZXlzID0gW10sXG4gICAgICAkbGFuZ3VhZ2VLZXlBbGlhc2VzLFxuICAgICAgJGZhbGxiYWNrTGFuZ3VhZ2UsXG4gICAgICAkZmFsbGJhY2tXYXNTdHJpbmcsXG4gICAgICAkdXNlcyxcbiAgICAgICRuZXh0TGFuZyxcbiAgICAgICRzdG9yYWdlRmFjdG9yeSxcbiAgICAgICRzdG9yYWdlS2V5ID0gJFNUT1JBR0VfS0VZLFxuICAgICAgJHN0b3JhZ2VQcmVmaXgsXG4gICAgICAkbWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlckZhY3RvcnksXG4gICAgICAkaW50ZXJwb2xhdGlvbkZhY3RvcnksXG4gICAgICAkaW50ZXJwb2xhdG9yRmFjdG9yaWVzID0gW10sXG4gICAgICAkbG9hZGVyRmFjdG9yeSxcbiAgICAgICRjbG9ha0NsYXNzTmFtZSA9ICd0cmFuc2xhdGUtY2xvYWsnLFxuICAgICAgJGxvYWRlck9wdGlvbnMsXG4gICAgICAkbm90Rm91bmRJbmRpY2F0b3JMZWZ0LFxuICAgICAgJG5vdEZvdW5kSW5kaWNhdG9yUmlnaHQsXG4gICAgICAkcG9zdENvbXBpbGluZ0VuYWJsZWQgPSBmYWxzZSxcbiAgICAgICRmb3JjZUFzeW5jUmVsb2FkRW5hYmxlZCA9IGZhbHNlLFxuICAgICAgJG5lc3RlZE9iamVjdERlbGltZXRlciA9ICcuJyxcbiAgICAgICRpc1JlYWR5ID0gZmFsc2UsXG4gICAgICBsb2FkZXJDYWNoZSxcbiAgICAgIGRpcmVjdGl2ZVByaW9yaXR5ID0gMCxcbiAgICAgIHN0YXRlZnVsRmlsdGVyID0gdHJ1ZSxcbiAgICAgIHVuaWZvcm1MYW5ndWFnZVRhZ1Jlc29sdmVyID0gJ2RlZmF1bHQnLFxuICAgICAgbGFuZ3VhZ2VUYWdSZXNvbHZlciA9IHtcbiAgICAgICAgJ2RlZmF1bHQnOiBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgcmV0dXJuICh0YWcgfHwgJycpLnNwbGl0KCctJykuam9pbignXycpO1xuICAgICAgICB9LFxuICAgICAgICBqYXZhOiBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSAodGFnIHx8ICcnKS5zcGxpdCgnLScpLmpvaW4oJ18nKTtcbiAgICAgICAgICB2YXIgcGFydHMgPSB0ZW1wLnNwbGl0KCdfJyk7XG4gICAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA+IDEgPyAocGFydHNbMF0udG9Mb3dlckNhc2UoKSArICdfJyArIHBhcnRzWzFdLnRvVXBwZXJDYXNlKCkpIDogdGVtcDtcbiAgICAgICAgfSxcbiAgICAgICAgYmNwNDc6IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9ICh0YWcgfHwgJycpLnNwbGl0KCdfJykuam9pbignLScpO1xuICAgICAgICAgIHZhciBwYXJ0cyA9IHRlbXAuc3BsaXQoJy0nKTtcbiAgICAgICAgICByZXR1cm4gcGFydHMubGVuZ3RoID4gMSA/IChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpICsgJy0nICsgcGFydHNbMV0udG9VcHBlckNhc2UoKSkgOiB0ZW1wO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gIHZhciB2ZXJzaW9uID0gJzIuMTAuMCc7XG5cbiAgLy8gdHJpZXMgdG8gZGV0ZXJtaW5lIHRoZSBicm93c2VycyBsYW5ndWFnZVxuICB2YXIgZ2V0Rmlyc3RCcm93c2VyTGFuZ3VhZ2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBpbnRlcm5hbCBwdXJwb3NlIG9ubHlcbiAgICBpZiAoYW5ndWxhci5pc0Z1bmN0aW9uKHBhc2NhbHByZWNodFRyYW5zbGF0ZU92ZXJyaWRlci5nZXRMb2NhbGUpKSB7XG4gICAgICByZXR1cm4gcGFzY2FscHJlY2h0VHJhbnNsYXRlT3ZlcnJpZGVyLmdldExvY2FsZSgpO1xuICAgIH1cblxuICAgIHZhciBuYXYgPSAkd2luZG93UHJvdmlkZXIuJGdldCgpLm5hdmlnYXRvcixcbiAgICAgICAgYnJvd3Nlckxhbmd1YWdlUHJvcGVydHlLZXlzID0gWydsYW5ndWFnZScsICdicm93c2VyTGFuZ3VhZ2UnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndXNlckxhbmd1YWdlJ10sXG4gICAgICAgIGksXG4gICAgICAgIGxhbmd1YWdlO1xuXG4gICAgLy8gc3VwcG9ydCBmb3IgSFRNTCA1LjEgXCJuYXZpZ2F0b3IubGFuZ3VhZ2VzXCJcbiAgICBpZiAoYW5ndWxhci5pc0FycmF5KG5hdi5sYW5ndWFnZXMpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbmF2Lmxhbmd1YWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYW5ndWFnZSA9IG5hdi5sYW5ndWFnZXNbaV07XG4gICAgICAgIGlmIChsYW5ndWFnZSAmJiBsYW5ndWFnZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0IGZvciBvdGhlciB3ZWxsIGtub3duIHByb3BlcnRpZXMgaW4gYnJvd3NlcnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnJvd3Nlckxhbmd1YWdlUHJvcGVydHlLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsYW5ndWFnZSA9IG5hdlticm93c2VyTGFuZ3VhZ2VQcm9wZXJ0eUtleXNbaV1dO1xuICAgICAgaWYgKGxhbmd1YWdlICYmIGxhbmd1YWdlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGdldEZpcnN0QnJvd3Nlckxhbmd1YWdlLmRpc3BsYXlOYW1lID0gJ2FuZ3VsYXItdHJhbnNsYXRlL3NlcnZpY2U6IGdldEZpcnN0QnJvd3Nlckxhbmd1YWdlJztcblxuICAvLyB0cmllcyB0byBkZXRlcm1pbmUgdGhlIGJyb3dzZXJzIGxvY2FsZVxuICB2YXIgZ2V0TG9jYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsb2NhbGUgPSBnZXRGaXJzdEJyb3dzZXJMYW5ndWFnZSgpIHx8ICcnO1xuICAgIGlmIChsYW5ndWFnZVRhZ1Jlc29sdmVyW3VuaWZvcm1MYW5ndWFnZVRhZ1Jlc29sdmVyXSkge1xuICAgICAgbG9jYWxlID0gbGFuZ3VhZ2VUYWdSZXNvbHZlclt1bmlmb3JtTGFuZ3VhZ2VUYWdSZXNvbHZlcl0obG9jYWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZTtcbiAgfTtcbiAgZ2V0TG9jYWxlLmRpc3BsYXlOYW1lID0gJ2FuZ3VsYXItdHJhbnNsYXRlL3NlcnZpY2U6IGdldExvY2FsZSc7XG5cbiAgLyoqXG4gICAqIEBuYW1lIGluZGV4T2ZcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIGluZGV4T2YgcG9seWZpbGwuIEtpbmRhIHNvcnRhLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBhcnJheSBBcnJheSB0byBzZWFyY2ggaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gc2VhcmNoIGZvci5cbiAgICpcbiAgICogQHJldHVybnMge2ludH0gSW5kZXggb2Ygc2VhcmNoIGVsZW1lbnQuXG4gICAqL1xuICB2YXIgaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBzZWFyY2hFbGVtZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgdHJpbVxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogdHJpbSBwb2x5ZmlsbFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIHN0cmlwcGVkIG9mIHdoaXRlc3BhY2UgZnJvbSBib3RoIGVuZHNcbiAgICovXG4gIHZhciB0cmltID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gIH07XG5cbiAgdmFyIG5lZ290aWF0ZUxvY2FsZSA9IGZ1bmN0aW9uIChwcmVmZXJyZWQpIHtcbiAgICBpZighcHJlZmVycmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF2YWlsID0gW10sXG4gICAgICAgIGxvY2FsZSA9IGFuZ3VsYXIubG93ZXJjYXNlKHByZWZlcnJlZCksXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBuID0gJGF2YWlsYWJsZUxhbmd1YWdlS2V5cy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgYXZhaWwucHVzaChhbmd1bGFyLmxvd2VyY2FzZSgkYXZhaWxhYmxlTGFuZ3VhZ2VLZXlzW2ldKSk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGFuIGV4YWN0IG1hdGNoIGluIG91ciBsaXN0IG9mIGF2YWlsYWJsZSBrZXlzXG4gICAgaWYgKGluZGV4T2YoYXZhaWwsIGxvY2FsZSkgPiAtMSkge1xuICAgICAgcmV0dXJuIHByZWZlcnJlZDtcbiAgICB9XG5cbiAgICBpZiAoJGxhbmd1YWdlS2V5QWxpYXNlcykge1xuICAgICAgdmFyIGFsaWFzO1xuICAgICAgZm9yICh2YXIgbGFuZ0tleUFsaWFzIGluICRsYW5ndWFnZUtleUFsaWFzZXMpIHtcbiAgICAgICAgdmFyIGhhc1dpbGRjYXJkS2V5ID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNFeGFjdEtleSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgkbGFuZ3VhZ2VLZXlBbGlhc2VzLCBsYW5nS2V5QWxpYXMpICYmXG4gICAgICAgICAgYW5ndWxhci5sb3dlcmNhc2UobGFuZ0tleUFsaWFzKSA9PT0gYW5ndWxhci5sb3dlcmNhc2UocHJlZmVycmVkKTtcblxuICAgICAgICBpZiAobGFuZ0tleUFsaWFzLnNsaWNlKC0xKSA9PT0gJyonKSB7XG4gICAgICAgICAgaGFzV2lsZGNhcmRLZXkgPSBsYW5nS2V5QWxpYXMuc2xpY2UoMCwgLTEpID09PSBwcmVmZXJyZWQuc2xpY2UoMCwgbGFuZ0tleUFsaWFzLmxlbmd0aC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRXhhY3RLZXkgfHwgaGFzV2lsZGNhcmRLZXkpIHtcbiAgICAgICAgICBhbGlhcyA9ICRsYW5ndWFnZUtleUFsaWFzZXNbbGFuZ0tleUFsaWFzXTtcbiAgICAgICAgICBpZiAoaW5kZXhPZihhdmFpbCwgYW5ndWxhci5sb3dlcmNhc2UoYWxpYXMpKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gYWxpYXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGEgbGFuZ3VhZ2UgY29kZSB3aXRob3V0IHJlZ2lvblxuICAgIHZhciBwYXJ0cyA9IHByZWZlcnJlZC5zcGxpdCgnXycpO1xuXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEgJiYgaW5kZXhPZihhdmFpbCwgYW5ndWxhci5sb3dlcmNhc2UocGFydHNbMF0pKSA+IC0xKSB7XG4gICAgICByZXR1cm4gcGFydHNbMF07XG4gICAgfVxuXG4gICAgLy8gSWYgZXZlcnl0aGluZyBmYWlscywgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICByZXR1cm47XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlciN0cmFuc2xhdGlvbnNcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZWdpc3RlcnMgYSBuZXcgdHJhbnNsYXRpb24gdGFibGUgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGtleS5cbiAgICpcbiAgICogVG8gcmVnaXN0ZXIgYSB0cmFuc2xhdGlvbiB0YWJsZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UsIHBhc3MgYSBkZWZpbmVkIGxhbmd1YWdlXG4gICAqIGtleSBhcyBmaXJzdCBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIDxwcmU+XG4gICAqICAvLyByZWdpc3RlciB0cmFuc2xhdGlvbiB0YWJsZSBmb3IgbGFuZ3VhZ2U6ICdkZV9ERSdcbiAgICogICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2RlX0RFJywge1xuICAgKiAgICAnR1JFRVRJTkcnOiAnSGFsbG8gV2VsdCEnXG4gICAqICB9KTtcbiAgICpcbiAgICogIC8vIHJlZ2lzdGVyIGFub3RoZXIgb25lXG4gICAqICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdlbl9VUycsIHtcbiAgICogICAgJ0dSRUVUSU5HJzogJ0hlbGxvIHdvcmxkISdcbiAgICogIH0pO1xuICAgKiA8L3ByZT5cbiAgICpcbiAgICogV2hlbiByZWdpc3RlcmluZyBtdWx0aXBsZSB0cmFuc2xhdGlvbiB0YWJsZXMgZm9yIGZvciB0aGUgc2FtZSBsYW5ndWFnZSBrZXksXG4gICAqIHRoZSBhY3R1YWwgdHJhbnNsYXRpb24gdGFibGUgZ2V0cyBleHRlbmRlZC4gVGhpcyBhbGxvd3MgeW91IHRvIGRlZmluZSBtb2R1bGVcbiAgICogc3BlY2lmaWMgdHJhbnNsYXRpb24gd2hpY2ggb25seSBnZXQgYWRkZWQsIG9uY2UgYSBzcGVjaWZpYyBtb2R1bGUgaXMgbG9hZGVkIGluXG4gICAqIHlvdXIgYXBwLlxuICAgKlxuICAgKiBJbnZva2luZyB0aGlzIG1ldGhvZCB3aXRoIG5vIGFyZ3VtZW50cyByZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiB0YWJsZSB3aGljaCB3YXNcbiAgICogcmVnaXN0ZXJlZCB3aXRoIG5vIGxhbmd1YWdlIGtleS4gSW52b2tpbmcgaXQgd2l0aCBhIGxhbmd1YWdlIGtleSByZXR1cm5zIHRoZVxuICAgKiByZWxhdGVkIHRyYW5zbGF0aW9uIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEEgbGFuZ3VhZ2Uga2V5LlxuICAgKiBAcGFyYW0ge29iamVjdH0gdHJhbnNsYXRpb25UYWJsZSBBIHBsYWluIG9sZCBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSB0cmFuc2xhdGlvbiB0YWJsZS5cbiAgICpcbiAgICovXG4gIHZhciB0cmFuc2xhdGlvbnMgPSBmdW5jdGlvbiAobGFuZ0tleSwgdHJhbnNsYXRpb25UYWJsZSkge1xuXG4gICAgaWYgKCFsYW5nS2V5ICYmICF0cmFuc2xhdGlvblRhYmxlKSB7XG4gICAgICByZXR1cm4gJHRyYW5zbGF0aW9uVGFibGU7XG4gICAgfVxuXG4gICAgaWYgKGxhbmdLZXkgJiYgIXRyYW5zbGF0aW9uVGFibGUpIHtcbiAgICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKGxhbmdLZXkpKSB7XG4gICAgICAgIHJldHVybiAkdHJhbnNsYXRpb25UYWJsZVtsYW5nS2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFhbmd1bGFyLmlzT2JqZWN0KCR0cmFuc2xhdGlvblRhYmxlW2xhbmdLZXldKSkge1xuICAgICAgICAkdHJhbnNsYXRpb25UYWJsZVtsYW5nS2V5XSA9IHt9O1xuICAgICAgfVxuICAgICAgYW5ndWxhci5leHRlbmQoJHRyYW5zbGF0aW9uVGFibGVbbGFuZ0tleV0sIGZsYXRPYmplY3QodHJhbnNsYXRpb25UYWJsZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLnRyYW5zbGF0aW9ucyA9IHRyYW5zbGF0aW9ucztcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI2Nsb2FrQ2xhc3NOYW1lXG4gICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogTGV0J3MgeW91IGNoYW5nZSB0aGUgY2xhc3MgbmFtZSBmb3IgYHRyYW5zbGF0ZS1jbG9ha2AgZGlyZWN0aXZlLlxuICAgKiBEZWZhdWx0IGNsYXNzIG5hbWUgaXMgYHRyYW5zbGF0ZS1jbG9ha2AuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRyYW5zbGF0ZS1jbG9hayBjbGFzcyBuYW1lXG4gICAqL1xuICB0aGlzLmNsb2FrQ2xhc3NOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybiAkY2xvYWtDbGFzc05hbWU7XG4gICAgfVxuICAgICRjbG9ha0NsYXNzTmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlciNuZXN0ZWRPYmplY3REZWxpbWV0ZXJcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBMZXQncyB5b3UgY2hhbmdlIHRoZSBkZWxpbWl0ZXIgZm9yIG5hbWVzcGFjZWQgdHJhbnNsYXRpb25zLlxuICAgKiBEZWZhdWx0IGRlbGltaXRlciBpcyBgLmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkZWxpbWl0ZXIgbmFtZXNwYWNlIHNlcGFyYXRvclxuICAgKi9cbiAgdGhpcy5uZXN0ZWRPYmplY3REZWxpbWV0ZXIgPSBmdW5jdGlvbiAoZGVsaW1pdGVyKSB7XG4gICAgaWYgKCFkZWxpbWl0ZXIpIHtcbiAgICAgIHJldHVybiAkbmVzdGVkT2JqZWN0RGVsaW1ldGVyO1xuICAgIH1cbiAgICAkbmVzdGVkT2JqZWN0RGVsaW1ldGVyID0gZGVsaW1pdGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBmbGF0T2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBGbGF0cyBhbiBvYmplY3QuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBmbGF0dGVuIGdpdmVuIHRyYW5zbGF0aW9uIGRhdGEgd2l0aFxuICAgKiBuYW1lc3BhY2VzLCBzbyB0aGV5IGFyZSBsYXRlciBhY2Nlc3NpYmxlIHZpYSBkb3Qgbm90YXRpb24uXG4gICAqL1xuICB2YXIgZmxhdE9iamVjdCA9IGZ1bmN0aW9uIChkYXRhLCBwYXRoLCByZXN1bHQsIHByZXZLZXkpIHtcbiAgICB2YXIga2V5LCBrZXlXaXRoUGF0aCwga2V5V2l0aFNob3J0UGF0aCwgdmFsO1xuXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICBwYXRoID0gW107XG4gICAgfVxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXN1bHQgPSB7fTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gZGF0YSkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhbCA9IGRhdGFba2V5XTtcbiAgICAgIGlmIChhbmd1bGFyLmlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgZmxhdE9iamVjdCh2YWwsIHBhdGguY29uY2F0KGtleSksIHJlc3VsdCwga2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleVdpdGhQYXRoID0gcGF0aC5sZW5ndGggPyAoJycgKyBwYXRoLmpvaW4oJG5lc3RlZE9iamVjdERlbGltZXRlcikgKyAkbmVzdGVkT2JqZWN0RGVsaW1ldGVyICsga2V5KSA6IGtleTtcbiAgICAgICAgaWYocGF0aC5sZW5ndGggJiYga2V5ID09PSBwcmV2S2V5KXtcbiAgICAgICAgICAvLyBDcmVhdGUgc2hvcnRjdXQgcGF0aCAoZm9vLmJhciA9PSBmb28uYmFyLmJhcilcbiAgICAgICAgICBrZXlXaXRoU2hvcnRQYXRoID0gJycgKyBwYXRoLmpvaW4oJG5lc3RlZE9iamVjdERlbGltZXRlcik7XG4gICAgICAgICAgLy8gTGluayBpdCB0byBvcmlnaW5hbCBwYXRoXG4gICAgICAgICAgcmVzdWx0W2tleVdpdGhTaG9ydFBhdGhdID0gJ0A6JyArIGtleVdpdGhQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXlXaXRoUGF0aF0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGZsYXRPYmplY3QuZGlzcGxheU5hbWUgPSAnZmxhdE9iamVjdCc7XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlciNhZGRJbnRlcnBvbGF0aW9uXG4gICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQWRkcyBpbnRlcnBvbGF0aW9uIHNlcnZpY2VzIHRvIGFuZ3VsYXItdHJhbnNsYXRlLCBzbyBpdCBjYW4gbWFuYWdlIHRoZW0uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmYWN0b3J5IEludGVycG9sYXRpb24gc2VydmljZSBmYWN0b3J5XG4gICAqL1xuICB0aGlzLmFkZEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgICRpbnRlcnBvbGF0b3JGYWN0b3JpZXMucHVzaChmYWN0b3J5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI3VzZU1lc3NhZ2VGb3JtYXRJbnRlcnBvbGF0aW9uXG4gICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGVsbHMgYW5ndWxhci10cmFuc2xhdGUgdG8gdXNlIGludGVycG9sYXRpb24gZnVuY3Rpb25hbGl0eSBvZiBtZXNzYWdlZm9ybWF0LmpzLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGhhdmluZyBoaWdoIGxldmVsIHBsdXJhbGl6YXRpb24gYW5kIGdlbmRlciBzZWxlY3Rpb24uXG4gICAqL1xuICB0aGlzLnVzZU1lc3NhZ2VGb3JtYXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVzZUludGVycG9sYXRpb24oJyR0cmFuc2xhdGVNZXNzYWdlRm9ybWF0SW50ZXJwb2xhdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjdXNlSW50ZXJwb2xhdGlvblxuICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRlbGxzIGFuZ3VsYXItdHJhbnNsYXRlIHdoaWNoIGludGVycG9sYXRpb24gc3R5bGUgdG8gdXNlIGFzIGRlZmF1bHQsIGFwcGxpY2F0aW9uLXdpZGUuXG4gICAqIFNpbXBseSBwYXNzIGEgZmFjdG9yeS9zZXJ2aWNlIG5hbWUuIFRoZSBpbnRlcnBvbGF0aW9uIHNlcnZpY2UgaGFzIHRvIGltcGxlbWVudFxuICAgKiB0aGUgY29ycmVjdCBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmYWN0b3J5IEludGVycG9sYXRpb24gc2VydmljZSBuYW1lLlxuICAgKi9cbiAgdGhpcy51c2VJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICAkaW50ZXJwb2xhdGlvbkZhY3RvcnkgPSBmYWN0b3J5O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjdXNlU2FuaXRpemVTdHJhdGVneVxuICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNpbXBseSBzZXRzIGEgc2FuaXRhdGlvbiBzdHJhdGVneSB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgU3RyYXRlZ3kgdHlwZS5cbiAgICovXG4gIHRoaXMudXNlU2FuaXRpemVWYWx1ZVN0cmF0ZWd5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgJHRyYW5zbGF0ZVNhbml0aXphdGlvblByb3ZpZGVyLnVzZVN0cmF0ZWd5KHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjcHJlZmVycmVkTGFuZ3VhZ2VcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUZWxscyB0aGUgbW9kdWxlIHdoaWNoIG9mIHRoZSByZWdpc3RlcmVkIHRyYW5zbGF0aW9uIHRhYmxlcyB0byB1c2UgZm9yIHRyYW5zbGF0aW9uXG4gICAqIGF0IGluaXRpYWwgc3RhcnR1cCBieSBwYXNzaW5nIGEgbGFuZ3VhZ2Uga2V5LiBTaW1pbGFyIHRvIGAkdHJhbnNsYXRlUHJvdmlkZXIjdXNlYFxuICAgKiBvbmx5IHRoYXQgaXQgc2F5cyB3aGljaCBsYW5ndWFnZSB0byAqKnByZWZlcioqLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ0tleSBBIGxhbmd1YWdlIGtleS5cbiAgICovXG4gIHRoaXMucHJlZmVycmVkTGFuZ3VhZ2UgPSBmdW5jdGlvbihsYW5nS2V5KSB7XG4gICAgaWYgKGxhbmdLZXkpIHtcbiAgICAgIHNldHVwUHJlZmVycmVkTGFuZ3VhZ2UobGFuZ0tleSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuICRwcmVmZXJyZWRMYW5ndWFnZTtcbiAgfTtcbiAgdmFyIHNldHVwUHJlZmVycmVkTGFuZ3VhZ2UgPSBmdW5jdGlvbiAobGFuZ0tleSkge1xuICAgIGlmIChsYW5nS2V5KSB7XG4gICAgICAkcHJlZmVycmVkTGFuZ3VhZ2UgPSBsYW5nS2V5O1xuICAgIH1cbiAgICByZXR1cm4gJHByZWZlcnJlZExhbmd1YWdlO1xuICB9O1xuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI3RyYW5zbGF0aW9uTm90Rm91bmRJbmRpY2F0b3JcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIGFuIGluZGljYXRvciB3aGljaCBpcyB1c2VkIHdoZW4gYSB0cmFuc2xhdGlvbiBpc24ndCBmb3VuZC4gRS5nLiB3aGVuXG4gICAqIHNldHRpbmcgdGhlIGluZGljYXRvciBhcyAnWCcgYW5kIG9uZSB0cmllcyB0byB0cmFuc2xhdGUgYSB0cmFuc2xhdGlvbiBpZFxuICAgKiBjYWxsZWQgYE5PVF9GT1VORGAsIHRoaXMgd2lsbCByZXN1bHQgaW4gYFggTk9UX0ZPVU5EIFhgLlxuICAgKlxuICAgKiBJbnRlcm5hbGx5IHRoaXMgbWV0aG9kcyBzZXRzIGEgbGVmdCBpbmRpY2F0b3IgYW5kIGEgcmlnaHQgaW5kaWNhdG9yIHVzaW5nXG4gICAqIGAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25Ob3RGb3VuZEluZGljYXRvckxlZnQoKWAgYW5kXG4gICAqIGAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25Ob3RGb3VuZEluZGljYXRvclJpZ2h0KClgLlxuICAgKlxuICAgKiAqKk5vdGUqKjogVGhlc2UgbWV0aG9kcyBhdXRvbWF0aWNhbGx5IGFkZCBhIHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgaW5kaWNhdG9yc1xuICAgKiBhbmQgdGhlIHRyYW5zbGF0aW9uIGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5kaWNhdG9yIEFuIGluZGljYXRvciwgY291bGQgYmUgYW55IHN0cmluZy5cbiAgICovXG4gIHRoaXMudHJhbnNsYXRpb25Ob3RGb3VuZEluZGljYXRvciA9IGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICB0aGlzLnRyYW5zbGF0aW9uTm90Rm91bmRJbmRpY2F0b3JMZWZ0KGluZGljYXRvcik7XG4gICAgdGhpcy50cmFuc2xhdGlvbk5vdEZvdW5kSW5kaWNhdG9yUmlnaHQoaW5kaWNhdG9yKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjdHJhbnNsYXRpb25Ob3RGb3VuZEluZGljYXRvckxlZnRcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIGFuIGluZGljYXRvciB3aGljaCBpcyB1c2VkIHdoZW4gYSB0cmFuc2xhdGlvbiBpc24ndCBmb3VuZCBsZWZ0IHRvIHRoZVxuICAgKiB0cmFuc2xhdGlvbiBpZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluZGljYXRvciBBbiBpbmRpY2F0b3IuXG4gICAqL1xuICB0aGlzLnRyYW5zbGF0aW9uTm90Rm91bmRJbmRpY2F0b3JMZWZ0ID0gZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgIGlmICghaW5kaWNhdG9yKSB7XG4gICAgICByZXR1cm4gJG5vdEZvdW5kSW5kaWNhdG9yTGVmdDtcbiAgICB9XG4gICAgJG5vdEZvdW5kSW5kaWNhdG9yTGVmdCA9IGluZGljYXRvcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjdHJhbnNsYXRpb25Ob3RGb3VuZEluZGljYXRvckxlZnRcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIGFuIGluZGljYXRvciB3aGljaCBpcyB1c2VkIHdoZW4gYSB0cmFuc2xhdGlvbiBpc24ndCBmb3VuZCByaWdodCB0byB0aGVcbiAgICogdHJhbnNsYXRpb24gaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbmRpY2F0b3IgQW4gaW5kaWNhdG9yLlxuICAgKi9cbiAgdGhpcy50cmFuc2xhdGlvbk5vdEZvdW5kSW5kaWNhdG9yUmlnaHQgPSBmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgaWYgKCFpbmRpY2F0b3IpIHtcbiAgICAgIHJldHVybiAkbm90Rm91bmRJbmRpY2F0b3JSaWdodDtcbiAgICB9XG4gICAgJG5vdEZvdW5kSW5kaWNhdG9yUmlnaHQgPSBpbmRpY2F0b3I7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlciNmYWxsYmFja0xhbmd1YWdlXG4gICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGVsbHMgdGhlIG1vZHVsZSB3aGljaCBvZiB0aGUgcmVnaXN0ZXJlZCB0cmFuc2xhdGlvbiB0YWJsZXMgdG8gdXNlIHdoZW4gbWlzc2luZyB0cmFuc2xhdGlvbnNcbiAgICogYXQgaW5pdGlhbCBzdGFydHVwIGJ5IHBhc3NpbmcgYSBsYW5ndWFnZSBrZXkuIFNpbWlsYXIgdG8gYCR0cmFuc2xhdGVQcm92aWRlciN1c2VgXG4gICAqIG9ubHkgdGhhdCBpdCBzYXlzIHdoaWNoIGxhbmd1YWdlIHRvICoqZmFsbGJhY2sqKi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8fGFycmF5fSBsYW5nS2V5IEEgbGFuZ3VhZ2Uga2V5LlxuICAgKlxuICAgKi9cbiAgdGhpcy5mYWxsYmFja0xhbmd1YWdlID0gZnVuY3Rpb24gKGxhbmdLZXkpIHtcbiAgICBmYWxsYmFja1N0YWNrKGxhbmdLZXkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBmYWxsYmFja1N0YWNrID0gZnVuY3Rpb24gKGxhbmdLZXkpIHtcbiAgICBpZiAobGFuZ0tleSkge1xuICAgICAgaWYgKGFuZ3VsYXIuaXNTdHJpbmcobGFuZ0tleSkpIHtcbiAgICAgICAgJGZhbGxiYWNrV2FzU3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgJGZhbGxiYWNrTGFuZ3VhZ2UgPSBbIGxhbmdLZXkgXTtcbiAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc0FycmF5KGxhbmdLZXkpKSB7XG4gICAgICAgICRmYWxsYmFja1dhc1N0cmluZyA9IGZhbHNlO1xuICAgICAgICAkZmFsbGJhY2tMYW5ndWFnZSA9IGxhbmdLZXk7XG4gICAgICB9XG4gICAgICBpZiAoYW5ndWxhci5pc1N0cmluZygkcHJlZmVycmVkTGFuZ3VhZ2UpICAmJiBpbmRleE9mKCRmYWxsYmFja0xhbmd1YWdlLCAkcHJlZmVycmVkTGFuZ3VhZ2UpIDwgMCkge1xuICAgICAgICAkZmFsbGJhY2tMYW5ndWFnZS5wdXNoKCRwcmVmZXJyZWRMYW5ndWFnZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJGZhbGxiYWNrV2FzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAkZmFsbGJhY2tMYW5ndWFnZVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAkZmFsbGJhY2tMYW5ndWFnZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlciN1c2VcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXQgd2hpY2ggdHJhbnNsYXRpb24gdGFibGUgdG8gdXNlIGZvciB0cmFuc2xhdGlvbiBieSBnaXZlbiBsYW5ndWFnZSBrZXkuIFdoZW5cbiAgICogdHJ5aW5nIHRvICd1c2UnIGEgbGFuZ3VhZ2Ugd2hpY2ggaXNuJ3QgcHJvdmlkZWQsIGl0J2xsIHRocm93IGFuIGVycm9yLlxuICAgKlxuICAgKiBZb3UgYWN0dWFsbHkgZG9uJ3QgaGF2ZSB0byB1c2UgdGhpcyBtZXRob2Qgc2luY2UgYCR0cmFuc2xhdGVQcm92aWRlciNwcmVmZXJyZWRMYW5ndWFnZWBcbiAgICogZG9lcyB0aGUgam9iIHRvby5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmdLZXkgQSBsYW5ndWFnZSBrZXkuXG4gICAqL1xuICB0aGlzLnVzZSA9IGZ1bmN0aW9uIChsYW5nS2V5KSB7XG4gICAgaWYgKGxhbmdLZXkpIHtcbiAgICAgIGlmICghJHRyYW5zbGF0aW9uVGFibGVbbGFuZ0tleV0gJiYgKCEkbG9hZGVyRmFjdG9yeSkpIHtcbiAgICAgICAgLy8gb25seSB0aHJvdyBhbiBlcnJvciwgd2hlbiBub3QgbG9hZGluZyB0cmFuc2xhdGlvbiBkYXRhIGFzeW5jaHJvbm91c2x5XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignJHRyYW5zbGF0ZVByb3ZpZGVyIGNvdWxkblxcJ3QgZmluZCB0cmFuc2xhdGlvblRhYmxlIGZvciBsYW5nS2V5OiBcXCcnICsgbGFuZ0tleSArICdcXCcnKTtcbiAgICAgIH1cbiAgICAgICR1c2VzID0gbGFuZ0tleTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gJHVzZXM7XG4gIH07XG5cbiAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI3N0b3JhZ2VLZXlcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUZWxscyB0aGUgbW9kdWxlIHdoaWNoIGtleSBtdXN0IHJlcHJlc2VudCB0aGUgY2hvb3NlZCBsYW5ndWFnZSBieSBhIHVzZXIgaW4gdGhlIHN0b3JhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgQSBrZXkgZm9yIHRoZSBzdG9yYWdlLlxuICAgKi9cbiAgdmFyIHN0b3JhZ2VLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgaWYgKCRzdG9yYWdlUHJlZml4KSB7XG4gICAgICAgIHJldHVybiAkc3RvcmFnZVByZWZpeCArICRzdG9yYWdlS2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuICRzdG9yYWdlS2V5O1xuICAgIH1cbiAgICAkc3RvcmFnZUtleSA9IGtleTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLnN0b3JhZ2VLZXkgPSBzdG9yYWdlS2V5O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjdXNlVXJsTG9hZGVyXG4gICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGVsbHMgYW5ndWxhci10cmFuc2xhdGUgdG8gdXNlIGAkdHJhbnNsYXRlVXJsTG9hZGVyYCBleHRlbnNpb24gc2VydmljZSBhcyBsb2FkZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVXJsXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgdGhpcy51c2VVcmxMb2FkZXIgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlTG9hZGVyKCckdHJhbnNsYXRlVXJsTG9hZGVyJywgYW5ndWxhci5leHRlbmQoeyB1cmw6IHVybCB9LCBvcHRpb25zKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlciN1c2VTdGF0aWNGaWxlc0xvYWRlclxuICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRlbGxzIGFuZ3VsYXItdHJhbnNsYXRlIHRvIHVzZSBgJHRyYW5zbGF0ZVN0YXRpY0ZpbGVzTG9hZGVyYCBleHRlbnNpb24gc2VydmljZSBhcyBsb2FkZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgdGhpcy51c2VTdGF0aWNGaWxlc0xvYWRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlTG9hZGVyKCckdHJhbnNsYXRlU3RhdGljRmlsZXNMb2FkZXInLCBvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI3VzZUxvYWRlclxuICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRlbGxzIGFuZ3VsYXItdHJhbnNsYXRlIHRvIHVzZSBhbnkgb3RoZXIgc2VydmljZSBhcyBsb2FkZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2FkZXJGYWN0b3J5IEZhY3RvcnkgbmFtZSB0byB1c2VcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICB0aGlzLnVzZUxvYWRlciA9IGZ1bmN0aW9uIChsb2FkZXJGYWN0b3J5LCBvcHRpb25zKSB7XG4gICAgJGxvYWRlckZhY3RvcnkgPSBsb2FkZXJGYWN0b3J5O1xuICAgICRsb2FkZXJPcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI3VzZUxvY2FsU3RvcmFnZVxuICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRlbGxzIGFuZ3VsYXItdHJhbnNsYXRlIHRvIHVzZSBgJHRyYW5zbGF0ZUxvY2FsU3RvcmFnZWAgc2VydmljZSBhcyBzdG9yYWdlIGxheWVyLlxuICAgKlxuICAgKi9cbiAgdGhpcy51c2VMb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlU3RvcmFnZSgnJHRyYW5zbGF0ZUxvY2FsU3RvcmFnZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjdXNlQ29va2llU3RvcmFnZVxuICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRlbGxzIGFuZ3VsYXItdHJhbnNsYXRlIHRvIHVzZSBgJHRyYW5zbGF0ZUNvb2tpZVN0b3JhZ2VgIHNlcnZpY2UgYXMgc3RvcmFnZSBsYXllci5cbiAgICovXG4gIHRoaXMudXNlQ29va2llU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51c2VTdG9yYWdlKCckdHJhbnNsYXRlQ29va2llU3RvcmFnZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjdXNlU3RvcmFnZVxuICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRlbGxzIGFuZ3VsYXItdHJhbnNsYXRlIHRvIHVzZSBjdXN0b20gc2VydmljZSBhcyBzdG9yYWdlIGxheWVyLlxuICAgKi9cbiAgdGhpcy51c2VTdG9yYWdlID0gZnVuY3Rpb24gKHN0b3JhZ2VGYWN0b3J5KSB7XG4gICAgJHN0b3JhZ2VGYWN0b3J5ID0gc3RvcmFnZUZhY3Rvcnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlciNzdG9yYWdlUHJlZml4XG4gICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogU2V0cyBwcmVmaXggZm9yIHN0b3JhZ2Uga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFN0b3JhZ2Uga2V5IHByZWZpeFxuICAgKi9cbiAgdGhpcy5zdG9yYWdlUHJlZml4ID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlmICghcHJlZml4KSB7XG4gICAgICByZXR1cm4gcHJlZml4O1xuICAgIH1cbiAgICAkc3RvcmFnZVByZWZpeCA9IHByZWZpeDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI3VzZU1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJMb2dcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUZWxscyBhbmd1bGFyLXRyYW5zbGF0ZSB0byB1c2UgYnVpbHQtaW4gbG9nIGhhbmRsZXIgd2hlbiB0cnlpbmcgdG8gdHJhbnNsYXRlXG4gICAqIGEgdHJhbnNsYXRpb24gSWQgd2hpY2ggZG9lc24ndCBleGlzdC5cbiAgICpcbiAgICogVGhpcyBpcyBhY3R1YWxseSBhIHNob3J0Y3V0IG1ldGhvZCBmb3IgYHVzZU1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXIoKWAuXG4gICAqXG4gICAqL1xuICB0aGlzLnVzZU1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJMb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlTWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlcignJHRyYW5zbGF0ZU1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJMb2cnKTtcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI3VzZU1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBFeHBlY3RzIGEgZmFjdG9yeSBuYW1lIHdoaWNoIGxhdGVyIGdldHMgaW5zdGFudGlhdGVkIHdpdGggYCRpbmplY3RvcmAuXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIHRlbGwgYW5ndWxhci10cmFuc2xhdGUgdG8gdXNlIGEgY3VzdG9tXG4gICAqIG1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXIuIEp1c3QgYnVpbGQgYSBmYWN0b3J5IHdoaWNoIHJldHVybnMgYSBmdW5jdGlvblxuICAgKiBhbmQgZXhwZWN0cyBhIHRyYW5zbGF0aW9uIGlkIGFzIGFyZ3VtZW50LlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiA8cHJlPlxuICAgKiAgYXBwLmNvbmZpZyhmdW5jdGlvbiAoJHRyYW5zbGF0ZVByb3ZpZGVyKSB7XG4gICAqICAgICR0cmFuc2xhdGVQcm92aWRlci51c2VNaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyKCdjdXN0b21IYW5kbGVyJyk7XG4gICAqICB9KTtcbiAgICpcbiAgICogIGFwcC5mYWN0b3J5KCdjdXN0b21IYW5kbGVyJywgZnVuY3Rpb24gKGRlcDEsIGRlcDIpIHtcbiAgICogICAgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc2xhdGlvbklkKSB7XG4gICAqICAgICAgLy8gc29tZXRoaW5nIHdpdGggdHJhbnNsYXRpb25JZCBhbmQgZGVwMSBhbmQgZGVwMlxuICAgKiAgICB9O1xuICAgKiAgfSk7XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjdG9yeSBGYWN0b3J5IG5hbWVcbiAgICovXG4gIHRoaXMudXNlTWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlciA9IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgJG1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJGYWN0b3J5ID0gZmFjdG9yeTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI3VzZVBvc3RDb21waWxpbmdcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBJZiBwb3N0IGNvbXBpbGluZyBpcyBlbmFibGVkLCBhbGwgdHJhbnNsYXRlZCB2YWx1ZXMgd2lsbCBiZSBwcm9jZXNzZWRcbiAgICogYWdhaW4gd2l0aCBBbmd1bGFySlMnICRjb21waWxlLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiA8cHJlPlxuICAgKiAgYXBwLmNvbmZpZyhmdW5jdGlvbiAoJHRyYW5zbGF0ZVByb3ZpZGVyKSB7XG4gICAqICAgICR0cmFuc2xhdGVQcm92aWRlci51c2VQb3N0Q29tcGlsaW5nKHRydWUpO1xuICAgKiAgfSk7XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmFjdG9yeSBGYWN0b3J5IG5hbWVcbiAgICovXG4gIHRoaXMudXNlUG9zdENvbXBpbGluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICRwb3N0Q29tcGlsaW5nRW5hYmxlZCA9ICEoIXZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI2ZvcmNlQXN5bmNSZWxvYWRcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBJZiBmb3JjZSBhc3luYyByZWxvYWQgaXMgZW5hYmxlZCwgYXN5bmMgbG9hZGVyIHdpbGwgYWx3YXlzIGJlIGNhbGxlZFxuICAgKiBldmVuIGlmICR0cmFuc2xhdGlvblRhYmxlIGFscmVhZHkgY29udGFpbnMgdGhlIGxhbmd1YWdlIGtleSwgYWRkaW5nXG4gICAqIHBvc3NpYmxlIG5ldyBlbnRyaWVzIHRvIHRoZSAkdHJhbnNsYXRpb25UYWJsZS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogPHByZT5cbiAgICogIGFwcC5jb25maWcoZnVuY3Rpb24gKCR0cmFuc2xhdGVQcm92aWRlcikge1xuICAgKiAgICAkdHJhbnNsYXRlUHJvdmlkZXIuZm9yY2VBc3luY1JlbG9hZCh0cnVlKTtcbiAgICogIH0pO1xuICAgKiA8L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIHZhbGlkIHZhbHVlcyBhcmUgdHJ1ZSBvciBmYWxzZVxuICAgKi9cbiAgdGhpcy5mb3JjZUFzeW5jUmVsb2FkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgJGZvcmNlQXN5bmNSZWxvYWRFbmFibGVkID0gISghdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjdW5pZm9ybUxhbmd1YWdlVGFnXG4gICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGVsbHMgYW5ndWxhci10cmFuc2xhdGUgd2hpY2ggbGFuZ3VhZ2UgdGFnIHNob3VsZCBiZSB1c2VkIGFzIGEgcmVzdWx0IHdoZW4gZGV0ZXJtaW5pbmdcbiAgICogdGhlIGN1cnJlbnQgYnJvd3NlciBsYW5ndWFnZS5cbiAgICpcbiAgICogVGhpcyBzZXR0aW5nIG11c3QgYmUgc2V0IGJlZm9yZSBpbnZva2luZyB7QGxpbmsgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjbWV0aG9kc19kZXRlcm1pbmVQcmVmZXJyZWRMYW5ndWFnZSBkZXRlcm1pbmVQcmVmZXJyZWRMYW5ndWFnZSgpfS5cbiAgICpcbiAgICogPHByZT5cbiAgICogJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqICAgLnVuaWZvcm1MYW5ndWFnZVRhZygnYmNwNDcnKVxuICAgKiAgIC5kZXRlcm1pbmVQcmVmZXJyZWRMYW5ndWFnZSgpXG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBUaGUgcmVzb2x2ZXIgY3VycmVudGx5IHN1cHBvcnRzOlxuICAgKiAqIGRlZmF1bHRcbiAgICogICAgICh0cmFkaXRpb25hbGx5OiBoeXBoZW5zIHdpbGwgYmUgY29udmVydGVkIGludG8gdW5kZXJzY29yZXMsIGkuZS4gZW4tVVMgPT4gZW5fVVMpXG4gICAqICAgICBlbi1VUyA9PiBlbl9VU1xuICAgKiAgICAgZW5fVVMgPT4gZW5fVVNcbiAgICogICAgIGVuLXVzID0+IGVuX3VzXG4gICAqICogamF2YVxuICAgKiAgICAgbGlrZSBkZWZhdWx0LCBidXQgdGhlIHNlY29uZCBwYXJ0IHdpbGwgYmUgYWx3YXlzIGluIHVwcGVyY2FzZVxuICAgKiAgICAgZW4tVVMgPT4gZW5fVVNcbiAgICogICAgIGVuX1VTID0+IGVuX1VTXG4gICAqICAgICBlbi11cyA9PiBlbl9VU1xuICAgKiAqIEJDUCA0NyAoUkZDIDQ2NDYgJiA0NjQ3KVxuICAgKiAgICAgZW4tVVMgPT4gZW4tVVNcbiAgICogICAgIGVuX1VTID0+IGVuLVVTXG4gICAqICAgICBlbi11cyA9PiBlbi1VU1xuICAgKlxuICAgKiBTZWUgYWxzbzpcbiAgICogKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lFVEZfbGFuZ3VhZ2VfdGFnXG4gICAqICogaHR0cDovL3d3dy53My5vcmcvSW50ZXJuYXRpb25hbC9jb3JlL2xhbmd0YWdzL1xuICAgKiAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2JjcDQ3XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgKG9yIHN0YW5kYXJkKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zdGFuZGFyZCAtIHZhbGlkIHZhbHVlcyBhcmUgJ2RlZmF1bHQnLCAnYmNwNDcnLCAnamF2YSdcbiAgICovXG4gIHRoaXMudW5pZm9ybUxhbmd1YWdlVGFnID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc1N0cmluZyhvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgc3RhbmRhcmQ6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdW5pZm9ybUxhbmd1YWdlVGFnUmVzb2x2ZXIgPSBvcHRpb25zLnN0YW5kYXJkO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlciNkZXRlcm1pbmVQcmVmZXJyZWRMYW5ndWFnZVxuICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRlbGxzIGFuZ3VsYXItdHJhbnNsYXRlIHRvIHRyeSB0byBkZXRlcm1pbmUgb24gaXRzIG93biB3aGljaCBsYW5ndWFnZSBrZXlcbiAgICogdG8gc2V0IGFzIHByZWZlcnJlZCBsYW5ndWFnZS4gV2hlbiBgZm5gIGlzIGdpdmVuLCBhbmd1bGFyLXRyYW5zbGF0ZSB1c2VzIGl0XG4gICAqIHRvIGRldGVybWluZSBhIGxhbmd1YWdlIGtleSwgb3RoZXJ3aXNlIGl0IHVzZXMgdGhlIGJ1aWx0LWluIGBnZXRMb2NhbGUoKWBcbiAgICogbWV0aG9kLlxuICAgKlxuICAgKiBUaGUgYGdldExvY2FsZSgpYCByZXR1cm5zIGEgbGFuZ3VhZ2Uga2V5IGluIHRoZSBmb3JtYXQgYFtsYW5nXV9bY291bnRyeV1gIG9yXG4gICAqIGBbbGFuZ11gIGRlcGVuZGluZyBvbiB3aGF0IHRoZSBicm93c2VyIHByb3ZpZGVzLlxuICAgKlxuICAgKiBVc2UgdGhpcyBtZXRob2QgYXQgeW91ciBvd24gcmlzaywgc2luY2Ugbm90IGFsbCBicm93c2VycyByZXR1cm4gYSB2YWxpZFxuICAgKiBsb2NhbGUgKHNlZSB7QGxpbmsgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjbWV0aG9kc191bmlmb3JtTGFuZ3VhZ2VUYWcgdW5pZm9ybUxhbmd1YWdlVGFnKCl9KS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGZuIEZ1bmN0aW9uIHRvIGRldGVybWluZSBhIGJyb3dzZXIncyBsb2NhbGVcbiAgICovXG4gIHRoaXMuZGV0ZXJtaW5lUHJlZmVycmVkTGFuZ3VhZ2UgPSBmdW5jdGlvbiAoZm4pIHtcblxuICAgIHZhciBsb2NhbGUgPSAoZm4gJiYgYW5ndWxhci5pc0Z1bmN0aW9uKGZuKSkgPyBmbigpIDogZ2V0TG9jYWxlKCk7XG5cbiAgICBpZiAoISRhdmFpbGFibGVMYW5ndWFnZUtleXMubGVuZ3RoKSB7XG4gICAgICAkcHJlZmVycmVkTGFuZ3VhZ2UgPSBsb2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICRwcmVmZXJyZWRMYW5ndWFnZSA9IG5lZ290aWF0ZUxvY2FsZShsb2NhbGUpIHx8IGxvY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI3JlZ2lzdGVyQXZhaWxhYmxlTGFuZ3VhZ2VLZXlzXG4gICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmVnaXN0ZXJzIGEgc2V0IG9mIGxhbmd1YWdlIGtleXMgdGhlIGFwcCB3aWxsIHdvcmsgd2l0aC4gVXNlIHRoaXMgbWV0aG9kIGluXG4gICAqIGNvbWJpbmF0aW9uIHdpdGhcbiAgICoge0BsaW5rIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI2RldGVybWluZVByZWZlcnJlZExhbmd1YWdlIGRldGVybWluZVByZWZlcnJlZExhbmd1YWdlfS5cbiAgICogV2hlbiBhdmFpbGFibGUgbGFuZ3VhZ2VzIGtleXMgYXJlIHJlZ2lzdGVyZWQsIGFuZ3VsYXItdHJhbnNsYXRlXG4gICAqIHRyaWVzIHRvIGZpbmQgdGhlIGJlc3QgZml0dGluZyBsYW5ndWFnZSBrZXkgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VycyBsb2NhbGUsXG4gICAqIGNvbnNpZGVyaW5nIHlvdXIgbGFuZ3VhZ2Uga2V5IGNvbnZlbnRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYW5ndWFnZUtleXMgQXJyYXkgb2YgbGFuZ3VhZ2Uga2V5cyB0aGUgeW91ciBhcHAgd2lsbCB1c2VcbiAgICogQHBhcmFtIHtvYmplY3Q9fSBhbGlhc2VzIEFsaWFzIG1hcC5cbiAgICovXG4gIHRoaXMucmVnaXN0ZXJBdmFpbGFibGVMYW5ndWFnZUtleXMgPSBmdW5jdGlvbiAobGFuZ3VhZ2VLZXlzLCBhbGlhc2VzKSB7XG4gICAgaWYgKGxhbmd1YWdlS2V5cykge1xuICAgICAgJGF2YWlsYWJsZUxhbmd1YWdlS2V5cyA9IGxhbmd1YWdlS2V5cztcbiAgICAgIGlmIChhbGlhc2VzKSB7XG4gICAgICAgICRsYW5ndWFnZUtleUFsaWFzZXMgPSBhbGlhc2VzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiAkYXZhaWxhYmxlTGFuZ3VhZ2VLZXlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjdXNlTG9hZGVyQ2FjaGVcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZWdpc3RlcnMgYSBjYWNoZSBmb3IgaW50ZXJuYWwgJGh0dHAgYmFzZWQgbG9hZGVycy5cbiAgICoge0BsaW5rIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0aW9uQ2FjaGUgJHRyYW5zbGF0aW9uQ2FjaGV9LlxuICAgKiBXaGVuIGZhbHNlIHRoZSBjYWNoZSB3aWxsIGJlIGRpc2FibGVkIChkZWZhdWx0KS4gV2hlbiB0cnVlIG9yIHVuZGVmaW5lZFxuICAgKiB0aGUgY2FjaGUgd2lsbCBiZSBhIGRlZmF1bHQgKHNlZSAkY2FjaGVGYWN0b3J5KS4gV2hlbiBhbiBvYmplY3QgaXQgd2lsbFxuICAgKiBiZSB0cmVhdCBhcyBhIGNhY2hlIG9iamVjdCBpdHNlbGY6IHRoZSB1c2FnZSBpcyAkaHR0cCh7Y2FjaGU6IGNhY2hlfSlcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNhY2hlIGJvb2xlYW4sIHN0cmluZyBvciBjYWNoZS1vYmplY3RcbiAgICovXG4gIHRoaXMudXNlTG9hZGVyQ2FjaGUgPSBmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICBpZiAoY2FjaGUgPT09IGZhbHNlKSB7XG4gICAgICAvLyBkaXNhYmxlIGNhY2hlXG4gICAgICBsb2FkZXJDYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKGNhY2hlID09PSB0cnVlKSB7XG4gICAgICAvLyBlbmFibGUgY2FjaGUgdXNpbmcgQUpTIGRlZmF1bHRzXG4gICAgICBsb2FkZXJDYWNoZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YoY2FjaGUpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZW5hYmxlIGNhY2hlIHVzaW5nIGRlZmF1bHRcbiAgICAgIGxvYWRlckNhY2hlID0gJyR0cmFuc2xhdGlvbkNhY2hlJztcbiAgICB9IGVsc2UgaWYgKGNhY2hlKSB7XG4gICAgICAvLyBlbmFibGUgY2FjaGUgdXNpbmcgZ2l2ZW4gb25lIChzZWUgJGNhY2hlRmFjdG9yeSlcbiAgICAgIGxvYWRlckNhY2hlID0gY2FjaGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXIjZGlyZWN0aXZlUHJpb3JpdHlcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIHRoZSBkZWZhdWx0IHByaW9yaXR5IG9mIHRoZSB0cmFuc2xhdGUgZGlyZWN0aXZlLiBUaGUgc3RhbmRhcmQgdmFsdWUgaXMgYDBgLlxuICAgKiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2l0aG91dCBhbiBhcmd1bWVudCB3aWxsIHJldHVybiB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByaW9yaXR5IGZvciB0aGUgdHJhbnNsYXRlLWRpcmVjdGl2ZVxuICAgKi9cbiAgdGhpcy5kaXJlY3RpdmVQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xuICAgIGlmIChwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBnZXR0ZXJcbiAgICAgIHJldHVybiBkaXJlY3RpdmVQcmlvcml0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0dGVyIHdpdGggY2hhaW5pbmdcbiAgICAgIGRpcmVjdGl2ZVByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlciNzdGF0ZWZ1bEZpbHRlclxuICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNpbmNlIEFuZ3VsYXJKUyAxLjMsIGZpbHRlcnMgd2hpY2ggYXJlIG5vdCBzdGF0ZWxlc3MgKGRlcGVuZGluZyBhdCB0aGUgc2NvcGUpXG4gICAqIGhhdmUgdG8gZXhwbGljaXQgZGVmaW5lIHRoaXMgYmVoYXZpb3IuXG4gICAqIFNldHMgd2hldGhlciB0aGUgdHJhbnNsYXRlIGZpbHRlciBzaG91bGQgYmUgc3RhdGVmdWwgb3Igc3RhdGVsZXNzLiBUaGUgc3RhbmRhcmQgdmFsdWUgaXMgYHRydWVgXG4gICAqIG1lYW5pbmcgYmVpbmcgc3RhdGVmdWwuXG4gICAqIENhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aXRob3V0IGFuIGFyZ3VtZW50IHdpbGwgcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIC0gZGVmaW5lcyB0aGUgc3RhdGUgb2YgdGhlIGZpbHRlclxuICAgKi9cbiAgdGhpcy5zdGF0ZWZ1bEZpbHRlciA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBnZXR0ZXJcbiAgICAgIHJldHVybiBzdGF0ZWZ1bEZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0dGVyIHdpdGggY2hhaW5pbmdcbiAgICAgIHN0YXRlZnVsRmlsdGVyID0gc3RhdGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBvYmplY3RcbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlXG4gICAqIEByZXF1aXJlcyAkaW50ZXJwb2xhdGVcbiAgICogQHJlcXVpcmVzICRsb2dcbiAgICogQHJlcXVpcmVzICRyb290U2NvcGVcbiAgICogQHJlcXVpcmVzICRxXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgYCR0cmFuc2xhdGVgIHNlcnZpY2UgaXMgdGhlIGFjdHVhbCBjb3JlIG9mIGFuZ3VsYXItdHJhbnNsYXRlLiBJdCBleHBlY3RzIGEgdHJhbnNsYXRpb24gaWRcbiAgICogYW5kIG9wdGlvbmFsIGludGVycG9sYXRlIHBhcmFtZXRlcnMgdG8gdHJhbnNsYXRlIGNvbnRlbnRzLlxuICAgKlxuICAgKiA8cHJlPlxuICAgKiAgJHRyYW5zbGF0ZSgnSEVBRExJTkVfVEVYVCcpLnRoZW4oZnVuY3Rpb24gKHRyYW5zbGF0aW9uKSB7XG4gICAqICAgICRzY29wZS50cmFuc2xhdGVkVGV4dCA9IHRyYW5zbGF0aW9uO1xuICAgKiAgfSk7XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdHJhbnNsYXRpb25JZCBBIHRva2VuIHdoaWNoIHJlcHJlc2VudHMgYSB0cmFuc2xhdGlvbiBpZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGNhbiBiZSBvcHRpb25hbGx5IGFuIGFycmF5IG9mIHRyYW5zbGF0aW9uIGlkcyB3aGljaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzIHRoYXQgdGhlIGZ1bmN0aW9uIHJldHVybnMgYW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRoZSB0cmFuc2xhdGlvbiBpZCBhbmQgdGhlIHZhbHVlIHRoZSB0cmFuc2xhdGlvbi5cbiAgICogQHBhcmFtIHtvYmplY3Q9fSBpbnRlcnBvbGF0ZVBhcmFtcyBBbiBvYmplY3QgaGFzaCBmb3IgZHluYW1pYyB2YWx1ZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGludGVycG9sYXRpb25JZCBUaGUgaWQgb2YgdGhlIGludGVycG9sYXRpb24gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JjZUxhbmd1YWdlIEEgbGFuZ3VhZ2UgdG8gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IHByb21pc2VcbiAgICovXG4gIHRoaXMuJGdldCA9IFtcbiAgICAnJGxvZycsXG4gICAgJyRpbmplY3RvcicsXG4gICAgJyRyb290U2NvcGUnLFxuICAgICckcScsXG4gICAgZnVuY3Rpb24gKCRsb2csICRpbmplY3RvciwgJHJvb3RTY29wZSwgJHEpIHtcblxuICAgICAgdmFyIFN0b3JhZ2UsXG4gICAgICAgICAgZGVmYXVsdEludGVycG9sYXRvciA9ICRpbmplY3Rvci5nZXQoJGludGVycG9sYXRpb25GYWN0b3J5IHx8ICckdHJhbnNsYXRlRGVmYXVsdEludGVycG9sYXRpb24nKSxcbiAgICAgICAgICBwZW5kaW5nTG9hZGVyID0gZmFsc2UsXG4gICAgICAgICAgaW50ZXJwb2xhdG9ySGFzaE1hcCA9IHt9LFxuICAgICAgICAgIGxhbmdQcm9taXNlcyA9IHt9LFxuICAgICAgICAgIGZhbGxiYWNrSW5kZXgsXG4gICAgICAgICAgc3RhcnRGYWxsYmFja0l0ZXJhdGlvbjtcblxuICAgICAgdmFyICR0cmFuc2xhdGUgPSBmdW5jdGlvbiAodHJhbnNsYXRpb25JZCwgaW50ZXJwb2xhdGVQYXJhbXMsIGludGVycG9sYXRpb25JZCwgZGVmYXVsdFRyYW5zbGF0aW9uVGV4dCwgZm9yY2VMYW5ndWFnZSkge1xuXG4gICAgICAgIHZhciB1c2VzID0gKGZvcmNlTGFuZ3VhZ2UgJiYgZm9yY2VMYW5ndWFnZSAhPT0gJHVzZXMpID8gLy8gd2UgZG9uJ3Qgd2FudCB0byByZS1uZWdvdGlhdGUgJHVzZXNcbiAgICAgICAgICAgICAgKG5lZ290aWF0ZUxvY2FsZShmb3JjZUxhbmd1YWdlKSB8fCBmb3JjZUxhbmd1YWdlKSA6ICR1c2VzO1xuXG4gICAgICAgIC8vIER1Y2sgZGV0ZWN0aW9uOiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gYXJyYXksIGEgYnVuY2ggb2YgdHJhbnNsYXRpb25zIHdhcyByZXF1ZXN0ZWQuXG4gICAgICAgIC8vIFRoZSByZXN1bHQgaXMgYW4gb2JqZWN0LlxuICAgICAgICBpZiAoYW5ndWxhci5pc0FycmF5KHRyYW5zbGF0aW9uSWQpKSB7XG4gICAgICAgICAgLy8gSW5zcGlyZWQgYnkgUS5hbGxTZXR0bGVkIGJ5IEtyaXMgS293YWxcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EvYmxvYi9iMGZhNzI5ODA3MTdkYzIwMmZmYzNjYmYwM2I5MzZlMTBlYmJiOWQ3L3EuanMjTDE1NTMtMTU2M1xuICAgICAgICAgIC8vIFRoaXMgdHJhbnNmb3JtcyBhbGwgcHJvbWlzZXMgcmVnYXJkbGVzcyByZXNvbHZlZCBvciByZWplY3RlZFxuICAgICAgICAgIHZhciB0cmFuc2xhdGVBbGwgPSBmdW5jdGlvbiAodHJhbnNsYXRpb25JZHMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307IC8vIHN0b3JpbmcgdGhlIGFjdHVhbCByZXN1bHRzXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTsgLy8gcHJvbWlzZXMgdG8gd2FpdCBmb3JcbiAgICAgICAgICAgIC8vIFdyYXBzIHRoZSBwcm9taXNlIGEpIGJlaW5nIGFsd2F5cyByZXNvbHZlZCBhbmQgYikgc3RvcmluZyB0aGUgbGluayBpZC0+dmFsdWVcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGUgPSBmdW5jdGlvbiAodHJhbnNsYXRpb25JZCkge1xuICAgICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgICB2YXIgcmVnYXJkbGVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbdHJhbnNsYXRpb25JZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKFt0cmFuc2xhdGlvbklkLCB2YWx1ZV0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBjYXJlIHdoZXRoZXIgdGhlIHByb21pc2Ugd2FzIHJlc29sdmVkIG9yIHJlamVjdGVkOyBqdXN0IHN0b3JlIHRoZSB2YWx1ZXNcbiAgICAgICAgICAgICAgJHRyYW5zbGF0ZSh0cmFuc2xhdGlvbklkLCBpbnRlcnBvbGF0ZVBhcmFtcywgaW50ZXJwb2xhdGlvbklkLCBkZWZhdWx0VHJhbnNsYXRpb25UZXh0LCBmb3JjZUxhbmd1YWdlKS50aGVuKHJlZ2FyZGxlc3MsIHJlZ2FyZGxlc3MpO1xuICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYyA9IHRyYW5zbGF0aW9uSWRzLmxlbmd0aDsgaSA8IGM7IGkrKykge1xuICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRyYW5zbGF0ZSh0cmFuc2xhdGlvbklkc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2FpdCBmb3IgYWxsIChpbmNsdWRpbmcgc3RvcmluZyB0byByZXN1bHRzKVxuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcmVzdWx0c1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZUFsbCh0cmFuc2xhdGlvbklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgLy8gdHJpbSBvZmYgYW55IHdoaXRlc3BhY2VcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9uSWQpIHtcbiAgICAgICAgICB0cmFuc2xhdGlvbklkID0gdHJpbS5hcHBseSh0cmFuc2xhdGlvbklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9taXNlVG9XYWl0Rm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9ICRwcmVmZXJyZWRMYW5ndWFnZSA/XG4gICAgICAgICAgICBsYW5nUHJvbWlzZXNbJHByZWZlcnJlZExhbmd1YWdlXSA6XG4gICAgICAgICAgICBsYW5nUHJvbWlzZXNbdXNlc107XG5cbiAgICAgICAgICBmYWxsYmFja0luZGV4ID0gMDtcblxuICAgICAgICAgIGlmICgkc3RvcmFnZUZhY3RvcnkgJiYgIXByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIGxvb2tzIGxpa2UgdGhlcmUncyBubyBwZW5kaW5nIHByb21pc2UgZm9yICRwcmVmZXJyZWRMYW5ndWFnZSBvclxuICAgICAgICAgICAgLy8gJHVzZXMuIE1heWJlIHRoZXJlJ3Mgb25lIHBlbmRpbmcgZm9yIGEgbGFuZ3VhZ2UgdGhhdCBjb21lcyBmcm9tXG4gICAgICAgICAgICAvLyBzdG9yYWdlLlxuICAgICAgICAgICAgdmFyIGxhbmdLZXkgPSBTdG9yYWdlLmdldCgkc3RvcmFnZUtleSk7XG4gICAgICAgICAgICBwcm9taXNlID0gbGFuZ1Byb21pc2VzW2xhbmdLZXldO1xuXG4gICAgICAgICAgICBpZiAoJGZhbGxiYWNrTGFuZ3VhZ2UgJiYgJGZhbGxiYWNrTGFuZ3VhZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhPZigkZmFsbGJhY2tMYW5ndWFnZSwgbGFuZ0tleSk7XG4gICAgICAgICAgICAgICAgLy8gbWF5YmUgdGhlIGxhbmd1YWdlIGZyb20gc3RvcmFnZSBpcyBhbHNvIGRlZmluZWQgYXMgZmFsbGJhY2sgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAvLyB3ZSBpbmNyZWFzZSB0aGUgZmFsbGJhY2sgbGFuZ3VhZ2UgaW5kZXggdG8gbm90IHNlYXJjaCBpbiB0aGF0IGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgLy8gYXMgZmFsbGJhY2ssIHNpbmNlIGl0J3MgcHJvYmFibHkgdGhlIGZpcnN0IHVzZWQgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgdGhlIGluZGV4IHN0YXJ0cyBhZnRlciB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrSW5kZXggPSAoaW5kZXggPT09IDApID8gMSA6IDA7XG5cbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgY2FuIG1ha2Ugc3VyZSB0byBBTFdBWVMgZmFsbGJhY2sgdG8gcHJlZmVycmVkIGxhbmd1YWdlIGF0IGxlYXN0XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4T2YoJGZhbGxiYWNrTGFuZ3VhZ2UsICRwcmVmZXJyZWRMYW5ndWFnZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAkZmFsbGJhY2tMYW5ndWFnZS5wdXNoKCRwcmVmZXJyZWRMYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfSgpKTtcblxuICAgICAgICBpZiAoIXByb21pc2VUb1dhaXRGb3IpIHtcbiAgICAgICAgICAvLyBubyBwcm9taXNlIHRvIHdhaXQgZm9yPyBva2F5LiBUaGVuIHRoZXJlJ3Mgbm8gbG9hZGVyIHJlZ2lzdGVyZWRcbiAgICAgICAgICAvLyBub3IgaXMgYSBvbmUgcGVuZGluZyBmb3IgbGFuZ3VhZ2UgdGhhdCBjb21lcyBmcm9tIHN0b3JhZ2UuXG4gICAgICAgICAgLy8gV2UgY2FuIGp1c3QgdHJhbnNsYXRlLlxuICAgICAgICAgIGRldGVybWluZVRyYW5zbGF0aW9uKHRyYW5zbGF0aW9uSWQsIGludGVycG9sYXRlUGFyYW1zLCBpbnRlcnBvbGF0aW9uSWQsIGRlZmF1bHRUcmFuc2xhdGlvblRleHQsIHVzZXMpLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJvbWlzZVJlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gJHVzZXMgbWF5IGhhdmUgY2hhbmdlZCB3aGlsZSB3YWl0aW5nXG4gICAgICAgICAgICBpZiAoIWZvcmNlTGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgdXNlcyA9ICR1c2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0ZXJtaW5lVHJhbnNsYXRpb24odHJhbnNsYXRpb25JZCwgaW50ZXJwb2xhdGVQYXJhbXMsIGludGVycG9sYXRpb25JZCwgZGVmYXVsdFRyYW5zbGF0aW9uVGV4dCwgdXNlcykudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcHJvbWlzZVJlc29sdmVkLmRpc3BsYXlOYW1lID0gJ3Byb21pc2VSZXNvbHZlZCc7XG5cbiAgICAgICAgICBwcm9taXNlVG9XYWl0Rm9yWydmaW5hbGx5J10ocHJvbWlzZVJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5hbWUgYXBwbHlOb3RGb3VuZEluZGljYXRvcnNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBBcHBsaWVzIG5vdCBmb3VudCBpbmRpY2F0b3JzIHRvIGdpdmVuIHRyYW5zbGF0aW9uIGlkLCBpZiBuZWVkZWQuXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIGdldHMgb25seSBleGVjdXRlZCwgaWYgYSB0cmFuc2xhdGlvbiBpZCBkb2Vzbid0IGV4aXN0LFxuICAgICAgICogd2hpY2ggaXMgd2h5IGEgdHJhbnNsYXRpb24gaWQgaXMgZXhwZWN0ZWQgYXMgYXJndW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zbGF0aW9uSWQgVHJhbnNsYXRpb24gaWQuXG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTYW1lIGFzIGdpdmVuIHRyYW5zbGF0aW9uIGlkIGJ1dCBhcHBsaWVkIHdpdGggbm90IGZvdW5kXG4gICAgICAgKiBpbmRpY2F0b3JzLlxuICAgICAgICovXG4gICAgICB2YXIgYXBwbHlOb3RGb3VuZEluZGljYXRvcnMgPSBmdW5jdGlvbiAodHJhbnNsYXRpb25JZCkge1xuICAgICAgICAvLyBhcHBseWluZyBub3RGb3VuZEluZGljYXRvcnNcbiAgICAgICAgaWYgKCRub3RGb3VuZEluZGljYXRvckxlZnQpIHtcbiAgICAgICAgICB0cmFuc2xhdGlvbklkID0gWyRub3RGb3VuZEluZGljYXRvckxlZnQsIHRyYW5zbGF0aW9uSWRdLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJG5vdEZvdW5kSW5kaWNhdG9yUmlnaHQpIHtcbiAgICAgICAgICB0cmFuc2xhdGlvbklkID0gW3RyYW5zbGF0aW9uSWQsICRub3RGb3VuZEluZGljYXRvclJpZ2h0XS5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uSWQ7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lIHVzZUxhbmd1YWdlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogTWFrZXMgYWN0dWFsIHVzZSBvZiBhIGxhbmd1YWdlIGJ5IHNldHRpbmcgYSBnaXZlbiBsYW5ndWFnZSBrZXkgYXMgdXNlZFxuICAgICAgICogbGFuZ3VhZ2UgYW5kIGluZm9ybXMgcmVnaXN0ZXJlZCBpbnRlcnBvbGF0b3JzIHRvIGFsc28gdXNlIHRoZSBnaXZlblxuICAgICAgICoga2V5IGFzIGxvY2FsZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2tleX0gTG9jYWxlIGtleS5cbiAgICAgICAqL1xuICAgICAgdmFyIHVzZUxhbmd1YWdlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAkdXNlcyA9IGtleTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gc3RvcmUgbmV3IGxhbmd1YWdlIGtleSBiZWZvcmUgdHJpZ2dlcmluZyBzdWNjZXNzIGV2ZW50XG4gICAgICAgIGlmICgkc3RvcmFnZUZhY3RvcnkpIHtcbiAgICAgICAgICBTdG9yYWdlLnB1dCgkdHJhbnNsYXRlLnN0b3JhZ2VLZXkoKSwgJHVzZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgJHJvb3RTY29wZS4kZW1pdCgnJHRyYW5zbGF0ZUNoYW5nZVN1Y2Nlc3MnLCB7bGFuZ3VhZ2U6IGtleX0pO1xuXG4gICAgICAgIC8vIGluZm9ybSBkZWZhdWx0IGludGVycG9sYXRvclxuICAgICAgICBkZWZhdWx0SW50ZXJwb2xhdG9yLnNldExvY2FsZSgkdXNlcyk7XG5cbiAgICAgICAgdmFyIGVhY2hJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiAoaW50ZXJwb2xhdG9yLCBpZCkge1xuICAgICAgICAgIGludGVycG9sYXRvckhhc2hNYXBbaWRdLnNldExvY2FsZSgkdXNlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGVhY2hJbnRlcnBvbGF0b3IuZGlzcGxheU5hbWUgPSAnZWFjaEludGVycG9sYXRvckxvY2FsZVNldHRlcic7XG5cbiAgICAgICAgLy8gaW5mb3JtIGFsbCBvdGhlcnMgdG9vIVxuICAgICAgICBhbmd1bGFyLmZvckVhY2goaW50ZXJwb2xhdG9ySGFzaE1hcCwgZWFjaEludGVycG9sYXRvcik7XG4gICAgICAgICRyb290U2NvcGUuJGVtaXQoJyR0cmFuc2xhdGVDaGFuZ2VFbmQnLCB7bGFuZ3VhZ2U6IGtleX0pO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBsb2FkQXN5bmNcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBLaWNrcyBvZiByZWdpc3RlcmVkIGFzeW5jIGxvYWRlciB1c2luZyBgJGluamVjdG9yYCBhbmQgYXBwbGllcyBleGlzdGluZ1xuICAgICAgICogbG9hZGVyIG9wdGlvbnMuIFdoZW4gcmVzb2x2ZWQsIGl0IHVwZGF0ZXMgdHJhbnNsYXRpb24gdGFibGVzIGFjY29yZGluZ2x5XG4gICAgICAgKiBvciByZWplY3RzIHdpdGggZ2l2ZW4gbGFuZ3VhZ2Uga2V5LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgTGFuZ3VhZ2Uga2V5LlxuICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlLlxuICAgICAgICovXG4gICAgICB2YXIgbG9hZEFzeW5jID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgIHRocm93ICdObyBsYW5ndWFnZSBrZXkgc3BlY2lmaWVkIGZvciBsb2FkaW5nLic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgICRyb290U2NvcGUuJGVtaXQoJyR0cmFuc2xhdGVMb2FkaW5nU3RhcnQnLCB7bGFuZ3VhZ2U6IGtleX0pO1xuICAgICAgICBwZW5kaW5nTG9hZGVyID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY2FjaGUgPSBsb2FkZXJDYWNoZTtcbiAgICAgICAgaWYgKHR5cGVvZihjYWNoZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gZ2V0dGluZyBvbi1kZW1hbmQgaW5zdGFuY2Ugb2YgbG9hZGVyXG4gICAgICAgICAgY2FjaGUgPSAkaW5qZWN0b3IuZ2V0KGNhY2hlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2FkZXJPcHRpb25zID0gYW5ndWxhci5leHRlbmQoe30sICRsb2FkZXJPcHRpb25zLCB7XG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgJGh0dHA6IGFuZ3VsYXIuZXh0ZW5kKHt9LCB7XG4gICAgICAgICAgICBjYWNoZTogY2FjaGVcbiAgICAgICAgICB9LCAkbG9hZGVyT3B0aW9ucy4kaHR0cClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG9uTG9hZGVyU3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgdmFyIHRyYW5zbGF0aW9uVGFibGUgPSB7fTtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRlbWl0KCckdHJhbnNsYXRlTG9hZGluZ1N1Y2Nlc3MnLCB7bGFuZ3VhZ2U6IGtleX0pO1xuXG4gICAgICAgICAgaWYgKGFuZ3VsYXIuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRhdGEsIGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICAgICAgICBhbmd1bGFyLmV4dGVuZCh0cmFuc2xhdGlvblRhYmxlLCBmbGF0T2JqZWN0KHRhYmxlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5ndWxhci5leHRlbmQodHJhbnNsYXRpb25UYWJsZSwgZmxhdE9iamVjdChkYXRhKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBlbmRpbmdMb2FkZXIgPSBmYWxzZTtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdGFibGU6IHRyYW5zbGF0aW9uVGFibGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRlbWl0KCckdHJhbnNsYXRlTG9hZGluZ0VuZCcsIHtsYW5ndWFnZToga2V5fSk7XG4gICAgICAgIH07XG4gICAgICAgIG9uTG9hZGVyU3VjY2Vzcy5kaXNwbGF5TmFtZSA9ICdvbkxvYWRlclN1Y2Nlc3MnO1xuXG4gICAgICAgIHZhciBvbkxvYWRlckVycm9yID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICRyb290U2NvcGUuJGVtaXQoJyR0cmFuc2xhdGVMb2FkaW5nRXJyb3InLCB7bGFuZ3VhZ2U6IGtleX0pO1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdChrZXkpO1xuICAgICAgICAgICRyb290U2NvcGUuJGVtaXQoJyR0cmFuc2xhdGVMb2FkaW5nRW5kJywge2xhbmd1YWdlOiBrZXl9KTtcbiAgICAgICAgfTtcbiAgICAgICAgb25Mb2FkZXJFcnJvci5kaXNwbGF5TmFtZSA9ICdvbkxvYWRlckVycm9yJztcblxuICAgICAgICAkaW5qZWN0b3IuZ2V0KCRsb2FkZXJGYWN0b3J5KShsb2FkZXJPcHRpb25zKVxuICAgICAgICAgIC50aGVuKG9uTG9hZGVyU3VjY2Vzcywgb25Mb2FkZXJFcnJvcik7XG5cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9O1xuXG4gICAgICBpZiAoJHN0b3JhZ2VGYWN0b3J5KSB7XG4gICAgICAgIFN0b3JhZ2UgPSAkaW5qZWN0b3IuZ2V0KCRzdG9yYWdlRmFjdG9yeSk7XG5cbiAgICAgICAgaWYgKCFTdG9yYWdlLmdldCB8fCAhU3RvcmFnZS5wdXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkblxcJ3QgdXNlIHN0b3JhZ2UgXFwnJyArICRzdG9yYWdlRmFjdG9yeSArICdcXCcsIG1pc3NpbmcgZ2V0KCkgb3IgcHV0KCkgbWV0aG9kIScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgYWRkaXRpb25hbCBpbnRlcnBvbGF0aW9ucyB0aGF0IHdlcmUgYWRkZWQgdmlhXG4gICAgICAvLyAkdHJhbnNsYXRlUHJvdmlkZXIuYWRkSW50ZXJwb2xhdGlvbigpLCB3ZSBoYXZlIHRvIG1hcCdlbVxuICAgICAgaWYgKCRpbnRlcnBvbGF0b3JGYWN0b3JpZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlYWNoSW50ZXJwb2xhdGlvbkZhY3RvcnkgPSBmdW5jdGlvbiAoaW50ZXJwb2xhdG9yRmFjdG9yeSkge1xuICAgICAgICAgIHZhciBpbnRlcnBvbGF0b3IgPSAkaW5qZWN0b3IuZ2V0KGludGVycG9sYXRvckZhY3RvcnkpO1xuICAgICAgICAgIC8vIHNldHRpbmcgaW5pdGlhbCBsb2NhbGUgZm9yIGVhY2ggaW50ZXJwb2xhdGlvbiBzZXJ2aWNlXG4gICAgICAgICAgaW50ZXJwb2xhdG9yLnNldExvY2FsZSgkcHJlZmVycmVkTGFuZ3VhZ2UgfHwgJHVzZXMpO1xuICAgICAgICAgIC8vIG1ha2UnZW0gcmVjb2duaXphYmxlIHRocm91Z2ggaWRcbiAgICAgICAgICBpbnRlcnBvbGF0b3JIYXNoTWFwW2ludGVycG9sYXRvci5nZXRJbnRlcnBvbGF0aW9uSWRlbnRpZmllcigpXSA9IGludGVycG9sYXRvcjtcbiAgICAgICAgfTtcbiAgICAgICAgZWFjaEludGVycG9sYXRpb25GYWN0b3J5LmRpc3BsYXlOYW1lID0gJ2ludGVycG9sYXRpb25GYWN0b3J5QWRkZXInO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkaW50ZXJwb2xhdG9yRmFjdG9yaWVzLCBlYWNoSW50ZXJwb2xhdGlvbkZhY3RvcnkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lIGdldFRyYW5zbGF0aW9uVGFibGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmFuc2xhdGlvbiB0YWJsZVxuICAgICAgICogb3IgaXMgcmVqZWN0ZWQgaWYgYW4gZXJyb3Igb2NjdXJyZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGxhbmdLZXlcbiAgICAgICAqIEByZXR1cm5zIHtRLnByb21pc2V9XG4gICAgICAgKi9cbiAgICAgIHZhciBnZXRUcmFuc2xhdGlvblRhYmxlID0gZnVuY3Rpb24gKGxhbmdLZXkpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgkdHJhbnNsYXRpb25UYWJsZSwgbGFuZ0tleSkpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCR0cmFuc2xhdGlvblRhYmxlW2xhbmdLZXldKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYW5nUHJvbWlzZXNbbGFuZ0tleV0pIHtcbiAgICAgICAgICB2YXIgb25SZXNvbHZlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRyYW5zbGF0aW9ucyhkYXRhLmtleSwgZGF0YS50YWJsZSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGRhdGEudGFibGUpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgb25SZXNvbHZlLmRpc3BsYXlOYW1lID0gJ3RyYW5zbGF0aW9uVGFibGVSZXNvbHZlcic7XG4gICAgICAgICAgbGFuZ1Byb21pc2VzW2xhbmdLZXldLnRoZW4ob25SZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBnZXRGYWxsYmFja1RyYW5zbGF0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgdG8gdGhlIHRyYW5zbGF0aW9uXG4gICAgICAgKiBvciBiZSByZWplY3RlZCBpZiBubyB0cmFuc2xhdGlvbiB3YXMgZm91bmQgZm9yIHRoZSBsYW5ndWFnZS5cbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY3VycmVudGx5IG9ubHkgdXNlZCBmb3IgZmFsbGJhY2sgbGFuZ3VhZ2UgdHJhbnNsYXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGxhbmdLZXkgVGhlIGxhbmd1YWdlIHRvIHRyYW5zbGF0ZSB0by5cbiAgICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbklkXG4gICAgICAgKiBAcGFyYW0gaW50ZXJwb2xhdGVQYXJhbXNcbiAgICAgICAqIEBwYXJhbSBJbnRlcnBvbGF0b3JcbiAgICAgICAqIEByZXR1cm5zIHtRLnByb21pc2V9XG4gICAgICAgKi9cbiAgICAgIHZhciBnZXRGYWxsYmFja1RyYW5zbGF0aW9uID0gZnVuY3Rpb24gKGxhbmdLZXksIHRyYW5zbGF0aW9uSWQsIGludGVycG9sYXRlUGFyYW1zLCBJbnRlcnBvbGF0b3IpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICB2YXIgb25SZXNvbHZlID0gZnVuY3Rpb24gKHRyYW5zbGF0aW9uVGFibGUpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRyYW5zbGF0aW9uVGFibGUsIHRyYW5zbGF0aW9uSWQpKSB7XG4gICAgICAgICAgICBJbnRlcnBvbGF0b3Iuc2V0TG9jYWxlKGxhbmdLZXkpO1xuICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb25UYWJsZVt0cmFuc2xhdGlvbklkXTtcbiAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbi5zdWJzdHIoMCwgMikgPT09ICdAOicpIHtcbiAgICAgICAgICAgICAgZ2V0RmFsbGJhY2tUcmFuc2xhdGlvbihsYW5nS2V5LCB0cmFuc2xhdGlvbi5zdWJzdHIoMiksIGludGVycG9sYXRlUGFyYW1zLCBJbnRlcnBvbGF0b3IpXG4gICAgICAgICAgICAgICAgLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoSW50ZXJwb2xhdG9yLmludGVycG9sYXRlKHRyYW5zbGF0aW9uVGFibGVbdHJhbnNsYXRpb25JZF0sIGludGVycG9sYXRlUGFyYW1zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBJbnRlcnBvbGF0b3Iuc2V0TG9jYWxlKCR1c2VzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBvblJlc29sdmUuZGlzcGxheU5hbWUgPSAnZmFsbGJhY2tUcmFuc2xhdGlvblJlc29sdmVyJztcblxuICAgICAgICBnZXRUcmFuc2xhdGlvblRhYmxlKGxhbmdLZXkpLnRoZW4ob25SZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpO1xuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBnZXRGYWxsYmFja1RyYW5zbGF0aW9uSW5zdGFudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFJldHVybnMgYSB0cmFuc2xhdGlvblxuICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBjdXJyZW50bHkgb25seSB1c2VkIGZvciBmYWxsYmFjayBsYW5ndWFnZSB0cmFuc2xhdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gbGFuZ0tleSBUaGUgbGFuZ3VhZ2UgdG8gdHJhbnNsYXRlIHRvLlxuICAgICAgICogQHBhcmFtIHRyYW5zbGF0aW9uSWRcbiAgICAgICAqIEBwYXJhbSBpbnRlcnBvbGF0ZVBhcmFtc1xuICAgICAgICogQHBhcmFtIEludGVycG9sYXRvclxuICAgICAgICogQHJldHVybnMge3N0cmluZ30gdHJhbnNsYXRpb25cbiAgICAgICAqL1xuICAgICAgdmFyIGdldEZhbGxiYWNrVHJhbnNsYXRpb25JbnN0YW50ID0gZnVuY3Rpb24gKGxhbmdLZXksIHRyYW5zbGF0aW9uSWQsIGludGVycG9sYXRlUGFyYW1zLCBJbnRlcnBvbGF0b3IpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgdHJhbnNsYXRpb25UYWJsZSA9ICR0cmFuc2xhdGlvblRhYmxlW2xhbmdLZXldO1xuXG4gICAgICAgIGlmICh0cmFuc2xhdGlvblRhYmxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0cmFuc2xhdGlvblRhYmxlLCB0cmFuc2xhdGlvbklkKSkge1xuICAgICAgICAgIEludGVycG9sYXRvci5zZXRMb2NhbGUobGFuZ0tleSk7XG4gICAgICAgICAgcmVzdWx0ID0gSW50ZXJwb2xhdG9yLmludGVycG9sYXRlKHRyYW5zbGF0aW9uVGFibGVbdHJhbnNsYXRpb25JZF0sIGludGVycG9sYXRlUGFyYW1zKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnN1YnN0cigwLCAyKSA9PT0gJ0A6Jykge1xuICAgICAgICAgICAgcmV0dXJuIGdldEZhbGxiYWNrVHJhbnNsYXRpb25JbnN0YW50KGxhbmdLZXksIHJlc3VsdC5zdWJzdHIoMiksIGludGVycG9sYXRlUGFyYW1zLCBJbnRlcnBvbGF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBJbnRlcnBvbGF0b3Iuc2V0TG9jYWxlKCR1c2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG5cbiAgICAgIC8qKlxuICAgICAgICogQG5hbWUgdHJhbnNsYXRlQnlIYW5kbGVyXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICpcbiAgICAgICAqIFRyYW5zbGF0ZSBieSBtaXNzaW5nIHRyYW5zbGF0aW9uIGhhbmRsZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHRyYW5zbGF0aW9uSWRcbiAgICAgICAqIEByZXR1cm5zIHRyYW5zbGF0aW9uIGNyZWF0ZWQgYnkgJG1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXIgb3IgdHJhbnNsYXRpb25JZCBpcyAkbWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlciBpc1xuICAgICAgICogYWJzZW50XG4gICAgICAgKi9cbiAgICAgIHZhciB0cmFuc2xhdGVCeUhhbmRsZXIgPSBmdW5jdGlvbiAodHJhbnNsYXRpb25JZCwgaW50ZXJwb2xhdGVQYXJhbXMpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGhhbmRsZXIgZmFjdG9yeSAtIHdlIG1pZ2h0IGFsc28gY2FsbCBpdCBoZXJlIHRvIGRldGVybWluZSBpZiBpdCBwcm92aWRlc1xuICAgICAgICAvLyBhIGRlZmF1bHQgdGV4dCBmb3IgYSB0cmFuc2xhdGlvbmlkIHRoYXQgY2FuJ3QgYmUgZm91bmQgYW55d2hlcmUgaW4gb3VyIHRhYmxlc1xuICAgICAgICBpZiAoJG1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdFN0cmluZyA9ICRpbmplY3Rvci5nZXQoJG1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJGYWN0b3J5KSh0cmFuc2xhdGlvbklkLCAkdXNlcywgaW50ZXJwb2xhdGVQYXJhbXMpO1xuICAgICAgICAgIGlmIChyZXN1bHRTdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFN0cmluZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uSWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGlvbklkO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lIHJlc29sdmVGb3JGYWxsYmFja0xhbmd1YWdlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICpcbiAgICAgICAqIFJlY3Vyc2l2ZSBoZWxwZXIgZnVuY3Rpb24gZm9yIGZhbGxiYWNrVHJhbnNsYXRpb24gdGhhdCB3aWxsIHNlcXVlbnRpYWxseSBsb29rXG4gICAgICAgKiBmb3IgYSB0cmFuc2xhdGlvbiBpbiB0aGUgZmFsbGJhY2tMYW5ndWFnZXMgc3RhcnRpbmcgd2l0aCBmYWxsYmFja0xhbmd1YWdlSW5kZXguXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIGZhbGxiYWNrTGFuZ3VhZ2VJbmRleFxuICAgICAgICogQHBhcmFtIHRyYW5zbGF0aW9uSWRcbiAgICAgICAqIEBwYXJhbSBpbnRlcnBvbGF0ZVBhcmFtc1xuICAgICAgICogQHBhcmFtIEludGVycG9sYXRvclxuICAgICAgICogQHJldHVybnMge1EucHJvbWlzZX0gUHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB0byB0aGUgdHJhbnNsYXRpb24uXG4gICAgICAgKi9cbiAgICAgIHZhciByZXNvbHZlRm9yRmFsbGJhY2tMYW5ndWFnZSA9IGZ1bmN0aW9uIChmYWxsYmFja0xhbmd1YWdlSW5kZXgsIHRyYW5zbGF0aW9uSWQsIGludGVycG9sYXRlUGFyYW1zLCBJbnRlcnBvbGF0b3IsIGRlZmF1bHRUcmFuc2xhdGlvblRleHQpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICBpZiAoZmFsbGJhY2tMYW5ndWFnZUluZGV4IDwgJGZhbGxiYWNrTGFuZ3VhZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGxhbmdLZXkgPSAkZmFsbGJhY2tMYW5ndWFnZVtmYWxsYmFja0xhbmd1YWdlSW5kZXhdO1xuICAgICAgICAgIGdldEZhbGxiYWNrVHJhbnNsYXRpb24obGFuZ0tleSwgdHJhbnNsYXRpb25JZCwgaW50ZXJwb2xhdGVQYXJhbXMsIEludGVycG9sYXRvcikudGhlbihcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIExvb2sgaW4gdGhlIG5leHQgZmFsbGJhY2sgbGFuZ3VhZ2UgZm9yIGEgdHJhbnNsYXRpb24uXG4gICAgICAgICAgICAgIC8vIEl0IGRlbGF5cyB0aGUgcmVzb2x2aW5nIGJ5IHBhc3NpbmcgYW5vdGhlciBwcm9taXNlIHRvIHJlc29sdmUuXG4gICAgICAgICAgICAgIHJlc29sdmVGb3JGYWxsYmFja0xhbmd1YWdlKGZhbGxiYWNrTGFuZ3VhZ2VJbmRleCArIDEsIHRyYW5zbGF0aW9uSWQsIGludGVycG9sYXRlUGFyYW1zLCBJbnRlcnBvbGF0b3IsIGRlZmF1bHRUcmFuc2xhdGlvblRleHQpLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyB0cmFuc2xhdGlvbiBmb3VuZCBpbiBhbnkgZmFsbGJhY2sgbGFuZ3VhZ2VcbiAgICAgICAgICAvLyBpZiBhIGRlZmF1bHQgdHJhbnNsYXRpb24gdGV4dCBpcyBzZXQgaW4gdGhlIGRpcmVjdGl2ZSwgdGhlbiByZXR1cm4gdGhpcyBhcyBhIHJlc3VsdFxuICAgICAgICAgIGlmIChkZWZhdWx0VHJhbnNsYXRpb25UZXh0KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGRlZmF1bHRUcmFuc2xhdGlvblRleHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBubyBkZWZhdWx0IHRyYW5zbGF0aW9uIGlzIHNldCBhbmQgYW4gZXJyb3IgaGFuZGxlciBpcyBkZWZpbmVkLCBzZW5kIGl0IHRvIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICAvLyBhbmQgdGhlbiByZXR1cm4gdGhlIHJlc3VsdFxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0cmFuc2xhdGVCeUhhbmRsZXIodHJhbnNsYXRpb25JZCwgaW50ZXJwb2xhdGVQYXJhbXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lIHJlc29sdmVGb3JGYWxsYmFja0xhbmd1YWdlSW5zdGFudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqXG4gICAgICAgKiBSZWN1cnNpdmUgaGVscGVyIGZ1bmN0aW9uIGZvciBmYWxsYmFja1RyYW5zbGF0aW9uIHRoYXQgd2lsbCBzZXF1ZW50aWFsbHkgbG9va1xuICAgICAgICogZm9yIGEgdHJhbnNsYXRpb24gaW4gdGhlIGZhbGxiYWNrTGFuZ3VhZ2VzIHN0YXJ0aW5nIHdpdGggZmFsbGJhY2tMYW5ndWFnZUluZGV4LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBmYWxsYmFja0xhbmd1YWdlSW5kZXhcbiAgICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbklkXG4gICAgICAgKiBAcGFyYW0gaW50ZXJwb2xhdGVQYXJhbXNcbiAgICAgICAqIEBwYXJhbSBJbnRlcnBvbGF0b3JcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRyYW5zbGF0aW9uXG4gICAgICAgKi9cbiAgICAgIHZhciByZXNvbHZlRm9yRmFsbGJhY2tMYW5ndWFnZUluc3RhbnQgPSBmdW5jdGlvbiAoZmFsbGJhY2tMYW5ndWFnZUluZGV4LCB0cmFuc2xhdGlvbklkLCBpbnRlcnBvbGF0ZVBhcmFtcywgSW50ZXJwb2xhdG9yKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGZhbGxiYWNrTGFuZ3VhZ2VJbmRleCA8ICRmYWxsYmFja0xhbmd1YWdlLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBsYW5nS2V5ID0gJGZhbGxiYWNrTGFuZ3VhZ2VbZmFsbGJhY2tMYW5ndWFnZUluZGV4XTtcbiAgICAgICAgICByZXN1bHQgPSBnZXRGYWxsYmFja1RyYW5zbGF0aW9uSW5zdGFudChsYW5nS2V5LCB0cmFuc2xhdGlvbklkLCBpbnRlcnBvbGF0ZVBhcmFtcywgSW50ZXJwb2xhdG9yKTtcbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzb2x2ZUZvckZhbGxiYWNrTGFuZ3VhZ2VJbnN0YW50KGZhbGxiYWNrTGFuZ3VhZ2VJbmRleCArIDEsIHRyYW5zbGF0aW9uSWQsIGludGVycG9sYXRlUGFyYW1zLCBJbnRlcnBvbGF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2xhdGVzIHdpdGggdGhlIHVzYWdlIG9mIHRoZSBmYWxsYmFjayBsYW5ndWFnZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHRyYW5zbGF0aW9uSWRcbiAgICAgICAqIEBwYXJhbSBpbnRlcnBvbGF0ZVBhcmFtc1xuICAgICAgICogQHBhcmFtIEludGVycG9sYXRvclxuICAgICAgICogQHJldHVybnMge1EucHJvbWlzZX0gUHJvbWlzZSwgdGhhdCByZXNvbHZlcyB0byB0aGUgdHJhbnNsYXRpb24uXG4gICAgICAgKi9cbiAgICAgIHZhciBmYWxsYmFja1RyYW5zbGF0aW9uID0gZnVuY3Rpb24gKHRyYW5zbGF0aW9uSWQsIGludGVycG9sYXRlUGFyYW1zLCBJbnRlcnBvbGF0b3IsIGRlZmF1bHRUcmFuc2xhdGlvblRleHQpIHtcbiAgICAgICAgLy8gU3RhcnQgd2l0aCB0aGUgZmFsbGJhY2tMYW5ndWFnZSB3aXRoIGluZGV4IDBcbiAgICAgICAgcmV0dXJuIHJlc29sdmVGb3JGYWxsYmFja0xhbmd1YWdlKChzdGFydEZhbGxiYWNrSXRlcmF0aW9uPjAgPyBzdGFydEZhbGxiYWNrSXRlcmF0aW9uIDogZmFsbGJhY2tJbmRleCksIHRyYW5zbGF0aW9uSWQsIGludGVycG9sYXRlUGFyYW1zLCBJbnRlcnBvbGF0b3IsIGRlZmF1bHRUcmFuc2xhdGlvblRleHQpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2xhdGVzIHdpdGggdGhlIHVzYWdlIG9mIHRoZSBmYWxsYmFjayBsYW5ndWFnZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHRyYW5zbGF0aW9uSWRcbiAgICAgICAqIEBwYXJhbSBpbnRlcnBvbGF0ZVBhcmFtc1xuICAgICAgICogQHBhcmFtIEludGVycG9sYXRvclxuICAgICAgICogQHJldHVybnMge1N0cmluZ30gdHJhbnNsYXRpb25cbiAgICAgICAqL1xuICAgICAgdmFyIGZhbGxiYWNrVHJhbnNsYXRpb25JbnN0YW50ID0gZnVuY3Rpb24gKHRyYW5zbGF0aW9uSWQsIGludGVycG9sYXRlUGFyYW1zLCBJbnRlcnBvbGF0b3IpIHtcbiAgICAgICAgLy8gU3RhcnQgd2l0aCB0aGUgZmFsbGJhY2tMYW5ndWFnZSB3aXRoIGluZGV4IDBcbiAgICAgICAgcmV0dXJuIHJlc29sdmVGb3JGYWxsYmFja0xhbmd1YWdlSW5zdGFudCgoc3RhcnRGYWxsYmFja0l0ZXJhdGlvbj4wID8gc3RhcnRGYWxsYmFja0l0ZXJhdGlvbiA6IGZhbGxiYWNrSW5kZXgpLCB0cmFuc2xhdGlvbklkLCBpbnRlcnBvbGF0ZVBhcmFtcywgSW50ZXJwb2xhdG9yKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBkZXRlcm1pbmVUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2xhdGlvbklkLCBpbnRlcnBvbGF0ZVBhcmFtcywgaW50ZXJwb2xhdGlvbklkLCBkZWZhdWx0VHJhbnNsYXRpb25UZXh0LCB1c2VzKSB7XG5cbiAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcblxuICAgICAgICB2YXIgdGFibGUgPSB1c2VzID8gJHRyYW5zbGF0aW9uVGFibGVbdXNlc10gOiAkdHJhbnNsYXRpb25UYWJsZSxcbiAgICAgICAgICAgIEludGVycG9sYXRvciA9IChpbnRlcnBvbGF0aW9uSWQpID8gaW50ZXJwb2xhdG9ySGFzaE1hcFtpbnRlcnBvbGF0aW9uSWRdIDogZGVmYXVsdEludGVycG9sYXRvcjtcblxuICAgICAgICAvLyBpZiB0aGUgdHJhbnNsYXRpb24gaWQgZXhpc3RzLCB3ZSBjYW4ganVzdCBpbnRlcnBvbGF0ZSBpdFxuICAgICAgICBpZiAodGFibGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhYmxlLCB0cmFuc2xhdGlvbklkKSkge1xuICAgICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRhYmxlW3RyYW5zbGF0aW9uSWRdO1xuXG4gICAgICAgICAgLy8gSWYgdXNpbmcgbGluaywgcmVydW4gJHRyYW5zbGF0ZSB3aXRoIGxpbmtlZCB0cmFuc2xhdGlvbklkIGFuZCByZXR1cm4gaXRcbiAgICAgICAgICBpZiAodHJhbnNsYXRpb24uc3Vic3RyKDAsIDIpID09PSAnQDonKSB7XG5cbiAgICAgICAgICAgICR0cmFuc2xhdGUodHJhbnNsYXRpb24uc3Vic3RyKDIpLCBpbnRlcnBvbGF0ZVBhcmFtcywgaW50ZXJwb2xhdGlvbklkLCBkZWZhdWx0VHJhbnNsYXRpb25UZXh0LCB1c2VzKVxuICAgICAgICAgICAgICAudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKEludGVycG9sYXRvci5pbnRlcnBvbGF0ZSh0cmFuc2xhdGlvbiwgaW50ZXJwb2xhdGVQYXJhbXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJUcmFuc2xhdGlvbjtcbiAgICAgICAgICAvLyBmb3IgbG9nZ2luZyBwdXJwb3NlcyBvbmx5IChhcyBpbiAkdHJhbnNsYXRlTWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlckxvZyksIHZhbHVlIGlzIG5vdCByZXR1cm5lZCB0byBwcm9taXNlXG4gICAgICAgICAgaWYgKCRtaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyRmFjdG9yeSAmJiAhcGVuZGluZ0xvYWRlcikge1xuICAgICAgICAgICAgbWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlclRyYW5zbGF0aW9uID0gdHJhbnNsYXRlQnlIYW5kbGVyKHRyYW5zbGF0aW9uSWQsIGludGVycG9sYXRlUGFyYW1zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBzaW5jZSB3ZSBjb3VsZG4ndCB0cmFuc2xhdGUgdGhlIGluaXRhbCByZXF1ZXN0ZWQgdHJhbnNsYXRpb24gaWQsXG4gICAgICAgICAgLy8gd2UgdHJ5IGl0IG5vdyB3aXRoIG9uZSBvciBtb3JlIGZhbGxiYWNrIGxhbmd1YWdlcywgaWYgZmFsbGJhY2sgbGFuZ3VhZ2UocykgaXNcbiAgICAgICAgICAvLyBjb25maWd1cmVkLlxuICAgICAgICAgIGlmICh1c2VzICYmICRmYWxsYmFja0xhbmd1YWdlICYmICRmYWxsYmFja0xhbmd1YWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgZmFsbGJhY2tUcmFuc2xhdGlvbih0cmFuc2xhdGlvbklkLCBpbnRlcnBvbGF0ZVBhcmFtcywgSW50ZXJwb2xhdG9yLCBkZWZhdWx0VHJhbnNsYXRpb25UZXh0KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0cmFuc2xhdGlvbikge1xuICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0cmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKF90cmFuc2xhdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoYXBwbHlOb3RGb3VuZEluZGljYXRvcnMoX3RyYW5zbGF0aW9uSWQpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCRtaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyRmFjdG9yeSAmJiAhcGVuZGluZ0xvYWRlciAmJiBtaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyVHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgIC8vIGxvb2tzIGxpa2UgdGhlIHJlcXVlc3RlZCB0cmFuc2xhdGlvbiBpZCBkb2Vzbid0IGV4aXN0cy5cbiAgICAgICAgICAgIC8vIE5vdywgaWYgdGhlcmUgaXMgYSByZWdpc3RlcmVkIGhhbmRsZXIgZm9yIG1pc3NpbmcgdHJhbnNsYXRpb25zIGFuZCBub1xuICAgICAgICAgICAgLy8gYXN5bmNMb2FkZXIgaXMgcGVuZGluZywgd2UgZXhlY3V0ZSB0aGUgaGFuZGxlclxuICAgICAgICAgICAgaWYgKGRlZmF1bHRUcmFuc2xhdGlvblRleHQpIHtcbiAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkZWZhdWx0VHJhbnNsYXRpb25UZXh0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKG1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJUcmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRUcmFuc2xhdGlvblRleHQpIHtcbiAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShkZWZhdWx0VHJhbnNsYXRpb25UZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChhcHBseU5vdEZvdW5kSW5kaWNhdG9ycyh0cmFuc2xhdGlvbklkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfTtcblxuICAgICAgdmFyIGRldGVybWluZVRyYW5zbGF0aW9uSW5zdGFudCA9IGZ1bmN0aW9uICh0cmFuc2xhdGlvbklkLCBpbnRlcnBvbGF0ZVBhcmFtcywgaW50ZXJwb2xhdGlvbklkLCB1c2VzKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCwgdGFibGUgPSB1c2VzID8gJHRyYW5zbGF0aW9uVGFibGVbdXNlc10gOiAkdHJhbnNsYXRpb25UYWJsZSxcbiAgICAgICAgICAgIEludGVycG9sYXRvciA9IGRlZmF1bHRJbnRlcnBvbGF0b3I7XG5cbiAgICAgICAgLy8gaWYgdGhlIGludGVycG9sYXRpb24gaWQgZXhpc3RzIHVzZSBjdXN0b20gaW50ZXJwb2xhdG9yXG4gICAgICAgIGlmIChpbnRlcnBvbGF0b3JIYXNoTWFwICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbnRlcnBvbGF0b3JIYXNoTWFwLCBpbnRlcnBvbGF0aW9uSWQpKSB7XG4gICAgICAgICAgSW50ZXJwb2xhdG9yID0gaW50ZXJwb2xhdG9ySGFzaE1hcFtpbnRlcnBvbGF0aW9uSWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHRyYW5zbGF0aW9uIGlkIGV4aXN0cywgd2UgY2FuIGp1c3QgaW50ZXJwb2xhdGUgaXRcbiAgICAgICAgaWYgKHRhYmxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YWJsZSwgdHJhbnNsYXRpb25JZCkpIHtcbiAgICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB0YWJsZVt0cmFuc2xhdGlvbklkXTtcblxuICAgICAgICAgIC8vIElmIHVzaW5nIGxpbmssIHJlcnVuICR0cmFuc2xhdGUgd2l0aCBsaW5rZWQgdHJhbnNsYXRpb25JZCBhbmQgcmV0dXJuIGl0XG4gICAgICAgICAgaWYgKHRyYW5zbGF0aW9uLnN1YnN0cigwLCAyKSA9PT0gJ0A6Jykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGV0ZXJtaW5lVHJhbnNsYXRpb25JbnN0YW50KHRyYW5zbGF0aW9uLnN1YnN0cigyKSwgaW50ZXJwb2xhdGVQYXJhbXMsIGludGVycG9sYXRpb25JZCwgdXNlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEludGVycG9sYXRvci5pbnRlcnBvbGF0ZSh0cmFuc2xhdGlvbiwgaW50ZXJwb2xhdGVQYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlclRyYW5zbGF0aW9uO1xuICAgICAgICAgIC8vIGZvciBsb2dnaW5nIHB1cnBvc2VzIG9ubHkgKGFzIGluICR0cmFuc2xhdGVNaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyTG9nKSwgdmFsdWUgaXMgbm90IHJldHVybmVkIHRvIHByb21pc2VcbiAgICAgICAgICBpZiAoJG1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJGYWN0b3J5ICYmICFwZW5kaW5nTG9hZGVyKSB7XG4gICAgICAgICAgICBtaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyVHJhbnNsYXRpb24gPSB0cmFuc2xhdGVCeUhhbmRsZXIodHJhbnNsYXRpb25JZCwgaW50ZXJwb2xhdGVQYXJhbXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNpbmNlIHdlIGNvdWxkbid0IHRyYW5zbGF0ZSB0aGUgaW5pdGFsIHJlcXVlc3RlZCB0cmFuc2xhdGlvbiBpZCxcbiAgICAgICAgICAvLyB3ZSB0cnkgaXQgbm93IHdpdGggb25lIG9yIG1vcmUgZmFsbGJhY2sgbGFuZ3VhZ2VzLCBpZiBmYWxsYmFjayBsYW5ndWFnZShzKSBpc1xuICAgICAgICAgIC8vIGNvbmZpZ3VyZWQuXG4gICAgICAgICAgaWYgKHVzZXMgJiYgJGZhbGxiYWNrTGFuZ3VhZ2UgJiYgJGZhbGxiYWNrTGFuZ3VhZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICBmYWxsYmFja0luZGV4ID0gMDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbGxiYWNrVHJhbnNsYXRpb25JbnN0YW50KHRyYW5zbGF0aW9uSWQsIGludGVycG9sYXRlUGFyYW1zLCBJbnRlcnBvbGF0b3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJG1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJGYWN0b3J5ICYmICFwZW5kaW5nTG9hZGVyICYmIG1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXJUcmFuc2xhdGlvbikge1xuICAgICAgICAgICAgLy8gbG9va3MgbGlrZSB0aGUgcmVxdWVzdGVkIHRyYW5zbGF0aW9uIGlkIGRvZXNuJ3QgZXhpc3RzLlxuICAgICAgICAgICAgLy8gTm93LCBpZiB0aGVyZSBpcyBhIHJlZ2lzdGVyZWQgaGFuZGxlciBmb3IgbWlzc2luZyB0cmFuc2xhdGlvbnMgYW5kIG5vXG4gICAgICAgICAgICAvLyBhc3luY0xvYWRlciBpcyBwZW5kaW5nLCB3ZSBleGVjdXRlIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICByZXN1bHQgPSBtaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyVHJhbnNsYXRpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFwcGx5Tm90Rm91bmRJbmRpY2F0b3JzKHRyYW5zbGF0aW9uSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2xlYXJOZXh0TGFuZ0FuZFByb21pc2UgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCRuZXh0TGFuZyA9PT0ga2V5KSB7XG4gICAgICAgICAgJG5leHRMYW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxhbmdQcm9taXNlc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZSNwcmVmZXJyZWRMYW5ndWFnZVxuICAgICAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogUmV0dXJucyB0aGUgbGFuZ3VhZ2Uga2V5IGZvciB0aGUgcHJlZmVycmVkIGxhbmd1YWdlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nS2V5IGxhbmd1YWdlIFN0cmluZyBvciBBcnJheSB0byBiZSB1c2VkIGFzIHByZWZlcnJlZExhbmd1YWdlIChjaGFuZ2luZyBhdCBydW50aW1lKVxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gcHJlZmVycmVkIGxhbmd1YWdlIGtleVxuICAgICAgICovXG4gICAgICAkdHJhbnNsYXRlLnByZWZlcnJlZExhbmd1YWdlID0gZnVuY3Rpb24gKGxhbmdLZXkpIHtcbiAgICAgICAgaWYobGFuZ0tleSkge1xuICAgICAgICAgIHNldHVwUHJlZmVycmVkTGFuZ3VhZ2UobGFuZ0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRwcmVmZXJyZWRMYW5ndWFnZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGUjY2xvYWtDbGFzc05hbWVcbiAgICAgICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVcbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFJldHVybnMgdGhlIGNvbmZpZ3VyZWQgY2xhc3MgbmFtZSBmb3IgYHRyYW5zbGF0ZS1jbG9ha2AgZGlyZWN0aXZlLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gY2xvYWtDbGFzc05hbWVcbiAgICAgICAqL1xuICAgICAgJHRyYW5zbGF0ZS5jbG9ha0NsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICRjbG9ha0NsYXNzTmFtZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGUjbmVzdGVkT2JqZWN0RGVsaW1ldGVyXG4gICAgICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBSZXR1cm5zIHRoZSBjb25maWd1cmVkIGRlbGltaXRlciBmb3IgbmVzdGVkIG5hbWVzcGFjZXMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBuZXN0ZWRPYmplY3REZWxpbWV0ZXJcbiAgICAgICAqL1xuICAgICAgJHRyYW5zbGF0ZS5uZXN0ZWRPYmplY3REZWxpbWV0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAkbmVzdGVkT2JqZWN0RGVsaW1ldGVyO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZSNmYWxsYmFja0xhbmd1YWdlXG4gICAgICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBSZXR1cm5zIHRoZSBsYW5ndWFnZSBrZXkgZm9yIHRoZSBmYWxsYmFjayBsYW5ndWFnZXMgb3Igc2V0cyBhIG5ldyBmYWxsYmFjayBzdGFjay5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGxhbmdLZXkgbGFuZ3VhZ2UgU3RyaW5nIG9yIEFycmF5IG9mIGZhbGxiYWNrIGxhbmd1YWdlcyB0byBiZSB1c2VkICh0byBjaGFuZ2Ugc3RhY2sgYXQgcnVudGltZSlcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd8fGFycmF5fSBmYWxsYmFjayBsYW5ndWFnZSBrZXlcbiAgICAgICAqL1xuICAgICAgJHRyYW5zbGF0ZS5mYWxsYmFja0xhbmd1YWdlID0gZnVuY3Rpb24gKGxhbmdLZXkpIHtcbiAgICAgICAgaWYgKGxhbmdLZXkgIT09IHVuZGVmaW5lZCAmJiBsYW5nS2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgZmFsbGJhY2tTdGFjayhsYW5nS2V5KTtcblxuICAgICAgICAgIC8vIGFzIHdlIG1pZ2h0IGhhdmUgYW4gYXN5bmMgbG9hZGVyIGluaXRpYXRlZCBhbmQgYSBuZXcgdHJhbnNsYXRpb24gbGFuZ3VhZ2UgbWlnaHQgaGF2ZSBiZWVuIGRlZmluZWRcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGFkZCB0aGUgcHJvbWlzZSB0byB0aGUgc3RhY2sgYWxzby4gU28gLSBpdGVyYXRlLlxuICAgICAgICAgIGlmICgkbG9hZGVyRmFjdG9yeSkge1xuICAgICAgICAgICAgaWYgKCRmYWxsYmFja0xhbmd1YWdlICYmICRmYWxsYmFja0xhbmd1YWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJGZhbGxiYWNrTGFuZ3VhZ2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhbmdQcm9taXNlc1skZmFsbGJhY2tMYW5ndWFnZVtpXV0pIHtcbiAgICAgICAgICAgICAgICAgIGxhbmdQcm9taXNlc1skZmFsbGJhY2tMYW5ndWFnZVtpXV0gPSBsb2FkQXN5bmMoJGZhbGxiYWNrTGFuZ3VhZ2VbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAkdHJhbnNsYXRlLnVzZSgkdHJhbnNsYXRlLnVzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGZhbGxiYWNrV2FzU3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuICRmYWxsYmFja0xhbmd1YWdlWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZmFsbGJhY2tMYW5ndWFnZTtcbiAgICAgICAgfVxuXG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlI3VzZUZhbGxiYWNrTGFuZ3VhZ2VcbiAgICAgICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVcbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFNldHMgdGhlIGZpcnN0IGtleSBvZiB0aGUgZmFsbGJhY2sgbGFuZ3VhZ2Ugc3RhY2sgdG8gYmUgdXNlZCBmb3IgdHJhbnNsYXRpb24uXG4gICAgICAgKiBUaGVyZWZvcmUgYWxsIGxhbmd1YWdlcyBpbiB0aGUgZmFsbGJhY2sgYXJyYXkgQkVGT1JFIHRoaXMga2V5IHdpbGwgYmUgc2tpcHBlZCFcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGxhbmdLZXkgQ29udGFpbnMgdGhlIGxhbmdLZXkgdGhlIGl0ZXJhdGlvbiBzaGFsbCBzdGFydCB3aXRoLiBTZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG9cbiAgICAgICAqIGdldCBiYWNrIHRvIHRoZSB3aG9sZSBzdGFja1xuICAgICAgICovXG4gICAgICAkdHJhbnNsYXRlLnVzZUZhbGxiYWNrTGFuZ3VhZ2UgPSBmdW5jdGlvbiAobGFuZ0tleSkge1xuICAgICAgICBpZiAobGFuZ0tleSAhPT0gdW5kZWZpbmVkICYmIGxhbmdLZXkgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWxhbmdLZXkpIHtcbiAgICAgICAgICAgIHN0YXJ0RmFsbGJhY2tJdGVyYXRpb24gPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGFuZ0tleVBvc2l0aW9uID0gaW5kZXhPZigkZmFsbGJhY2tMYW5ndWFnZSwgbGFuZ0tleSk7XG4gICAgICAgICAgICBpZiAobGFuZ0tleVBvc2l0aW9uID4gLTEpIHtcbiAgICAgICAgICAgICAgc3RhcnRGYWxsYmFja0l0ZXJhdGlvbiA9IGxhbmdLZXlQb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlI3Byb3Bvc2VkTGFuZ3VhZ2VcbiAgICAgICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVcbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFJldHVybnMgdGhlIGxhbmd1YWdlIGtleSBvZiBsYW5ndWFnZSB0aGF0IGlzIGN1cnJlbnRseSBsb2FkZWQgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBsYW5ndWFnZSBrZXlcbiAgICAgICAqL1xuICAgICAgJHRyYW5zbGF0ZS5wcm9wb3NlZExhbmd1YWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJG5leHRMYW5nO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZSNzdG9yYWdlXG4gICAgICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBSZXR1cm5zIHJlZ2lzdGVyZWQgc3RvcmFnZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFN0b3JhZ2VcbiAgICAgICAqL1xuICAgICAgJHRyYW5zbGF0ZS5zdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU3RvcmFnZTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGUjbmVnb3RpYXRlTG9jYWxlXG4gICAgICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBSZXR1cm5zIGEgbGFuZ3VhZ2Uga2V5IGJhc2VkIG9uIGF2YWlsYWJsZSBsYW5ndWFnZXMgYW5kIGxhbmd1YWdlIGFsaWFzZXMuIElmIGFcbiAgICAgICAqIGxhbmd1YWdlIGtleSBjYW5ub3QgYmUgcmVzb2x2ZWQsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAgICpcbiAgICAgICAqIElmIG5vIG9yIGEgZmFsc3kga2V5IGlzIGdpdmVuLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gTGFuZ3VhZ2Uga2V5XG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBMYW5ndWFnZSBrZXkgb3IgdW5kZWZpbmVkIGlmIG5vIGxhbmd1YWdlIGtleSBpcyBmb3VuZC5cbiAgICAgICAqL1xuICAgICAgJHRyYW5zbGF0ZS5uZWdvdGlhdGVMb2NhbGUgPSBuZWdvdGlhdGVMb2NhbGU7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGUjdXNlXG4gICAgICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBUZWxscyBhbmd1bGFyLXRyYW5zbGF0ZSB3aGljaCBsYW5ndWFnZSB0byB1c2UgYnkgZ2l2ZW4gbGFuZ3VhZ2Uga2V5LiBUaGlzIG1ldGhvZCBpc1xuICAgICAgICogdXNlZCB0byBjaGFuZ2UgbGFuZ3VhZ2UgYXQgcnVudGltZS4gSXQgYWxzbyB0YWtlcyBjYXJlIG9mIHN0b3JpbmcgdGhlIGxhbmd1YWdlXG4gICAgICAgKiBrZXkgaW4gYSBjb25maWd1cmVkIHN0b3JlIHRvIGxldCB5b3VyIGFwcCByZW1lbWJlciB0aGUgY2hvb3NlZCBsYW5ndWFnZS5cbiAgICAgICAqXG4gICAgICAgKiBXaGVuIHRyeWluZyB0byAndXNlJyBhIGxhbmd1YWdlIHdoaWNoIGlzbid0IGF2YWlsYWJsZSBpdCB0cmllcyB0byBsb2FkIGl0XG4gICAgICAgKiBhc3luY2hyb25vdXNseSB3aXRoIHJlZ2lzdGVyZWQgbG9hZGVycy5cbiAgICAgICAqXG4gICAgICAgKiBSZXR1cm5zIHByb21pc2Ugb2JqZWN0IHdpdGggbG9hZGVkIGxhbmd1YWdlIGZpbGUgZGF0YSBvciBzdHJpbmcgb2YgdGhlIGN1cnJlbnRseSB1c2VkIGxhbmd1YWdlLlxuICAgICAgICpcbiAgICAgICAqIElmIG5vIG9yIGEgZmFsc3kga2V5IGlzIGdpdmVuIGl0IHJldHVybnMgdGhlIGN1cnJlbnRseSB1c2VkIGxhbmd1YWdlIGtleS5cbiAgICAgICAqIFRoZSByZXR1cm5lZCBzdHJpbmcgd2lsbCBiZSBgYGB1bmRlZmluZWRgYGAgaWYgc2V0dGluZyB1cCAkdHJhbnNsYXRlIGhhc24ndCBmaW5pc2hlZC5cbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiAkdHJhbnNsYXRlLnVzZShcImVuX1VTXCIpLnRoZW4oZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgKiAgICRzY29wZS50ZXh0ID0gJHRyYW5zbGF0ZShcIkhFTExPXCIpO1xuICAgICAgICogfSk7XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIExhbmd1YWdlIGtleVxuICAgICAgICogQHJldHVybiB7b2JqZWN0fHN0cmluZ30gUHJvbWlzZSB3aXRoIGxvYWRlZCBsYW5ndWFnZSBkYXRhIG9yIHRoZSBsYW5ndWFnZSBrZXkgaWYgYSBmYWxzeSBwYXJhbSB3YXMgZ2l2ZW4uXG4gICAgICAgKi9cbiAgICAgICR0cmFuc2xhdGUudXNlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgIHJldHVybiAkdXNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgJHJvb3RTY29wZS4kZW1pdCgnJHRyYW5zbGF0ZUNoYW5nZVN0YXJ0Jywge2xhbmd1YWdlOiBrZXl9KTtcblxuICAgICAgICAvLyBUcnkgdG8gZ2V0IHRoZSBhbGlhc2VkIGxhbmd1YWdlIGtleVxuICAgICAgICB2YXIgYWxpYXNlZEtleSA9IG5lZ290aWF0ZUxvY2FsZShrZXkpO1xuICAgICAgICBpZiAoYWxpYXNlZEtleSkge1xuICAgICAgICAgIGtleSA9IGFsaWFzZWRLZXk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSBpc24ndCBhIHRyYW5zbGF0aW9uIHRhYmxlIGZvciB0aGUgbGFuZ3VhZ2Ugd2UndmUgcmVxdWVzdGVkLFxuICAgICAgICAvLyB3ZSBsb2FkIGl0IGFzeW5jaHJvbm91c2x5XG4gICAgICAgICRuZXh0TGFuZyA9IGtleTtcbiAgICAgICAgaWYgKCgkZm9yY2VBc3luY1JlbG9hZEVuYWJsZWQgfHwgISR0cmFuc2xhdGlvblRhYmxlW2tleV0pICYmICRsb2FkZXJGYWN0b3J5ICYmICFsYW5nUHJvbWlzZXNba2V5XSkge1xuICAgICAgICAgIGxhbmdQcm9taXNlc1trZXldID0gbG9hZEFzeW5jKGtleSkudGhlbihmdW5jdGlvbiAodHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgIHRyYW5zbGF0aW9ucyh0cmFuc2xhdGlvbi5rZXksIHRyYW5zbGF0aW9uLnRhYmxlKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodHJhbnNsYXRpb24ua2V5KTtcbiAgICAgICAgICAgIGlmICgkbmV4dExhbmcgPT09IGtleSkge1xuICAgICAgICAgICAgICB1c2VMYW5ndWFnZSh0cmFuc2xhdGlvbi5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGVtaXQoJyR0cmFuc2xhdGVDaGFuZ2VFcnJvcicsIHtsYW5ndWFnZToga2V5fSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3Qoa2V5KTtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGVtaXQoJyR0cmFuc2xhdGVDaGFuZ2VFbmQnLCB7bGFuZ3VhZ2U6IGtleX0pO1xuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChrZXkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhbmdQcm9taXNlc1trZXldWydmaW5hbGx5J10oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJOZXh0TGFuZ0FuZFByb21pc2Uoa2V5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChsYW5nUHJvbWlzZXNba2V5XSkge1xuICAgICAgICAgIC8vIHdlIGFyZSBhbHJlYWR5IGxvYWRpbmcgdGhpcyBhc3luY2hyb25vdXNseVxuICAgICAgICAgIC8vIHJlc29sdmUgb3VyIG5ldyBkZWZlcnJlZCB3aGVuIHRoZSBvbGQgbGFuZ1Byb21pc2UgaXMgcmVzb2x2ZWRcbiAgICAgICAgICBsYW5nUHJvbWlzZXNba2V5XS50aGVuKGZ1bmN0aW9uICh0cmFuc2xhdGlvbikge1xuICAgICAgICAgICAgaWYgKCRuZXh0TGFuZyA9PT0gdHJhbnNsYXRpb24ua2V5KSB7XG4gICAgICAgICAgICAgIHVzZUxhbmd1YWdlKHRyYW5zbGF0aW9uLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHRyYW5zbGF0aW9uLmtleSk7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb247XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgLy8gZmluZCBmaXJzdCBhdmFpbGFibGUgZmFsbGJhY2sgbGFuZ3VhZ2UgaWYgdGhhdCByZXF1ZXN0IGhhcyBmYWlsZWRcbiAgICAgICAgICAgIGlmICghJHVzZXMgJiYgJGZhbGxiYWNrTGFuZ3VhZ2UgJiYgJGZhbGxiYWNrTGFuZ3VhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gJHRyYW5zbGF0ZS51c2UoJGZhbGxiYWNrTGFuZ3VhZ2VbMF0pLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZWplY3Qoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGtleSk7XG4gICAgICAgICAgdXNlTGFuZ3VhZ2Uoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZSNzdG9yYWdlS2V5XG4gICAgICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBSZXR1cm5zIHRoZSBrZXkgZm9yIHRoZSBzdG9yYWdlLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RvcmFnZSBrZXlcbiAgICAgICAqL1xuICAgICAgJHRyYW5zbGF0ZS5zdG9yYWdlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RvcmFnZUtleSgpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZSNpc1Bvc3RDb21waWxpbmdFbmFibGVkXG4gICAgICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgcG9zdCBjb21waWxpbmcgaXMgZW5hYmxlZCBvciBub3RcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtib29sfSBzdG9yYWdlIGtleVxuICAgICAgICovXG4gICAgICAkdHJhbnNsYXRlLmlzUG9zdENvbXBpbGluZ0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAkcG9zdENvbXBpbGluZ0VuYWJsZWQ7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlI2lzRm9yY2VBc3luY1JlbG9hZEVuYWJsZWRcbiAgICAgICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVcbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFJldHVybnMgd2hldGhlciBmb3JjZSBhc3luYyByZWxvYWQgaXMgZW5hYmxlZCBvciBub3RcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBmb3JjZUFzeW5jUmVsb2FkIHZhbHVlXG4gICAgICAgKi9cbiAgICAgICR0cmFuc2xhdGUuaXNGb3JjZUFzeW5jUmVsb2FkRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICRmb3JjZUFzeW5jUmVsb2FkRW5hYmxlZDtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGUjcmVmcmVzaFxuICAgICAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogUmVmcmVzaGVzIGEgdHJhbnNsYXRpb24gdGFibGUgcG9pbnRlZCBieSB0aGUgZ2l2ZW4gbGFuZ0tleS4gSWYgbGFuZ0tleSBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAgICogdGhlIG1vZHVsZSB3aWxsIGRyb3AgYWxsIGV4aXN0ZW50IHRyYW5zbGF0aW9uIHRhYmxlcyBhbmQgbG9hZCBuZXcgdmVyc2lvbiBvZiB0aG9zZSB3aGljaFxuICAgICAgICogYXJlIGN1cnJlbnRseSBpbiB1c2UuXG4gICAgICAgKlxuICAgICAgICogUmVmcmVzaCBtZWFucyB0aGF0IHRoZSBtb2R1bGUgd2lsbCBkcm9wIHRhcmdldCB0cmFuc2xhdGlvbiB0YWJsZSBhbmQgdHJ5IHRvIGxvYWQgaXQgYWdhaW4uXG4gICAgICAgKlxuICAgICAgICogSW4gY2FzZSB0aGVyZSBhcmUgbm8gbG9hZGVycyByZWdpc3RlcmVkIHRoZSByZWZyZXNoKCkgbWV0aG9kIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gICAgICAgKlxuICAgICAgICogSWYgdGhlIG1vZHVsZSBpcyBhYmxlIHRvIHJlZnJlc2ggdHJhbnNsYXRpb24gdGFibGVzIHJlZnJlc2goKSBtZXRob2Qgd2lsbCBicm9hZGNhc3RcbiAgICAgICAqICR0cmFuc2xhdGVSZWZyZXNoU3RhcnQgYW5kICR0cmFuc2xhdGVSZWZyZXNoRW5kIGV2ZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogLy8gdGhpcyB3aWxsIGRyb3AgYWxsIGN1cnJlbnRseSBleGlzdGVudCB0cmFuc2xhdGlvbiB0YWJsZXMgYW5kIHJlbG9hZCB0aG9zZSB3aGljaCBhcmVcbiAgICAgICAqIC8vIGN1cnJlbnRseSBpbiB1c2VcbiAgICAgICAqICR0cmFuc2xhdGUucmVmcmVzaCgpO1xuICAgICAgICogLy8gdGhpcyB3aWxsIHJlZnJlc2ggYSB0cmFuc2xhdGlvbiB0YWJsZSBmb3IgdGhlIGVuX1VTIGxhbmd1YWdlXG4gICAgICAgKiAkdHJhbnNsYXRlLnJlZnJlc2goJ2VuX1VTJyk7XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmdLZXkgQSBsYW5ndWFnZSBrZXkgb2YgdGhlIHRhYmxlLCB3aGljaCBoYXMgdG8gYmUgcmVmcmVzaGVkXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7cHJvbWlzZX0gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBpbiBjYXNlIGEgdHJhbnNsYXRpb24gdGFibGVzIHJlZnJlc2hpbmdcbiAgICAgICAqIHByb2Nlc3MgaXMgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5LCBhbmQgcmVqZWN0IGlmIG5vdC5cbiAgICAgICAqL1xuICAgICAgJHRyYW5zbGF0ZS5yZWZyZXNoID0gZnVuY3Rpb24gKGxhbmdLZXkpIHtcbiAgICAgICAgaWYgKCEkbG9hZGVyRmFjdG9yeSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGRuXFwndCByZWZyZXNoIHRyYW5zbGF0aW9uIHRhYmxlLCBubyBsb2FkZXIgcmVnaXN0ZXJlZCEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgJHJvb3RTY29wZS4kZW1pdCgnJHRyYW5zbGF0ZVJlZnJlc2hFbmQnLCB7bGFuZ3VhZ2U6IGxhbmdLZXl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCgpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRlbWl0KCckdHJhbnNsYXRlUmVmcmVzaEVuZCcsIHtsYW5ndWFnZTogbGFuZ0tleX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgJHJvb3RTY29wZS4kZW1pdCgnJHRyYW5zbGF0ZVJlZnJlc2hTdGFydCcsIHtsYW5ndWFnZTogbGFuZ0tleX0pO1xuXG4gICAgICAgIGlmICghbGFuZ0tleSkge1xuICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gbGFuZ3VhZ2Uga2V5IHNwZWNpZmllZCB3ZSByZWZyZXNoIEFMTCBUSEUgVEhJTkdTIVxuICAgICAgICAgIHZhciB0YWJsZXMgPSBbXSwgbG9hZGluZ0tleXMgPSB7fTtcblxuICAgICAgICAgIC8vIHJlbG9hZCByZWdpc3RlcmVkIGZhbGxiYWNrIGxhbmd1YWdlc1xuICAgICAgICAgIGlmICgkZmFsbGJhY2tMYW5ndWFnZSAmJiAkZmFsbGJhY2tMYW5ndWFnZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSAkZmFsbGJhY2tMYW5ndWFnZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICB0YWJsZXMucHVzaChsb2FkQXN5bmMoJGZhbGxiYWNrTGFuZ3VhZ2VbaV0pKTtcbiAgICAgICAgICAgICAgbG9hZGluZ0tleXNbJGZhbGxiYWNrTGFuZ3VhZ2VbaV1dID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZWxvYWQgY3VycmVudGx5IHVzZWQgbGFuZ3VhZ2VcbiAgICAgICAgICBpZiAoJHVzZXMgJiYgIWxvYWRpbmdLZXlzWyR1c2VzXSkge1xuICAgICAgICAgICAgdGFibGVzLnB1c2gobG9hZEFzeW5jKCR1c2VzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFsbFRyYW5zbGF0aW9uc0xvYWRlZCA9IGZ1bmN0aW9uICh0YWJsZURhdGEpIHtcbiAgICAgICAgICAgICR0cmFuc2xhdGlvblRhYmxlID0ge307XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2godGFibGVEYXRhLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICB0cmFuc2xhdGlvbnMoZGF0YS5rZXksIGRhdGEudGFibGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoJHVzZXMpIHtcbiAgICAgICAgICAgICAgdXNlTGFuZ3VhZ2UoJHVzZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgYWxsVHJhbnNsYXRpb25zTG9hZGVkLmRpc3BsYXlOYW1lID0gJ3JlZnJlc2hQb3N0UHJvY2Vzc29yJztcblxuICAgICAgICAgICRxLmFsbCh0YWJsZXMpLnRoZW4oYWxsVHJhbnNsYXRpb25zTG9hZGVkLCByZWplY3QpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoJHRyYW5zbGF0aW9uVGFibGVbbGFuZ0tleV0pIHtcblxuICAgICAgICAgIHZhciBvbmVUcmFuc2xhdGlvbnNMb2FkZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdHJhbnNsYXRpb25zKGRhdGEua2V5LCBkYXRhLnRhYmxlKTtcbiAgICAgICAgICAgIGlmIChsYW5nS2V5ID09PSAkdXNlcykge1xuICAgICAgICAgICAgICB1c2VMYW5ndWFnZSgkdXNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBvbmVUcmFuc2xhdGlvbnNMb2FkZWQuZGlzcGxheU5hbWUgPSAncmVmcmVzaFBvc3RQcm9jZXNzb3InO1xuXG4gICAgICAgICAgbG9hZEFzeW5jKGxhbmdLZXkpLnRoZW4ob25lVHJhbnNsYXRpb25zTG9hZGVkLCByZWplY3QpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlI2luc3RhbnRcbiAgICAgICAqIEBtZXRob2RPZiBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVcbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFJldHVybnMgYSB0cmFuc2xhdGlvbiBpbnN0YW50bHkgZnJvbSB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgbG9hZGVkIHRyYW5zbGF0aW9uLiBBbGwgcnVsZXNcbiAgICAgICAqIHJlZ2FyZGluZyB0aGUgY3VycmVudCBsYW5ndWFnZSwgdGhlIHByZWZlcnJlZCBsYW5ndWFnZSBvZiBldmVuIGZhbGxiYWNrIGxhbmd1YWdlcyB3aWxsIGJlXG4gICAgICAgKiB1c2VkIGV4Y2VwdCBhbnkgcHJvbWlzZSBoYW5kbGluZy4gSWYgYSBsYW5ndWFnZSB3YXMgbm90IGZvdW5kLCBhbiBhc3luY2hyb25vdXMgbG9hZGluZ1xuICAgICAgICogd2lsbCBiZSBpbnZva2VkIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSB0cmFuc2xhdGlvbklkIEEgdG9rZW4gd2hpY2ggcmVwcmVzZW50cyBhIHRyYW5zbGF0aW9uIGlkXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGNhbiBiZSBvcHRpb25hbGx5IGFuIGFycmF5IG9mIHRyYW5zbGF0aW9uIGlkcyB3aGljaFxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyB0aGF0IHRoZSBmdW5jdGlvbidzIHByb21pc2UgcmV0dXJucyBhbiBvYmplY3Qgd2hlcmVcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2gga2V5IGlzIHRoZSB0cmFuc2xhdGlvbiBpZCBhbmQgdGhlIHZhbHVlIHRoZSB0cmFuc2xhdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbnRlcnBvbGF0ZVBhcmFtcyBQYXJhbXNcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcnBvbGF0aW9uSWQgVGhlIGlkIG9mIHRoZSBpbnRlcnBvbGF0aW9uIHRvIHVzZVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcmNlTGFuZ3VhZ2UgQSBsYW5ndWFnZSB0byBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgbGFuZ3VhZ2VcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd8b2JqZWN0fSB0cmFuc2xhdGlvblxuICAgICAgICovXG4gICAgICAkdHJhbnNsYXRlLmluc3RhbnQgPSBmdW5jdGlvbiAodHJhbnNsYXRpb25JZCwgaW50ZXJwb2xhdGVQYXJhbXMsIGludGVycG9sYXRpb25JZCwgZm9yY2VMYW5ndWFnZSkge1xuXG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gcmUtbmVnb3RpYXRlICR1c2VzXG4gICAgICAgIHZhciB1c2VzID0gKGZvcmNlTGFuZ3VhZ2UgJiYgZm9yY2VMYW5ndWFnZSAhPT0gJHVzZXMpID8gLy8gd2UgZG9uJ3Qgd2FudCB0byByZS1uZWdvdGlhdGUgJHVzZXNcbiAgICAgICAgICAgICAgKG5lZ290aWF0ZUxvY2FsZShmb3JjZUxhbmd1YWdlKSB8fCBmb3JjZUxhbmd1YWdlKSA6ICR1c2VzO1xuXG4gICAgICAgIC8vIERldGVjdCB1bmRlZmluZWQgYW5kIG51bGwgdmFsdWVzIHRvIHNob3J0ZW4gdGhlIGV4ZWN1dGlvbiBhbmQgcHJldmVudCBleGNlcHRpb25zXG4gICAgICAgIGlmICh0cmFuc2xhdGlvbklkID09PSBudWxsIHx8IGFuZ3VsYXIuaXNVbmRlZmluZWQodHJhbnNsYXRpb25JZCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb25JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIER1Y2sgZGV0ZWN0aW9uOiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gYXJyYXksIGEgYnVuY2ggb2YgdHJhbnNsYXRpb25zIHdhcyByZXF1ZXN0ZWQuXG4gICAgICAgIC8vIFRoZSByZXN1bHQgaXMgYW4gb2JqZWN0LlxuICAgICAgICBpZiAoYW5ndWxhci5pc0FycmF5KHRyYW5zbGF0aW9uSWQpKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYyA9IHRyYW5zbGF0aW9uSWQubGVuZ3RoOyBpIDwgYzsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRzW3RyYW5zbGF0aW9uSWRbaV1dID0gJHRyYW5zbGF0ZS5pbnN0YW50KHRyYW5zbGF0aW9uSWRbaV0sIGludGVycG9sYXRlUGFyYW1zLCBpbnRlcnBvbGF0aW9uSWQsIGZvcmNlTGFuZ3VhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGRpc2NhcmRlZCB1bmFjY2VwdGFibGUgdmFsdWVzLiBTbyB3ZSBqdXN0IG5lZWQgdG8gdmVyaWZ5IGlmIHRyYW5zbGF0aW9uSWQgaXMgZW1wdHkgU3RyaW5nXG4gICAgICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKHRyYW5zbGF0aW9uSWQpICYmIHRyYW5zbGF0aW9uSWQubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGlvbklkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJpbSBvZmYgYW55IHdoaXRlc3BhY2VcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9uSWQpIHtcbiAgICAgICAgICB0cmFuc2xhdGlvbklkID0gdHJpbS5hcHBseSh0cmFuc2xhdGlvbklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQsIHBvc3NpYmxlTGFuZ0tleXMgPSBbXTtcbiAgICAgICAgaWYgKCRwcmVmZXJyZWRMYW5ndWFnZSkge1xuICAgICAgICAgIHBvc3NpYmxlTGFuZ0tleXMucHVzaCgkcHJlZmVycmVkTGFuZ3VhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VzKSB7XG4gICAgICAgICAgcG9zc2libGVMYW5nS2V5cy5wdXNoKHVzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkZmFsbGJhY2tMYW5ndWFnZSAmJiAkZmFsbGJhY2tMYW5ndWFnZS5sZW5ndGgpIHtcbiAgICAgICAgICBwb3NzaWJsZUxhbmdLZXlzID0gcG9zc2libGVMYW5nS2V5cy5jb25jYXQoJGZhbGxiYWNrTGFuZ3VhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBkID0gcG9zc2libGVMYW5nS2V5cy5sZW5ndGg7IGogPCBkOyBqKyspIHtcbiAgICAgICAgICB2YXIgcG9zc2libGVMYW5nS2V5ID0gcG9zc2libGVMYW5nS2V5c1tqXTtcbiAgICAgICAgICBpZiAoJHRyYW5zbGF0aW9uVGFibGVbcG9zc2libGVMYW5nS2V5XSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAkdHJhbnNsYXRpb25UYWJsZVtwb3NzaWJsZUxhbmdLZXldW3RyYW5zbGF0aW9uSWRdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBkZXRlcm1pbmVUcmFuc2xhdGlvbkluc3RhbnQodHJhbnNsYXRpb25JZCwgaW50ZXJwb2xhdGVQYXJhbXMsIGludGVycG9sYXRpb25JZCwgdXNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXN1bHQgJiYgcmVzdWx0ICE9PSAnJykge1xuICAgICAgICAgIGlmICgkbm90Rm91bmRJbmRpY2F0b3JMZWZ0IHx8ICRub3RGb3VuZEluZGljYXRvclJpZ2h0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhcHBseU5vdEZvdW5kSW5kaWNhdG9ycyh0cmFuc2xhdGlvbklkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRyYW5zbGF0aW9uIG9mIGRlZmF1bHQgaW50ZXJwb2xhdG9yIGlmIG5vdCBmb3VuZCBhbnl0aGluZy5cbiAgICAgICAgICAgIHJlc3VsdCA9IGRlZmF1bHRJbnRlcnBvbGF0b3IuaW50ZXJwb2xhdGUodHJhbnNsYXRpb25JZCwgaW50ZXJwb2xhdGVQYXJhbXMpO1xuICAgICAgICAgICAgaWYgKCRtaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyRmFjdG9yeSAmJiAhcGVuZGluZ0xvYWRlcikge1xuICAgICAgICAgICAgICByZXN1bHQgPSB0cmFuc2xhdGVCeUhhbmRsZXIodHJhbnNsYXRpb25JZCwgaW50ZXJwb2xhdGVQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlI3ZlcnNpb25JbmZvXG4gICAgICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZlcnNpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBhbmd1bGFyLXRyYW5zbGF0ZSBsaWJyYXJ5XG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7c3RyaW5nfSBhbmd1bGFyLXRyYW5zbGF0ZSB2ZXJzaW9uXG4gICAgICAgKi9cbiAgICAgICR0cmFuc2xhdGUudmVyc2lvbkluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZSNsb2FkZXJDYWNoZVxuICAgICAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogUmV0dXJucyB0aGUgZGVmaW5lZCBsb2FkZXJDYWNoZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ3xvYmplY3R9IGN1cnJlbnQgdmFsdWUgb2YgbG9hZGVyQ2FjaGVcbiAgICAgICAqL1xuICAgICAgJHRyYW5zbGF0ZS5sb2FkZXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlO1xuICAgICAgfTtcblxuICAgICAgLy8gaW50ZXJuYWwgcHVycG9zZSBvbmx5XG4gICAgICAkdHJhbnNsYXRlLmRpcmVjdGl2ZVByaW9yaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZGlyZWN0aXZlUHJpb3JpdHk7XG4gICAgICB9O1xuXG4gICAgICAvLyBpbnRlcm5hbCBwdXJwb3NlIG9ubHlcbiAgICAgICR0cmFuc2xhdGUuc3RhdGVmdWxGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZWZ1bEZpbHRlcjtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGUjaXNSZWFkeVxuICAgICAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBzZXJ2aWNlIGlzIFwicmVhZHlcIiB0byB0cmFuc2xhdGUgKGkuZS4gbG9hZGluZyAxc3QgbGFuZ3VhZ2UpLlxuICAgICAgICpcbiAgICAgICAqIFNlZSBhbHNvIHtAbGluayBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGUjbWV0aG9kc19vblJlYWR5IG9uUmVhZHkoKX0uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gY3VycmVudCB2YWx1ZSBvZiByZWFkeVxuICAgICAgICovXG4gICAgICAkdHJhbnNsYXRlLmlzUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAkaXNSZWFkeTtcbiAgICAgIH07XG5cbiAgICAgIHZhciAkb25SZWFkeURlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICRvblJlYWR5RGVmZXJyZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJGlzUmVhZHkgPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGUjb25SZWFkeVxuICAgICAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBzZXJ2aWNlIGlzIFwicmVhZHlcIiB0byB0cmFuc2xhdGUgKGkuZS4gbG9hZGluZyAxc3QgbGFuZ3VhZ2UpLlxuICAgICAgICpcbiAgICAgICAqIFNlZSBhbHNvIHtAbGluayBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGUjbWV0aG9kc19pc1JlYWR5IGlzUmVhZHkoKX0uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbj19IGZuIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHNlcnZpY2UgaXMgcmVhZHlcbiAgICAgICAqIEByZXR1cm4ge29iamVjdH0gUHJvbWlzZSByZXNvbHZlZCB3aGVuIHNlcnZpY2UgaXMgcmVhZHlcbiAgICAgICAqL1xuICAgICAgJHRyYW5zbGF0ZS5vblJlYWR5ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAgICAgZGVmZXJyZWQucHJvbWlzZS50aGVuKGZuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGlzUmVhZHkpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJG9uUmVhZHlEZWZlcnJlZC5wcm9taXNlLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9O1xuXG4gICAgICAvLyBXaGVuZXZlciAkdHJhbnNsYXRlUmVhZHkgaXMgYmVpbmcgZmlyZWQsIHRoaXMgd2lsbCBlbnN1cmUgdGhlIHN0YXRlIG9mICRpc1JlYWR5XG4gICAgICB2YXIgZ2xvYmFsT25SZWFkeUxpc3RlbmVyID0gJHJvb3RTY29wZS4kb24oJyR0cmFuc2xhdGVSZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJG9uUmVhZHlEZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgIGdsb2JhbE9uUmVhZHlMaXN0ZW5lcigpOyAvLyBvbmUgdGltZSBvbmx5XG4gICAgICAgIGdsb2JhbE9uUmVhZHlMaXN0ZW5lciA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIHZhciBnbG9iYWxPbkNoYW5nZUxpc3RlbmVyID0gJHJvb3RTY29wZS4kb24oJyR0cmFuc2xhdGVDaGFuZ2VFbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICRvblJlYWR5RGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICBnbG9iYWxPbkNoYW5nZUxpc3RlbmVyKCk7IC8vIG9uZSB0aW1lIG9ubHlcbiAgICAgICAgZ2xvYmFsT25DaGFuZ2VMaXN0ZW5lciA9IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCRsb2FkZXJGYWN0b3J5KSB7XG5cbiAgICAgICAgLy8gSWYgYXQgbGVhc3Qgb25lIGFzeW5jIGxvYWRlciBpcyBkZWZpbmVkIGFuZCB0aGVyZSBhcmUgbm9cbiAgICAgICAgLy8gKGRlZmF1bHQpIHRyYW5zbGF0aW9ucyBhdmFpbGFibGUgd2Ugc2hvdWxkIHRyeSB0byBsb2FkIHRoZW0uXG4gICAgICAgIGlmIChhbmd1bGFyLmVxdWFscygkdHJhbnNsYXRpb25UYWJsZSwge30pKSB7XG4gICAgICAgICAgaWYgKCR0cmFuc2xhdGUudXNlKCkpIHtcbiAgICAgICAgICAgICR0cmFuc2xhdGUudXNlKCR0cmFuc2xhdGUudXNlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsc28sIGlmIHRoZXJlIGFyZSBhbnkgZmFsbGJhY2sgbGFuZ3VhZ2UgcmVnaXN0ZXJlZCwgd2Ugc3RhcnRcbiAgICAgICAgLy8gbG9hZGluZyB0aGVtIGFzeW5jaHJvbm91c2x5IGFzIHNvb24gYXMgd2UgY2FuLlxuICAgICAgICBpZiAoJGZhbGxiYWNrTGFuZ3VhZ2UgJiYgJGZhbGxiYWNrTGFuZ3VhZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHByb2Nlc3NBc3luY1Jlc3VsdCA9IGZ1bmN0aW9uICh0cmFuc2xhdGlvbikge1xuICAgICAgICAgICAgdHJhbnNsYXRpb25zKHRyYW5zbGF0aW9uLmtleSwgdHJhbnNsYXRpb24udGFibGUpO1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kZW1pdCgnJHRyYW5zbGF0ZUNoYW5nZUVuZCcsIHsgbGFuZ3VhZ2U6IHRyYW5zbGF0aW9uLmtleSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGlvbjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSAkZmFsbGJhY2tMYW5ndWFnZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGZhbGxiYWNrTGFuZ3VhZ2VJZCA9ICRmYWxsYmFja0xhbmd1YWdlW2ldO1xuICAgICAgICAgICAgaWYgKCRmb3JjZUFzeW5jUmVsb2FkRW5hYmxlZCB8fCAhJHRyYW5zbGF0aW9uVGFibGVbZmFsbGJhY2tMYW5ndWFnZUlkXSkge1xuICAgICAgICAgICAgICBsYW5nUHJvbWlzZXNbZmFsbGJhY2tMYW5ndWFnZUlkXSA9IGxvYWRBc3luYyhmYWxsYmFja0xhbmd1YWdlSWQpLnRoZW4ocHJvY2Vzc0FzeW5jUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUuJGVtaXQoJyR0cmFuc2xhdGVSZWFkeScsIHsgbGFuZ3VhZ2U6ICR0cmFuc2xhdGUudXNlKCkgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkdHJhbnNsYXRlO1xuICAgIH1cbiAgXTtcbn1cbiR0cmFuc2xhdGUuJGluamVjdCA9IFsnJFNUT1JBR0VfS0VZJywgJyR3aW5kb3dQcm92aWRlcicsICckdHJhbnNsYXRlU2FuaXRpemF0aW9uUHJvdmlkZXInLCAncGFzY2FscHJlY2h0VHJhbnNsYXRlT3ZlcnJpZGVyJ107XG5cbiR0cmFuc2xhdGUuZGlzcGxheU5hbWUgPSAnZGlzcGxheU5hbWUnO1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZURlZmF1bHRJbnRlcnBvbGF0aW9uXG4gKiBAcmVxdWlyZXMgJGludGVycG9sYXRlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBVc2VzIGFuZ3VsYXIncyBgJGludGVycG9sYXRlYCBzZXJ2aWNlcyB0byBpbnRlcnBvbGF0ZSBzdHJpbmdzIGFnYWluc3Qgc29tZSB2YWx1ZXMuXG4gKlxuICogQmUgYXdhcmUgdG8gY29uZmlndXJlIGEgcHJvcGVyIHNhbml0aXphdGlvbiBzdHJhdGVneS5cbiAqXG4gKiBTZWUgYWxzbzpcbiAqICoge0BsaW5rIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVNhbml0aXphdGlvbn1cbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9ICR0cmFuc2xhdGVEZWZhdWx0SW50ZXJwb2xhdGlvbiBJbnRlcnBvbGF0b3Igc2VydmljZVxuICovXG5hbmd1bGFyLm1vZHVsZSgncGFzY2FscHJlY2h0LnRyYW5zbGF0ZScpLmZhY3RvcnkoJyR0cmFuc2xhdGVEZWZhdWx0SW50ZXJwb2xhdGlvbicsICR0cmFuc2xhdGVEZWZhdWx0SW50ZXJwb2xhdGlvbik7XG5cbmZ1bmN0aW9uICR0cmFuc2xhdGVEZWZhdWx0SW50ZXJwb2xhdGlvbiAoJGludGVycG9sYXRlLCAkdHJhbnNsYXRlU2FuaXRpemF0aW9uKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciAkdHJhbnNsYXRlSW50ZXJwb2xhdG9yID0ge30sXG4gICAgICAkbG9jYWxlLFxuICAgICAgJGlkZW50aWZpZXIgPSAnZGVmYXVsdCc7XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVEZWZhdWx0SW50ZXJwb2xhdGlvbiNzZXRMb2NhbGVcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZURlZmF1bHRJbnRlcnBvbGF0aW9uXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIGN1cnJlbnQgbG9jYWxlICh0aGlzIGlzIGN1cnJlbnRseSBub3QgdXNlIGluIHRoaXMgaW50ZXJwb2xhdGlvbikuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGUgTGFuZ3VhZ2Uga2V5IG9yIGxvY2FsZS5cbiAgICovXG4gICR0cmFuc2xhdGVJbnRlcnBvbGF0b3Iuc2V0TG9jYWxlID0gZnVuY3Rpb24gKGxvY2FsZSkge1xuICAgICRsb2NhbGUgPSBsb2NhbGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVEZWZhdWx0SW50ZXJwb2xhdGlvbiNnZXRJbnRlcnBvbGF0aW9uSWRlbnRpZmllclxuICAgKiBAbWV0aG9kT2YgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlRGVmYXVsdEludGVycG9sYXRpb25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHVybnMgYW4gaWRlbnRpZmllciBmb3IgdGhpcyBpbnRlcnBvbGF0aW9uIHNlcnZpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9ICRpZGVudGlmaWVyXG4gICAqL1xuICAkdHJhbnNsYXRlSW50ZXJwb2xhdG9yLmdldEludGVycG9sYXRpb25JZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAkaWRlbnRpZmllcjtcbiAgfTtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgd2lsbCBiZSByZW1vdmVkIGluIDMuMFxuICAgKiBAc2VlIHtAbGluayBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVTYW5pdGl6YXRpb259XG4gICAqL1xuICAkdHJhbnNsYXRlSW50ZXJwb2xhdG9yLnVzZVNhbml0aXplVmFsdWVTdHJhdGVneSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICR0cmFuc2xhdGVTYW5pdGl6YXRpb24udXNlU3RyYXRlZ3kodmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS4kdHJhbnNsYXRlRGVmYXVsdEludGVycG9sYXRpb24jaW50ZXJwb2xhdGVcbiAgICogQG1ldGhvZE9mIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZURlZmF1bHRJbnRlcnBvbGF0aW9uXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBJbnRlcnBvbGF0ZXMgZ2l2ZW4gc3RyaW5nIGFnYWlucyBnaXZlbiBpbnRlcnBvbGF0ZSBwYXJhbXMgdXNpbmcgYW5ndWxhcnNcbiAgICogYCRpbnRlcnBvbGF0ZWAgc2VydmljZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gaW50ZXJwb2xhdGVkIHN0cmluZy5cbiAgICovXG4gICR0cmFuc2xhdGVJbnRlcnBvbGF0b3IuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBpbnRlcnBvbGF0aW9uUGFyYW1zKSB7XG4gICAgaW50ZXJwb2xhdGlvblBhcmFtcyA9IGludGVycG9sYXRpb25QYXJhbXMgfHwge307XG4gICAgaW50ZXJwb2xhdGlvblBhcmFtcyA9ICR0cmFuc2xhdGVTYW5pdGl6YXRpb24uc2FuaXRpemUoaW50ZXJwb2xhdGlvblBhcmFtcywgJ3BhcmFtcycpO1xuXG4gICAgdmFyIGludGVycG9sYXRlZFRleHQgPSAkaW50ZXJwb2xhdGUoc3RyaW5nKShpbnRlcnBvbGF0aW9uUGFyYW1zKTtcbiAgICBpbnRlcnBvbGF0ZWRUZXh0ID0gJHRyYW5zbGF0ZVNhbml0aXphdGlvbi5zYW5pdGl6ZShpbnRlcnBvbGF0ZWRUZXh0LCAndGV4dCcpO1xuXG4gICAgcmV0dXJuIGludGVycG9sYXRlZFRleHQ7XG4gIH07XG5cbiAgcmV0dXJuICR0cmFuc2xhdGVJbnRlcnBvbGF0b3I7XG59XG4kdHJhbnNsYXRlRGVmYXVsdEludGVycG9sYXRpb24uJGluamVjdCA9IFsnJGludGVycG9sYXRlJywgJyR0cmFuc2xhdGVTYW5pdGl6YXRpb24nXTtcblxuJHRyYW5zbGF0ZURlZmF1bHRJbnRlcnBvbGF0aW9uLmRpc3BsYXlOYW1lID0gJyR0cmFuc2xhdGVEZWZhdWx0SW50ZXJwb2xhdGlvbic7XG5cbmFuZ3VsYXIubW9kdWxlKCdwYXNjYWxwcmVjaHQudHJhbnNsYXRlJykuY29uc3RhbnQoJyRTVE9SQUdFX0tFWScsICdOR19UUkFOU0xBVEVfTEFOR19LRVknKTtcblxuYW5ndWxhci5tb2R1bGUoJ3Bhc2NhbHByZWNodC50cmFuc2xhdGUnKVxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLmRpcmVjdGl2ZTp0cmFuc2xhdGVcbiAqIEByZXF1aXJlcyAkY29tcGlsZVxuICogQHJlcXVpcmVzICRmaWx0ZXJcbiAqIEByZXF1aXJlcyAkaW50ZXJwb2xhdGVcbiAqIEByZXN0cmljdCBBRVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVHJhbnNsYXRlcyBnaXZlbiB0cmFuc2xhdGlvbiBpZCBlaXRoZXIgdGhyb3VnaCBhdHRyaWJ1dGUgb3IgRE9NIGNvbnRlbnQuXG4gKiBJbnRlcm5hbGx5IGl0IHVzZXMgYHRyYW5zbGF0ZWAgZmlsdGVyIHRvIHRyYW5zbGF0ZSB0cmFuc2xhdGlvbiBpZC4gSXQgcG9zc2libGUgdG9cbiAqIHBhc3MgYW4gb3B0aW9uYWwgYHRyYW5zbGF0ZS12YWx1ZXNgIG9iamVjdCBsaXRlcmFsIGFzIHN0cmluZyBpbnRvIHRyYW5zbGF0aW9uIGlkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHJhbnNsYXRlIFRyYW5zbGF0aW9uIGlkIHdoaWNoIGNvdWxkIGJlIGVpdGhlciBzdHJpbmcgb3IgaW50ZXJwb2xhdGVkIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHJhbnNsYXRlLXZhbHVlcyBWYWx1ZXMgdG8gcGFzcyBpbnRvIHRyYW5zbGF0aW9uIGlkLiBDYW4gYmUgcGFzc2VkIGFzIG9iamVjdCBsaXRlcmFsIHN0cmluZyBvciBpbnRlcnBvbGF0ZWQgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmc9fSB0cmFuc2xhdGUtYXR0ci1BVFRSIHRyYW5zbGF0ZSBUcmFuc2xhdGlvbiBpZCBhbmQgcHV0IGl0IGludG8gQVRUUiBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0ge3N0cmluZz19IHRyYW5zbGF0ZS1kZWZhdWx0IHdpbGwgYmUgdXNlZCB1bmxlc3MgdHJhbnNsYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHRyYW5zbGF0ZS1jb21waWxlIChkZWZhdWx0IHRydWUgaWYgcHJlc2VudCkgZGVmaW5lcyBsb2NhbGx5IGFjdGl2YXRpb24gb2Yge0BsaW5rIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVByb3ZpZGVyI21ldGhvZHNfdXNlUG9zdENvbXBpbGluZ31cbiAqXG4gKiBAZXhhbXBsZVxuICAgPGV4YW1wbGUgbW9kdWxlPVwibmdWaWV3XCI+XG4gICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIlRyYW5zbGF0ZUN0cmxcIj5cblxuICAgICAgICA8cHJlIHRyYW5zbGF0ZT1cIlRSQU5TTEFUSU9OX0lEXCI+PC9wcmU+XG4gICAgICAgIDxwcmUgdHJhbnNsYXRlPlRSQU5TTEFUSU9OX0lEPC9wcmU+XG4gICAgICAgIDxwcmUgdHJhbnNsYXRlIHRyYW5zbGF0ZS1hdHRyLXRpdGxlPVwiVFJBTlNMQVRJT05fSURcIj48L3ByZT5cbiAgICAgICAgPHByZSB0cmFuc2xhdGU9XCJ7e3RyYW5zbGF0aW9uSWR9fVwiPjwvcHJlPlxuICAgICAgICA8cHJlIHRyYW5zbGF0ZT57e3RyYW5zbGF0aW9uSWR9fTwvcHJlPlxuICAgICAgICA8cHJlIHRyYW5zbGF0ZT1cIldJVEhfVkFMVUVTXCIgdHJhbnNsYXRlLXZhbHVlcz1cInt2YWx1ZTogNX1cIj48L3ByZT5cbiAgICAgICAgPHByZSB0cmFuc2xhdGUgdHJhbnNsYXRlLXZhbHVlcz1cInt2YWx1ZTogNX1cIj5XSVRIX1ZBTFVFUzwvcHJlPlxuICAgICAgICA8cHJlIHRyYW5zbGF0ZT1cIldJVEhfVkFMVUVTXCIgdHJhbnNsYXRlLXZhbHVlcz1cInt7dmFsdWVzfX1cIj48L3ByZT5cbiAgICAgICAgPHByZSB0cmFuc2xhdGUgdHJhbnNsYXRlLXZhbHVlcz1cInt7dmFsdWVzfX1cIj5XSVRIX1ZBTFVFUzwvcHJlPlxuICAgICAgICA8cHJlIHRyYW5zbGF0ZSB0cmFuc2xhdGUtYXR0ci10aXRsZT1cIldJVEhfVkFMVUVTXCIgdHJhbnNsYXRlLXZhbHVlcz1cInt7dmFsdWVzfX1cIj48L3ByZT5cblxuICAgICAgPC9kaXY+XG4gICAgPC9maWxlPlxuICAgIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cbiAgICAgIGFuZ3VsYXIubW9kdWxlKCduZ1ZpZXcnLCBbJ3Bhc2NhbHByZWNodC50cmFuc2xhdGUnXSlcblxuICAgICAgLmNvbmZpZyhmdW5jdGlvbiAoJHRyYW5zbGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAgICAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnZW4nLHtcbiAgICAgICAgICAnVFJBTlNMQVRJT05fSUQnOiAnSGVsbG8gdGhlcmUhJyxcbiAgICAgICAgICAnV0lUSF9WQUxVRVMnOiAnVGhlIGZvbGxvd2luZyB2YWx1ZSBpcyBkeW5hbWljOiB7e3ZhbHVlfX0nXG4gICAgICAgIH0pLnByZWZlcnJlZExhbmd1YWdlKCdlbicpO1xuXG4gICAgICB9KTtcblxuICAgICAgYW5ndWxhci5tb2R1bGUoJ25nVmlldycpLmNvbnRyb2xsZXIoJ1RyYW5zbGF0ZUN0cmwnLCBmdW5jdGlvbiAoJHNjb3BlKSB7XG4gICAgICAgICRzY29wZS50cmFuc2xhdGlvbklkID0gJ1RSQU5TTEFUSU9OX0lEJztcblxuICAgICAgICAkc2NvcGUudmFsdWVzID0ge1xuICAgICAgICAgIHZhbHVlOiA3OFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgPC9maWxlPlxuICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxuICAgICAgaXQoJ3Nob3VsZCB0cmFuc2xhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluamVjdChmdW5jdGlvbiAoJHJvb3RTY29wZSwgJGNvbXBpbGUpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLnRyYW5zbGF0aW9uSWQgPSAnVFJBTlNMQVRJT05fSUQnO1xuXG4gICAgICAgICAgZWxlbWVudCA9ICRjb21waWxlKCc8cCB0cmFuc2xhdGU9XCJUUkFOU0xBVElPTl9JRFwiPjwvcD4nKSgkcm9vdFNjb3BlKTtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudC50ZXh0KCkpLnRvQmUoJ0hlbGxvIHRoZXJlIScpO1xuXG4gICAgICAgICAgZWxlbWVudCA9ICRjb21waWxlKCc8cCB0cmFuc2xhdGU9XCJ7e3RyYW5zbGF0aW9uSWR9fVwiPjwvcD4nKSgkcm9vdFNjb3BlKTtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudC50ZXh0KCkpLnRvQmUoJ0hlbGxvIHRoZXJlIScpO1xuXG4gICAgICAgICAgZWxlbWVudCA9ICRjb21waWxlKCc8cCB0cmFuc2xhdGU+VFJBTlNMQVRJT05fSUQ8L3A+JykoJHJvb3RTY29wZSk7XG4gICAgICAgICAgJHJvb3RTY29wZS4kZGlnZXN0KCk7XG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQudGV4dCgpKS50b0JlKCdIZWxsbyB0aGVyZSEnKTtcblxuICAgICAgICAgIGVsZW1lbnQgPSAkY29tcGlsZSgnPHAgdHJhbnNsYXRlPnt7dHJhbnNsYXRpb25JZH19PC9wPicpKCRyb290U2NvcGUpO1xuICAgICAgICAgICRyb290U2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgIGV4cGVjdChlbGVtZW50LnRleHQoKSkudG9CZSgnSGVsbG8gdGhlcmUhJyk7XG5cbiAgICAgICAgICBlbGVtZW50ID0gJGNvbXBpbGUoJzxwIHRyYW5zbGF0ZSB0cmFuc2xhdGUtYXR0ci10aXRsZT1cIlRSQU5TTEFUSU9OX0lEXCI+PC9wPicpKCRyb290U2NvcGUpO1xuICAgICAgICAgICRyb290U2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgIGV4cGVjdChlbGVtZW50LmF0dHIoJ3RpdGxlJykpLnRvQmUoJ0hlbGxvIHRoZXJlIScpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIDwvZmlsZT5cbiAgIDwvZXhhbXBsZT5cbiAqL1xuLmRpcmVjdGl2ZSgndHJhbnNsYXRlJywgdHJhbnNsYXRlRGlyZWN0aXZlKTtcbmZ1bmN0aW9uIHRyYW5zbGF0ZURpcmVjdGl2ZSgkdHJhbnNsYXRlLCAkcSwgJGludGVycG9sYXRlLCAkY29tcGlsZSwgJHBhcnNlLCAkcm9vdFNjb3BlKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAbmFtZSB0cmltXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiB0cmltIHBvbHlmaWxsXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzdHJpbmcgc3RyaXBwZWQgb2Ygd2hpdGVzcGFjZSBmcm9tIGJvdGggZW5kc1xuICAgKi9cbiAgdmFyIHRyaW0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQUUnLFxuICAgIHNjb3BlOiB0cnVlLFxuICAgIHByaW9yaXR5OiAkdHJhbnNsYXRlLmRpcmVjdGl2ZVByaW9yaXR5KCksXG4gICAgY29tcGlsZTogZnVuY3Rpb24gKHRFbGVtZW50LCB0QXR0cikge1xuXG4gICAgICB2YXIgdHJhbnNsYXRlVmFsdWVzRXhpc3QgPSAodEF0dHIudHJhbnNsYXRlVmFsdWVzKSA/XG4gICAgICAgIHRBdHRyLnRyYW5zbGF0ZVZhbHVlcyA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIHRyYW5zbGF0ZUludGVycG9sYXRpb24gPSAodEF0dHIudHJhbnNsYXRlSW50ZXJwb2xhdGlvbikgP1xuICAgICAgICB0QXR0ci50cmFuc2xhdGVJbnRlcnBvbGF0aW9uIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgdHJhbnNsYXRlVmFsdWVFeGlzdCA9IHRFbGVtZW50WzBdLm91dGVySFRNTC5tYXRjaCgvdHJhbnNsYXRlLXZhbHVlLSsvaSk7XG5cbiAgICAgIHZhciBpbnRlcnBvbGF0ZVJlZ0V4cCA9ICdeKC4qKSgnICsgJGludGVycG9sYXRlLnN0YXJ0U3ltYm9sKCkgKyAnLionICsgJGludGVycG9sYXRlLmVuZFN5bWJvbCgpICsgJykoLiopJyxcbiAgICAgICAgICB3YXRjaGVyUmVnRXhwID0gJ14oLiopJyArICRpbnRlcnBvbGF0ZS5zdGFydFN5bWJvbCgpICsgJyguKiknICsgJGludGVycG9sYXRlLmVuZFN5bWJvbCgpICsgJyguKiknO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gbGlua0ZuKHNjb3BlLCBpRWxlbWVudCwgaUF0dHIpIHtcblxuICAgICAgICBzY29wZS5pbnRlcnBvbGF0ZVBhcmFtcyA9IHt9O1xuICAgICAgICBzY29wZS5wcmVUZXh0ID0gJyc7XG4gICAgICAgIHNjb3BlLnBvc3RUZXh0ID0gJyc7XG4gICAgICAgIHNjb3BlLnRyYW5zbGF0ZU5hbWVzcGFjZSA9IGdldFRyYW5zbGF0ZU5hbWVzcGFjZShzY29wZSk7XG4gICAgICAgIHZhciB0cmFuc2xhdGlvbklkcyA9IHt9O1xuXG4gICAgICAgIHZhciBpbml0SW50ZXJwb2xhdGlvblBhcmFtcyA9IGZ1bmN0aW9uIChpbnRlcnBvbGF0ZVBhcmFtcywgaUF0dHIsIHRBdHRyKSB7XG4gICAgICAgICAgLy8gaW5pdGlhbCBzZXR1cFxuICAgICAgICAgIGlmIChpQXR0ci50cmFuc2xhdGVWYWx1ZXMpIHtcbiAgICAgICAgICAgIGFuZ3VsYXIuZXh0ZW5kKGludGVycG9sYXRlUGFyYW1zLCAkcGFyc2UoaUF0dHIudHJhbnNsYXRlVmFsdWVzKShzY29wZS4kcGFyZW50KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGluaXRpYWxseSBmZXRjaCBhbGwgYXR0cmlidXRlcyBpZiBleGlzdGluZyBhbmQgZmlsbCB0aGUgcGFyYW1zXG4gICAgICAgICAgaWYgKHRyYW5zbGF0ZVZhbHVlRXhpc3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gdEF0dHIpIHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpQXR0ciwgYXR0cikgJiYgYXR0ci5zdWJzdHIoMCwgMTQpID09PSAndHJhbnNsYXRlVmFsdWUnICYmIGF0dHIgIT09ICd0cmFuc2xhdGVWYWx1ZXMnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBhbmd1bGFyLmxvd2VyY2FzZShhdHRyLnN1YnN0cigxNCwgMSkpICsgYXR0ci5zdWJzdHIoMTUpO1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlUGFyYW1zW2F0dHJpYnV0ZU5hbWVdID0gdEF0dHJbYXR0cl07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRW5zdXJlcyBhbnkgY2hhbmdlIG9mIHRoZSBhdHRyaWJ1dGUgXCJ0cmFuc2xhdGVcIiBjb250YWluaW5nIHRoZSBpZCB3aWxsXG4gICAgICAgIC8vIGJlIHJlLXN0b3JlZCB0byB0aGUgc2NvcGUncyBcInRyYW5zbGF0aW9uSWRcIi5cbiAgICAgICAgLy8gSWYgdGhlIGF0dHJpYnV0ZSBoYXMgbm8gY29udGVudCwgdGhlIGVsZW1lbnQncyB0ZXh0IHZhbHVlICh3aGl0ZSBzcGFjZXMgdHJpbW1lZCBvZmYpIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgdmFyIG9ic2VydmVFbGVtZW50VHJhbnNsYXRpb24gPSBmdW5jdGlvbiAodHJhbnNsYXRpb25JZCkge1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIGFueSBvbGQgd2F0Y2hlclxuICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24ob2JzZXJ2ZUVsZW1lbnRUcmFuc2xhdGlvbi5fdW53YXRjaE9sZCkpIHtcbiAgICAgICAgICAgIG9ic2VydmVFbGVtZW50VHJhbnNsYXRpb24uX3Vud2F0Y2hPbGQoKTtcbiAgICAgICAgICAgIG9ic2VydmVFbGVtZW50VHJhbnNsYXRpb24uX3Vud2F0Y2hPbGQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFuZ3VsYXIuZXF1YWxzKHRyYW5zbGF0aW9uSWQgLCAnJykgfHwgIWFuZ3VsYXIuaXNEZWZpbmVkKHRyYW5zbGF0aW9uSWQpKSB7XG4gICAgICAgICAgICB2YXIgaUVsZW1lbnRUZXh0ID0gdHJpbS5hcHBseShpRWxlbWVudC50ZXh0KCkpO1xuXG4gICAgICAgICAgICAvLyBSZXNvbHZlIHRyYW5zbGF0aW9uIGlkIGJ5IGlubmVyIGh0bWwgaWYgcmVxdWlyZWRcbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0ZU1hdGNoZXMgPSBpRWxlbWVudFRleHQubWF0Y2goaW50ZXJwb2xhdGVSZWdFeHApO1xuICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGUgdHJhbnNsYXRpb24gaWQgaWYgcmVxdWlyZWRcbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzQXJyYXkoaW50ZXJwb2xhdGVNYXRjaGVzKSkge1xuICAgICAgICAgICAgICBzY29wZS5wcmVUZXh0ID0gaW50ZXJwb2xhdGVNYXRjaGVzWzFdO1xuICAgICAgICAgICAgICBzY29wZS5wb3N0VGV4dCA9IGludGVycG9sYXRlTWF0Y2hlc1szXTtcbiAgICAgICAgICAgICAgdHJhbnNsYXRpb25JZHMudHJhbnNsYXRlID0gJGludGVycG9sYXRlKGludGVycG9sYXRlTWF0Y2hlc1syXSkoc2NvcGUuJHBhcmVudCk7XG4gICAgICAgICAgICAgIHZhciB3YXRjaGVyTWF0Y2hlcyA9IGlFbGVtZW50VGV4dC5tYXRjaCh3YXRjaGVyUmVnRXhwKTtcbiAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNBcnJheSh3YXRjaGVyTWF0Y2hlcykgJiYgd2F0Y2hlck1hdGNoZXNbMl0gJiYgd2F0Y2hlck1hdGNoZXNbMl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZUVsZW1lbnRUcmFuc2xhdGlvbi5fdW53YXRjaE9sZCA9IHNjb3BlLiR3YXRjaCh3YXRjaGVyTWF0Y2hlc1syXSwgZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbklkcy50cmFuc2xhdGUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZVRyYW5zbGF0aW9ucygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBkbyBub3QgYXNzaWduZSB0aGUgdHJhbnNsYXRpb24gaWQgaWYgaXQgaXMgZW1wdHkuXG4gICAgICAgICAgICAgIHRyYW5zbGF0aW9uSWRzLnRyYW5zbGF0ZSA9ICFpRWxlbWVudFRleHQgPyB1bmRlZmluZWQgOiBpRWxlbWVudFRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uSWRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0aW9uSWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVRyYW5zbGF0aW9ucygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvYnNlcnZlQXR0cmlidXRlVHJhbnNsYXRpb24gPSBmdW5jdGlvbiAodHJhbnNsYXRlQXR0cikge1xuICAgICAgICAgIGlBdHRyLiRvYnNlcnZlKHRyYW5zbGF0ZUF0dHIsIGZ1bmN0aW9uICh0cmFuc2xhdGlvbklkKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGlvbklkc1t0cmFuc2xhdGVBdHRyXSA9IHRyYW5zbGF0aW9uSWQ7XG4gICAgICAgICAgICB1cGRhdGVUcmFuc2xhdGlvbnMoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBpbml0aWFsIHNldHVwIHdpdGggdmFsdWVzXG4gICAgICAgIGluaXRJbnRlcnBvbGF0aW9uUGFyYW1zKHNjb3BlLmludGVycG9sYXRlUGFyYW1zLCBpQXR0ciwgdEF0dHIpO1xuXG4gICAgICAgIHZhciBmaXJzdEF0dHJpYnV0ZUNoYW5nZWRFdmVudCA9IHRydWU7XG4gICAgICAgIGlBdHRyLiRvYnNlcnZlKCd0cmFuc2xhdGUnLCBmdW5jdGlvbiAodHJhbnNsYXRpb25JZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHJhbnNsYXRpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGNhc2Ugb2YgZWxlbWVudCBcIjx0cmFuc2xhdGU+eHl6PC90cmFuc2xhdGU+XCJcbiAgICAgICAgICAgIG9ic2VydmVFbGVtZW50VHJhbnNsYXRpb24oJycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjYXNlIG9mIHJlZ3VsYXIgYXR0cmlidXRlXG4gICAgICAgICAgICBpZiAodHJhbnNsYXRpb25JZCAhPT0gJycgfHwgIWZpcnN0QXR0cmlidXRlQ2hhbmdlZEV2ZW50KSB7XG4gICAgICAgICAgICAgIHRyYW5zbGF0aW9uSWRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0aW9uSWQ7XG4gICAgICAgICAgICAgIHVwZGF0ZVRyYW5zbGF0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmaXJzdEF0dHJpYnV0ZUNoYW5nZWRFdmVudCA9IGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciB0cmFuc2xhdGVBdHRyIGluIGlBdHRyKSB7XG4gICAgICAgICAgaWYgKGlBdHRyLmhhc093blByb3BlcnR5KHRyYW5zbGF0ZUF0dHIpICYmIHRyYW5zbGF0ZUF0dHIuc3Vic3RyKDAsIDEzKSA9PT0gJ3RyYW5zbGF0ZUF0dHInKSB7XG4gICAgICAgICAgICBvYnNlcnZlQXR0cmlidXRlVHJhbnNsYXRpb24odHJhbnNsYXRlQXR0cik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaUF0dHIuJG9ic2VydmUoJ3RyYW5zbGF0ZURlZmF1bHQnLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBzY29wZS5kZWZhdWx0VGV4dCA9IHZhbHVlO1xuICAgICAgICAgIHVwZGF0ZVRyYW5zbGF0aW9ucygpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodHJhbnNsYXRlVmFsdWVzRXhpc3QpIHtcbiAgICAgICAgICBpQXR0ci4kb2JzZXJ2ZSgndHJhbnNsYXRlVmFsdWVzJywgZnVuY3Rpb24gKGludGVycG9sYXRlUGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJwb2xhdGVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZXh0ZW5kKHNjb3BlLmludGVycG9sYXRlUGFyYW1zLCAkcGFyc2UoaW50ZXJwb2xhdGVQYXJhbXMpKHNjb3BlLiRwYXJlbnQpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNsYXRlVmFsdWVFeGlzdCkge1xuICAgICAgICAgIHZhciBvYnNlcnZlVmFsdWVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICAgIGlBdHRyLiRvYnNlcnZlKGF0dHJOYW1lLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBhbmd1bGFyLmxvd2VyY2FzZShhdHRyTmFtZS5zdWJzdHIoMTQsIDEpKSArIGF0dHJOYW1lLnN1YnN0cigxNSk7XG4gICAgICAgICAgICAgIHNjb3BlLmludGVycG9sYXRlUGFyYW1zW2F0dHJpYnV0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gaUF0dHIpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaUF0dHIsIGF0dHIpICYmIGF0dHIuc3Vic3RyKDAsIDE0KSA9PT0gJ3RyYW5zbGF0ZVZhbHVlJyAmJiBhdHRyICE9PSAndHJhbnNsYXRlVmFsdWVzJykge1xuICAgICAgICAgICAgICBvYnNlcnZlVmFsdWVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFzdGVyIHVwZGF0ZSBmdW5jdGlvblxuICAgICAgICB2YXIgdXBkYXRlVHJhbnNsYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0cmFuc2xhdGlvbklkcykge1xuXG4gICAgICAgICAgICBpZiAodHJhbnNsYXRpb25JZHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0cmFuc2xhdGlvbklkc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdXBkYXRlVHJhbnNsYXRpb24oa2V5LCB0cmFuc2xhdGlvbklkc1trZXldLCBzY29wZSwgc2NvcGUuaW50ZXJwb2xhdGVQYXJhbXMsIHNjb3BlLmRlZmF1bHRUZXh0LCBzY29wZS50cmFuc2xhdGVOYW1lc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdXQgdHJhbnNsYXRpb24gcHJvY2Vzc2luZyBmdW5jdGlvbiBvdXRzaWRlIGxvb3BcbiAgICAgICAgdmFyIHVwZGF0ZVRyYW5zbGF0aW9uID0gZnVuY3Rpb24odHJhbnNsYXRlQXR0ciwgdHJhbnNsYXRpb25JZCwgc2NvcGUsIGludGVycG9sYXRlUGFyYW1zLCBkZWZhdWx0VHJhbnNsYXRpb25UZXh0LCB0cmFuc2xhdGVOYW1lc3BhY2UpIHtcbiAgICAgICAgICBpZiAodHJhbnNsYXRpb25JZCkge1xuICAgICAgICAgICAgLy8gaWYgdHJhbnNsYXRpb24gaWQgc3RhcnRzIHdpdGggJy4nIGFuZCB0cmFuc2xhdGVOYW1lc3BhY2UgZ2l2ZW4sIHByZXBlbmQgbmFtZXNwYWNlXG4gICAgICAgICAgICBpZiAodHJhbnNsYXRlTmFtZXNwYWNlICYmIHRyYW5zbGF0aW9uSWQuY2hhckF0KDApID09PSAnLicpIHtcbiAgICAgICAgICAgICAgdHJhbnNsYXRpb25JZCA9IHRyYW5zbGF0ZU5hbWVzcGFjZSArIHRyYW5zbGF0aW9uSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICR0cmFuc2xhdGUodHJhbnNsYXRpb25JZCwgaW50ZXJwb2xhdGVQYXJhbXMsIHRyYW5zbGF0ZUludGVycG9sYXRpb24sIGRlZmF1bHRUcmFuc2xhdGlvblRleHQsIHNjb3BlLnRyYW5zbGF0ZUxhbmd1YWdlKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgICAgICBhcHBseVRyYW5zbGF0aW9uKHRyYW5zbGF0aW9uLCBzY29wZSwgdHJ1ZSwgdHJhbnNsYXRlQXR0cik7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0cmFuc2xhdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlUcmFuc2xhdGlvbih0cmFuc2xhdGlvbklkLCBzY29wZSwgZmFsc2UsIHRyYW5zbGF0ZUF0dHIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYXMgYW4gZW1wdHkgc3RyaW5nIGNhbm5vdCBiZSB0cmFuc2xhdGVkLCB3ZSBjYW4gc29sdmUgdGhpcyB1c2luZyBzdWNjZXNzZnVsPWZhbHNlXG4gICAgICAgICAgICBhcHBseVRyYW5zbGF0aW9uKHRyYW5zbGF0aW9uSWQsIHNjb3BlLCBmYWxzZSwgdHJhbnNsYXRlQXR0cik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhcHBseVRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzY29wZSwgc3VjY2Vzc2Z1bCwgdHJhbnNsYXRlQXR0cikge1xuICAgICAgICAgIGlmICh0cmFuc2xhdGVBdHRyID09PSAndHJhbnNsYXRlJykge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCB0cmFuc2xhdGUgaW50byBpbm5lckhUTUxcbiAgICAgICAgICAgIGlmICghc3VjY2Vzc2Z1bCAmJiB0eXBlb2Ygc2NvcGUuZGVmYXVsdFRleHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gc2NvcGUuZGVmYXVsdFRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpRWxlbWVudC5lbXB0eSgpLmFwcGVuZChzY29wZS5wcmVUZXh0ICsgdmFsdWUgKyBzY29wZS5wb3N0VGV4dCk7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsbHlFbmFibGVkID0gJHRyYW5zbGF0ZS5pc1Bvc3RDb21waWxpbmdFbmFibGVkKCk7XG4gICAgICAgICAgICB2YXIgbG9jYWxseURlZmluZWQgPSB0eXBlb2YgdEF0dHIudHJhbnNsYXRlQ29tcGlsZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICB2YXIgbG9jYWxseUVuYWJsZWQgPSBsb2NhbGx5RGVmaW5lZCAmJiB0QXR0ci50cmFuc2xhdGVDb21waWxlICE9PSAnZmFsc2UnO1xuICAgICAgICAgICAgaWYgKChnbG9iYWxseUVuYWJsZWQgJiYgIWxvY2FsbHlEZWZpbmVkKSB8fCBsb2NhbGx5RW5hYmxlZCkge1xuICAgICAgICAgICAgICAkY29tcGlsZShpRWxlbWVudC5jb250ZW50cygpKShzY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGlmICghc3VjY2Vzc2Z1bCAmJiB0eXBlb2Ygc2NvcGUuZGVmYXVsdFRleHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gc2NvcGUuZGVmYXVsdFRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IGlBdHRyLiRhdHRyW3RyYW5zbGF0ZUF0dHJdO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUuc3Vic3RyKDAsIDUpID09PSAnZGF0YS0nKSB7XG4gICAgICAgICAgICAgIC8vIGVuc3VyZSBodG1sNSBkYXRhIHByZWZpeCBpcyBzdHJpcHBlZFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZS5zdWJzdHIoNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZS5zdWJzdHIoMTUpO1xuICAgICAgICAgICAgaUVsZW1lbnQuYXR0cihhdHRyaWJ1dGVOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0cmFuc2xhdGVWYWx1ZXNFeGlzdCB8fCB0cmFuc2xhdGVWYWx1ZUV4aXN0IHx8IGlBdHRyLnRyYW5zbGF0ZURlZmF1bHQpIHtcbiAgICAgICAgICBzY29wZS4kd2F0Y2goJ2ludGVycG9sYXRlUGFyYW1zJywgdXBkYXRlVHJhbnNsYXRpb25zLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBzY29wZS4kd2F0Y2goJ3RyYW5zbGF0ZUxhbmd1YWdlJywgdXBkYXRlVHJhbnNsYXRpb25zKTtcblxuICAgICAgICAvLyBFbnN1cmVzIHRoZSB0ZXh0IHdpbGwgYmUgcmVmcmVzaGVkIGFmdGVyIHRoZSBjdXJyZW50IGxhbmd1YWdlIHdhcyBjaGFuZ2VkXG4gICAgICAgIC8vIHcvICR0cmFuc2xhdGUudXNlKC4uLilcbiAgICAgICAgdmFyIHVuYmluZCA9ICRyb290U2NvcGUuJG9uKCckdHJhbnNsYXRlQ2hhbmdlU3VjY2VzcycsIHVwZGF0ZVRyYW5zbGF0aW9ucyk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRyYW5zbGF0aW9uIHdpbGwgYmUgbG9va2VkIHVwIGF0IGxlYXN0IG9uZVxuICAgICAgICBpZiAoaUVsZW1lbnQudGV4dCgpLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChpQXR0ci50cmFuc2xhdGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVFbGVtZW50VHJhbnNsYXRpb24oaUF0dHIudHJhbnNsYXRlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JzZXJ2ZUVsZW1lbnRUcmFuc2xhdGlvbignJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlBdHRyLnRyYW5zbGF0ZSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBhdHRyaWJ1dGUgd2lsbCBiZSBub3Qgc2tpcHBlZFxuICAgICAgICAgIG9ic2VydmVFbGVtZW50VHJhbnNsYXRpb24oaUF0dHIudHJhbnNsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVUcmFuc2xhdGlvbnMoKTtcbiAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIHVuYmluZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbnRyYW5zbGF0ZURpcmVjdGl2ZS4kaW5qZWN0ID0gWyckdHJhbnNsYXRlJywgJyRxJywgJyRpbnRlcnBvbGF0ZScsICckY29tcGlsZScsICckcGFyc2UnLCAnJHJvb3RTY29wZSddO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjb3BlJ3MgbmFtZXNwYWNlLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBzY29wZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNsYXRlTmFtZXNwYWNlKHNjb3BlKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgaWYgKHNjb3BlLnRyYW5zbGF0ZU5hbWVzcGFjZSkge1xuICAgIHJldHVybiBzY29wZS50cmFuc2xhdGVOYW1lc3BhY2U7XG4gIH1cbiAgaWYgKHNjb3BlLiRwYXJlbnQpIHtcbiAgICByZXR1cm4gZ2V0VHJhbnNsYXRlTmFtZXNwYWNlKHNjb3BlLiRwYXJlbnQpO1xuICB9XG59XG5cbnRyYW5zbGF0ZURpcmVjdGl2ZS5kaXNwbGF5TmFtZSA9ICd0cmFuc2xhdGVEaXJlY3RpdmUnO1xuXG5hbmd1bGFyLm1vZHVsZSgncGFzY2FscHJlY2h0LnRyYW5zbGF0ZScpXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuZGlyZWN0aXZlOnRyYW5zbGF0ZUNsb2FrXG4gKiBAcmVxdWlyZXMgJHJvb3RTY29wZVxuICogQHJlcXVpcmVzICR0cmFuc2xhdGVcbiAqIEByZXN0cmljdCBBXG4gKlxuICogJGRlc2NyaXB0aW9uXG4gKiBBZGRzIGEgYHRyYW5zbGF0ZS1jbG9ha2AgY2xhc3MgbmFtZSB0byB0aGUgZ2l2ZW4gZWxlbWVudCB3aGVyZSB0aGlzIGRpcmVjdGl2ZVxuICogaXMgYXBwbGllZCBpbml0aWFsbHkgYW5kIHJlbW92ZXMgaXQsIG9uY2UgYSBsb2FkZXIgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIHVzZWQgdG8gcHJldmVudCBpbml0aWFsIGZsaWNrZXJpbmcgd2hlbiBsb2FkaW5nIHRyYW5zbGF0aW9uXG4gKiBkYXRhIGFzeW5jaHJvbm91c2x5LlxuICpcbiAqIFRoZSBjbGFzcyBuYW1lIGlzIGRlZmluZWQgaW5cbiAqIHtAbGluayBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGVQcm92aWRlciNjbG9ha0NsYXNzTmFtZSAkdHJhbnNsYXRlLmNsb2FrQ2xhc3NOYW1lKCl9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHJhbnNsYXRlLWNsb2FrIElmIGEgdHJhbnNsYXRpb25JZCBpcyBwcm92aWRlZCwgaXQgd2lsbCBiZSB1c2VkIGZvciBzaG93aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBoaWRpbmcgdGhlIGNsb2FrLiBCYXNpY2FsbHkgaXQgcmVsaWVzIG9uIHRoZSB0cmFuc2xhdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZS5cbiAqL1xuLmRpcmVjdGl2ZSgndHJhbnNsYXRlQ2xvYWsnLCB0cmFuc2xhdGVDbG9ha0RpcmVjdGl2ZSk7XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUNsb2FrRGlyZWN0aXZlKCR0cmFuc2xhdGUsICRyb290U2NvcGUpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgcmV0dXJuIHtcbiAgICBjb21waWxlOiBmdW5jdGlvbiAodEVsZW1lbnQpIHtcbiAgICAgIHZhciBhcHBseUNsb2FrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0RWxlbWVudC5hZGRDbGFzcygkdHJhbnNsYXRlLmNsb2FrQ2xhc3NOYW1lKCkpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsb2FrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0RWxlbWVudC5yZW1vdmVDbGFzcygkdHJhbnNsYXRlLmNsb2FrQ2xhc3NOYW1lKCkpO1xuICAgICAgfTtcbiAgICAgICR0cmFuc2xhdGUub25SZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZUNsb2FrKCk7XG4gICAgICB9KTtcbiAgICAgIGFwcGx5Q2xvYWsoKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxpbmtGbihzY29wZSwgaUVsZW1lbnQsIGlBdHRyKSB7XG4gICAgICAgIGlmIChpQXR0ci50cmFuc2xhdGVDbG9hayAmJiBpQXR0ci50cmFuc2xhdGVDbG9hay5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBSZWdpc3RlciBhIHdhdGNoZXIgZm9yIHRoZSBkZWZpbmVkIHRyYW5zbGF0aW9uIGFsbG93aW5nIGEgZmluZSB0dW5lZCBjbG9ha1xuICAgICAgICAgIGlBdHRyLiRvYnNlcnZlKCd0cmFuc2xhdGVDbG9haycsIGZ1bmN0aW9uICh0cmFuc2xhdGlvbklkKSB7XG4gICAgICAgICAgICAkdHJhbnNsYXRlKHRyYW5zbGF0aW9uSWQpLnRoZW4ocmVtb3ZlQ2xvYWssIGFwcGx5Q2xvYWspO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFJlZ2lzdGVyIGZvciBjaGFuZ2UgZXZlbnRzIGFzIHRoaXMgaXMgYmVpbmcgYW5vdGhlciBpbmRpY2ljYXRvciByZXZhbGlkYXRpbmcgdGhlIGNsb2FrKVxuICAgICAgICAgICRyb290U2NvcGUuJG9uKCckdHJhbnNsYXRlQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICR0cmFuc2xhdGUoaUF0dHIudHJhbnNsYXRlQ2xvYWspLnRoZW4ocmVtb3ZlQ2xvYWssIGFwcGx5Q2xvYWspO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbnRyYW5zbGF0ZUNsb2FrRGlyZWN0aXZlLiRpbmplY3QgPSBbJyR0cmFuc2xhdGUnLCAnJHJvb3RTY29wZSddO1xuXG50cmFuc2xhdGVDbG9ha0RpcmVjdGl2ZS5kaXNwbGF5TmFtZSA9ICd0cmFuc2xhdGVDbG9ha0RpcmVjdGl2ZSc7XG5cbmFuZ3VsYXIubW9kdWxlKCdwYXNjYWxwcmVjaHQudHJhbnNsYXRlJylcbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgcGFzY2FscHJlY2h0LnRyYW5zbGF0ZS5kaXJlY3RpdmU6dHJhbnNsYXRlTmFtZXNwYWNlXG4gKiBAcmVzdHJpY3QgQVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVHJhbnNsYXRlcyBnaXZlbiB0cmFuc2xhdGlvbiBpZCBlaXRoZXIgdGhyb3VnaCBhdHRyaWJ1dGUgb3IgRE9NIGNvbnRlbnQuXG4gKiBJbnRlcm5hbGx5IGl0IHVzZXMgYHRyYW5zbGF0ZWAgZmlsdGVyIHRvIHRyYW5zbGF0ZSB0cmFuc2xhdGlvbiBpZC4gSXQgcG9zc2libGUgdG9cbiAqIHBhc3MgYW4gb3B0aW9uYWwgYHRyYW5zbGF0ZS12YWx1ZXNgIG9iamVjdCBsaXRlcmFsIGFzIHN0cmluZyBpbnRvIHRyYW5zbGF0aW9uIGlkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHJhbnNsYXRlIG5hbWVzcGFjZSBuYW1lIHdoaWNoIGNvdWxkIGJlIGVpdGhlciBzdHJpbmcgb3IgaW50ZXJwb2xhdGVkIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICAgPGV4YW1wbGUgbW9kdWxlPVwibmdWaWV3XCI+XG4gICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICAgIDxkaXYgdHJhbnNsYXRlLW5hbWVzcGFjZT1cIkNPTlRFTlRcIj5cblxuICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGgxIHRyYW5zbGF0ZT4uSEVBREVSUy5USVRMRTwvaDE+XG4gICAgICAgICAgICA8aDEgdHJhbnNsYXRlPi5IRUFERVJTLldFTENPTUU8L2gxPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IHRyYW5zbGF0ZS1uYW1lc3BhY2U9XCIuSEVBREVSU1wiPlxuICAgICAgICAgICAgPGgxIHRyYW5zbGF0ZT4uVElUTEU8L2gxPlxuICAgICAgICAgICAgPGgxIHRyYW5zbGF0ZT4uV0VMQ09NRTwvaDE+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICA8L2Rpdj5cbiAgICA8L2ZpbGU+XG4gICAgPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxuICAgICAgYW5ndWxhci5tb2R1bGUoJ25nVmlldycsIFsncGFzY2FscHJlY2h0LnRyYW5zbGF0ZSddKVxuXG4gICAgICAuY29uZmlnKGZ1bmN0aW9uICgkdHJhbnNsYXRlUHJvdmlkZXIpIHtcblxuICAgICAgICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdlbicse1xuICAgICAgICAgICdUUkFOU0xBVElPTl9JRCc6ICdIZWxsbyB0aGVyZSEnLFxuICAgICAgICAgICdDT05URU5UJzoge1xuICAgICAgICAgICAgJ0hFQURFUlMnOiB7XG4gICAgICAgICAgICAgICAgVElUTEU6ICdUaXRsZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgICdDT05URU5ULkhFQURFUlMuV0VMQ09NRSc6ICdXZWxjb21lJ1xuICAgICAgICB9KS5wcmVmZXJyZWRMYW5ndWFnZSgnZW4nKTtcblxuICAgICAgfSk7XG5cbiAgICA8L2ZpbGU+XG4gICA8L2V4YW1wbGU+XG4gKi9cbi5kaXJlY3RpdmUoJ3RyYW5zbGF0ZU5hbWVzcGFjZScsIHRyYW5zbGF0ZU5hbWVzcGFjZURpcmVjdGl2ZSk7XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZU5hbWVzcGFjZURpcmVjdGl2ZSgpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHNjb3BlOiB0cnVlLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZTogZnVuY3Rpb24gKHNjb3BlLCBpRWxlbWVudCwgaUF0dHJzKSB7XG4gICAgICAgICAgc2NvcGUudHJhbnNsYXRlTmFtZXNwYWNlID0gZ2V0VHJhbnNsYXRlTmFtZXNwYWNlKHNjb3BlKTtcblxuICAgICAgICAgIGlmIChzY29wZS50cmFuc2xhdGVOYW1lc3BhY2UgJiYgaUF0dHJzLnRyYW5zbGF0ZU5hbWVzcGFjZS5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgICAgc2NvcGUudHJhbnNsYXRlTmFtZXNwYWNlICs9IGlBdHRycy50cmFuc2xhdGVOYW1lc3BhY2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjb3BlLnRyYW5zbGF0ZU5hbWVzcGFjZSA9IGlBdHRycy50cmFuc2xhdGVOYW1lc3BhY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY29wZSdzIG5hbWVzcGFjZS5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gc2NvcGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFRyYW5zbGF0ZU5hbWVzcGFjZShzY29wZSkge1xuICAndXNlIHN0cmljdCc7XG4gIGlmIChzY29wZS50cmFuc2xhdGVOYW1lc3BhY2UpIHtcbiAgICByZXR1cm4gc2NvcGUudHJhbnNsYXRlTmFtZXNwYWNlO1xuICB9XG4gIGlmIChzY29wZS4kcGFyZW50KSB7XG4gICAgcmV0dXJuIGdldFRyYW5zbGF0ZU5hbWVzcGFjZShzY29wZS4kcGFyZW50KTtcbiAgfVxufVxuXG50cmFuc2xhdGVOYW1lc3BhY2VEaXJlY3RpdmUuZGlzcGxheU5hbWUgPSAndHJhbnNsYXRlTmFtZXNwYWNlRGlyZWN0aXZlJztcblxuYW5ndWxhci5tb2R1bGUoJ3Bhc2NhbHByZWNodC50cmFuc2xhdGUnKVxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLmRpcmVjdGl2ZTp0cmFuc2xhdGVMYW5ndWFnZVxuICogQHJlc3RyaWN0IEFcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEZvcmNlcyB0aGUgbGFuZ3VhZ2UgdG8gdGhlIGRpcmVjdGl2ZXMgaW4gdGhlIHVuZGVybHlpbmcgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSB0cmFuc2xhdGUgbGFuZ3VhZ2UgdGhhdCB3aWxsIGJlIG5lZ290aWF0ZWQuXG4gKlxuICogQGV4YW1wbGVcbiAgIDxleGFtcGxlIG1vZHVsZT1cIm5nVmlld1wiPlxuICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICA8ZGl2PlxuXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8aDEgdHJhbnNsYXRlPkhFTExPPC9oMT5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiB0cmFuc2xhdGUtbGFuZ3VhZ2U9XCJkZVwiPlxuICAgICAgICAgICAgPGgxIHRyYW5zbGF0ZT5IRUxMTzwvaDE+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICA8L2Rpdj5cbiAgICA8L2ZpbGU+XG4gICAgPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxuICAgICAgYW5ndWxhci5tb2R1bGUoJ25nVmlldycsIFsncGFzY2FscHJlY2h0LnRyYW5zbGF0ZSddKVxuXG4gICAgICAuY29uZmlnKGZ1bmN0aW9uICgkdHJhbnNsYXRlUHJvdmlkZXIpIHtcblxuICAgICAgICAkdHJhbnNsYXRlUHJvdmlkZXJcbiAgICAgICAgICAudHJhbnNsYXRpb25zKCdlbicse1xuICAgICAgICAgICAgJ0hFTExPJzogJ0hlbGxvIHdvcmxkISdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50cmFuc2xhdGlvbnMoJ2RlJyx7XG4gICAgICAgICAgICAnSEVMTE8nOiAnSGFsbG8gV2VsdCEnXG4gICAgICAgICAgfSlcbiAgICAgICAgICAudHJhbnNsYXRpb25zKC5wcmVmZXJyZWRMYW5ndWFnZSgnZW4nKTtcblxuICAgICAgfSk7XG5cbiAgICA8L2ZpbGU+XG4gICA8L2V4YW1wbGU+XG4gKi9cbi5kaXJlY3RpdmUoJ3RyYW5zbGF0ZUxhbmd1YWdlJywgdHJhbnNsYXRlTGFuZ3VhZ2VEaXJlY3RpdmUpO1xuXG5mdW5jdGlvbiB0cmFuc2xhdGVMYW5ndWFnZURpcmVjdGl2ZSgpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHNjb3BlOiB0cnVlLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBsaW5rRm4oc2NvcGUsIGlFbGVtZW50LCBpQXR0cnMpIHtcbiAgICAgICAgaUF0dHJzLiRvYnNlcnZlKCd0cmFuc2xhdGVMYW5ndWFnZScsIGZ1bmN0aW9uIChuZXdUcmFuc2xhdGVMYW5ndWFnZSkge1xuICAgICAgICAgIHNjb3BlLnRyYW5zbGF0ZUxhbmd1YWdlID0gbmV3VHJhbnNsYXRlTGFuZ3VhZ2U7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbnRyYW5zbGF0ZUxhbmd1YWdlRGlyZWN0aXZlLmRpc3BsYXlOYW1lID0gJ3RyYW5zbGF0ZUxhbmd1YWdlRGlyZWN0aXZlJztcblxuXG5hbmd1bGFyLm1vZHVsZSgncGFzY2FscHJlY2h0LnRyYW5zbGF0ZScpXG4vKipcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIHBhc2NhbHByZWNodC50cmFuc2xhdGUuZmlsdGVyOnRyYW5zbGF0ZVxuICogQHJlcXVpcmVzICRwYXJzZVxuICogQHJlcXVpcmVzIHBhc2NhbHByZWNodC50cmFuc2xhdGUuJHRyYW5zbGF0ZVxuICogQGZ1bmN0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBVc2VzIGAkdHJhbnNsYXRlYCBzZXJ2aWNlIHRvIHRyYW5zbGF0ZSBjb250ZW50cy4gQWNjZXB0cyBpbnRlcnBvbGF0ZSBwYXJhbWV0ZXJzXG4gKiB0byBwYXNzIGR5bmFtaXplZCB2YWx1ZXMgdGhvdWdoIHRyYW5zbGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2xhdGlvbklkIEEgdHJhbnNsYXRpb24gaWQgdG8gYmUgdHJhbnNsYXRlZC5cbiAqIEBwYXJhbSB7Kj19IGludGVycG9sYXRlUGFyYW1zIE9wdGlvbmFsIG9iamVjdCBsaXRlcmFsIChhcyBoYXNoIG9yIHN0cmluZykgdG8gcGFzcyB2YWx1ZXMgaW50byB0cmFuc2xhdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUcmFuc2xhdGVkIHRleHQuXG4gKlxuICogQGV4YW1wbGVcbiAgIDxleGFtcGxlIG1vZHVsZT1cIm5nVmlld1wiPlxuICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJUcmFuc2xhdGVDdHJsXCI+XG5cbiAgICAgICAgPHByZT57eyAnVFJBTlNMQVRJT05fSUQnIHwgdHJhbnNsYXRlIH19PC9wcmU+XG4gICAgICAgIDxwcmU+e3sgdHJhbnNsYXRpb25JZCB8IHRyYW5zbGF0ZSB9fTwvcHJlPlxuICAgICAgICA8cHJlPnt7ICdXSVRIX1ZBTFVFUycgfCB0cmFuc2xhdGU6J3t2YWx1ZTogNX0nIH19PC9wcmU+XG4gICAgICAgIDxwcmU+e3sgJ1dJVEhfVkFMVUVTJyB8IHRyYW5zbGF0ZTp2YWx1ZXMgfX08L3ByZT5cblxuICAgICAgPC9kaXY+XG4gICAgPC9maWxlPlxuICAgIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cbiAgICAgIGFuZ3VsYXIubW9kdWxlKCduZ1ZpZXcnLCBbJ3Bhc2NhbHByZWNodC50cmFuc2xhdGUnXSlcblxuICAgICAgLmNvbmZpZyhmdW5jdGlvbiAoJHRyYW5zbGF0ZVByb3ZpZGVyKSB7XG5cbiAgICAgICAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnZW4nLCB7XG4gICAgICAgICAgJ1RSQU5TTEFUSU9OX0lEJzogJ0hlbGxvIHRoZXJlIScsXG4gICAgICAgICAgJ1dJVEhfVkFMVUVTJzogJ1RoZSBmb2xsb3dpbmcgdmFsdWUgaXMgZHluYW1pYzoge3t2YWx1ZX19J1xuICAgICAgICB9KTtcbiAgICAgICAgJHRyYW5zbGF0ZVByb3ZpZGVyLnByZWZlcnJlZExhbmd1YWdlKCdlbicpO1xuXG4gICAgICB9KTtcblxuICAgICAgYW5ndWxhci5tb2R1bGUoJ25nVmlldycpLmNvbnRyb2xsZXIoJ1RyYW5zbGF0ZUN0cmwnLCBmdW5jdGlvbiAoJHNjb3BlKSB7XG4gICAgICAgICRzY29wZS50cmFuc2xhdGlvbklkID0gJ1RSQU5TTEFUSU9OX0lEJztcblxuICAgICAgICAkc2NvcGUudmFsdWVzID0ge1xuICAgICAgICAgIHZhbHVlOiA3OFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgPC9maWxlPlxuICAgPC9leGFtcGxlPlxuICovXG4uZmlsdGVyKCd0cmFuc2xhdGUnLCB0cmFuc2xhdGVGaWx0ZXJGYWN0b3J5KTtcblxuZnVuY3Rpb24gdHJhbnNsYXRlRmlsdGVyRmFjdG9yeSgkcGFyc2UsICR0cmFuc2xhdGUpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHRyYW5zbGF0ZUZpbHRlciA9IGZ1bmN0aW9uICh0cmFuc2xhdGlvbklkLCBpbnRlcnBvbGF0ZVBhcmFtcywgaW50ZXJwb2xhdGlvbiwgZm9yY2VMYW5ndWFnZSkge1xuXG4gICAgaWYgKCFhbmd1bGFyLmlzT2JqZWN0KGludGVycG9sYXRlUGFyYW1zKSkge1xuICAgICAgaW50ZXJwb2xhdGVQYXJhbXMgPSAkcGFyc2UoaW50ZXJwb2xhdGVQYXJhbXMpKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiAkdHJhbnNsYXRlLmluc3RhbnQodHJhbnNsYXRpb25JZCwgaW50ZXJwb2xhdGVQYXJhbXMsIGludGVycG9sYXRpb24sIGZvcmNlTGFuZ3VhZ2UpO1xuICB9O1xuXG4gIGlmICgkdHJhbnNsYXRlLnN0YXRlZnVsRmlsdGVyKCkpIHtcbiAgICB0cmFuc2xhdGVGaWx0ZXIuJHN0YXRlZnVsID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2xhdGVGaWx0ZXI7XG59XG50cmFuc2xhdGVGaWx0ZXJGYWN0b3J5LiRpbmplY3QgPSBbJyRwYXJzZScsICckdHJhbnNsYXRlJ107XG5cbnRyYW5zbGF0ZUZpbHRlckZhY3RvcnkuZGlzcGxheU5hbWUgPSAndHJhbnNsYXRlRmlsdGVyRmFjdG9yeSc7XG5cbmFuZ3VsYXIubW9kdWxlKCdwYXNjYWxwcmVjaHQudHJhbnNsYXRlJylcblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBwYXNjYWxwcmVjaHQudHJhbnNsYXRlLiR0cmFuc2xhdGlvbkNhY2hlXG4gKiBAcmVxdWlyZXMgJGNhY2hlRmFjdG9yeVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGZpcnN0IHRpbWUgYSB0cmFuc2xhdGlvbiB0YWJsZSBpcyB1c2VkLCBpdCBpcyBsb2FkZWQgaW4gdGhlIHRyYW5zbGF0aW9uIGNhY2hlIGZvciBxdWljayByZXRyaWV2YWwuIFlvdVxuICogY2FuIGxvYWQgdHJhbnNsYXRpb24gdGFibGVzIGRpcmVjdGx5IGludG8gdGhlIGNhY2hlIGJ5IGNvbnN1bWluZyB0aGVcbiAqIGAkdHJhbnNsYXRpb25DYWNoZWAgc2VydmljZSBkaXJlY3RseS5cbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9ICRjYWNoZUZhY3Rvcnkgb2JqZWN0LlxuICovXG4gIC5mYWN0b3J5KCckdHJhbnNsYXRpb25DYWNoZScsICR0cmFuc2xhdGlvbkNhY2hlKTtcblxuZnVuY3Rpb24gJHRyYW5zbGF0aW9uQ2FjaGUoJGNhY2hlRmFjdG9yeSkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICByZXR1cm4gJGNhY2hlRmFjdG9yeSgndHJhbnNsYXRpb25zJyk7XG59XG4kdHJhbnNsYXRpb25DYWNoZS4kaW5qZWN0ID0gWyckY2FjaGVGYWN0b3J5J107XG5cbiR0cmFuc2xhdGlvbkNhY2hlLmRpc3BsYXlOYW1lID0gJyR0cmFuc2xhdGlvbkNhY2hlJztcbnJldHVybiAncGFzY2FscHJlY2h0LnRyYW5zbGF0ZSc7XG5cbn0pKTtcbiIsIi8qKlxuICogU3RhdGUtYmFzZWQgcm91dGluZyBmb3IgQW5ndWxhckpTXG4gKiBAdmVyc2lvbiB2MC4yLjE4XG4gKiBAbGluayBodHRwOi8vYW5ndWxhci11aS5naXRodWIuY29tL1xuICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UsIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyogY29tbW9uanMgcGFja2FnZSBtYW5hZ2VyIHN1cHBvcnQgKGVnIGNvbXBvbmVudGpzKSAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgPT09IGV4cG9ydHMpe1xuICBtb2R1bGUuZXhwb3J0cyA9ICd1aS5yb3V0ZXInO1xufVxuXG4oZnVuY3Rpb24gKHdpbmRvdywgYW5ndWxhciwgdW5kZWZpbmVkKSB7XG4vKmpzaGludCBnbG9iYWxzdHJpY3Q6dHJ1ZSovXG4vKmdsb2JhbCBhbmd1bGFyOmZhbHNlKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzRGVmaW5lZCA9IGFuZ3VsYXIuaXNEZWZpbmVkLFxuICAgIGlzRnVuY3Rpb24gPSBhbmd1bGFyLmlzRnVuY3Rpb24sXG4gICAgaXNTdHJpbmcgPSBhbmd1bGFyLmlzU3RyaW5nLFxuICAgIGlzT2JqZWN0ID0gYW5ndWxhci5pc09iamVjdCxcbiAgICBpc0FycmF5ID0gYW5ndWxhci5pc0FycmF5LFxuICAgIGZvckVhY2ggPSBhbmd1bGFyLmZvckVhY2gsXG4gICAgZXh0ZW5kID0gYW5ndWxhci5leHRlbmQsXG4gICAgY29weSA9IGFuZ3VsYXIuY29weSxcbiAgICB0b0pzb24gPSBhbmd1bGFyLnRvSnNvbjtcblxuZnVuY3Rpb24gaW5oZXJpdChwYXJlbnQsIGV4dHJhKSB7XG4gIHJldHVybiBleHRlbmQobmV3IChleHRlbmQoZnVuY3Rpb24oKSB7fSwgeyBwcm90b3R5cGU6IHBhcmVudCB9KSkoKSwgZXh0cmEpO1xufVxuXG5mdW5jdGlvbiBtZXJnZShkc3QpIHtcbiAgZm9yRWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogIT09IGRzdCkge1xuICAgICAgZm9yRWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKCFkc3QuaGFzT3duUHJvcGVydHkoa2V5KSkgZHN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkc3Q7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGNvbW1vbiBhbmNlc3RvciBwYXRoIGJldHdlZW4gdHdvIHN0YXRlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmlyc3QgVGhlIGZpcnN0IHN0YXRlLlxuICogQHBhcmFtIHtPYmplY3R9IHNlY29uZCBUaGUgc2Vjb25kIHN0YXRlLlxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGUgbmFtZXMgaW4gZGVzY2VuZGluZyBvcmRlciwgbm90IGluY2x1ZGluZyB0aGUgcm9vdC5cbiAqL1xuZnVuY3Rpb24gYW5jZXN0b3JzKGZpcnN0LCBzZWNvbmQpIHtcbiAgdmFyIHBhdGggPSBbXTtcblxuICBmb3IgKHZhciBuIGluIGZpcnN0LnBhdGgpIHtcbiAgICBpZiAoZmlyc3QucGF0aFtuXSAhPT0gc2Vjb25kLnBhdGhbbl0pIGJyZWFrO1xuICAgIHBhdGgucHVzaChmaXJzdC5wYXRoW25dKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cblxuLyoqXG4gKiBJRTgtc2FmZSB3cmFwcGVyIGZvciBgT2JqZWN0LmtleXMoKWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBBIEphdmFTY3JpcHQgb2JqZWN0LlxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgdGhlIGtleXMgb2YgdGhlIG9iamVjdCBhcyBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvckVhY2gob2JqZWN0LCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIElFOC1zYWZlIHdyYXBwZXIgZm9yIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZigpYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBIEphdmFTY3JpcHQgYXJyYXkuXG4gKiBAcGFyYW0geyp9IHZhbHVlIEEgdmFsdWUgdG8gc2VhcmNoIHRoZSBhcnJheSBmb3IuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIGFycmF5IGluZGV4IHZhbHVlIG9mIGB2YWx1ZWAsIG9yIGAtMWAgaWYgbm90IHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlLCBOdW1iZXIoYXJndW1lbnRzWzJdKSB8fCAwKTtcbiAgfVxuICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoID4+PiAwLCBmcm9tID0gTnVtYmVyKGFyZ3VtZW50c1syXSkgfHwgMDtcbiAgZnJvbSA9IChmcm9tIDwgMCkgPyBNYXRoLmNlaWwoZnJvbSkgOiBNYXRoLmZsb29yKGZyb20pO1xuXG4gIGlmIChmcm9tIDwgMCkgZnJvbSArPSBsZW47XG5cbiAgZm9yICg7IGZyb20gPCBsZW47IGZyb20rKykge1xuICAgIGlmIChmcm9tIGluIGFycmF5ICYmIGFycmF5W2Zyb21dID09PSB2YWx1ZSkgcmV0dXJuIGZyb207XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIE1lcmdlcyBhIHNldCBvZiBwYXJhbWV0ZXJzIHdpdGggYWxsIHBhcmFtZXRlcnMgaW5oZXJpdGVkIGJldHdlZW4gdGhlIGNvbW1vbiBwYXJlbnRzIG9mIHRoZVxuICogY3VycmVudCBzdGF0ZSBhbmQgYSBnaXZlbiBkZXN0aW5hdGlvbiBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFBhcmFtcyBUaGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgc3RhdGUgcGFyYW1ldGVycyAoJHN0YXRlUGFyYW1zKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdQYXJhbXMgVGhlIHNldCBvZiBwYXJhbWV0ZXJzIHdoaWNoIHdpbGwgYmUgY29tcG9zaXRlZCB3aXRoIGluaGVyaXRlZCBwYXJhbXMuXG4gKiBAcGFyYW0ge09iamVjdH0gJGN1cnJlbnQgSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHtPYmplY3R9ICR0byBJbnRlcm5hbCBkZWZpbml0aW9uIG9mIG9iamVjdCByZXByZXNlbnRpbmcgc3RhdGUgdG8gdHJhbnNpdGlvbiB0by5cbiAqL1xuZnVuY3Rpb24gaW5oZXJpdFBhcmFtcyhjdXJyZW50UGFyYW1zLCBuZXdQYXJhbXMsICRjdXJyZW50LCAkdG8pIHtcbiAgdmFyIHBhcmVudHMgPSBhbmNlc3RvcnMoJGN1cnJlbnQsICR0byksIHBhcmVudFBhcmFtcywgaW5oZXJpdGVkID0ge30sIGluaGVyaXRMaXN0ID0gW107XG5cbiAgZm9yICh2YXIgaSBpbiBwYXJlbnRzKSB7XG4gICAgaWYgKCFwYXJlbnRzW2ldIHx8ICFwYXJlbnRzW2ldLnBhcmFtcykgY29udGludWU7XG4gICAgcGFyZW50UGFyYW1zID0gb2JqZWN0S2V5cyhwYXJlbnRzW2ldLnBhcmFtcyk7XG4gICAgaWYgKCFwYXJlbnRQYXJhbXMubGVuZ3RoKSBjb250aW51ZTtcblxuICAgIGZvciAodmFyIGogaW4gcGFyZW50UGFyYW1zKSB7XG4gICAgICBpZiAoaW5kZXhPZihpbmhlcml0TGlzdCwgcGFyZW50UGFyYW1zW2pdKSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGluaGVyaXRMaXN0LnB1c2gocGFyZW50UGFyYW1zW2pdKTtcbiAgICAgIGluaGVyaXRlZFtwYXJlbnRQYXJhbXNbal1dID0gY3VycmVudFBhcmFtc1twYXJlbnRQYXJhbXNbal1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXh0ZW5kKHt9LCBpbmhlcml0ZWQsIG5ld1BhcmFtcyk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBub24tc3RyaWN0IGNvbXBhcmlzb24gb2YgdGhlIHN1YnNldCBvZiB0d28gb2JqZWN0cywgZGVmaW5lZCBieSBhIGxpc3Qgb2Yga2V5cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgZmlyc3Qgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIHNlY29uZCBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5fSBrZXlzIFRoZSBsaXN0IG9mIGtleXMgd2l0aGluIGVhY2ggb2JqZWN0IHRvIGNvbXBhcmUuIElmIHRoZSBsaXN0IGlzIGVtcHR5IG9yIG5vdCBzcGVjaWZpZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgIGl0IGRlZmF1bHRzIHRvIHRoZSBsaXN0IG9mIGtleXMgaW4gYGFgLlxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEZvcktleXMoYSwgYiwga2V5cykge1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gW107XG4gICAgZm9yICh2YXIgbiBpbiBhKSBrZXlzLnB1c2gobik7IC8vIFVzZWQgaW5zdGVhZCBvZiBPYmplY3Qua2V5cygpIGZvciBJRTggY29tcGF0aWJpbGl0eVxuICB9XG5cbiAgZm9yICh2YXIgaT0wOyBpPGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgayA9IGtleXNbaV07XG4gICAgaWYgKGFba10gIT0gYltrXSkgcmV0dXJuIGZhbHNlOyAvLyBOb3QgJz09PScsIHZhbHVlcyBhcmVuJ3QgbmVjZXNzYXJpbHkgbm9ybWFsaXplZFxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN1YnNldCBvZiBhbiBvYmplY3QsIGJhc2VkIG9uIGEgbGlzdCBvZiBrZXlzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGtleXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXNcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYSBzdWJzZXQgb2YgYHZhbHVlc2AuXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckJ5S2V5cyhrZXlzLCB2YWx1ZXMpIHtcbiAgdmFyIGZpbHRlcmVkID0ge307XG5cbiAgZm9yRWFjaChrZXlzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGZpbHRlcmVkW25hbWVdID0gdmFsdWVzW25hbWVdO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcmVkO1xufVxuXG4vLyBsaWtlIF8uaW5kZXhCeVxuLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLCBvciB5b3Ugd2FudCBsYXN0LW9uZS1pbiB0byB3aW5cbmZ1bmN0aW9uIGluZGV4QnkoYXJyYXksIHByb3BOYW1lKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yRWFjaChhcnJheSwgZnVuY3Rpb24oaXRlbSkge1xuICAgIHJlc3VsdFtpdGVtW3Byb3BOYW1lXV0gPSBpdGVtO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gZXh0cmFjdGVkIGZyb20gdW5kZXJzY29yZS5qc1xuLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbmZ1bmN0aW9uIHBpY2sob2JqKSB7XG4gIHZhciBjb3B5ID0ge307XG4gIHZhciBrZXlzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShBcnJheS5wcm90b3R5cGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICBmb3JFYWNoKGtleXMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgfSk7XG4gIHJldHVybiBjb3B5O1xufVxuXG4vLyBleHRyYWN0ZWQgZnJvbSB1bmRlcnNjb3JlLmpzXG4vLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb21pdHRpbmcgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG5mdW5jdGlvbiBvbWl0KG9iaikge1xuICB2YXIgY29weSA9IHt9O1xuICB2YXIga2V5cyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoQXJyYXkucHJvdG90eXBlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChpbmRleE9mKGtleXMsIGtleSkgPT0gLTEpIGNvcHlba2V5XSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBwbHVjayhjb2xsZWN0aW9uLCBrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBbXSA6IHt9O1xuXG4gIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsLCBpKSB7XG4gICAgcmVzdWx0W2ldID0gaXNGdW5jdGlvbihrZXkpID8ga2V5KHZhbCkgOiB2YWxba2V5XTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xuICB2YXIgYXJyYXkgPSBpc0FycmF5KGNvbGxlY3Rpb24pO1xuICB2YXIgcmVzdWx0ID0gYXJyYXkgPyBbXSA6IHt9O1xuICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbCwgaSkge1xuICAgIGlmIChjYWxsYmFjayh2YWwsIGkpKSB7XG4gICAgICByZXN1bHRbYXJyYXkgPyByZXN1bHQubGVuZ3RoIDogaV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gIHZhciByZXN1bHQgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gW10gOiB7fTtcblxuICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbCwgaSkge1xuICAgIHJlc3VsdFtpXSA9IGNhbGxiYWNrKHZhbCwgaSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBuZ2RvYyBvdmVydmlld1xuICogQG5hbWUgdWkucm91dGVyLnV0aWxcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICMgdWkucm91dGVyLnV0aWwgc3ViLW1vZHVsZVxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIGEgZGVwZW5kZW5jeSBvZiBvdGhlciBzdWItbW9kdWxlcy4gRG8gbm90IGluY2x1ZGUgdGhpcyBtb2R1bGUgYXMgYSBkZXBlbmRlbmN5XG4gKiBpbiB5b3VyIGFuZ3VsYXIgYXBwICh1c2Uge0BsaW5rIHVpLnJvdXRlcn0gbW9kdWxlIGluc3RlYWQpLlxuICpcbiAqL1xuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci51dGlsJywgWyduZyddKTtcblxuLyoqXG4gKiBAbmdkb2Mgb3ZlcnZpZXdcbiAqIEBuYW1lIHVpLnJvdXRlci5yb3V0ZXJcbiAqIFxuICogQHJlcXVpcmVzIHVpLnJvdXRlci51dGlsXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAjIHVpLnJvdXRlci5yb3V0ZXIgc3ViLW1vZHVsZVxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIGEgZGVwZW5kZW5jeSBvZiBvdGhlciBzdWItbW9kdWxlcy4gRG8gbm90IGluY2x1ZGUgdGhpcyBtb2R1bGUgYXMgYSBkZXBlbmRlbmN5XG4gKiBpbiB5b3VyIGFuZ3VsYXIgYXBwICh1c2Uge0BsaW5rIHVpLnJvdXRlcn0gbW9kdWxlIGluc3RlYWQpLlxuICovXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnJvdXRlcicsIFsndWkucm91dGVyLnV0aWwnXSk7XG5cbi8qKlxuICogQG5nZG9jIG92ZXJ2aWV3XG4gKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGVcbiAqIFxuICogQHJlcXVpcmVzIHVpLnJvdXRlci5yb3V0ZXJcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIudXRpbFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogIyB1aS5yb3V0ZXIuc3RhdGUgc3ViLW1vZHVsZVxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIGEgZGVwZW5kZW5jeSBvZiB0aGUgbWFpbiB1aS5yb3V0ZXIgbW9kdWxlLiBEbyBub3QgaW5jbHVkZSB0aGlzIG1vZHVsZSBhcyBhIGRlcGVuZGVuY3lcbiAqIGluIHlvdXIgYW5ndWxhciBhcHAgKHVzZSB7QGxpbmsgdWkucm91dGVyfSBtb2R1bGUgaW5zdGVhZCkuXG4gKiBcbiAqL1xuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScsIFsndWkucm91dGVyLnJvdXRlcicsICd1aS5yb3V0ZXIudXRpbCddKTtcblxuLyoqXG4gKiBAbmdkb2Mgb3ZlcnZpZXdcbiAqIEBuYW1lIHVpLnJvdXRlclxuICpcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIuc3RhdGVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICMgdWkucm91dGVyXG4gKiBcbiAqICMjIFRoZSBtYWluIG1vZHVsZSBmb3IgdWkucm91dGVyIFxuICogVGhlcmUgYXJlIHNldmVyYWwgc3ViLW1vZHVsZXMgaW5jbHVkZWQgd2l0aCB0aGUgdWkucm91dGVyIG1vZHVsZSwgaG93ZXZlciBvbmx5IHRoaXMgbW9kdWxlIGlzIG5lZWRlZFxuICogYXMgYSBkZXBlbmRlbmN5IHdpdGhpbiB5b3VyIGFuZ3VsYXIgYXBwLiBUaGUgb3RoZXIgbW9kdWxlcyBhcmUgZm9yIG9yZ2FuaXphdGlvbiBwdXJwb3Nlcy4gXG4gKlxuICogVGhlIG1vZHVsZXMgYXJlOlxuICogKiB1aS5yb3V0ZXIgLSB0aGUgbWFpbiBcInVtYnJlbGxhXCIgbW9kdWxlXG4gKiAqIHVpLnJvdXRlci5yb3V0ZXIgLSBcbiAqIFxuICogKllvdSdsbCBuZWVkIHRvIGluY2x1ZGUgKipvbmx5KiogdGhpcyBtb2R1bGUgYXMgdGhlIGRlcGVuZGVuY3kgd2l0aGluIHlvdXIgYW5ndWxhciBhcHAuKlxuICogXG4gKiA8cHJlPlxuICogPCFkb2N0eXBlIGh0bWw+XG4gKiA8aHRtbCBuZy1hcHA9XCJteUFwcFwiPlxuICogPGhlYWQ+XG4gKiAgIDxzY3JpcHQgc3JjPVwianMvYW5ndWxhci5qc1wiPjwvc2NyaXB0PlxuICogICA8IS0tIEluY2x1ZGUgdGhlIHVpLXJvdXRlciBzY3JpcHQgLS0+XG4gKiAgIDxzY3JpcHQgc3JjPVwianMvYW5ndWxhci11aS1yb3V0ZXIubWluLmpzXCI+PC9zY3JpcHQ+XG4gKiAgIDxzY3JpcHQ+XG4gKiAgICAgLy8gLi4uYW5kIGFkZCAndWkucm91dGVyJyBhcyBhIGRlcGVuZGVuY3lcbiAqICAgICB2YXIgbXlBcHAgPSBhbmd1bGFyLm1vZHVsZSgnbXlBcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAqICAgPC9zY3JpcHQ+XG4gKiA8L2hlYWQ+XG4gKiA8Ym9keT5cbiAqIDwvYm9keT5cbiAqIDwvaHRtbD5cbiAqIDwvcHJlPlxuICovXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyJywgWyd1aS5yb3V0ZXIuc3RhdGUnXSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIuY29tcGF0JywgWyd1aS5yb3V0ZXInXSk7XG5cbi8qKlxuICogQG5nZG9jIG9iamVjdFxuICogQG5hbWUgdWkucm91dGVyLnV0aWwuJHJlc29sdmVcbiAqXG4gKiBAcmVxdWlyZXMgJHFcbiAqIEByZXF1aXJlcyAkaW5qZWN0b3JcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1hbmFnZXMgcmVzb2x1dGlvbiBvZiAoYWN5Y2xpYykgZ3JhcGhzIG9mIHByb21pc2VzLlxuICovXG4kUmVzb2x2ZS4kaW5qZWN0ID0gWyckcScsICckaW5qZWN0b3InXTtcbmZ1bmN0aW9uICRSZXNvbHZlKCAgJHEsICAgICRpbmplY3Rvcikge1xuICBcbiAgdmFyIFZJU0lUX0lOX1BST0dSRVNTID0gMSxcbiAgICAgIFZJU0lUX0RPTkUgPSAyLFxuICAgICAgTk9USElORyA9IHt9LFxuICAgICAgTk9fREVQRU5ERU5DSUVTID0gW10sXG4gICAgICBOT19MT0NBTFMgPSBOT1RISU5HLFxuICAgICAgTk9fUEFSRU5UID0gZXh0ZW5kKCRxLndoZW4oTk9USElORyksIHsgJCRwcm9taXNlczogTk9USElORywgJCR2YWx1ZXM6IE5PVEhJTkcgfSk7XG4gIFxuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgdWkucm91dGVyLnV0aWwuJHJlc29sdmUjc3R1ZHlcbiAgICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLiRyZXNvbHZlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTdHVkaWVzIGEgc2V0IG9mIGludm9jYWJsZXMgdGhhdCBhcmUgbGlrZWx5IHRvIGJlIHVzZWQgbXVsdGlwbGUgdGltZXMuXG4gICAqIDxwcmU+XG4gICAqICRyZXNvbHZlLnN0dWR5KGludm9jYWJsZXMpKGxvY2FscywgcGFyZW50LCBzZWxmKVxuICAgKiA8L3ByZT5cbiAgICogaXMgZXF1aXZhbGVudCB0b1xuICAgKiA8cHJlPlxuICAgKiAkcmVzb2x2ZS5yZXNvbHZlKGludm9jYWJsZXMsIGxvY2FscywgcGFyZW50LCBzZWxmKVxuICAgKiA8L3ByZT5cbiAgICogYnV0IHRoZSBmb3JtZXIgaXMgbW9yZSBlZmZpY2llbnQgKGluIGZhY3QgYHJlc29sdmVgIGp1c3QgY2FsbHMgYHN0dWR5YCBcbiAgICogaW50ZXJuYWxseSkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnZvY2FibGVzIEludm9jYWJsZSBvYmplY3RzXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRvIHBhc3MgaW4gbG9jYWxzLCBwYXJlbnQgYW5kIHNlbGZcbiAgICovXG4gIHRoaXMuc3R1ZHkgPSBmdW5jdGlvbiAoaW52b2NhYmxlcykge1xuICAgIGlmICghaXNPYmplY3QoaW52b2NhYmxlcykpIHRocm93IG5ldyBFcnJvcihcIidpbnZvY2FibGVzJyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICB2YXIgaW52b2NhYmxlS2V5cyA9IG9iamVjdEtleXMoaW52b2NhYmxlcyB8fCB7fSk7XG4gICAgXG4gICAgLy8gUGVyZm9ybSBhIHRvcG9sb2dpY2FsIHNvcnQgb2YgaW52b2NhYmxlcyB0byBidWlsZCBhbiBvcmRlcmVkIHBsYW5cbiAgICB2YXIgcGxhbiA9IFtdLCBjeWNsZSA9IFtdLCB2aXNpdGVkID0ge307XG4gICAgZnVuY3Rpb24gdmlzaXQodmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZpc2l0ZWRba2V5XSA9PT0gVklTSVRfRE9ORSkgcmV0dXJuO1xuICAgICAgXG4gICAgICBjeWNsZS5wdXNoKGtleSk7XG4gICAgICBpZiAodmlzaXRlZFtrZXldID09PSBWSVNJVF9JTl9QUk9HUkVTUykge1xuICAgICAgICBjeWNsZS5zcGxpY2UoMCwgaW5kZXhPZihjeWNsZSwga2V5KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN5Y2xpYyBkZXBlbmRlbmN5OiBcIiArIGN5Y2xlLmpvaW4oXCIgLT4gXCIpKTtcbiAgICAgIH1cbiAgICAgIHZpc2l0ZWRba2V5XSA9IFZJU0lUX0lOX1BST0dSRVNTO1xuICAgICAgXG4gICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHBsYW4ucHVzaChrZXksIFsgZnVuY3Rpb24oKSB7IHJldHVybiAkaW5qZWN0b3IuZ2V0KHZhbHVlKTsgfV0sIE5PX0RFUEVOREVOQ0lFUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGFyYW1zID0gJGluamVjdG9yLmFubm90YXRlKHZhbHVlKTtcbiAgICAgICAgZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgIGlmIChwYXJhbSAhPT0ga2V5ICYmIGludm9jYWJsZXMuaGFzT3duUHJvcGVydHkocGFyYW0pKSB2aXNpdChpbnZvY2FibGVzW3BhcmFtXSwgcGFyYW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcGxhbi5wdXNoKGtleSwgdmFsdWUsIHBhcmFtcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGN5Y2xlLnBvcCgpO1xuICAgICAgdmlzaXRlZFtrZXldID0gVklTSVRfRE9ORTtcbiAgICB9XG4gICAgZm9yRWFjaChpbnZvY2FibGVzLCB2aXNpdCk7XG4gICAgaW52b2NhYmxlcyA9IGN5Y2xlID0gdmlzaXRlZCA9IG51bGw7IC8vIHBsYW4gaXMgYWxsIHRoYXQncyByZXF1aXJlZFxuICAgIFxuICAgIGZ1bmN0aW9uIGlzUmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS50aGVuICYmIHZhbHVlLiQkcHJvbWlzZXM7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmdW5jdGlvbiAobG9jYWxzLCBwYXJlbnQsIHNlbGYpIHtcbiAgICAgIGlmIChpc1Jlc29sdmUobG9jYWxzKSAmJiBzZWxmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VsZiA9IHBhcmVudDsgcGFyZW50ID0gbG9jYWxzOyBsb2NhbHMgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFsb2NhbHMpIGxvY2FscyA9IE5PX0xPQ0FMUztcbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChsb2NhbHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIidsb2NhbHMnIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgICAgfSAgICAgICBcbiAgICAgIGlmICghcGFyZW50KSBwYXJlbnQgPSBOT19QQVJFTlQ7XG4gICAgICBlbHNlIGlmICghaXNSZXNvbHZlKHBhcmVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3BhcmVudCcgbXVzdCBiZSBhIHByb21pc2UgcmV0dXJuZWQgYnkgJHJlc29sdmUucmVzb2x2ZSgpXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUbyBjb21wbGV0ZSB0aGUgb3ZlcmFsbCByZXNvbHV0aW9uLCB3ZSBoYXZlIHRvIHdhaXQgZm9yIHRoZSBwYXJlbnRcbiAgICAgIC8vIHByb21pc2UgYW5kIGZvciB0aGUgcHJvbWlzZSBmb3IgZWFjaCBpbnZva2FibGUgaW4gb3VyIHBsYW4uXG4gICAgICB2YXIgcmVzb2x1dGlvbiA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgcmVzdWx0ID0gcmVzb2x1dGlvbi5wcm9taXNlLFxuICAgICAgICAgIHByb21pc2VzID0gcmVzdWx0LiQkcHJvbWlzZXMgPSB7fSxcbiAgICAgICAgICB2YWx1ZXMgPSBleHRlbmQoe30sIGxvY2FscyksXG4gICAgICAgICAgd2FpdCA9IDEgKyBwbGFuLmxlbmd0aC8zLFxuICAgICAgICAgIG1lcmdlZCA9IGZhbHNlO1xuICAgICAgICAgIFxuICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgLy8gTWVyZ2UgcGFyZW50IHZhbHVlcyB3ZSBoYXZlbid0IGdvdCB5ZXQgYW5kIHB1Ymxpc2ggb3VyIG93biAkJHZhbHVlc1xuICAgICAgICBpZiAoIS0td2FpdCkge1xuICAgICAgICAgIGlmICghbWVyZ2VkKSBtZXJnZSh2YWx1ZXMsIHBhcmVudC4kJHZhbHVlcyk7IFxuICAgICAgICAgIHJlc3VsdC4kJHZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgICByZXN1bHQuJCRwcm9taXNlcyA9IHJlc3VsdC4kJHByb21pc2VzIHx8IHRydWU7IC8vIGtlZXAgZm9yIGlzUmVzb2x2ZSgpXG4gICAgICAgICAgZGVsZXRlIHJlc3VsdC4kJGluaGVyaXRlZFZhbHVlcztcbiAgICAgICAgICByZXNvbHV0aW9uLnJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBmYWlsKHJlYXNvbikge1xuICAgICAgICByZXN1bHQuJCRmYWlsdXJlID0gcmVhc29uO1xuICAgICAgICByZXNvbHV0aW9uLnJlamVjdChyZWFzb24pO1xuICAgICAgfVxuXG4gICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHBhcmVudCBoYXMgYWxyZWFkeSBmYWlsZWRcbiAgICAgIGlmIChpc0RlZmluZWQocGFyZW50LiQkZmFpbHVyZSkpIHtcbiAgICAgICAgZmFpbChwYXJlbnQuJCRmYWlsdXJlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHBhcmVudC4kJGluaGVyaXRlZFZhbHVlcykge1xuICAgICAgICBtZXJnZSh2YWx1ZXMsIG9taXQocGFyZW50LiQkaW5oZXJpdGVkVmFsdWVzLCBpbnZvY2FibGVLZXlzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1lcmdlIHBhcmVudCB2YWx1ZXMgaWYgdGhlIHBhcmVudCBoYXMgYWxyZWFkeSByZXNvbHZlZCwgb3IgbWVyZ2VcbiAgICAgIC8vIHBhcmVudCBwcm9taXNlcyBhbmQgd2FpdCBpZiB0aGUgcGFyZW50IHJlc29sdmUgaXMgc3RpbGwgaW4gcHJvZ3Jlc3MuXG4gICAgICBleHRlbmQocHJvbWlzZXMsIHBhcmVudC4kJHByb21pc2VzKTtcbiAgICAgIGlmIChwYXJlbnQuJCR2YWx1ZXMpIHtcbiAgICAgICAgbWVyZ2VkID0gbWVyZ2UodmFsdWVzLCBvbWl0KHBhcmVudC4kJHZhbHVlcywgaW52b2NhYmxlS2V5cykpO1xuICAgICAgICByZXN1bHQuJCRpbmhlcml0ZWRWYWx1ZXMgPSBvbWl0KHBhcmVudC4kJHZhbHVlcywgaW52b2NhYmxlS2V5cyk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJlbnQuJCRpbmhlcml0ZWRWYWx1ZXMpIHtcbiAgICAgICAgICByZXN1bHQuJCRpbmhlcml0ZWRWYWx1ZXMgPSBvbWl0KHBhcmVudC4kJGluaGVyaXRlZFZhbHVlcywgaW52b2NhYmxlS2V5cyk7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBwYXJlbnQudGhlbihkb25lLCBmYWlsKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBlYWNoIGludm9jYWJsZSBpbiB0aGUgcGxhbiwgYnV0IGlnbm9yZSBhbnkgd2hlcmUgYSBsb2NhbCBvZiB0aGUgc2FtZSBuYW1lIGV4aXN0cy5cbiAgICAgIGZvciAodmFyIGk9MCwgaWk9cGxhbi5sZW5ndGg7IGk8aWk7IGkrPTMpIHtcbiAgICAgICAgaWYgKGxvY2Fscy5oYXNPd25Qcm9wZXJ0eShwbGFuW2ldKSkgZG9uZSgpO1xuICAgICAgICBlbHNlIGludm9rZShwbGFuW2ldLCBwbGFuW2krMV0sIHBsYW5baSsyXSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGludm9rZShrZXksIGludm9jYWJsZSwgcGFyYW1zKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGRlZmVycmVkIGZvciB0aGlzIGludm9jYXRpb24uIEZhaWx1cmVzIHdpbGwgcHJvcGFnYXRlIHRvIHRoZSByZXNvbHV0aW9uIGFzIHdlbGwuXG4gICAgICAgIHZhciBpbnZvY2F0aW9uID0gJHEuZGVmZXIoKSwgd2FpdFBhcmFtcyA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIG9uZmFpbHVyZShyZWFzb24pIHtcbiAgICAgICAgICBpbnZvY2F0aW9uLnJlamVjdChyZWFzb24pO1xuICAgICAgICAgIGZhaWwocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IGZvciBhbnkgcGFyYW1ldGVyIHRoYXQgd2UgaGF2ZSBhIHByb21pc2UgZm9yIChlaXRoZXIgZnJvbSBwYXJlbnQgb3IgZnJvbSB0aGlzXG4gICAgICAgIC8vIHJlc29sdmU7IGluIHRoYXQgY2FzZSBzdHVkeSgpIHdpbGwgaGF2ZSBtYWRlIHN1cmUgaXQncyBvcmRlcmVkIGJlZm9yZSB1cyBpbiB0aGUgcGxhbikuXG4gICAgICAgIGZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgaWYgKHByb21pc2VzLmhhc093blByb3BlcnR5KGRlcCkgJiYgIWxvY2Fscy5oYXNPd25Qcm9wZXJ0eShkZXApKSB7XG4gICAgICAgICAgICB3YWl0UGFyYW1zKys7XG4gICAgICAgICAgICBwcm9taXNlc1tkZXBdLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICB2YWx1ZXNbZGVwXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgaWYgKCEoLS13YWl0UGFyYW1zKSkgcHJvY2VlZCgpO1xuICAgICAgICAgICAgfSwgb25mYWlsdXJlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXdhaXRQYXJhbXMpIHByb2NlZWQoKTtcbiAgICAgICAgZnVuY3Rpb24gcHJvY2VlZCgpIHtcbiAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJlc3VsdC4kJGZhaWx1cmUpKSByZXR1cm47XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGludm9jYXRpb24ucmVzb2x2ZSgkaW5qZWN0b3IuaW52b2tlKGludm9jYWJsZSwgc2VsZiwgdmFsdWVzKSk7XG4gICAgICAgICAgICBpbnZvY2F0aW9uLnByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHZhbHVlc1trZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9LCBvbmZhaWx1cmUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9uZmFpbHVyZShlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHVibGlzaCBwcm9taXNlIHN5bmNocm9ub3VzbHk7IGludm9jYXRpb25zIGZ1cnRoZXIgZG93biBpbiB0aGUgcGxhbiBtYXkgZGVwZW5kIG9uIGl0LlxuICAgICAgICBwcm9taXNlc1trZXldID0gaW52b2NhdGlvbi5wcm9taXNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG4gIFxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHVpLnJvdXRlci51dGlsLiRyZXNvbHZlI3Jlc29sdmVcbiAgICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLiRyZXNvbHZlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXNvbHZlcyBhIHNldCBvZiBpbnZvY2FibGVzLiBBbiBpbnZvY2FibGUgaXMgYSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHZpYSBcbiAgICogYCRpbmplY3Rvci5pbnZva2UoKWAsIGFuZCBjYW4gaGF2ZSBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGRlcGVuZGVuY2llcy4gXG4gICAqIEFuIGludm9jYWJsZSBjYW4gZWl0aGVyIHJldHVybiBhIHZhbHVlIGRpcmVjdGx5LFxuICAgKiBvciBhIGAkcWAgcHJvbWlzZS4gSWYgYSBwcm9taXNlIGlzIHJldHVybmVkIGl0IHdpbGwgYmUgcmVzb2x2ZWQgYW5kIHRoZSBcbiAgICogcmVzdWx0aW5nIHZhbHVlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBEZXBlbmRlbmNpZXMgb2YgaW52b2NhYmxlcyBhcmUgcmVzb2x2ZWQgXG4gICAqIChpbiB0aGlzIG9yZGVyIG9mIHByZWNlZGVuY2UpXG4gICAqXG4gICAqIC0gZnJvbSB0aGUgc3BlY2lmaWVkIGBsb2NhbHNgXG4gICAqIC0gZnJvbSBhbm90aGVyIGludm9jYWJsZSB0aGF0IGlzIHBhcnQgb2YgdGhpcyBgJHJlc29sdmVgIGNhbGxcbiAgICogLSBmcm9tIGFuIGludm9jYWJsZSB0aGF0IGlzIGluaGVyaXRlZCBmcm9tIGEgYHBhcmVudGAgY2FsbCB0byBgJHJlc29sdmVgIFxuICAgKiAgIChvciByZWN1cnNpdmVseVxuICAgKiAtIGZyb20gYW55IGFuY2VzdG9yIGAkcmVzb2x2ZWAgb2YgdGhhdCBwYXJlbnQpLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIG9mIGAkcmVzb2x2ZWAgaXMgYSBwcm9taXNlIGZvciBhbiBvYmplY3QgdGhhdCBjb250YWlucyBcbiAgICogKGluIHRoaXMgb3JkZXIgb2YgcHJlY2VkZW5jZSlcbiAgICpcbiAgICogLSBhbnkgYGxvY2Fsc2AgKGlmIHNwZWNpZmllZClcbiAgICogLSB0aGUgcmVzb2x2ZWQgcmV0dXJuIHZhbHVlcyBvZiBhbGwgaW5qZWN0YWJsZXNcbiAgICogLSBhbnkgdmFsdWVzIGluaGVyaXRlZCBmcm9tIGEgYHBhcmVudGAgY2FsbCB0byBgJHJlc29sdmVgIChpZiBzcGVjaWZpZWQpXG4gICAqXG4gICAqIFRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZSBhZnRlciB0aGUgYHBhcmVudGAgcHJvbWlzZSAoaWYgYW55KSBhbmQgYWxsIHByb21pc2VzIFxuICAgKiByZXR1cm5lZCBieSBpbmplY3RhYmxlcyBoYXZlIGJlZW4gcmVzb2x2ZWQuIElmIGFueSBpbnZvY2FibGUgXG4gICAqIChvciBgJGluamVjdG9yLmludm9rZWApIHRocm93cyBhbiBleGNlcHRpb24sIG9yIGlmIGEgcHJvbWlzZSByZXR1cm5lZCBieSBhbiBcbiAgICogaW52b2NhYmxlIGlzIHJlamVjdGVkLCB0aGUgYCRyZXNvbHZlYCBwcm9taXNlIGlzIGltbWVkaWF0ZWx5IHJlamVjdGVkIHdpdGggdGhlIFxuICAgKiBzYW1lIGVycm9yLiBBIHJlamVjdGlvbiBvZiBhIGBwYXJlbnRgIHByb21pc2UgKGlmIHNwZWNpZmllZCkgd2lsbCBsaWtld2lzZSBiZSBcbiAgICogcHJvcGFnYXRlZCBpbW1lZGlhdGVseS4gT25jZSB0aGUgYCRyZXNvbHZlYCBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkLCBubyBcbiAgICogZnVydGhlciBpbnZvY2FibGVzIHdpbGwgYmUgY2FsbGVkLlxuICAgKiBcbiAgICogQ3ljbGljIGRlcGVuZGVuY2llcyBiZXR3ZWVuIGludm9jYWJsZXMgYXJlIG5vdCBwZXJtaXR0ZWQgYW5kIHdpbGwgY2F1c2UgYCRyZXNvbHZlYFxuICAgKiB0byB0aHJvdyBhbiBlcnJvci4gQXMgYSBzcGVjaWFsIGNhc2UsIGFuIGluamVjdGFibGUgY2FuIGRlcGVuZCBvbiBhIHBhcmFtZXRlciBcbiAgICogd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBpbmplY3RhYmxlLCB3aGljaCB3aWxsIGJlIGZ1bGZpbGxlZCBmcm9tIHRoZSBgcGFyZW50YCBcbiAgICogaW5qZWN0YWJsZSBvZiB0aGUgc2FtZSBuYW1lLiBUaGlzIGFsbG93cyBpbmhlcml0ZWQgdmFsdWVzIHRvIGJlIGRlY29yYXRlZC4gXG4gICAqIE5vdGUgdGhhdCBpbiB0aGlzIGNhc2UgYW55IG90aGVyIGluamVjdGFibGUgaW4gdGhlIHNhbWUgYCRyZXNvbHZlYCB3aXRoIHRoZSBzYW1lXG4gICAqIGRlcGVuZGVuY3kgd291bGQgc2VlIHRoZSBkZWNvcmF0ZWQgdmFsdWUsIG5vdCB0aGUgaW5oZXJpdGVkIHZhbHVlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgbWlzc2luZyBkZXBlbmRlbmNpZXMgLS0gdW5saWtlIGN5Y2xpYyBkZXBlbmRlbmNpZXMgLS0gd2lsbCBjYXVzZSBhbiBcbiAgICogKGFzeW5jaHJvbm91cykgcmVqZWN0aW9uIG9mIHRoZSBgJHJlc29sdmVgIHByb21pc2UgcmF0aGVyIHRoYW4gYSAoc3luY2hyb25vdXMpIFxuICAgKiBleGNlcHRpb24uXG4gICAqXG4gICAqIEludm9jYWJsZXMgYXJlIGludm9rZWQgZWFnZXJseSBhcyBzb29uIGFzIGFsbCBkZXBlbmRlbmNpZXMgYXJlIGF2YWlsYWJsZS4gXG4gICAqIFRoaXMgaXMgdHJ1ZSBldmVuIGZvciBkZXBlbmRlbmNpZXMgaW5oZXJpdGVkIGZyb20gYSBgcGFyZW50YCBjYWxsIHRvIGAkcmVzb2x2ZWAuXG4gICAqXG4gICAqIEFzIGEgc3BlY2lhbCBjYXNlLCBhbiBpbnZvY2FibGUgY2FuIGJlIGEgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGl0IGlzIHRha2VuIHRvIFxuICAgKiBiZSBhIHNlcnZpY2UgbmFtZSB0byBiZSBwYXNzZWQgdG8gYCRpbmplY3Rvci5nZXQoKWAuIFRoaXMgaXMgc3VwcG9ydGVkIHByaW1hcmlseSBcbiAgICogZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggdGhlIGByZXNvbHZlYCBwcm9wZXJ0eSBvZiBgJHJvdXRlUHJvdmlkZXJgIFxuICAgKiByb3V0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnZvY2FibGVzIGZ1bmN0aW9ucyB0byBpbnZva2Ugb3IgXG4gICAqIGAkaW5qZWN0b3JgIHNlcnZpY2VzIHRvIGZldGNoLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbG9jYWxzICB2YWx1ZXMgdG8gbWFrZSBhdmFpbGFibGUgdG8gdGhlIGluamVjdGFibGVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnQgIGEgcHJvbWlzZSByZXR1cm5lZCBieSBhbm90aGVyIGNhbGwgdG8gYCRyZXNvbHZlYC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHNlbGYgIHRoZSBgdGhpc2AgZm9yIHRoZSBpbnZva2VkIG1ldGhvZHNcbiAgICogQHJldHVybiB7b2JqZWN0fSBQcm9taXNlIGZvciBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgcmVzb2x2ZWQgcmV0dXJuIHZhbHVlXG4gICAqIG9mIGFsbCBpbnZvY2FibGVzLCBhcyB3ZWxsIGFzIGFueSBpbmhlcml0ZWQgYW5kIGxvY2FsIHZhbHVlcy5cbiAgICovXG4gIHRoaXMucmVzb2x2ZSA9IGZ1bmN0aW9uIChpbnZvY2FibGVzLCBsb2NhbHMsIHBhcmVudCwgc2VsZikge1xuICAgIHJldHVybiB0aGlzLnN0dWR5KGludm9jYWJsZXMpKGxvY2FscywgcGFyZW50LCBzZWxmKTtcbiAgfTtcbn1cblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci51dGlsJykuc2VydmljZSgnJHJlc29sdmUnLCAkUmVzb2x2ZSk7XG5cblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kdGVtcGxhdGVGYWN0b3J5XG4gKlxuICogQHJlcXVpcmVzICRodHRwXG4gKiBAcmVxdWlyZXMgJHRlbXBsYXRlQ2FjaGVcbiAqIEByZXF1aXJlcyAkaW5qZWN0b3JcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNlcnZpY2UuIE1hbmFnZXMgbG9hZGluZyBvZiB0ZW1wbGF0ZXMuXG4gKi9cbiRUZW1wbGF0ZUZhY3RvcnkuJGluamVjdCA9IFsnJGh0dHAnLCAnJHRlbXBsYXRlQ2FjaGUnLCAnJGluamVjdG9yJ107XG5mdW5jdGlvbiAkVGVtcGxhdGVGYWN0b3J5KCAgJGh0dHAsICAgJHRlbXBsYXRlQ2FjaGUsICAgJGluamVjdG9yKSB7XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kdGVtcGxhdGVGYWN0b3J5I2Zyb21Db25maWdcbiAgICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLiR0ZW1wbGF0ZUZhY3RvcnlcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgY29uZmlndXJhdGlvbiBvYmplY3QuIFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB3aGljaCB0byBsb2FkIGEgdGVtcGxhdGUuIFxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIHNlYXJjaCBpbiB0aGUgc3BlY2lmaWVkIG9yZGVyLCBhbmQgdGhlIGZpcnN0IG9uZSBcbiAgICogdGhhdCBpcyBkZWZpbmVkIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSB0ZW1wbGF0ZTpcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBjb25maWcudGVtcGxhdGUgaHRtbCBzdHJpbmcgdGVtcGxhdGUgb3IgZnVuY3Rpb24gdG8gXG4gICAqIGxvYWQgdmlhIHtAbGluayB1aS5yb3V0ZXIudXRpbC4kdGVtcGxhdGVGYWN0b3J5I2Zyb21TdHJpbmcgZnJvbVN0cmluZ30uXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gY29uZmlnLnRlbXBsYXRlVXJsIHVybCB0byBsb2FkIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIFxuICAgKiB0aGUgdXJsIHRvIGxvYWQgdmlhIHtAbGluayB1aS5yb3V0ZXIudXRpbC4kdGVtcGxhdGVGYWN0b3J5I2Zyb21VcmwgZnJvbVVybH0uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy50ZW1wbGF0ZVByb3ZpZGVyIGZ1bmN0aW9uIHRvIGludm9rZSB2aWEgXG4gICAqIHtAbGluayB1aS5yb3V0ZXIudXRpbC4kdGVtcGxhdGVGYWN0b3J5I2Zyb21Qcm92aWRlciBmcm9tUHJvdmlkZXJ9LlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zICBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbG9jYWxzIExvY2FscyB0byBwYXNzIHRvIGBpbnZva2VgIGlmIHRoZSB0ZW1wbGF0ZSBpcyBsb2FkZWQgXG4gICAqIHZpYSBhIGB0ZW1wbGF0ZVByb3ZpZGVyYC4gRGVmYXVsdHMgdG8gYHsgcGFyYW1zOiBwYXJhbXMgfWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3xvYmplY3R9ICBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIGZvciBcbiAgICogdGhhdCBzdHJpbmcsb3IgYG51bGxgIGlmIG5vIHRlbXBsYXRlIGlzIGNvbmZpZ3VyZWQuXG4gICAqL1xuICB0aGlzLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY29uZmlnLCBwYXJhbXMsIGxvY2Fscykge1xuICAgIHJldHVybiAoXG4gICAgICBpc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlKSA/IHRoaXMuZnJvbVN0cmluZyhjb25maWcudGVtcGxhdGUsIHBhcmFtcykgOlxuICAgICAgaXNEZWZpbmVkKGNvbmZpZy50ZW1wbGF0ZVVybCkgPyB0aGlzLmZyb21VcmwoY29uZmlnLnRlbXBsYXRlVXJsLCBwYXJhbXMpIDpcbiAgICAgIGlzRGVmaW5lZChjb25maWcudGVtcGxhdGVQcm92aWRlcikgPyB0aGlzLmZyb21Qcm92aWRlcihjb25maWcudGVtcGxhdGVQcm92aWRlciwgcGFyYW1zLCBsb2NhbHMpIDpcbiAgICAgIG51bGxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgdWkucm91dGVyLnV0aWwuJHRlbXBsYXRlRmFjdG9yeSNmcm9tU3RyaW5nXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC4kdGVtcGxhdGVGYWN0b3J5XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDcmVhdGVzIGEgdGVtcGxhdGUgZnJvbSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSB0ZW1wbGF0ZSBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nIG9yIGZ1bmN0aW9uIHRoYXQgXG4gICAqIHJldHVybnMgYW4gaHRtbCB0ZW1wbGF0ZSBhcyBhIHN0cmluZy5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8b2JqZWN0fSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIGZvciB0aGF0IFxuICAgKiBzdHJpbmcuXG4gICAqL1xuICB0aGlzLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHBhcmFtcykge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKHRlbXBsYXRlKSA/IHRlbXBsYXRlKHBhcmFtcykgOiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHVpLnJvdXRlci51dGlsLiR0ZW1wbGF0ZUZhY3RvcnkjZnJvbVVybFxuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwuJHRlbXBsYXRlRmFjdG9yeVxuICAgKiBcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIExvYWRzIGEgdGVtcGxhdGUgZnJvbSB0aGUgYSBVUkwgdmlhIGAkaHR0cGAgYW5kIGAkdGVtcGxhdGVDYWNoZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSB1cmwgdXJsIG9mIHRoZSB0ZW1wbGF0ZSB0byBsb2FkLCBvciBhIGZ1bmN0aW9uIFxuICAgKiB0aGF0IHJldHVybnMgYSB1cmwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgUGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSB1cmwgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge3N0cmluZ3xQcm9taXNlLjxzdHJpbmc+fSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIFxuICAgKiBmb3IgdGhhdCBzdHJpbmcuXG4gICAqL1xuICB0aGlzLmZyb21VcmwgPSBmdW5jdGlvbiAodXJsLCBwYXJhbXMpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih1cmwpKSB1cmwgPSB1cmwocGFyYW1zKTtcbiAgICBpZiAodXJsID09IG51bGwpIHJldHVybiBudWxsO1xuICAgIGVsc2UgcmV0dXJuICRodHRwXG4gICAgICAgIC5nZXQodXJsLCB7IGNhY2hlOiAkdGVtcGxhdGVDYWNoZSwgaGVhZGVyczogeyBBY2NlcHQ6ICd0ZXh0L2h0bWwnIH19KVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZSkgeyByZXR1cm4gcmVzcG9uc2UuZGF0YTsgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kdGVtcGxhdGVGYWN0b3J5I2Zyb21Qcm92aWRlclxuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwuJHRlbXBsYXRlRmFjdG9yeVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGJ5IGludm9raW5nIGFuIGluamVjdGFibGUgcHJvdmlkZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3ZpZGVyIEZ1bmN0aW9uIHRvIGludm9rZSB2aWEgYCRpbmplY3Rvci5pbnZva2VgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgUGFyYW1ldGVycyBmb3IgdGhlIHRlbXBsYXRlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYWxzIExvY2FscyB0byBwYXNzIHRvIGBpbnZva2VgLiBEZWZhdWx0cyB0byBcbiAgICogYHsgcGFyYW1zOiBwYXJhbXMgfWAuXG4gICAqIEByZXR1cm4ge3N0cmluZ3xQcm9taXNlLjxzdHJpbmc+fSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIFxuICAgKiBmb3IgdGhhdCBzdHJpbmcuXG4gICAqL1xuICB0aGlzLmZyb21Qcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgcGFyYW1zLCBsb2NhbHMpIHtcbiAgICByZXR1cm4gJGluamVjdG9yLmludm9rZShwcm92aWRlciwgbnVsbCwgbG9jYWxzIHx8IHsgcGFyYW1zOiBwYXJhbXMgfSk7XG4gIH07XG59XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIudXRpbCcpLnNlcnZpY2UoJyR0ZW1wbGF0ZUZhY3RvcnknLCAkVGVtcGxhdGVGYWN0b3J5KTtcblxudmFyICQkVU1GUDsgLy8gcmVmZXJlbmNlIHRvICRVcmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyXG5cbi8qKlxuICogQG5nZG9jIG9iamVjdFxuICogQG5hbWUgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNYXRjaGVzIFVSTHMgYWdhaW5zdCBwYXR0ZXJucyBhbmQgZXh0cmFjdHMgbmFtZWQgcGFyYW1ldGVycyBmcm9tIHRoZSBwYXRoIG9yIHRoZSBzZWFyY2hcbiAqIHBhcnQgb2YgdGhlIFVSTC4gQSBVUkwgcGF0dGVybiBjb25zaXN0cyBvZiBhIHBhdGggcGF0dGVybiwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSAnPycgYW5kIGEgbGlzdFxuICogb2Ygc2VhcmNoIHBhcmFtZXRlcnMuIE11bHRpcGxlIHNlYXJjaCBwYXJhbWV0ZXIgbmFtZXMgYXJlIHNlcGFyYXRlZCBieSAnJicuIFNlYXJjaCBwYXJhbWV0ZXJzXG4gKiBkbyBub3QgaW5mbHVlbmNlIHdoZXRoZXIgb3Igbm90IGEgVVJMIGlzIG1hdGNoZWQsIGJ1dCB0aGVpciB2YWx1ZXMgYXJlIHBhc3NlZCB0aHJvdWdoIGludG9cbiAqIHRoZSBtYXRjaGVkIHBhcmFtZXRlcnMgcmV0dXJuZWQgYnkge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciNtZXRob2RzX2V4ZWMgZXhlY30uXG4gKlxuICogUGF0aCBwYXJhbWV0ZXIgcGxhY2Vob2xkZXJzIGNhbiBiZSBzcGVjaWZpZWQgdXNpbmcgc2ltcGxlIGNvbG9uL2NhdGNoLWFsbCBzeW50YXggb3IgY3VybHkgYnJhY2VcbiAqIHN5bnRheCwgd2hpY2ggb3B0aW9uYWxseSBhbGxvd3MgYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIHRoZSBwYXJhbWV0ZXIgdG8gYmUgc3BlY2lmaWVkOlxuICpcbiAqICogYCc6J2AgbmFtZSAtIGNvbG9uIHBsYWNlaG9sZGVyXG4gKiAqIGAnKidgIG5hbWUgLSBjYXRjaC1hbGwgcGxhY2Vob2xkZXJcbiAqICogYCd7JyBuYW1lICd9J2AgLSBjdXJseSBwbGFjZWhvbGRlclxuICogKiBgJ3snIG5hbWUgJzonIHJlZ2V4cHx0eXBlICd9J2AgLSBjdXJseSBwbGFjZWhvbGRlciB3aXRoIHJlZ2V4cCBvciB0eXBlIG5hbWUuIFNob3VsZCB0aGVcbiAqICAgcmVnZXhwIGl0c2VsZiBjb250YWluIGN1cmx5IGJyYWNlcywgdGhleSBtdXN0IGJlIGluIG1hdGNoZWQgcGFpcnMgb3IgZXNjYXBlZCB3aXRoIGEgYmFja3NsYXNoLlxuICpcbiAqIFBhcmFtZXRlciBuYW1lcyBtYXkgY29udGFpbiBvbmx5IHdvcmQgY2hhcmFjdGVycyAobGF0aW4gbGV0dGVycywgZGlnaXRzLCBhbmQgdW5kZXJzY29yZSkgYW5kXG4gKiBtdXN0IGJlIHVuaXF1ZSB3aXRoaW4gdGhlIHBhdHRlcm4gKGFjcm9zcyBib3RoIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzKS4gRm9yIGNvbG9uXG4gKiBwbGFjZWhvbGRlcnMgb3IgY3VybHkgcGxhY2Vob2xkZXJzIHdpdGhvdXQgYW4gZXhwbGljaXQgcmVnZXhwLCBhIHBhdGggcGFyYW1ldGVyIG1hdGNoZXMgYW55XG4gKiBudW1iZXIgb2YgY2hhcmFjdGVycyBvdGhlciB0aGFuICcvJy4gRm9yIGNhdGNoLWFsbCBwbGFjZWhvbGRlcnMgdGhlIHBhdGggcGFyYW1ldGVyIG1hdGNoZXNcbiAqIGFueSBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAqIGAnL2hlbGxvLydgIC0gTWF0Y2hlcyBvbmx5IGlmIHRoZSBwYXRoIGlzIGV4YWN0bHkgJy9oZWxsby8nLiBUaGVyZSBpcyBubyBzcGVjaWFsIHRyZWF0bWVudCBmb3JcbiAqICAgdHJhaWxpbmcgc2xhc2hlcywgYW5kIHBhdHRlcm5zIGhhdmUgdG8gbWF0Y2ggdGhlIGVudGlyZSBwYXRoLCBub3QganVzdCBhIHByZWZpeC5cbiAqICogYCcvdXNlci86aWQnYCAtIE1hdGNoZXMgJy91c2VyL2JvYicgb3IgJy91c2VyLzEyMzQhISEnIG9yIGV2ZW4gJy91c2VyLycgYnV0IG5vdCAnL3VzZXInIG9yXG4gKiAgICcvdXNlci9ib2IvZGV0YWlscycuIFRoZSBzZWNvbmQgcGF0aCBzZWdtZW50IHdpbGwgYmUgY2FwdHVyZWQgYXMgdGhlIHBhcmFtZXRlciAnaWQnLlxuICogKiBgJy91c2VyL3tpZH0nYCAtIFNhbWUgYXMgdGhlIHByZXZpb3VzIGV4YW1wbGUsIGJ1dCB1c2luZyBjdXJseSBicmFjZSBzeW50YXguXG4gKiAqIGAnL3VzZXIve2lkOlteL10qfSdgIC0gU2FtZSBhcyB0aGUgcHJldmlvdXMgZXhhbXBsZS5cbiAqICogYCcvdXNlci97aWQ6WzAtOWEtZkEtRl17MSw4fX0nYCAtIFNpbWlsYXIgdG8gdGhlIHByZXZpb3VzIGV4YW1wbGUsIGJ1dCBvbmx5IG1hdGNoZXMgaWYgdGhlIGlkXG4gKiAgIHBhcmFtZXRlciBjb25zaXN0cyBvZiAxIHRvIDggaGV4IGRpZ2l0cy5cbiAqICogYCcvZmlsZXMve3BhdGg6Lip9J2AgLSBNYXRjaGVzIGFueSBVUkwgc3RhcnRpbmcgd2l0aCAnL2ZpbGVzLycgYW5kIGNhcHR1cmVzIHRoZSByZXN0IG9mIHRoZVxuICogICBwYXRoIGludG8gdGhlIHBhcmFtZXRlciAncGF0aCcuXG4gKiAqIGAnL2ZpbGVzLypwYXRoJ2AgLSBkaXR0by5cbiAqICogYCcvY2FsZW5kYXIve3N0YXJ0OmRhdGV9J2AgLSBNYXRjaGVzIFwiL2NhbGVuZGFyLzIwMTQtMTEtMTJcIiAoYmVjYXVzZSB0aGUgcGF0dGVybiBkZWZpbmVkXG4gKiAgIGluIHRoZSBidWlsdC1pbiAgYGRhdGVgIFR5cGUgbWF0Y2hlcyBgMjAxNC0xMS0xMmApIGFuZCBwcm92aWRlcyBhIERhdGUgb2JqZWN0IGluICRzdGF0ZVBhcmFtcy5zdGFydFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuICBUaGUgcGF0dGVybiB0byBjb21waWxlIGludG8gYSBtYXRjaGVyLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAgQSBjb25maWd1cmF0aW9uIG9iamVjdCBoYXNoOlxuICogQHBhcmFtIHtPYmplY3Q9fSBwYXJlbnRNYXRjaGVyIFVzZWQgdG8gY29uY2F0ZW5hdGUgdGhlIHBhdHRlcm4vY29uZmlnIG9udG9cbiAqICAgYW4gZXhpc3RpbmcgVXJsTWF0Y2hlclxuICpcbiAqICogYGNhc2VJbnNlbnNpdGl2ZWAgLSBgdHJ1ZWAgaWYgVVJMIG1hdGNoaW5nIHNob3VsZCBiZSBjYXNlIGluc2Vuc2l0aXZlLCBvdGhlcndpc2UgYGZhbHNlYCwgdGhlIGRlZmF1bHQgdmFsdWUgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KSBpcyBgZmFsc2VgLlxuICogKiBgc3RyaWN0YCAtIGBmYWxzZWAgaWYgbWF0Y2hpbmcgYWdhaW5zdCBhIFVSTCB3aXRoIGEgdHJhaWxpbmcgc2xhc2ggc2hvdWxkIGJlIHRyZWF0ZWQgYXMgZXF1aXZhbGVudCB0byBhIFVSTCB3aXRob3V0IGEgdHJhaWxpbmcgc2xhc2gsIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcHJlZml4ICBBIHN0YXRpYyBwcmVmaXggb2YgdGhpcyBwYXR0ZXJuLiBUaGUgbWF0Y2hlciBndWFyYW50ZWVzIHRoYXQgYW55XG4gKiAgIFVSTCBtYXRjaGluZyB0aGlzIG1hdGNoZXIgKGkuZS4gYW55IHN0cmluZyBmb3Igd2hpY2gge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciNtZXRob2RzX2V4ZWMgZXhlYygpfSByZXR1cm5zXG4gKiAgIG5vbi1udWxsKSB3aWxsIHN0YXJ0IHdpdGggdGhpcyBwcmVmaXguXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZSAgVGhlIHBhdHRlcm4gdGhhdCB3YXMgcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZVBhdGggIFRoZSBwYXRoIHBvcnRpb24gb2YgdGhlIHNvdXJjZSBwcm9wZXJ0eVxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2VTZWFyY2ggIFRoZSBzZWFyY2ggcG9ydGlvbiBvZiB0aGUgc291cmNlIHByb3BlcnR5XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlZ2V4ICBUaGUgY29uc3RydWN0ZWQgcmVnZXggdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWF0Y2ggYWdhaW5zdCB0aGUgdXJsIHdoZW5cbiAqICAgaXQgaXMgdGltZSB0byBkZXRlcm1pbmUgd2hpY2ggdXJsIHdpbGwgbWF0Y2guXG4gKlxuICogQHJldHVybnMge09iamVjdH0gIE5ldyBgVXJsTWF0Y2hlcmAgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIFVybE1hdGNoZXIocGF0dGVybiwgY29uZmlnLCBwYXJlbnRNYXRjaGVyKSB7XG4gIGNvbmZpZyA9IGV4dGVuZCh7IHBhcmFtczoge30gfSwgaXNPYmplY3QoY29uZmlnKSA/IGNvbmZpZyA6IHt9KTtcblxuICAvLyBGaW5kIGFsbCBwbGFjZWhvbGRlcnMgYW5kIGNyZWF0ZSBhIGNvbXBpbGVkIHBhdHRlcm4sIHVzaW5nIGVpdGhlciBjbGFzc2ljIG9yIGN1cmx5IHN5bnRheDpcbiAgLy8gICAnKicgbmFtZVxuICAvLyAgICc6JyBuYW1lXG4gIC8vICAgJ3snIG5hbWUgJ30nXG4gIC8vICAgJ3snIG5hbWUgJzonIHJlZ2V4cCAnfSdcbiAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBzb21ld2hhdCBjb21wbGljYXRlZCBkdWUgdG8gdGhlIG5lZWQgdG8gYWxsb3cgY3VybHkgYnJhY2VzXG4gIC8vIGluc2lkZSB0aGUgcmVndWxhciBleHByZXNzaW9uLiBUaGUgcGxhY2Vob2xkZXIgcmVnZXhwIGJyZWFrcyBkb3duIGFzIGZvbGxvd3M6XG4gIC8vICAgIChbOipdKShbXFx3XFxbXFxdXSspICAgICAgICAgICAgICAtIGNsYXNzaWMgcGxhY2Vob2xkZXIgKCQxIC8gJDIpIChzZWFyY2ggdmVyc2lvbiBoYXMgLSBmb3Igc25ha2UtY2FzZSlcbiAgLy8gICAgXFx7KFtcXHdcXFtcXF1dKykoPzpcXDpcXHMqKCAuLi4gKSk/XFx9ICAtIGN1cmx5IGJyYWNlIHBsYWNlaG9sZGVyICgkMykgd2l0aCBvcHRpb25hbCByZWdleHAvdHlwZSAuLi4gKCQ0KSAoc2VhcmNoIHZlcnNpb24gaGFzIC0gZm9yIHNuYWtlLWNhc2VcbiAgLy8gICAgKD86IC4uLiB8IC4uLiB8IC4uLiApKyAgICAgICAgIC0gdGhlIHJlZ2V4cCBjb25zaXN0cyBvZiBhbnkgbnVtYmVyIG9mIGF0b21zLCBhbiBhdG9tIGJlaW5nIGVpdGhlclxuICAvLyAgICBbXnt9XFxcXF0rICAgICAgICAgICAgICAgICAgICAgICAtIGFueXRoaW5nIG90aGVyIHRoYW4gY3VybHkgYnJhY2VzIG9yIGJhY2tzbGFzaFxuICAvLyAgICBcXFxcLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGEgYmFja3NsYXNoIGVzY2FwZVxuICAvLyAgICBcXHsoPzpbXnt9XFxcXF0rfFxcXFwuKSpcXH0gICAgICAgICAgLSBhIG1hdGNoZWQgc2V0IG9mIGN1cmx5IGJyYWNlcyBjb250YWluaW5nIG90aGVyIGF0b21zXG4gIHZhciBwbGFjZWhvbGRlciAgICAgICA9IC8oWzoqXSkoW1xcd1xcW1xcXV0rKXxcXHsoW1xcd1xcW1xcXV0rKSg/OlxcOlxccyooKD86W157fVxcXFxdK3xcXFxcLnxcXHsoPzpbXnt9XFxcXF0rfFxcXFwuKSpcXH0pKykpP1xcfS9nLFxuICAgICAgc2VhcmNoUGxhY2Vob2xkZXIgPSAvKFs6XT8pKFtcXHdcXFtcXF0uLV0rKXxcXHsoW1xcd1xcW1xcXS4tXSspKD86XFw6XFxzKigoPzpbXnt9XFxcXF0rfFxcXFwufFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSkrKSk/XFx9L2csXG4gICAgICBjb21waWxlZCA9ICdeJywgbGFzdCA9IDAsIG0sXG4gICAgICBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHMgPSBbXSxcbiAgICAgIHBhcmVudFBhcmFtcyA9IHBhcmVudE1hdGNoZXIgPyBwYXJlbnRNYXRjaGVyLnBhcmFtcyA6IHt9LFxuICAgICAgcGFyYW1zID0gdGhpcy5wYXJhbXMgPSBwYXJlbnRNYXRjaGVyID8gcGFyZW50TWF0Y2hlci5wYXJhbXMuJCRuZXcoKSA6IG5ldyAkJFVNRlAuUGFyYW1TZXQoKSxcbiAgICAgIHBhcmFtTmFtZXMgPSBbXTtcblxuICBmdW5jdGlvbiBhZGRQYXJhbWV0ZXIoaWQsIHR5cGUsIGNvbmZpZywgbG9jYXRpb24pIHtcbiAgICBwYXJhbU5hbWVzLnB1c2goaWQpO1xuICAgIGlmIChwYXJlbnRQYXJhbXNbaWRdKSByZXR1cm4gcGFyZW50UGFyYW1zW2lkXTtcbiAgICBpZiAoIS9eXFx3KyhbLS5dK1xcdyspKig/OlxcW1xcXSk/JC8udGVzdChpZCkpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyYW1ldGVyIG5hbWUgJ1wiICsgaWQgKyBcIicgaW4gcGF0dGVybiAnXCIgKyBwYXR0ZXJuICsgXCInXCIpO1xuICAgIGlmIChwYXJhbXNbaWRdKSB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWUgJ1wiICsgaWQgKyBcIicgaW4gcGF0dGVybiAnXCIgKyBwYXR0ZXJuICsgXCInXCIpO1xuICAgIHBhcmFtc1tpZF0gPSBuZXcgJCRVTUZQLlBhcmFtKGlkLCB0eXBlLCBjb25maWcsIGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcGFyYW1zW2lkXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1b3RlUmVnRXhwKHN0cmluZywgcGF0dGVybiwgc3F1YXNoLCBvcHRpb25hbCkge1xuICAgIHZhciBzdXJyb3VuZFBhdHRlcm4gPSBbJycsJyddLCByZXN1bHQgPSBzdHJpbmcucmVwbGFjZSgvW1xcXFxcXFtcXF1cXF4kKis/LigpfHt9XS9nLCBcIlxcXFwkJlwiKTtcbiAgICBpZiAoIXBhdHRlcm4pIHJldHVybiByZXN1bHQ7XG4gICAgc3dpdGNoKHNxdWFzaCkge1xuICAgICAgY2FzZSBmYWxzZTogc3Vycm91bmRQYXR0ZXJuID0gWycoJywgJyknICsgKG9wdGlvbmFsID8gXCI/XCIgOiBcIlwiKV07IGJyZWFrO1xuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgICAgc3Vycm91bmRQYXR0ZXJuID0gWycoPzpcXC8oJywgJyl8XFwvKT8nXTtcbiAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogICAgc3Vycm91bmRQYXR0ZXJuID0gWycoJyArIHNxdWFzaCArIFwifFwiLCAnKT8nXTsgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyBzdXJyb3VuZFBhdHRlcm5bMF0gKyBwYXR0ZXJuICsgc3Vycm91bmRQYXR0ZXJuWzFdO1xuICB9XG5cbiAgdGhpcy5zb3VyY2UgPSBwYXR0ZXJuO1xuXG4gIC8vIFNwbGl0IGludG8gc3RhdGljIHNlZ21lbnRzIHNlcGFyYXRlZCBieSBwYXRoIHBhcmFtZXRlciBwbGFjZWhvbGRlcnMuXG4gIC8vIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgaXMgYWx3YXlzIDEgbW9yZSB0aGFuIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycy5cbiAgZnVuY3Rpb24gbWF0Y2hEZXRhaWxzKG0sIGlzU2VhcmNoKSB7XG4gICAgdmFyIGlkLCByZWdleHAsIHNlZ21lbnQsIHR5cGUsIGNmZywgYXJyYXlNb2RlO1xuICAgIGlkICAgICAgICAgID0gbVsyXSB8fCBtWzNdOyAvLyBJRVs3OF0gcmV0dXJucyAnJyBmb3IgdW5tYXRjaGVkIGdyb3VwcyBpbnN0ZWFkIG9mIG51bGxcbiAgICBjZmcgICAgICAgICA9IGNvbmZpZy5wYXJhbXNbaWRdO1xuICAgIHNlZ21lbnQgICAgID0gcGF0dGVybi5zdWJzdHJpbmcobGFzdCwgbS5pbmRleCk7XG4gICAgcmVnZXhwICAgICAgPSBpc1NlYXJjaCA/IG1bNF0gOiBtWzRdIHx8IChtWzFdID09ICcqJyA/ICcuKicgOiBudWxsKTtcblxuICAgIGlmIChyZWdleHApIHtcbiAgICAgIHR5cGUgICAgICA9ICQkVU1GUC50eXBlKHJlZ2V4cCkgfHwgaW5oZXJpdCgkJFVNRlAudHlwZShcInN0cmluZ1wiKSwgeyBwYXR0ZXJuOiBuZXcgUmVnRXhwKHJlZ2V4cCwgY29uZmlnLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6IHVuZGVmaW5lZCkgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBpZCwgcmVnZXhwOiByZWdleHAsIHNlZ21lbnQ6IHNlZ21lbnQsIHR5cGU6IHR5cGUsIGNmZzogY2ZnXG4gICAgfTtcbiAgfVxuXG4gIHZhciBwLCBwYXJhbSwgc2VnbWVudDtcbiAgd2hpbGUgKChtID0gcGxhY2Vob2xkZXIuZXhlYyhwYXR0ZXJuKSkpIHtcbiAgICBwID0gbWF0Y2hEZXRhaWxzKG0sIGZhbHNlKTtcbiAgICBpZiAocC5zZWdtZW50LmluZGV4T2YoJz8nKSA+PSAwKSBicmVhazsgLy8gd2UncmUgaW50byB0aGUgc2VhcmNoIHBhcnRcblxuICAgIHBhcmFtID0gYWRkUGFyYW1ldGVyKHAuaWQsIHAudHlwZSwgcC5jZmcsIFwicGF0aFwiKTtcbiAgICBjb21waWxlZCArPSBxdW90ZVJlZ0V4cChwLnNlZ21lbnQsIHBhcmFtLnR5cGUucGF0dGVybi5zb3VyY2UsIHBhcmFtLnNxdWFzaCwgcGFyYW0uaXNPcHRpb25hbCk7XG4gICAgc2VnbWVudHMucHVzaChwLnNlZ21lbnQpO1xuICAgIGxhc3QgPSBwbGFjZWhvbGRlci5sYXN0SW5kZXg7XG4gIH1cbiAgc2VnbWVudCA9IHBhdHRlcm4uc3Vic3RyaW5nKGxhc3QpO1xuXG4gIC8vIEZpbmQgYW55IHNlYXJjaCBwYXJhbWV0ZXIgbmFtZXMgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIGxhc3Qgc2VnbWVudFxuICB2YXIgaSA9IHNlZ21lbnQuaW5kZXhPZignPycpO1xuXG4gIGlmIChpID49IDApIHtcbiAgICB2YXIgc2VhcmNoID0gdGhpcy5zb3VyY2VTZWFyY2ggPSBzZWdtZW50LnN1YnN0cmluZyhpKTtcbiAgICBzZWdtZW50ID0gc2VnbWVudC5zdWJzdHJpbmcoMCwgaSk7XG4gICAgdGhpcy5zb3VyY2VQYXRoID0gcGF0dGVybi5zdWJzdHJpbmcoMCwgbGFzdCArIGkpO1xuXG4gICAgaWYgKHNlYXJjaC5sZW5ndGggPiAwKSB7XG4gICAgICBsYXN0ID0gMDtcbiAgICAgIHdoaWxlICgobSA9IHNlYXJjaFBsYWNlaG9sZGVyLmV4ZWMoc2VhcmNoKSkpIHtcbiAgICAgICAgcCA9IG1hdGNoRGV0YWlscyhtLCB0cnVlKTtcbiAgICAgICAgcGFyYW0gPSBhZGRQYXJhbWV0ZXIocC5pZCwgcC50eXBlLCBwLmNmZywgXCJzZWFyY2hcIik7XG4gICAgICAgIGxhc3QgPSBwbGFjZWhvbGRlci5sYXN0SW5kZXg7XG4gICAgICAgIC8vIGNoZWNrIGlmID8mXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuc291cmNlUGF0aCA9IHBhdHRlcm47XG4gICAgdGhpcy5zb3VyY2VTZWFyY2ggPSAnJztcbiAgfVxuXG4gIGNvbXBpbGVkICs9IHF1b3RlUmVnRXhwKHNlZ21lbnQpICsgKGNvbmZpZy5zdHJpY3QgPT09IGZhbHNlID8gJ1xcLz8nIDogJycpICsgJyQnO1xuICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXG4gIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChjb21waWxlZCwgY29uZmlnLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6IHVuZGVmaW5lZCk7XG4gIHRoaXMucHJlZml4ID0gc2VnbWVudHNbMF07XG4gIHRoaXMuJCRwYXJhbU5hbWVzID0gcGFyYW1OYW1lcztcbn1cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciNjb25jYXRcbiAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgYSBuZXcgbWF0Y2hlciBmb3IgYSBwYXR0ZXJuIGNvbnN0cnVjdGVkIGJ5IGFwcGVuZGluZyB0aGUgcGF0aCBwYXJ0IGFuZCBhZGRpbmcgdGhlXG4gKiBzZWFyY2ggcGFyYW1ldGVycyBvZiB0aGUgc3BlY2lmaWVkIHBhdHRlcm4gdG8gdGhpcyBwYXR0ZXJuLiBUaGUgY3VycmVudCBwYXR0ZXJuIGlzIG5vdFxuICogbW9kaWZpZWQuIFRoaXMgY2FuIGJlIHVuZGVyc3Rvb2QgYXMgY3JlYXRpbmcgYSBwYXR0ZXJuIGZvciBVUkxzIHRoYXQgYXJlIHJlbGF0aXZlIHRvIChvclxuICogc3VmZml4ZXMgb2YpIHRoZSBjdXJyZW50IHBhdHRlcm4uXG4gKlxuICogQGV4YW1wbGVcbiAqIFRoZSBmb2xsb3dpbmcgdHdvIG1hdGNoZXJzIGFyZSBlcXVpdmFsZW50OlxuICogPHByZT5cbiAqIG5ldyBVcmxNYXRjaGVyKCcvdXNlci97aWR9P3EnKS5jb25jYXQoJy9kZXRhaWxzP2RhdGUnKTtcbiAqIG5ldyBVcmxNYXRjaGVyKCcvdXNlci97aWR9L2RldGFpbHM/cSZkYXRlJyk7XG4gKiA8L3ByZT5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiAgVGhlIHBhdHRlcm4gdG8gYXBwZW5kLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAgQW4gb2JqZWN0IGhhc2ggb2YgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBtYXRjaGVyLlxuICogQHJldHVybnMge1VybE1hdGNoZXJ9ICBBIG1hdGNoZXIgZm9yIHRoZSBjb25jYXRlbmF0ZWQgcGF0dGVybi5cbiAqL1xuVXJsTWF0Y2hlci5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKHBhdHRlcm4sIGNvbmZpZykge1xuICAvLyBCZWNhdXNlIG9yZGVyIG9mIHNlYXJjaCBwYXJhbWV0ZXJzIGlzIGlycmVsZXZhbnQsIHdlIGNhbiBhZGQgb3VyIG93biBzZWFyY2hcbiAgLy8gcGFyYW1ldGVycyB0byB0aGUgZW5kIG9mIHRoZSBuZXcgcGF0dGVybi4gUGFyc2UgdGhlIG5ldyBwYXR0ZXJuIGJ5IGl0c2VsZlxuICAvLyBhbmQgdGhlbiBqb2luIHRoZSBiaXRzIHRvZ2V0aGVyLCBidXQgaXQncyBtdWNoIGVhc2llciB0byBkbyB0aGlzIG9uIGEgc3RyaW5nIGxldmVsLlxuICB2YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBjYXNlSW5zZW5zaXRpdmU6ICQkVU1GUC5jYXNlSW5zZW5zaXRpdmUoKSxcbiAgICBzdHJpY3Q6ICQkVU1GUC5zdHJpY3RNb2RlKCksXG4gICAgc3F1YXNoOiAkJFVNRlAuZGVmYXVsdFNxdWFzaFBvbGljeSgpXG4gIH07XG4gIHJldHVybiBuZXcgVXJsTWF0Y2hlcih0aGlzLnNvdXJjZVBhdGggKyBwYXR0ZXJuICsgdGhpcy5zb3VyY2VTZWFyY2gsIGV4dGVuZChkZWZhdWx0Q29uZmlnLCBjb25maWcpLCB0aGlzKTtcbn07XG5cblVybE1hdGNoZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zb3VyY2U7XG59O1xuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyI2V4ZWNcbiAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRlc3RzIHRoZSBzcGVjaWZpZWQgcGF0aCBhZ2FpbnN0IHRoaXMgbWF0Y2hlciwgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhcHR1cmVkXG4gKiBwYXJhbWV0ZXIgdmFsdWVzLCBvciBudWxsIGlmIHRoZSBwYXRoIGRvZXMgbm90IG1hdGNoLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zIHRoZSB2YWx1ZXNcbiAqIG9mIGFueSBzZWFyY2ggcGFyYW1ldGVycyB0aGF0IGFyZSBtZW50aW9uZWQgaW4gdGhlIHBhdHRlcm4sIGJ1dCB0aGVpciB2YWx1ZSBtYXkgYmUgbnVsbCBpZlxuICogdGhleSBhcmUgbm90IHByZXNlbnQgaW4gYHNlYXJjaFBhcmFtc2AuIFRoaXMgbWVhbnMgdGhhdCBzZWFyY2ggcGFyYW1ldGVycyBhcmUgYWx3YXlzIHRyZWF0ZWRcbiAqIGFzIG9wdGlvbmFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiA8cHJlPlxuICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0/cSZyJykuZXhlYygnL3VzZXIvYm9iJywge1xuICogICB4OiAnMScsIHE6ICdoZWxsbydcbiAqIH0pO1xuICogLy8gcmV0dXJucyB7IGlkOiAnYm9iJywgcTogJ2hlbGxvJywgcjogbnVsbCB9XG4gKiA8L3ByZT5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAgVGhlIFVSTCBwYXRoIHRvIG1hdGNoLCBlLmcuIGAkbG9jYXRpb24ucGF0aCgpYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWFyY2hQYXJhbXMgIFVSTCBzZWFyY2ggcGFyYW1ldGVycywgZS5nLiBgJGxvY2F0aW9uLnNlYXJjaCgpYC5cbiAqIEByZXR1cm5zIHtPYmplY3R9ICBUaGUgY2FwdHVyZWQgcGFyYW1ldGVyIHZhbHVlcy5cbiAqL1xuVXJsTWF0Y2hlci5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChwYXRoLCBzZWFyY2hQYXJhbXMpIHtcbiAgdmFyIG0gPSB0aGlzLnJlZ2V4cC5leGVjKHBhdGgpO1xuICBpZiAoIW0pIHJldHVybiBudWxsO1xuICBzZWFyY2hQYXJhbXMgPSBzZWFyY2hQYXJhbXMgfHwge307XG5cbiAgdmFyIHBhcmFtTmFtZXMgPSB0aGlzLnBhcmFtZXRlcnMoKSwgblRvdGFsID0gcGFyYW1OYW1lcy5sZW5ndGgsXG4gICAgblBhdGggPSB0aGlzLnNlZ21lbnRzLmxlbmd0aCAtIDEsXG4gICAgdmFsdWVzID0ge30sIGksIGosIGNmZywgcGFyYW1OYW1lO1xuXG4gIGlmIChuUGF0aCAhPT0gbS5sZW5ndGggLSAxKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmJhbGFuY2VkIGNhcHR1cmUgZ3JvdXAgaW4gcm91dGUgJ1wiICsgdGhpcy5zb3VyY2UgKyBcIidcIik7XG5cbiAgZnVuY3Rpb24gZGVjb2RlUGF0aEFycmF5KHN0cmluZykge1xuICAgIGZ1bmN0aW9uIHJldmVyc2VTdHJpbmcoc3RyKSB7IHJldHVybiBzdHIuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7IH1cbiAgICBmdW5jdGlvbiB1bnF1b3RlRGFzaGVzKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwtL2csIFwiLVwiKTsgfVxuXG4gICAgdmFyIHNwbGl0ID0gcmV2ZXJzZVN0cmluZyhzdHJpbmcpLnNwbGl0KC8tKD8hXFxcXCkvKTtcbiAgICB2YXIgYWxsUmV2ZXJzZWQgPSBtYXAoc3BsaXQsIHJldmVyc2VTdHJpbmcpO1xuICAgIHJldHVybiBtYXAoYWxsUmV2ZXJzZWQsIHVucXVvdGVEYXNoZXMpLnJldmVyc2UoKTtcbiAgfVxuXG4gIHZhciBwYXJhbSwgcGFyYW1WYWw7XG4gIGZvciAoaSA9IDA7IGkgPCBuUGF0aDsgaSsrKSB7XG4gICAgcGFyYW1OYW1lID0gcGFyYW1OYW1lc1tpXTtcbiAgICBwYXJhbSA9IHRoaXMucGFyYW1zW3BhcmFtTmFtZV07XG4gICAgcGFyYW1WYWwgPSBtW2krMV07XG4gICAgLy8gaWYgdGhlIHBhcmFtIHZhbHVlIG1hdGNoZXMgYSBwcmUtcmVwbGFjZSBwYWlyLCByZXBsYWNlIHRoZSB2YWx1ZSBiZWZvcmUgZGVjb2RpbmcuXG4gICAgZm9yIChqID0gMDsgaiA8IHBhcmFtLnJlcGxhY2UubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChwYXJhbS5yZXBsYWNlW2pdLmZyb20gPT09IHBhcmFtVmFsKSBwYXJhbVZhbCA9IHBhcmFtLnJlcGxhY2Vbal0udG87XG4gICAgfVxuICAgIGlmIChwYXJhbVZhbCAmJiBwYXJhbS5hcnJheSA9PT0gdHJ1ZSkgcGFyYW1WYWwgPSBkZWNvZGVQYXRoQXJyYXkocGFyYW1WYWwpO1xuICAgIGlmIChpc0RlZmluZWQocGFyYW1WYWwpKSBwYXJhbVZhbCA9IHBhcmFtLnR5cGUuZGVjb2RlKHBhcmFtVmFsKTtcbiAgICB2YWx1ZXNbcGFyYW1OYW1lXSA9IHBhcmFtLnZhbHVlKHBhcmFtVmFsKTtcbiAgfVxuICBmb3IgKC8qKi87IGkgPCBuVG90YWw7IGkrKykge1xuICAgIHBhcmFtTmFtZSA9IHBhcmFtTmFtZXNbaV07XG4gICAgdmFsdWVzW3BhcmFtTmFtZV0gPSB0aGlzLnBhcmFtc1twYXJhbU5hbWVdLnZhbHVlKHNlYXJjaFBhcmFtc1twYXJhbU5hbWVdKTtcbiAgICBwYXJhbSA9IHRoaXMucGFyYW1zW3BhcmFtTmFtZV07XG4gICAgcGFyYW1WYWwgPSBzZWFyY2hQYXJhbXNbcGFyYW1OYW1lXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgcGFyYW0ucmVwbGFjZS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKHBhcmFtLnJlcGxhY2Vbal0uZnJvbSA9PT0gcGFyYW1WYWwpIHBhcmFtVmFsID0gcGFyYW0ucmVwbGFjZVtqXS50bztcbiAgICB9XG4gICAgaWYgKGlzRGVmaW5lZChwYXJhbVZhbCkpIHBhcmFtVmFsID0gcGFyYW0udHlwZS5kZWNvZGUocGFyYW1WYWwpO1xuICAgIHZhbHVlc1twYXJhbU5hbWVdID0gcGFyYW0udmFsdWUocGFyYW1WYWwpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn07XG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIjcGFyYW1ldGVyc1xuICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJucyB0aGUgbmFtZXMgb2YgYWxsIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzIG9mIHRoaXMgcGF0dGVybiBpbiBhbiB1bnNwZWNpZmllZCBvcmRlci5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59ICBBbiBhcnJheSBvZiBwYXJhbWV0ZXIgbmFtZXMuIE11c3QgYmUgdHJlYXRlZCBhcyByZWFkLW9ubHkuIElmIHRoZVxuICogICAgcGF0dGVybiBoYXMgbm8gcGFyYW1ldGVycywgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQuXG4gKi9cblVybE1hdGNoZXIucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgaWYgKCFpc0RlZmluZWQocGFyYW0pKSByZXR1cm4gdGhpcy4kJHBhcmFtTmFtZXM7XG4gIHJldHVybiB0aGlzLnBhcmFtc1twYXJhbV0gfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIjdmFsaWRhdGVzXG4gKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDaGVja3MgYW4gb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZSB0aGVpciBjb3JyZWN0bmVzcyBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtZXRlclxuICogdHlwZXMgb2YgdGhpcyBgVXJsTWF0Y2hlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGUgb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGFyYW1zYCB2YWxpZGF0ZXMsIG90aGVyd2lzZSBgZmFsc2VgLlxuICovXG5VcmxNYXRjaGVyLnByb3RvdHlwZS52YWxpZGF0ZXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLnBhcmFtcy4kJHZhbGlkYXRlcyhwYXJhbXMpO1xufTtcblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciNmb3JtYXRcbiAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYSBVUkwgdGhhdCBtYXRjaGVzIHRoaXMgcGF0dGVybiBieSBzdWJzdGl0dXRpbmcgdGhlIHNwZWNpZmllZCB2YWx1ZXNcbiAqIGZvciB0aGUgcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMuIE51bGwgdmFsdWVzIGZvciBwYXRoIHBhcmFtZXRlcnMgYXJlXG4gKiB0cmVhdGVkIGFzIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIDxwcmU+XG4gKiBuZXcgVXJsTWF0Y2hlcignL3VzZXIve2lkfT9xJykuZm9ybWF0KHsgaWQ6J2JvYicsIHE6J3llcycgfSk7XG4gKiAvLyByZXR1cm5zICcvdXNlci9ib2I/cT15ZXMnXG4gKiA8L3ByZT5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzICB0aGUgdmFsdWVzIHRvIHN1YnN0aXR1dGUgZm9yIHRoZSBwYXJhbWV0ZXJzIGluIHRoaXMgcGF0dGVybi5cbiAqIEByZXR1cm5zIHtzdHJpbmd9ICB0aGUgZm9ybWF0dGVkIFVSTCAocGF0aCBhbmQgb3B0aW9uYWxseSBzZWFyY2ggcGFydCkuXG4gKi9cblVybE1hdGNoZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgdmFsdWVzID0gdmFsdWVzIHx8IHt9O1xuICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzLCBwYXJhbXMgPSB0aGlzLnBhcmFtZXRlcnMoKSwgcGFyYW1zZXQgPSB0aGlzLnBhcmFtcztcbiAgaWYgKCF0aGlzLnZhbGlkYXRlcyh2YWx1ZXMpKSByZXR1cm4gbnVsbDtcblxuICB2YXIgaSwgc2VhcmNoID0gZmFsc2UsIG5QYXRoID0gc2VnbWVudHMubGVuZ3RoIC0gMSwgblRvdGFsID0gcGFyYW1zLmxlbmd0aCwgcmVzdWx0ID0gc2VnbWVudHNbMF07XG5cbiAgZnVuY3Rpb24gZW5jb2RlRGFzaGVzKHN0cikgeyAvLyBSZXBsYWNlIGRhc2hlcyB3aXRoIGVuY29kZWQgXCJcXC1cIlxuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC8tL2csIGZ1bmN0aW9uKGMpIHsgcmV0dXJuICclNUMlJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfSk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgblRvdGFsOyBpKyspIHtcbiAgICB2YXIgaXNQYXRoUGFyYW0gPSBpIDwgblBhdGg7XG4gICAgdmFyIG5hbWUgPSBwYXJhbXNbaV0sIHBhcmFtID0gcGFyYW1zZXRbbmFtZV0sIHZhbHVlID0gcGFyYW0udmFsdWUodmFsdWVzW25hbWVdKTtcbiAgICB2YXIgaXNEZWZhdWx0VmFsdWUgPSBwYXJhbS5pc09wdGlvbmFsICYmIHBhcmFtLnR5cGUuZXF1YWxzKHBhcmFtLnZhbHVlKCksIHZhbHVlKTtcbiAgICB2YXIgc3F1YXNoID0gaXNEZWZhdWx0VmFsdWUgPyBwYXJhbS5zcXVhc2ggOiBmYWxzZTtcbiAgICB2YXIgZW5jb2RlZCA9IHBhcmFtLnR5cGUuZW5jb2RlKHZhbHVlKTtcblxuICAgIGlmIChpc1BhdGhQYXJhbSkge1xuICAgICAgdmFyIG5leHRTZWdtZW50ID0gc2VnbWVudHNbaSArIDFdO1xuICAgICAgdmFyIGlzRmluYWxQYXRoUGFyYW0gPSBpICsgMSA9PT0gblBhdGg7XG5cbiAgICAgIGlmIChzcXVhc2ggPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChlbmNvZGVkICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShlbmNvZGVkKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IG1hcChlbmNvZGVkLCBlbmNvZGVEYXNoZXMpLmpvaW4oXCItXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGVuY29kZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gbmV4dFNlZ21lbnQ7XG4gICAgICB9IGVsc2UgaWYgKHNxdWFzaCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgY2FwdHVyZSA9IHJlc3VsdC5tYXRjaCgvXFwvJC8pID8gL1xcLz8oLiopLyA6IC8oLiopLztcbiAgICAgICAgcmVzdWx0ICs9IG5leHRTZWdtZW50Lm1hdGNoKGNhcHR1cmUpWzFdO1xuICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhzcXVhc2gpKSB7XG4gICAgICAgIHJlc3VsdCArPSBzcXVhc2ggKyBuZXh0U2VnbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRmluYWxQYXRoUGFyYW0gJiYgcGFyYW0uc3F1YXNoID09PSB0cnVlICYmIHJlc3VsdC5zbGljZSgtMSkgPT09ICcvJykgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuY29kZWQgPT0gbnVsbCB8fCAoaXNEZWZhdWx0VmFsdWUgJiYgc3F1YXNoICE9PSBmYWxzZSkpIGNvbnRpbnVlO1xuICAgICAgaWYgKCFpc0FycmF5KGVuY29kZWQpKSBlbmNvZGVkID0gWyBlbmNvZGVkIF07XG4gICAgICBpZiAoZW5jb2RlZC5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgZW5jb2RlZCA9IG1hcChlbmNvZGVkLCBlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oJyYnICsgbmFtZSArICc9Jyk7XG4gICAgICByZXN1bHQgKz0gKHNlYXJjaCA/ICcmJyA6ICc/JykgKyAobmFtZSArICc9JyArIGVuY29kZWQpO1xuICAgICAgc2VhcmNoID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlR5cGVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEltcGxlbWVudHMgYW4gaW50ZXJmYWNlIHRvIGRlZmluZSBjdXN0b20gcGFyYW1ldGVyIHR5cGVzIHRoYXQgY2FuIGJlIGRlY29kZWQgZnJvbSBhbmQgZW5jb2RlZCB0b1xuICogc3RyaW5nIHBhcmFtZXRlcnMgbWF0Y2hlZCBpbiBhIFVSTC4gVXNlZCBieSB7QGxpbmsgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyIGBVcmxNYXRjaGVyYH1cbiAqIG9iamVjdHMgd2hlbiBtYXRjaGluZyBvciBmb3JtYXR0aW5nIFVSTHMsIG9yIGNvbXBhcmluZyBvciB2YWxpZGF0aW5nIHBhcmFtZXRlciB2YWx1ZXMuXG4gKlxuICogU2VlIHtAbGluayB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnkjbWV0aG9kc190eXBlIGAkdXJsTWF0Y2hlckZhY3RvcnkjdHlwZSgpYH0gZm9yIG1vcmVcbiAqIGluZm9ybWF0aW9uIG9uIHJlZ2lzdGVyaW5nIGN1c3RvbSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBjdXN0b20gdHlwZSBkZWZpbml0aW9uLiAgVGhlIG9iamVjdCdzXG4gKiAgICAgICAgcHJvcGVydGllcyB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG1ldGhvZHMgYW5kL29yIHBhdHRlcm4gaW4gYFR5cGVgJ3MgcHVibGljIGludGVyZmFjZS5cbiAqIEBleGFtcGxlXG4gKiA8cHJlPlxuICoge1xuICogICBkZWNvZGU6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7IH0sXG4gKiAgIGVuY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiB2YWwgJiYgdmFsLnRvU3RyaW5nKCk7IH0sXG4gKiAgIGVxdWFsczogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gdGhpcy5pcyhhKSAmJiBhID09PSBiOyB9LFxuICogICBpczogZnVuY3Rpb24odmFsKSB7IHJldHVybiBhbmd1bGFyLmlzTnVtYmVyKHZhbCkgaXNGaW5pdGUodmFsKSAmJiB2YWwgJSAxID09PSAwOyB9LFxuICogICBwYXR0ZXJuOiAvXFxkKy9cbiAqIH1cbiAqIDwvcHJlPlxuICpcbiAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBwYXR0ZXJuIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiB1c2VkIHRvIG1hdGNoIHZhbHVlcyBvZiB0aGlzIHR5cGUgd2hlblxuICogICAgICAgICAgIGNvbWluZyBmcm9tIGEgc3Vic3RyaW5nIG9mIGEgVVJMLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9ICBSZXR1cm5zIGEgbmV3IGBUeXBlYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIFR5cGUoY29uZmlnKSB7XG4gIGV4dGVuZCh0aGlzLCBjb25maWcpO1xufVxuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgdWkucm91dGVyLnV0aWwudHlwZTpUeXBlI2lzXG4gKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwudHlwZTpUeXBlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBEZXRlY3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyBvZiBhIHBhcnRpY3VsYXIgdHlwZS4gQWNjZXB0cyBhIG5hdGl2ZSAoZGVjb2RlZCkgdmFsdWVcbiAqIGFuZCBkZXRlcm1pbmVzIHdoZXRoZXIgaXQgbWF0Y2hlcyB0aGUgY3VycmVudCBgVHlwZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsICBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5ICBPcHRpb25hbC4gSWYgdGhlIHR5cGUgY2hlY2sgaXMgaGFwcGVuaW5nIGluIHRoZSBjb250ZXh0IG9mIGEgc3BlY2lmaWNcbiAqICAgICAgICB7QGxpbmsgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyIGBVcmxNYXRjaGVyYH0gb2JqZWN0LCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZVxuICogICAgICAgIHBhcmFtZXRlciBpbiB3aGljaCBgdmFsYCBpcyBzdG9yZWQuIENhbiBiZSB1c2VkIGZvciBtZXRhLXByb2dyYW1taW5nIG9mIGBUeXBlYCBvYmplY3RzLlxuICogQHJldHVybnMge0Jvb2xlYW59ICBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgbWF0Y2hlcyB0aGUgdHlwZSwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKi9cblR5cGUucHJvdG90eXBlLmlzID0gZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgdWkucm91dGVyLnV0aWwudHlwZTpUeXBlI2VuY29kZVxuICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLnR5cGU6VHlwZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRW5jb2RlcyBhIGN1c3RvbS9uYXRpdmUgdHlwZSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGNhbiBiZSBlbWJlZGRlZCBpbiBhIFVSTC4gTm90ZSB0aGF0IHRoZVxuICogcmV0dXJuIHZhbHVlIGRvZXMgKm5vdCogbmVlZCB0byBiZSBVUkwtc2FmZSAoaS5lLiBwYXNzZWQgdGhyb3VnaCBgZW5jb2RlVVJJQ29tcG9uZW50KClgKSwgaXRcbiAqIG9ubHkgbmVlZHMgdG8gYmUgYSByZXByZXNlbnRhdGlvbiBvZiBgdmFsYCB0aGF0IGhhcyBiZWVuIGNvZXJjZWQgdG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgIFRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5ICBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHdoaWNoIGB2YWxgIGlzIHN0b3JlZC4gQ2FuIGJlIHVzZWQgZm9yXG4gKiAgICAgICAgbWV0YS1wcm9ncmFtbWluZyBvZiBgVHlwZWAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9ICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGB2YWxgIHRoYXQgY2FuIGJlIGVuY29kZWQgaW4gYSBVUkwuXG4gKi9cblR5cGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgdWkucm91dGVyLnV0aWwudHlwZTpUeXBlI2RlY29kZVxuICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLnR5cGU6VHlwZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydHMgYSBwYXJhbWV0ZXIgdmFsdWUgKGZyb20gVVJMIHN0cmluZyBvciB0cmFuc2l0aW9uIHBhcmFtKSB0byBhIGN1c3RvbS9uYXRpdmUgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCAgVGhlIFVSTCBwYXJhbWV0ZXIgdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAgVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBpbiB3aGljaCBgdmFsYCBpcyBzdG9yZWQuIENhbiBiZSB1c2VkIGZvclxuICogICAgICAgIG1ldGEtcHJvZ3JhbW1pbmcgb2YgYFR5cGVgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Kn0gIFJldHVybnMgYSBjdXN0b20gcmVwcmVzZW50YXRpb24gb2YgdGhlIFVSTCBwYXJhbWV0ZXIgdmFsdWUuXG4gKi9cblR5cGUucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgdWkucm91dGVyLnV0aWwudHlwZTpUeXBlI2VxdWFsc1xuICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLnR5cGU6VHlwZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBkZWNvZGVkIHZhbHVlcyBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAcGFyYW0geyp9IGEgIEEgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICogQHBhcmFtIHsqfSBiICBBIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSAgUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudC9lcXVhbCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKi9cblR5cGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT0gYjtcbn07XG5cblR5cGUucHJvdG90eXBlLiRzdWJQYXR0ZXJuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWIgPSB0aGlzLnBhdHRlcm4udG9TdHJpbmcoKTtcbiAgcmV0dXJuIHN1Yi5zdWJzdHIoMSwgc3ViLmxlbmd0aCAtIDIpO1xufTtcblxuVHlwZS5wcm90b3R5cGUucGF0dGVybiA9IC8uKi87XG5cblR5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBcIntUeXBlOlwiICsgdGhpcy5uYW1lICsgXCJ9XCI7IH07XG5cbi8qKiBHaXZlbiBhbiBlbmNvZGVkIHN0cmluZywgb3IgYSBkZWNvZGVkIG9iamVjdCwgcmV0dXJucyBhIGRlY29kZWQgb2JqZWN0ICovXG5UeXBlLnByb3RvdHlwZS4kbm9ybWFsaXplID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0aGlzLmlzKHZhbCkgPyB2YWwgOiB0aGlzLmRlY29kZSh2YWwpO1xufTtcblxuLypcbiAqIFdyYXBzIGFuIGV4aXN0aW5nIGN1c3RvbSBUeXBlIGFzIGFuIGFycmF5IG9mIFR5cGUsIGRlcGVuZGluZyBvbiAnbW9kZScuXG4gKiBlLmcuOlxuICogLSB1cmxtYXRjaGVyIHBhdHRlcm4gXCIvcGF0aD97cXVlcnlQYXJhbVtdOmludH1cIlxuICogLSB1cmw6IFwiL3BhdGg/cXVlcnlQYXJhbT0xJnF1ZXJ5UGFyYW09MlxuICogLSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbSB3aWxsIGJlIFsxLCAyXVxuICogaWYgYG1vZGVgIGlzIFwiYXV0b1wiLCB0aGVuXG4gKiAtIHVybDogXCIvcGF0aD9xdWVyeVBhcmFtPTEgd2lsbCBjcmVhdGUgJHN0YXRlUGFyYW1zLnF1ZXJ5UGFyYW06IDFcbiAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSZxdWVyeVBhcmFtPTIgd2lsbCBjcmVhdGUgJHN0YXRlUGFyYW1zLnF1ZXJ5UGFyYW06IFsxLCAyXVxuICovXG5UeXBlLnByb3RvdHlwZS4kYXNBcnJheSA9IGZ1bmN0aW9uKG1vZGUsIGlzU2VhcmNoKSB7XG4gIGlmICghbW9kZSkgcmV0dXJuIHRoaXM7XG4gIGlmIChtb2RlID09PSBcImF1dG9cIiAmJiAhaXNTZWFyY2gpIHRocm93IG5ldyBFcnJvcihcIidhdXRvJyBhcnJheSBtb2RlIGlzIGZvciBxdWVyeSBwYXJhbWV0ZXJzIG9ubHlcIik7XG5cbiAgZnVuY3Rpb24gQXJyYXlUeXBlKHR5cGUsIG1vZGUpIHtcbiAgICBmdW5jdGlvbiBiaW5kVG8odHlwZSwgY2FsbGJhY2tOYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0eXBlW2NhbGxiYWNrTmFtZV0uYXBwbHkodHlwZSwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gV3JhcCBub24tYXJyYXkgdmFsdWUgYXMgYXJyYXlcbiAgICBmdW5jdGlvbiBhcnJheVdyYXAodmFsKSB7IHJldHVybiBpc0FycmF5KHZhbCkgPyB2YWwgOiAoaXNEZWZpbmVkKHZhbCkgPyBbIHZhbCBdIDogW10pOyB9XG4gICAgLy8gVW53cmFwIGFycmF5IHZhbHVlIGZvciBcImF1dG9cIiBtb2RlLiBSZXR1cm4gdW5kZWZpbmVkIGZvciBlbXB0eSBhcnJheS5cbiAgICBmdW5jdGlvbiBhcnJheVVud3JhcCh2YWwpIHtcbiAgICAgIHN3aXRjaCh2YWwubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbW9kZSA9PT0gXCJhdXRvXCIgPyB2YWxbMF0gOiB2YWw7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZhbHNleSh2YWwpIHsgcmV0dXJuICF2YWw7IH1cblxuICAgIC8vIFdyYXBzIHR5cGUgKC5pcy8uZW5jb2RlLy5kZWNvZGUpIGZ1bmN0aW9ucyB0byBvcGVyYXRlIG9uIGVhY2ggdmFsdWUgb2YgYW4gYXJyYXlcbiAgICBmdW5jdGlvbiBhcnJheUhhbmRsZXIoY2FsbGJhY2ssIGFsbFRydXRoeU1vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVBcnJheSh2YWwpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gdmFsO1xuICAgICAgICB2YWwgPSBhcnJheVdyYXAodmFsKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1hcCh2YWwsIGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGFsbFRydXRoeU1vZGUgPT09IHRydWUpXG4gICAgICAgICAgcmV0dXJuIGZpbHRlcihyZXN1bHQsIGZhbHNleSkubGVuZ3RoID09PSAwO1xuICAgICAgICByZXR1cm4gYXJyYXlVbndyYXAocmVzdWx0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gV3JhcHMgdHlwZSAoLmVxdWFscykgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gZWFjaCB2YWx1ZSBvZiBhbiBhcnJheVxuICAgIGZ1bmN0aW9uIGFycmF5RXF1YWxzSGFuZGxlcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbDEsIHZhbDIpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBhcnJheVdyYXAodmFsMSksIHJpZ2h0ID0gYXJyYXlXcmFwKHZhbDIpO1xuICAgICAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWNhbGxiYWNrKGxlZnRbaV0sIHJpZ2h0W2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmVuY29kZSA9IGFycmF5SGFuZGxlcihiaW5kVG8odHlwZSwgJ2VuY29kZScpKTtcbiAgICB0aGlzLmRlY29kZSA9IGFycmF5SGFuZGxlcihiaW5kVG8odHlwZSwgJ2RlY29kZScpKTtcbiAgICB0aGlzLmlzICAgICA9IGFycmF5SGFuZGxlcihiaW5kVG8odHlwZSwgJ2lzJyksIHRydWUpO1xuICAgIHRoaXMuZXF1YWxzID0gYXJyYXlFcXVhbHNIYW5kbGVyKGJpbmRUbyh0eXBlLCAnZXF1YWxzJykpO1xuICAgIHRoaXMucGF0dGVybiA9IHR5cGUucGF0dGVybjtcbiAgICB0aGlzLiRub3JtYWxpemUgPSBhcnJheUhhbmRsZXIoYmluZFRvKHR5cGUsICckbm9ybWFsaXplJykpO1xuICAgIHRoaXMubmFtZSA9IHR5cGUubmFtZTtcbiAgICB0aGlzLiRhcnJheU1vZGUgPSBtb2RlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBBcnJheVR5cGUodGhpcywgbW9kZSk7XG59O1xuXG5cblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnlcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEZhY3RvcnkgZm9yIHtAbGluayB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIgYFVybE1hdGNoZXJgfSBpbnN0YW5jZXMuIFRoZSBmYWN0b3J5XG4gKiBpcyBhbHNvIGF2YWlsYWJsZSB0byBwcm92aWRlcnMgdW5kZXIgdGhlIG5hbWUgYCR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyYC5cbiAqL1xuZnVuY3Rpb24gJFVybE1hdGNoZXJGYWN0b3J5KCkge1xuICAkJFVNRlAgPSB0aGlzO1xuXG4gIHZhciBpc0Nhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlLCBpc1N0cmljdE1vZGUgPSB0cnVlLCBkZWZhdWx0U3F1YXNoUG9saWN5ID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRpbGRlcyB0byBwcmUtZW5jb2RlIHNsYXNoZXMuXG4gIC8vIElmIHRoZSBzbGFzaGVzIGFyZSBzaW1wbHkgVVJMRW5jb2RlZCwgdGhlIGJyb3dzZXIgY2FuIGNob29zZSB0byBwcmUtZGVjb2RlIHRoZW0sXG4gIC8vIGFuZCBiaWRpcmVjdGlvbmFsIGVuY29kaW5nL2RlY29kaW5nIGZhaWxzLlxuICAvLyBUaWxkZSB3YXMgY2hvc2VuIGJlY2F1c2UgaXQncyBub3QgYSBSRkMgMzk4NiBzZWN0aW9uIDIuMiBSZXNlcnZlZCBDaGFyYWN0ZXJcbiAgZnVuY3Rpb24gdmFsVG9TdHJpbmcodmFsKSB7IHJldHVybiB2YWwgIT0gbnVsbCA/IHZhbC50b1N0cmluZygpLnJlcGxhY2UoL34vZywgXCJ+flwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MkZcIikgOiB2YWw7IH1cbiAgZnVuY3Rpb24gdmFsRnJvbVN0cmluZyh2YWwpIHsgcmV0dXJuIHZhbCAhPSBudWxsID8gdmFsLnRvU3RyaW5nKCkucmVwbGFjZSgvfjJGL2csIFwiL1wiKS5yZXBsYWNlKC9+fi9nLCBcIn5cIikgOiB2YWw7IH1cblxuICB2YXIgJHR5cGVzID0ge30sIGVucXVldWUgPSB0cnVlLCB0eXBlUXVldWUgPSBbXSwgaW5qZWN0b3IsIGRlZmF1bHRUeXBlcyA9IHtcbiAgICBcInN0cmluZ1wiOiB7XG4gICAgICBlbmNvZGU6IHZhbFRvU3RyaW5nLFxuICAgICAgZGVjb2RlOiB2YWxGcm9tU3RyaW5nLFxuICAgICAgLy8gVE9ETzogaW4gMS4wLCBtYWtlIHN0cmluZyAuaXMoKSByZXR1cm4gZmFsc2UgaWYgdmFsdWUgaXMgdW5kZWZpbmVkL251bGwgYnkgZGVmYXVsdC5cbiAgICAgIC8vIEluIDAuMi54LCBzdHJpbmcgcGFyYW1zIGFyZSBvcHRpb25hbCBieSBkZWZhdWx0IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgICBpczogZnVuY3Rpb24odmFsKSB7IHJldHVybiB2YWwgPT0gbnVsbCB8fCAhaXNEZWZpbmVkKHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIjsgfSxcbiAgICAgIHBhdHRlcm46IC9bXi9dKi9cbiAgICB9LFxuICAgIFwiaW50XCI6IHtcbiAgICAgIGVuY29kZTogdmFsVG9TdHJpbmcsXG4gICAgICBkZWNvZGU6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7IH0sXG4gICAgICBpczogZnVuY3Rpb24odmFsKSB7IHJldHVybiBpc0RlZmluZWQodmFsKSAmJiB0aGlzLmRlY29kZSh2YWwudG9TdHJpbmcoKSkgPT09IHZhbDsgfSxcbiAgICAgIHBhdHRlcm46IC9cXGQrL1xuICAgIH0sXG4gICAgXCJib29sXCI6IHtcbiAgICAgIGVuY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiB2YWwgPyAxIDogMDsgfSxcbiAgICAgIGRlY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiBwYXJzZUludCh2YWwsIDEwKSAhPT0gMDsgfSxcbiAgICAgIGlzOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09IGZhbHNlOyB9LFxuICAgICAgcGF0dGVybjogLzB8MS9cbiAgICB9LFxuICAgIFwiZGF0ZVwiOiB7XG4gICAgICBlbmNvZGU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzKHZhbCkpXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIFsgdmFsLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgKCcwJyArICh2YWwuZ2V0TW9udGgoKSArIDEpKS5zbGljZSgtMiksXG4gICAgICAgICAgKCcwJyArIHZhbC5nZXREYXRlKCkpLnNsaWNlKC0yKVxuICAgICAgICBdLmpvaW4oXCItXCIpO1xuICAgICAgfSxcbiAgICAgIGRlY29kZTogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBpZiAodGhpcy5pcyh2YWwpKSByZXR1cm4gdmFsO1xuICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLmNhcHR1cmUuZXhlYyh2YWwpO1xuICAgICAgICByZXR1cm4gbWF0Y2ggPyBuZXcgRGF0ZShtYXRjaFsxXSwgbWF0Y2hbMl0gLSAxLCBtYXRjaFszXSkgOiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgaXM6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gdmFsIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsLnZhbHVlT2YoKSk7IH0sXG4gICAgICBlcXVhbHM6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiB0aGlzLmlzKGEpICYmIHRoaXMuaXMoYikgJiYgYS50b0lTT1N0cmluZygpID09PSBiLnRvSVNPU3RyaW5nKCk7IH0sXG4gICAgICBwYXR0ZXJuOiAvWzAtOV17NH0tKD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfFsxLTJdWzAtOV18M1swLTFdKS8sXG4gICAgICBjYXB0dXJlOiAvKFswLTldezR9KS0oMFsxLTldfDFbMC0yXSktKDBbMS05XXxbMS0yXVswLTldfDNbMC0xXSkvXG4gICAgfSxcbiAgICBcImpzb25cIjoge1xuICAgICAgZW5jb2RlOiBhbmd1bGFyLnRvSnNvbixcbiAgICAgIGRlY29kZTogYW5ndWxhci5mcm9tSnNvbixcbiAgICAgIGlzOiBhbmd1bGFyLmlzT2JqZWN0LFxuICAgICAgZXF1YWxzOiBhbmd1bGFyLmVxdWFscyxcbiAgICAgIHBhdHRlcm46IC9bXi9dKi9cbiAgICB9LFxuICAgIFwiYW55XCI6IHsgLy8gZG9lcyBub3QgZW5jb2RlL2RlY29kZVxuICAgICAgZW5jb2RlOiBhbmd1bGFyLmlkZW50aXR5LFxuICAgICAgZGVjb2RlOiBhbmd1bGFyLmlkZW50aXR5LFxuICAgICAgZXF1YWxzOiBhbmd1bGFyLmVxdWFscyxcbiAgICAgIHBhdHRlcm46IC8uKi9cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0RGVmYXVsdENvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyaWN0OiBpc1N0cmljdE1vZGUsXG4gICAgICBjYXNlSW5zZW5zaXRpdmU6IGlzQ2FzZUluc2Vuc2l0aXZlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5qZWN0YWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgKGlzQXJyYXkodmFsdWUpICYmIGlzRnVuY3Rpb24odmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0pKSk7XG4gIH1cblxuICAvKipcbiAgICogW0ludGVybmFsXSBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwYXJhbWV0ZXIsIHdoaWNoIG1heSBiZSBhbiBpbmplY3RhYmxlIGZ1bmN0aW9uLlxuICAgKi9cbiAgJFVybE1hdGNoZXJGYWN0b3J5LiQkZ2V0RGVmYXVsdFZhbHVlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgaWYgKCFpc0luamVjdGFibGUoY29uZmlnLnZhbHVlKSkgcmV0dXJuIGNvbmZpZy52YWx1ZTtcbiAgICBpZiAoIWluamVjdG9yKSB0aHJvdyBuZXcgRXJyb3IoXCJJbmplY3RhYmxlIGZ1bmN0aW9ucyBjYW5ub3QgYmUgY2FsbGVkIGF0IGNvbmZpZ3VyYXRpb24gdGltZVwiKTtcbiAgICByZXR1cm4gaW5qZWN0b3IuaW52b2tlKGNvbmZpZy52YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnkjY2FzZUluc2Vuc2l0aXZlXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnlcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERlZmluZXMgd2hldGhlciBVUkwgbWF0Y2hpbmcgc2hvdWxkIGJlIGNhc2Ugc2Vuc2l0aXZlICh0aGUgZGVmYXVsdCBiZWhhdmlvciksIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBgZmFsc2VgIHRvIG1hdGNoIFVSTCBpbiBhIGNhc2Ugc2Vuc2l0aXZlIG1hbm5lcjsgb3RoZXJ3aXNlIGB0cnVlYDtcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRoZSBjdXJyZW50IHZhbHVlIG9mIGNhc2VJbnNlbnNpdGl2ZVxuICAgKi9cbiAgdGhpcy5jYXNlSW5zZW5zaXRpdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmIChpc0RlZmluZWQodmFsdWUpKVxuICAgICAgaXNDYXNlSW5zZW5zaXRpdmUgPSB2YWx1ZTtcbiAgICByZXR1cm4gaXNDYXNlSW5zZW5zaXRpdmU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3Rvcnkjc3RyaWN0TW9kZVxuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwuJHVybE1hdGNoZXJGYWN0b3J5XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBEZWZpbmVzIHdoZXRoZXIgVVJMcyBzaG91bGQgbWF0Y2ggdHJhaWxpbmcgc2xhc2hlcywgb3Igbm90ICh0aGUgZGVmYXVsdCBiZWhhdmlvcikuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHZhbHVlIGBmYWxzZWAgdG8gbWF0Y2ggdHJhaWxpbmcgc2xhc2hlcyBpbiBVUkxzLCBvdGhlcndpc2UgYHRydWVgLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdGhlIGN1cnJlbnQgdmFsdWUgb2Ygc3RyaWN0TW9kZVxuICAgKi9cbiAgdGhpcy5zdHJpY3RNb2RlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSlcbiAgICAgIGlzU3RyaWN0TW9kZSA9IHZhbHVlO1xuICAgIHJldHVybiBpc1N0cmljdE1vZGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnkjZGVmYXVsdFNxdWFzaFBvbGljeVxuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwuJHVybE1hdGNoZXJGYWN0b3J5XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gZ2VuZXJhdGluZyBvciBtYXRjaGluZyBVUkxzIHdpdGggZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBkZWZhdWx0IHBhcmFtZXRlciBVUkwgc3F1YXNoaW5nIGJlaGF2aW9yLlxuICAgKiAgICBgbm9zcXVhc2hgOiBXaGVuIGdlbmVyYXRpbmcgYW4gaHJlZiB3aXRoIGEgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWUsIGRvIG5vdCBzcXVhc2ggdGhlIHBhcmFtZXRlciB2YWx1ZSBmcm9tIHRoZSBVUkxcbiAgICogICAgYHNsYXNoYDogV2hlbiBnZW5lcmF0aW5nIGFuIGhyZWYgd2l0aCBhIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlLCBzcXVhc2ggKHJlbW92ZSkgdGhlIHBhcmFtZXRlciB2YWx1ZSwgYW5kLCBpZiB0aGVcbiAgICogICAgICAgICAgICAgcGFyYW1ldGVyIGlzIHN1cnJvdW5kZWQgYnkgc2xhc2hlcywgc3F1YXNoIChyZW1vdmUpIG9uZSBzbGFzaCBmcm9tIHRoZSBVUkxcbiAgICogICAgYW55IG90aGVyIHN0cmluZywgZS5nLiBcIn5cIjogV2hlbiBnZW5lcmF0aW5nIGFuIGhyZWYgd2l0aCBhIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlLCBzcXVhc2ggKHJlbW92ZSlcbiAgICogICAgICAgICAgICAgdGhlIHBhcmFtZXRlciB2YWx1ZSBmcm9tIHRoZSBVUkwgYW5kIHJlcGxhY2UgaXQgd2l0aCB0aGlzIHN0cmluZy5cbiAgICovXG4gIHRoaXMuZGVmYXVsdFNxdWFzaFBvbGljeSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSByZXR1cm4gZGVmYXVsdFNxdWFzaFBvbGljeTtcbiAgICBpZiAodmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09IGZhbHNlICYmICFpc1N0cmluZyh2YWx1ZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNxdWFzaCBwb2xpY3k6IFwiICsgdmFsdWUgKyBcIi4gVmFsaWQgcG9saWNpZXM6IGZhbHNlLCB0cnVlLCBhcmJpdHJhcnktc3RyaW5nXCIpO1xuICAgIGRlZmF1bHRTcXVhc2hQb2xpY3kgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnkjY29tcGlsZVxuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwuJHVybE1hdGNoZXJGYWN0b3J5XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDcmVhdGVzIGEge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciBgVXJsTWF0Y2hlcmB9IGZvciB0aGUgc3BlY2lmaWVkIHBhdHRlcm4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuICBUaGUgVVJMIHBhdHRlcm4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgIFRoZSBjb25maWcgb2JqZWN0IGhhc2guXG4gICAqIEByZXR1cm5zIHtVcmxNYXRjaGVyfSAgVGhlIFVybE1hdGNoZXIuXG4gICAqL1xuICB0aGlzLmNvbXBpbGUgPSBmdW5jdGlvbiAocGF0dGVybiwgY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBVcmxNYXRjaGVyKHBhdHRlcm4sIGV4dGVuZChnZXREZWZhdWx0Q29uZmlnKCksIGNvbmZpZykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgdWkucm91dGVyLnV0aWwuJHVybE1hdGNoZXJGYWN0b3J5I2lzTWF0Y2hlclxuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwuJHVybE1hdGNoZXJGYWN0b3J5XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBgVXJsTWF0Y2hlcmAsIG9yIGZhbHNlIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAgVGhlIG9iamVjdCB0byBwZXJmb3JtIHRoZSB0eXBlIGNoZWNrIGFnYWluc3QuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSAgUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBtYXRjaGVzIHRoZSBgVXJsTWF0Y2hlcmAgaW50ZXJmYWNlLCBieVxuICAgKiAgICAgICAgICBpbXBsZW1lbnRpbmcgYWxsIHRoZSBzYW1lIG1ldGhvZHMuXG4gICAqL1xuICB0aGlzLmlzTWF0Y2hlciA9IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKCFpc09iamVjdChvKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuXG4gICAgZm9yRWFjaChVcmxNYXRjaGVyLnByb3RvdHlwZSwgZnVuY3Rpb24odmFsLCBuYW1lKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiAoaXNEZWZpbmVkKG9bbmFtZV0pICYmIGlzRnVuY3Rpb24ob1tuYW1lXSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnkjdHlwZVxuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwuJHVybE1hdGNoZXJGYWN0b3J5XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZWdpc3RlcnMgYSBjdXN0b20ge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VHlwZSBgVHlwZWB9IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4gICAqIGdlbmVyYXRlIFVSTHMgd2l0aCB0eXBlZCBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgVGhlIHR5cGUgbmFtZS5cbiAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IGRlZmluaXRpb24gICBUaGUgdHlwZSBkZWZpbml0aW9uLiBTZWVcbiAgICogICAgICAgIHtAbGluayB1aS5yb3V0ZXIudXRpbC50eXBlOlR5cGUgYFR5cGVgfSBmb3IgaW5mb3JtYXRpb24gb24gdGhlIHZhbHVlcyBhY2NlcHRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IGRlZmluaXRpb25GbiAob3B0aW9uYWwpIEEgZnVuY3Rpb24gdGhhdCBpcyBpbmplY3RlZCBiZWZvcmUgdGhlIGFwcFxuICAgKiAgICAgICAgcnVudGltZSBzdGFydHMuICBUaGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gaXMgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIGBkZWZpbml0aW9uYC5cbiAgICogICAgICAgIFNlZSB7QGxpbmsgdWkucm91dGVyLnV0aWwudHlwZTpUeXBlIGBUeXBlYH0gZm9yIGluZm9ybWF0aW9uIG9uIHRoZSB2YWx1ZXMgYWNjZXB0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9ICBSZXR1cm5zIGAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlcmAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFRoaXMgaXMgYSBzaW1wbGUgZXhhbXBsZSBvZiBhIGN1c3RvbSB0eXBlIHRoYXQgZW5jb2RlcyBhbmQgZGVjb2RlcyBpdGVtcyBmcm9tIGFuXG4gICAqIGFycmF5LCB1c2luZyB0aGUgYXJyYXkgaW5kZXggYXMgdGhlIFVSTC1lbmNvZGVkIHZhbHVlOlxuICAgKlxuICAgKiA8cHJlPlxuICAgKiB2YXIgbGlzdCA9IFsnSm9obicsICdQYXVsJywgJ0dlb3JnZScsICdSaW5nbyddO1xuICAgKlxuICAgKiAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlci50eXBlKCdsaXN0SXRlbScsIHtcbiAgICogICBlbmNvZGU6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICogICAgIC8vIFJlcHJlc2VudCB0aGUgbGlzdCBpdGVtIGluIHRoZSBVUkwgdXNpbmcgaXRzIGNvcnJlc3BvbmRpbmcgaW5kZXhcbiAgICogICAgIHJldHVybiBsaXN0LmluZGV4T2YoaXRlbSk7XG4gICAqICAgfSxcbiAgICogICBkZWNvZGU6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICogICAgIC8vIExvb2sgdXAgdGhlIGxpc3QgaXRlbSBieSBpbmRleFxuICAgKiAgICAgcmV0dXJuIGxpc3RbcGFyc2VJbnQoaXRlbSwgMTApXTtcbiAgICogICB9LFxuICAgKiAgIGlzOiBmdW5jdGlvbihpdGVtKSB7XG4gICAqICAgICAvLyBFbnN1cmUgdGhlIGl0ZW0gaXMgdmFsaWQgYnkgY2hlY2tpbmcgdG8gc2VlIHRoYXQgaXQgYXBwZWFyc1xuICAgKiAgICAgLy8gaW4gdGhlIGxpc3RcbiAgICogICAgIHJldHVybiBsaXN0LmluZGV4T2YoaXRlbSkgPiAtMTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZSgnbGlzdCcsIHtcbiAgICogICB1cmw6IFwiL2xpc3Qve2l0ZW06bGlzdEl0ZW19XCIsXG4gICAqICAgY29udHJvbGxlcjogZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKCRzdGF0ZVBhcmFtcy5pdGVtKTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyAuLi5cbiAgICpcbiAgICogLy8gQ2hhbmdlcyBVUkwgdG8gJy9saXN0LzMnLCBsb2dzIFwiUmluZ29cIiB0byB0aGUgY29uc29sZVxuICAgKiAkc3RhdGUuZ28oJ2xpc3QnLCB7IGl0ZW06IFwiUmluZ29cIiB9KTtcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIFRoaXMgaXMgYSBtb3JlIGNvbXBsZXggZXhhbXBsZSBvZiBhIHR5cGUgdGhhdCByZWxpZXMgb24gZGVwZW5kZW5jeSBpbmplY3Rpb24gdG9cbiAgICogaW50ZXJhY3Qgd2l0aCBzZXJ2aWNlcywgYW5kIHVzZXMgdGhlIHBhcmFtZXRlciBuYW1lIGZyb20gdGhlIFVSTCB0byBpbmZlciBob3cgdG9cbiAgICogaGFuZGxlIGVuY29kaW5nIGFuZCBkZWNvZGluZyBwYXJhbWV0ZXIgdmFsdWVzOlxuICAgKlxuICAgKiA8cHJlPlxuICAgKiAvLyBEZWZpbmVzIGEgY3VzdG9tIHR5cGUgdGhhdCBnZXRzIGEgdmFsdWUgZnJvbSBhIHNlcnZpY2UsXG4gICAqIC8vIHdoZXJlIGVhY2ggc2VydmljZSBnZXRzIGRpZmZlcmVudCB0eXBlcyBvZiB2YWx1ZXMgZnJvbVxuICAgKiAvLyBhIGJhY2tlbmQgQVBJOlxuICAgKiAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlci50eXBlKCdkYk9iamVjdCcsIHt9LCBmdW5jdGlvbihVc2VycywgUG9zdHMpIHtcbiAgICpcbiAgICogICAvLyBNYXRjaGVzIHVwIHNlcnZpY2VzIHRvIFVSTCBwYXJhbWV0ZXIgbmFtZXNcbiAgICogICB2YXIgc2VydmljZXMgPSB7XG4gICAqICAgICB1c2VyOiBVc2VycyxcbiAgICogICAgIHBvc3Q6IFBvc3RzXG4gICAqICAgfTtcbiAgICpcbiAgICogICByZXR1cm4ge1xuICAgKiAgICAgZW5jb2RlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICogICAgICAgLy8gUmVwcmVzZW50IHRoZSBvYmplY3QgaW4gdGhlIFVSTCB1c2luZyBpdHMgdW5pcXVlIElEXG4gICAqICAgICAgIHJldHVybiBvYmplY3QuaWQ7XG4gICAqICAgICB9LFxuICAgKiAgICAgZGVjb2RlOiBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAqICAgICAgIC8vIExvb2sgdXAgdGhlIG9iamVjdCBieSBJRCwgdXNpbmcgdGhlIHBhcmFtZXRlclxuICAgKiAgICAgICAvLyBuYW1lIChrZXkpIHRvIGNhbGwgdGhlIGNvcnJlY3Qgc2VydmljZVxuICAgKiAgICAgICByZXR1cm4gc2VydmljZXNba2V5XS5maW5kQnlJZCh2YWx1ZSk7XG4gICAqICAgICB9LFxuICAgKiAgICAgaXM6IGZ1bmN0aW9uKG9iamVjdCwga2V5KSB7XG4gICAqICAgICAgIC8vIENoZWNrIHRoYXQgb2JqZWN0IGlzIGEgdmFsaWQgZGJPYmplY3RcbiAgICogICAgICAgcmV0dXJuIGFuZ3VsYXIuaXNPYmplY3Qob2JqZWN0KSAmJiBvYmplY3QuaWQgJiYgc2VydmljZXNba2V5XTtcbiAgICogICAgIH1cbiAgICogICAgIGVxdWFsczogZnVuY3Rpb24oYSwgYikge1xuICAgKiAgICAgICAvLyBDaGVjayB0aGUgZXF1YWxpdHkgb2YgZGVjb2RlZCBvYmplY3RzIGJ5IGNvbXBhcmluZ1xuICAgKiAgICAgICAvLyB0aGVpciB1bmlxdWUgSURzXG4gICAqICAgICAgIHJldHVybiBhLmlkID09PSBiLmlkO1xuICAgKiAgICAgfVxuICAgKiAgIH07XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBJbiBhIGNvbmZpZygpIGJsb2NrLCB5b3UgY2FuIHRoZW4gYXR0YWNoIFVSTHMgd2l0aFxuICAgKiAvLyB0eXBlLWFubm90YXRlZCBwYXJhbWV0ZXJzOlxuICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZSgndXNlcnMnLCB7XG4gICAqICAgdXJsOiBcIi91c2Vyc1wiLFxuICAgKiAgIC8vIC4uLlxuICAgKiB9KS5zdGF0ZSgndXNlcnMuaXRlbScsIHtcbiAgICogICB1cmw6IFwiL3t1c2VyOmRiT2JqZWN0fVwiLFxuICAgKiAgIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zKSB7XG4gICAqICAgICAvLyAkc3RhdGVQYXJhbXMudXNlciB3aWxsIG5vdyBiZSBhbiBvYmplY3QgcmV0dXJuZWQgZnJvbVxuICAgKiAgICAgLy8gdGhlIFVzZXJzIHNlcnZpY2VcbiAgICogICB9LFxuICAgKiAgIC8vIC4uLlxuICAgKiB9KTtcbiAgICogPC9wcmU+XG4gICAqL1xuICB0aGlzLnR5cGUgPSBmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbkZuKSB7XG4gICAgaWYgKCFpc0RlZmluZWQoZGVmaW5pdGlvbikpIHJldHVybiAkdHlwZXNbbmFtZV07XG4gICAgaWYgKCR0eXBlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgdGhyb3cgbmV3IEVycm9yKFwiQSB0eXBlIG5hbWVkICdcIiArIG5hbWUgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLlwiKTtcblxuICAgICR0eXBlc1tuYW1lXSA9IG5ldyBUeXBlKGV4dGVuZCh7IG5hbWU6IG5hbWUgfSwgZGVmaW5pdGlvbikpO1xuICAgIGlmIChkZWZpbml0aW9uRm4pIHtcbiAgICAgIHR5cGVRdWV1ZS5wdXNoKHsgbmFtZTogbmFtZSwgZGVmOiBkZWZpbml0aW9uRm4gfSk7XG4gICAgICBpZiAoIWVucXVldWUpIGZsdXNoVHlwZVF1ZXVlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIGBmbHVzaFR5cGVRdWV1ZSgpYCB3YWl0cyB1bnRpbCBgJHVybE1hdGNoZXJGYWN0b3J5YCBpcyBpbmplY3RlZCBiZWZvcmUgaW52b2tpbmcgdGhlIHF1ZXVlZCBgZGVmaW5pdGlvbkZuYHNcbiAgZnVuY3Rpb24gZmx1c2hUeXBlUXVldWUoKSB7XG4gICAgd2hpbGUodHlwZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlUXVldWUuc2hpZnQoKTtcbiAgICAgIGlmICh0eXBlLnBhdHRlcm4pIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3Qgb3ZlcnJpZGUgYSB0eXBlJ3MgLnBhdHRlcm4gYXQgcnVudGltZS5cIik7XG4gICAgICBhbmd1bGFyLmV4dGVuZCgkdHlwZXNbdHlwZS5uYW1lXSwgaW5qZWN0b3IuaW52b2tlKHR5cGUuZGVmKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgZGVmYXVsdCB0eXBlcy4gU3RvcmUgdGhlbSBpbiB0aGUgcHJvdG90eXBlIG9mICR0eXBlcy5cbiAgZm9yRWFjaChkZWZhdWx0VHlwZXMsIGZ1bmN0aW9uKHR5cGUsIG5hbWUpIHsgJHR5cGVzW25hbWVdID0gbmV3IFR5cGUoZXh0ZW5kKHtuYW1lOiBuYW1lfSwgdHlwZSkpOyB9KTtcbiAgJHR5cGVzID0gaW5oZXJpdCgkdHlwZXMsIHt9KTtcblxuICAvKiBObyBuZWVkIHRvIGRvY3VtZW50ICRnZXQsIHNpbmNlIGl0IHJldHVybnMgdGhpcyAqL1xuICB0aGlzLiRnZXQgPSBbJyRpbmplY3RvcicsIGZ1bmN0aW9uICgkaW5qZWN0b3IpIHtcbiAgICBpbmplY3RvciA9ICRpbmplY3RvcjtcbiAgICBlbnF1ZXVlID0gZmFsc2U7XG4gICAgZmx1c2hUeXBlUXVldWUoKTtcblxuICAgIGZvckVhY2goZGVmYXVsdFR5cGVzLCBmdW5jdGlvbih0eXBlLCBuYW1lKSB7XG4gICAgICBpZiAoISR0eXBlc1tuYW1lXSkgJHR5cGVzW25hbWVdID0gbmV3IFR5cGUodHlwZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1dO1xuXG4gIHRoaXMuUGFyYW0gPSBmdW5jdGlvbiBQYXJhbShpZCwgdHlwZSwgY29uZmlnLCBsb2NhdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBjb25maWcgPSB1bndyYXBTaG9ydGhhbmQoY29uZmlnKTtcbiAgICB0eXBlID0gZ2V0VHlwZShjb25maWcsIHR5cGUsIGxvY2F0aW9uKTtcbiAgICB2YXIgYXJyYXlNb2RlID0gZ2V0QXJyYXlNb2RlKCk7XG4gICAgdHlwZSA9IGFycmF5TW9kZSA/IHR5cGUuJGFzQXJyYXkoYXJyYXlNb2RlLCBsb2NhdGlvbiA9PT0gXCJzZWFyY2hcIikgOiB0eXBlO1xuICAgIGlmICh0eXBlLm5hbWUgPT09IFwic3RyaW5nXCIgJiYgIWFycmF5TW9kZSAmJiBsb2NhdGlvbiA9PT0gXCJwYXRoXCIgJiYgY29uZmlnLnZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICBjb25maWcudmFsdWUgPSBcIlwiOyAvLyBmb3IgMC4yLng7IGluIDAuMy4wKyBkbyBub3QgYXV0b21hdGljYWxseSBkZWZhdWx0IHRvIFwiXCJcbiAgICB2YXIgaXNPcHRpb25hbCA9IGNvbmZpZy52YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBzcXVhc2ggPSBnZXRTcXVhc2hQb2xpY3koY29uZmlnLCBpc09wdGlvbmFsKTtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2UoY29uZmlnLCBhcnJheU1vZGUsIGlzT3B0aW9uYWwsIHNxdWFzaCk7XG5cbiAgICBmdW5jdGlvbiB1bndyYXBTaG9ydGhhbmQoY29uZmlnKSB7XG4gICAgICB2YXIga2V5cyA9IGlzT2JqZWN0KGNvbmZpZykgPyBvYmplY3RLZXlzKGNvbmZpZykgOiBbXTtcbiAgICAgIHZhciBpc1Nob3J0aGFuZCA9IGluZGV4T2Yoa2V5cywgXCJ2YWx1ZVwiKSA9PT0gLTEgJiYgaW5kZXhPZihrZXlzLCBcInR5cGVcIikgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleE9mKGtleXMsIFwic3F1YXNoXCIpID09PSAtMSAmJiBpbmRleE9mKGtleXMsIFwiYXJyYXlcIikgPT09IC0xO1xuICAgICAgaWYgKGlzU2hvcnRoYW5kKSBjb25maWcgPSB7IHZhbHVlOiBjb25maWcgfTtcbiAgICAgIGNvbmZpZy4kJGZuID0gaXNJbmplY3RhYmxlKGNvbmZpZy52YWx1ZSkgPyBjb25maWcudmFsdWUgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWcudmFsdWU7IH07XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFR5cGUoY29uZmlnLCB1cmxUeXBlLCBsb2NhdGlvbikge1xuICAgICAgaWYgKGNvbmZpZy50eXBlICYmIHVybFR5cGUpIHRocm93IG5ldyBFcnJvcihcIlBhcmFtICdcIitpZCtcIicgaGFzIHR3byB0eXBlIGNvbmZpZ3VyYXRpb25zLlwiKTtcbiAgICAgIGlmICh1cmxUeXBlKSByZXR1cm4gdXJsVHlwZTtcbiAgICAgIGlmICghY29uZmlnLnR5cGUpIHJldHVybiAobG9jYXRpb24gPT09IFwiY29uZmlnXCIgPyAkdHlwZXMuYW55IDogJHR5cGVzLnN0cmluZyk7XG5cbiAgICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKGNvbmZpZy50eXBlKSlcbiAgICAgICAgcmV0dXJuICR0eXBlc1tjb25maWcudHlwZV07XG4gICAgICBpZiAoY29uZmlnLnR5cGUgaW5zdGFuY2VvZiBUeXBlKVxuICAgICAgICByZXR1cm4gY29uZmlnLnR5cGU7XG4gICAgICByZXR1cm4gbmV3IFR5cGUoY29uZmlnLnR5cGUpO1xuICAgIH1cblxuICAgIC8vIGFycmF5IGNvbmZpZzogcGFyYW0gbmFtZSAocGFyYW1bXSkgb3ZlcnJpZGVzIGRlZmF1bHQgc2V0dGluZ3MuICBleHBsaWNpdCBjb25maWcgb3ZlcnJpZGVzIHBhcmFtIG5hbWUuXG4gICAgZnVuY3Rpb24gZ2V0QXJyYXlNb2RlKCkge1xuICAgICAgdmFyIGFycmF5RGVmYXVsdHMgPSB7IGFycmF5OiAobG9jYXRpb24gPT09IFwic2VhcmNoXCIgPyBcImF1dG9cIiA6IGZhbHNlKSB9O1xuICAgICAgdmFyIGFycmF5UGFyYW1Ob21lbmNsYXR1cmUgPSBpZC5tYXRjaCgvXFxbXFxdJC8pID8geyBhcnJheTogdHJ1ZSB9IDoge307XG4gICAgICByZXR1cm4gZXh0ZW5kKGFycmF5RGVmYXVsdHMsIGFycmF5UGFyYW1Ob21lbmNsYXR1cmUsIGNvbmZpZykuYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBmYWxzZSwgdHJ1ZSwgb3IgdGhlIHNxdWFzaCB2YWx1ZSB0byBpbmRpY2F0ZSB0aGUgXCJkZWZhdWx0IHBhcmFtZXRlciB1cmwgc3F1YXNoIHBvbGljeVwiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNxdWFzaFBvbGljeShjb25maWcsIGlzT3B0aW9uYWwpIHtcbiAgICAgIHZhciBzcXVhc2ggPSBjb25maWcuc3F1YXNoO1xuICAgICAgaWYgKCFpc09wdGlvbmFsIHx8IHNxdWFzaCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghaXNEZWZpbmVkKHNxdWFzaCkgfHwgc3F1YXNoID09IG51bGwpIHJldHVybiBkZWZhdWx0U3F1YXNoUG9saWN5O1xuICAgICAgaWYgKHNxdWFzaCA9PT0gdHJ1ZSB8fCBpc1N0cmluZyhzcXVhc2gpKSByZXR1cm4gc3F1YXNoO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzcXVhc2ggcG9saWN5OiAnXCIgKyBzcXVhc2ggKyBcIicuIFZhbGlkIHBvbGljaWVzOiBmYWxzZSwgdHJ1ZSwgb3IgYXJiaXRyYXJ5IHN0cmluZ1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRSZXBsYWNlKGNvbmZpZywgYXJyYXlNb2RlLCBpc09wdGlvbmFsLCBzcXVhc2gpIHtcbiAgICAgIHZhciByZXBsYWNlLCBjb25maWd1cmVkS2V5cywgZGVmYXVsdFBvbGljeSA9IFtcbiAgICAgICAgeyBmcm9tOiBcIlwiLCAgIHRvOiAoaXNPcHRpb25hbCB8fCBhcnJheU1vZGUgPyB1bmRlZmluZWQgOiBcIlwiKSB9LFxuICAgICAgICB7IGZyb206IG51bGwsIHRvOiAoaXNPcHRpb25hbCB8fCBhcnJheU1vZGUgPyB1bmRlZmluZWQgOiBcIlwiKSB9XG4gICAgICBdO1xuICAgICAgcmVwbGFjZSA9IGlzQXJyYXkoY29uZmlnLnJlcGxhY2UpID8gY29uZmlnLnJlcGxhY2UgOiBbXTtcbiAgICAgIGlmIChpc1N0cmluZyhzcXVhc2gpKVxuICAgICAgICByZXBsYWNlLnB1c2goeyBmcm9tOiBzcXVhc2gsIHRvOiB1bmRlZmluZWQgfSk7XG4gICAgICBjb25maWd1cmVkS2V5cyA9IG1hcChyZXBsYWNlLCBmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtLmZyb207IH0gKTtcbiAgICAgIHJldHVybiBmaWx0ZXIoZGVmYXVsdFBvbGljeSwgZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaW5kZXhPZihjb25maWd1cmVkS2V5cywgaXRlbS5mcm9tKSA9PT0gLTE7IH0pLmNvbmNhdChyZXBsYWNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBbSW50ZXJuYWxdIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHBhcmFtZXRlciwgd2hpY2ggbWF5IGJlIGFuIGluamVjdGFibGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gJCRnZXREZWZhdWx0VmFsdWUoKSB7XG4gICAgICBpZiAoIWluamVjdG9yKSB0aHJvdyBuZXcgRXJyb3IoXCJJbmplY3RhYmxlIGZ1bmN0aW9ucyBjYW5ub3QgYmUgY2FsbGVkIGF0IGNvbmZpZ3VyYXRpb24gdGltZVwiKTtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBpbmplY3Rvci5pbnZva2UoY29uZmlnLiQkZm4pO1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhc2VsZi50eXBlLmlzKGRlZmF1bHRWYWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmF1bHQgdmFsdWUgKFwiICsgZGVmYXVsdFZhbHVlICsgXCIpIGZvciBwYXJhbWV0ZXIgJ1wiICsgc2VsZi5pZCArIFwiJyBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVHlwZSAoXCIgKyBzZWxmLnR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogW0ludGVybmFsXSBHZXRzIHRoZSBkZWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIGEgdmFsdWUgaWYgdGhlIHZhbHVlIGlzIGRlZmluZWQsIG90aGVyd2lzZSwgcmV0dXJucyB0aGVcbiAgICAgKiBkZWZhdWx0IHZhbHVlLCB3aGljaCBtYXkgYmUgdGhlIHJlc3VsdCBvZiBhbiBpbmplY3RhYmxlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uICR2YWx1ZSh2YWx1ZSkge1xuICAgICAgZnVuY3Rpb24gaGFzUmVwbGFjZVZhbCh2YWwpIHsgcmV0dXJuIGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gb2JqLmZyb20gPT09IHZhbDsgfTsgfVxuICAgICAgZnVuY3Rpb24gJHJlcGxhY2UodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gbWFwKGZpbHRlcihzZWxmLnJlcGxhY2UsIGhhc1JlcGxhY2VWYWwodmFsdWUpKSwgZnVuY3Rpb24ob2JqKSB7IHJldHVybiBvYmoudG87IH0pO1xuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQubGVuZ3RoID8gcmVwbGFjZW1lbnRbMF0gOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gJHJlcGxhY2UodmFsdWUpO1xuICAgICAgcmV0dXJuICFpc0RlZmluZWQodmFsdWUpID8gJCRnZXREZWZhdWx0VmFsdWUoKSA6IHNlbGYudHlwZS4kbm9ybWFsaXplKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHsgcmV0dXJuIFwie1BhcmFtOlwiICsgaWQgKyBcIiBcIiArIHR5cGUgKyBcIiBzcXVhc2g6ICdcIiArIHNxdWFzaCArIFwiJyBvcHRpb25hbDogXCIgKyBpc09wdGlvbmFsICsgXCJ9XCI7IH1cblxuICAgIGV4dGVuZCh0aGlzLCB7XG4gICAgICBpZDogaWQsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgYXJyYXk6IGFycmF5TW9kZSxcbiAgICAgIHNxdWFzaDogc3F1YXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwsXG4gICAgICB2YWx1ZTogJHZhbHVlLFxuICAgICAgZHluYW1pYzogdW5kZWZpbmVkLFxuICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBQYXJhbVNldChwYXJhbXMpIHtcbiAgICBleHRlbmQodGhpcywgcGFyYW1zIHx8IHt9KTtcbiAgfVxuXG4gIFBhcmFtU2V0LnByb3RvdHlwZSA9IHtcbiAgICAkJG5ldzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaW5oZXJpdCh0aGlzLCBleHRlbmQobmV3IFBhcmFtU2V0KCksIHsgJCRwYXJlbnQ6IHRoaXN9KSk7XG4gICAgfSxcbiAgICAkJGtleXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBrZXlzID0gW10sIGNoYWluID0gW10sIHBhcmVudCA9IHRoaXMsXG4gICAgICAgIGlnbm9yZSA9IG9iamVjdEtleXMoUGFyYW1TZXQucHJvdG90eXBlKTtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHsgY2hhaW4ucHVzaChwYXJlbnQpOyBwYXJlbnQgPSBwYXJlbnQuJCRwYXJlbnQ7IH1cbiAgICAgIGNoYWluLnJldmVyc2UoKTtcbiAgICAgIGZvckVhY2goY2hhaW4sIGZ1bmN0aW9uKHBhcmFtc2V0KSB7XG4gICAgICAgIGZvckVhY2gob2JqZWN0S2V5cyhwYXJhbXNldCksIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKGluZGV4T2Yoa2V5cywga2V5KSA9PT0gLTEgJiYgaW5kZXhPZihpZ25vcmUsIGtleSkgPT09IC0xKSBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0sXG4gICAgJCR2YWx1ZXM6IGZ1bmN0aW9uKHBhcmFtVmFsdWVzKSB7XG4gICAgICB2YXIgdmFsdWVzID0ge30sIHNlbGYgPSB0aGlzO1xuICAgICAgZm9yRWFjaChzZWxmLiQka2V5cygpLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFsdWVzW2tleV0gPSBzZWxmW2tleV0udmFsdWUocGFyYW1WYWx1ZXMgJiYgcGFyYW1WYWx1ZXNba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSxcbiAgICAkJGVxdWFsczogZnVuY3Rpb24ocGFyYW1WYWx1ZXMxLCBwYXJhbVZhbHVlczIpIHtcbiAgICAgIHZhciBlcXVhbCA9IHRydWUsIHNlbGYgPSB0aGlzO1xuICAgICAgZm9yRWFjaChzZWxmLiQka2V5cygpLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwYXJhbVZhbHVlczEgJiYgcGFyYW1WYWx1ZXMxW2tleV0sIHJpZ2h0ID0gcGFyYW1WYWx1ZXMyICYmIHBhcmFtVmFsdWVzMltrZXldO1xuICAgICAgICBpZiAoIXNlbGZba2V5XS50eXBlLmVxdWFscyhsZWZ0LCByaWdodCkpIGVxdWFsID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlcXVhbDtcbiAgICB9LFxuICAgICQkdmFsaWRhdGVzOiBmdW5jdGlvbiAkJHZhbGlkYXRlKHBhcmFtVmFsdWVzKSB7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuJCRrZXlzKCksIGksIHBhcmFtLCByYXdWYWwsIG5vcm1hbGl6ZWQsIGVuY29kZWQ7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJhbSA9IHRoaXNba2V5c1tpXV07XG4gICAgICAgIHJhd1ZhbCA9IHBhcmFtVmFsdWVzW2tleXNbaV1dO1xuICAgICAgICBpZiAoKHJhd1ZhbCA9PT0gdW5kZWZpbmVkIHx8IHJhd1ZhbCA9PT0gbnVsbCkgJiYgcGFyYW0uaXNPcHRpb25hbClcbiAgICAgICAgICBicmVhazsgLy8gVGhlcmUgd2FzIG5vIHBhcmFtZXRlciB2YWx1ZSwgYnV0IHRoZSBwYXJhbSBpcyBvcHRpb25hbFxuICAgICAgICBub3JtYWxpemVkID0gcGFyYW0udHlwZS4kbm9ybWFsaXplKHJhd1ZhbCk7XG4gICAgICAgIGlmICghcGFyYW0udHlwZS5pcyhub3JtYWxpemVkKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFRoZSB2YWx1ZSB3YXMgbm90IG9mIHRoZSBjb3JyZWN0IFR5cGUsIGFuZCBjb3VsZCBub3QgYmUgZGVjb2RlZCB0byB0aGUgY29ycmVjdCBUeXBlXG4gICAgICAgIGVuY29kZWQgPSBwYXJhbS50eXBlLmVuY29kZShub3JtYWxpemVkKTtcbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNTdHJpbmcoZW5jb2RlZCkgJiYgIXBhcmFtLnR5cGUucGF0dGVybi5leGVjKGVuY29kZWQpKVxuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gVGhlIHZhbHVlIHdhcyBvZiB0aGUgY29ycmVjdCB0eXBlLCBidXQgd2hlbiBlbmNvZGVkLCBkaWQgbm90IG1hdGNoIHRoZSBUeXBlJ3MgcmVnZXhwXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgICQkcGFyZW50OiB1bmRlZmluZWRcbiAgfTtcblxuICB0aGlzLlBhcmFtU2V0ID0gUGFyYW1TZXQ7XG59XG5cbi8vIFJlZ2lzdGVyIGFzIGEgcHJvdmlkZXIgc28gaXQncyBhdmFpbGFibGUgdG8gb3RoZXIgcHJvdmlkZXJzXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnV0aWwnKS5wcm92aWRlcignJHVybE1hdGNoZXJGYWN0b3J5JywgJFVybE1hdGNoZXJGYWN0b3J5KTtcbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIudXRpbCcpLnJ1bihbJyR1cmxNYXRjaGVyRmFjdG9yeScsIGZ1bmN0aW9uKCR1cmxNYXRjaGVyRmFjdG9yeSkgeyB9XSk7XG5cbi8qKlxuICogQG5nZG9jIG9iamVjdFxuICogQG5hbWUgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyUHJvdmlkZXJcbiAqXG4gKiBAcmVxdWlyZXMgdWkucm91dGVyLnV0aWwuJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXJcbiAqIEByZXF1aXJlcyAkbG9jYXRpb25Qcm92aWRlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogYCR1cmxSb3V0ZXJQcm92aWRlcmAgaGFzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB3YXRjaGluZyBgJGxvY2F0aW9uYC4gXG4gKiBXaGVuIGAkbG9jYXRpb25gIGNoYW5nZXMgaXQgcnVucyB0aHJvdWdoIGEgbGlzdCBvZiBydWxlcyBvbmUgYnkgb25lIHVudGlsIGEgXG4gKiBtYXRjaCBpcyBmb3VuZC4gYCR1cmxSb3V0ZXJQcm92aWRlcmAgaXMgdXNlZCBiZWhpbmQgdGhlIHNjZW5lcyBhbnl0aW1lIHlvdSBzcGVjaWZ5IFxuICogYSB1cmwgaW4gYSBzdGF0ZSBjb25maWd1cmF0aW9uLiBBbGwgdXJscyBhcmUgY29tcGlsZWQgaW50byBhIFVybE1hdGNoZXIgb2JqZWN0LlxuICpcbiAqIFRoZXJlIGFyZSBzZXZlcmFsIG1ldGhvZHMgb24gYCR1cmxSb3V0ZXJQcm92aWRlcmAgdGhhdCBtYWtlIGl0IHVzZWZ1bCB0byB1c2UgZGlyZWN0bHlcbiAqIGluIHlvdXIgbW9kdWxlIGNvbmZpZy5cbiAqL1xuJFVybFJvdXRlclByb3ZpZGVyLiRpbmplY3QgPSBbJyRsb2NhdGlvblByb3ZpZGVyJywgJyR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyJ107XG5mdW5jdGlvbiAkVXJsUm91dGVyUHJvdmlkZXIoICAgJGxvY2F0aW9uUHJvdmlkZXIsICAgJHVybE1hdGNoZXJGYWN0b3J5KSB7XG4gIHZhciBydWxlcyA9IFtdLCBvdGhlcndpc2UgPSBudWxsLCBpbnRlcmNlcHREZWZlcnJlZCA9IGZhbHNlLCBsaXN0ZW5lcjtcblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgYSBwcmVmaXggb2YgYWxsIHN0cmluZ3MgbWF0Y2hpbmcgdGhlIFJlZ0V4cFxuICBmdW5jdGlvbiByZWdFeHBQcmVmaXgocmUpIHtcbiAgICB2YXIgcHJlZml4ID0gL15cXF4oKD86XFxcXFteYS16QS1aMC05XXxbXlxcXFxcXFtcXF1cXF4kKis/LigpfHt9XSspKikvLmV4ZWMocmUuc291cmNlKTtcbiAgICByZXR1cm4gKHByZWZpeCAhPSBudWxsKSA/IHByZWZpeFsxXS5yZXBsYWNlKC9cXFxcKC4pL2csIFwiJDFcIikgOiAnJztcbiAgfVxuXG4gIC8vIEludGVycG9sYXRlcyBtYXRjaGVkIHZhbHVlcyBpbnRvIGEgU3RyaW5nLnJlcGxhY2UoKS1zdHlsZSBwYXR0ZXJuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlKHBhdHRlcm4sIG1hdGNoKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvXFwkKFxcJHxcXGR7MSwyfSkvLCBmdW5jdGlvbiAobSwgd2hhdCkge1xuICAgICAgcmV0dXJuIG1hdGNoW3doYXQgPT09ICckJyA/IDAgOiBOdW1iZXIod2hhdCldO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlciNydWxlXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRGVmaW5lcyBydWxlcyB0aGF0IGFyZSB1c2VkIGJ5IGAkdXJsUm91dGVyUHJvdmlkZXJgIHRvIGZpbmQgbWF0Y2hlcyBmb3JcbiAgICogc3BlY2lmaWMgVVJMcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPHByZT5cbiAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlci5yb3V0ZXInXSk7XG4gICAqXG4gICAqIGFwcC5jb25maWcoZnVuY3Rpb24gKCR1cmxSb3V0ZXJQcm92aWRlcikge1xuICAgKiAgIC8vIEhlcmUncyBhbiBleGFtcGxlIG9mIGhvdyB5b3UgbWlnaHQgYWxsb3cgY2FzZSBpbnNlbnNpdGl2ZSB1cmxzXG4gICAqICAgJHVybFJvdXRlclByb3ZpZGVyLnJ1bGUoZnVuY3Rpb24gKCRpbmplY3RvciwgJGxvY2F0aW9uKSB7XG4gICAqICAgICB2YXIgcGF0aCA9ICRsb2NhdGlvbi5wYXRoKCksXG4gICAqICAgICAgICAgbm9ybWFsaXplZCA9IHBhdGgudG9Mb3dlckNhc2UoKTtcbiAgICpcbiAgICogICAgIGlmIChwYXRoICE9PSBub3JtYWxpemVkKSB7XG4gICAqICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKiB9KTtcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJ1bGUgSGFuZGxlciBmdW5jdGlvbiB0aGF0IHRha2VzIGAkaW5qZWN0b3JgIGFuZCBgJGxvY2F0aW9uYFxuICAgKiBzZXJ2aWNlcyBhcyBhcmd1bWVudHMuIFlvdSBjYW4gdXNlIHRoZW0gdG8gcmV0dXJuIGEgdmFsaWQgcGF0aCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSBgJHVybFJvdXRlclByb3ZpZGVyYCAtIGAkdXJsUm91dGVyUHJvdmlkZXJgIGluc3RhbmNlXG4gICAqL1xuICB0aGlzLnJ1bGUgPSBmdW5jdGlvbiAocnVsZSkge1xuICAgIGlmICghaXNGdW5jdGlvbihydWxlKSkgdGhyb3cgbmV3IEVycm9yKFwiJ3J1bGUnIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICBydWxlcy5wdXNoKHJ1bGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2Mgb2JqZWN0XG4gICAqIEBuYW1lIHVpLnJvdXRlci5yb3V0ZXIuJHVybFJvdXRlclByb3ZpZGVyI290aGVyd2lzZVxuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERlZmluZXMgYSBwYXRoIHRoYXQgaXMgdXNlZCB3aGVuIGFuIGludmFsaWQgcm91dGUgaXMgcmVxdWVzdGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiA8cHJlPlxuICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcbiAgICpcbiAgICogYXBwLmNvbmZpZyhmdW5jdGlvbiAoJHVybFJvdXRlclByb3ZpZGVyKSB7XG4gICAqICAgLy8gaWYgdGhlIHBhdGggZG9lc24ndCBtYXRjaCBhbnkgb2YgdGhlIHVybHMgeW91IGNvbmZpZ3VyZWRcbiAgICogICAvLyBvdGhlcndpc2Ugd2lsbCB0YWtlIGNhcmUgb2Ygcm91dGluZyB0aGUgdXNlciB0byB0aGVcbiAgICogICAvLyBzcGVjaWZpZWQgdXJsXG4gICAqICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZSgnL2luZGV4Jyk7XG4gICAqXG4gICAqICAgLy8gRXhhbXBsZSBvZiB1c2luZyBmdW5jdGlvbiBydWxlIGFzIHBhcmFtXG4gICAqICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZShmdW5jdGlvbiAoJGluamVjdG9yLCAkbG9jYXRpb24pIHtcbiAgICogICAgIHJldHVybiAnL2EvdmFsaWQvdXJsJztcbiAgICogICB9KTtcbiAgICogfSk7XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gcnVsZSBUaGUgdXJsIHBhdGggeW91IHdhbnQgdG8gcmVkaXJlY3QgdG8gb3IgYSBmdW5jdGlvbiBcbiAgICogcnVsZSB0aGF0IHJldHVybnMgdGhlIHVybCBwYXRoLiBUaGUgZnVuY3Rpb24gdmVyc2lvbiBpcyBwYXNzZWQgdHdvIHBhcmFtczogXG4gICAqIGAkaW5qZWN0b3JgIGFuZCBgJGxvY2F0aW9uYCBzZXJ2aWNlcywgYW5kIG11c3QgcmV0dXJuIGEgdXJsIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSBgJHVybFJvdXRlclByb3ZpZGVyYCAtIGAkdXJsUm91dGVyUHJvdmlkZXJgIGluc3RhbmNlXG4gICAqL1xuICB0aGlzLm90aGVyd2lzZSA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgaWYgKGlzU3RyaW5nKHJ1bGUpKSB7XG4gICAgICB2YXIgcmVkaXJlY3QgPSBydWxlO1xuICAgICAgcnVsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZGlyZWN0OyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNGdW5jdGlvbihydWxlKSkgdGhyb3cgbmV3IEVycm9yKFwiJ3J1bGUnIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICBvdGhlcndpc2UgPSBydWxlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgZnVuY3Rpb24gaGFuZGxlSWZNYXRjaCgkaW5qZWN0b3IsIGhhbmRsZXIsIG1hdGNoKSB7XG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciByZXN1bHQgPSAkaW5qZWN0b3IuaW52b2tlKGhhbmRsZXIsIGhhbmRsZXIsIHsgJG1hdGNoOiBtYXRjaCB9KTtcbiAgICByZXR1cm4gaXNEZWZpbmVkKHJlc3VsdCkgPyByZXN1bHQgOiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlciN3aGVuXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmVnaXN0ZXJzIGEgaGFuZGxlciBmb3IgYSBnaXZlbiB1cmwgbWF0Y2hpbmcuIFxuICAgKiBcbiAgICogSWYgdGhlIGhhbmRsZXIgaXMgYSBzdHJpbmcsIGl0IGlzXG4gICAqIHRyZWF0ZWQgYXMgYSByZWRpcmVjdCwgYW5kIGlzIGludGVycG9sYXRlZCBhY2NvcmRpbmcgdG8gdGhlIHN5bnRheCBvZiBtYXRjaFxuICAgKiAoaS5lLiBsaWtlIGBTdHJpbmcucmVwbGFjZSgpYCBmb3IgYFJlZ0V4cGAsIG9yIGxpa2UgYSBgVXJsTWF0Y2hlcmAgcGF0dGVybiBvdGhlcndpc2UpLlxuICAgKlxuICAgKiBJZiB0aGUgaGFuZGxlciBpcyBhIGZ1bmN0aW9uLCBpdCBpcyBpbmplY3RhYmxlLiBJdCBnZXRzIGludm9rZWQgaWYgYCRsb2NhdGlvbmBcbiAgICogbWF0Y2hlcy4gWW91IGhhdmUgdGhlIG9wdGlvbiBvZiBpbmplY3QgdGhlIG1hdGNoIG9iamVjdCBhcyBgJG1hdGNoYC5cbiAgICpcbiAgICogVGhlIGhhbmRsZXIgY2FuIHJldHVyblxuICAgKlxuICAgKiAtICoqZmFsc3kqKiB0byBpbmRpY2F0ZSB0aGF0IHRoZSBydWxlIGRpZG4ndCBtYXRjaCBhZnRlciBhbGwsIHRoZW4gYCR1cmxSb3V0ZXJgXG4gICAqICAgd2lsbCBjb250aW51ZSB0cnlpbmcgdG8gZmluZCBhbm90aGVyIG9uZSB0aGF0IG1hdGNoZXMuXG4gICAqIC0gKipzdHJpbmcqKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcmVkaXJlY3QgYW5kIHBhc3NlZCB0byBgJGxvY2F0aW9uLnVybCgpYFxuICAgKiAtICoqdm9pZCoqIG9yIGFueSAqKnRydXRoeSoqIHZhbHVlIHRlbGxzIGAkdXJsUm91dGVyYCB0aGF0IHRoZSB1cmwgd2FzIGhhbmRsZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxwcmU+XG4gICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXIucm91dGVyJ10pO1xuICAgKlxuICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICogICAkdXJsUm91dGVyUHJvdmlkZXIud2hlbigkc3RhdGUudXJsLCBmdW5jdGlvbiAoJG1hdGNoLCAkc3RhdGVQYXJhbXMpIHtcbiAgICogICAgIGlmICgkc3RhdGUuJGN1cnJlbnQubmF2aWdhYmxlICE9PSBzdGF0ZSB8fFxuICAgKiAgICAgICAgICFlcXVhbEZvcktleXMoJG1hdGNoLCAkc3RhdGVQYXJhbXMpIHtcbiAgICogICAgICAkc3RhdGUudHJhbnNpdGlvblRvKHN0YXRlLCAkbWF0Y2gsIGZhbHNlKTtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogfSk7XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHdoYXQgVGhlIGluY29taW5nIHBhdGggdGhhdCB5b3Ugd2FudCB0byByZWRpcmVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IGhhbmRsZXIgVGhlIHBhdGggeW91IHdhbnQgdG8gcmVkaXJlY3QgeW91ciB1c2VyIHRvLlxuICAgKi9cbiAgdGhpcy53aGVuID0gZnVuY3Rpb24gKHdoYXQsIGhhbmRsZXIpIHtcbiAgICB2YXIgcmVkaXJlY3QsIGhhbmRsZXJJc1N0cmluZyA9IGlzU3RyaW5nKGhhbmRsZXIpO1xuICAgIGlmIChpc1N0cmluZyh3aGF0KSkgd2hhdCA9ICR1cmxNYXRjaGVyRmFjdG9yeS5jb21waWxlKHdoYXQpO1xuXG4gICAgaWYgKCFoYW5kbGVySXNTdHJpbmcgJiYgIWlzRnVuY3Rpb24oaGFuZGxlcikgJiYgIWlzQXJyYXkoaGFuZGxlcikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkICdoYW5kbGVyJyBpbiB3aGVuKClcIik7XG5cbiAgICB2YXIgc3RyYXRlZ2llcyA9IHtcbiAgICAgIG1hdGNoZXI6IGZ1bmN0aW9uICh3aGF0LCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChoYW5kbGVySXNTdHJpbmcpIHtcbiAgICAgICAgICByZWRpcmVjdCA9ICR1cmxNYXRjaGVyRmFjdG9yeS5jb21waWxlKGhhbmRsZXIpO1xuICAgICAgICAgIGhhbmRsZXIgPSBbJyRtYXRjaCcsIGZ1bmN0aW9uICgkbWF0Y2gpIHsgcmV0dXJuIHJlZGlyZWN0LmZvcm1hdCgkbWF0Y2gpOyB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgkaW5qZWN0b3IsICRsb2NhdGlvbikge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVJZk1hdGNoKCRpbmplY3RvciwgaGFuZGxlciwgd2hhdC5leGVjKCRsb2NhdGlvbi5wYXRoKCksICRsb2NhdGlvbi5zZWFyY2goKSkpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgcHJlZml4OiBpc1N0cmluZyh3aGF0LnByZWZpeCkgPyB3aGF0LnByZWZpeCA6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHJlZ2V4OiBmdW5jdGlvbiAod2hhdCwgaGFuZGxlcikge1xuICAgICAgICBpZiAod2hhdC5nbG9iYWwgfHwgd2hhdC5zdGlja3kpIHRocm93IG5ldyBFcnJvcihcIndoZW4oKSBSZWdFeHAgbXVzdCBub3QgYmUgZ2xvYmFsIG9yIHN0aWNreVwiKTtcblxuICAgICAgICBpZiAoaGFuZGxlcklzU3RyaW5nKSB7XG4gICAgICAgICAgcmVkaXJlY3QgPSBoYW5kbGVyO1xuICAgICAgICAgIGhhbmRsZXIgPSBbJyRtYXRjaCcsIGZ1bmN0aW9uICgkbWF0Y2gpIHsgcmV0dXJuIGludGVycG9sYXRlKHJlZGlyZWN0LCAkbWF0Y2gpOyB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgkaW5qZWN0b3IsICRsb2NhdGlvbikge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVJZk1hdGNoKCRpbmplY3RvciwgaGFuZGxlciwgd2hhdC5leGVjKCRsb2NhdGlvbi5wYXRoKCkpKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIHByZWZpeDogcmVnRXhwUHJlZml4KHdoYXQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY2hlY2sgPSB7IG1hdGNoZXI6ICR1cmxNYXRjaGVyRmFjdG9yeS5pc01hdGNoZXIod2hhdCksIHJlZ2V4OiB3aGF0IGluc3RhbmNlb2YgUmVnRXhwIH07XG5cbiAgICBmb3IgKHZhciBuIGluIGNoZWNrKSB7XG4gICAgICBpZiAoY2hlY2tbbl0pIHJldHVybiB0aGlzLnJ1bGUoc3RyYXRlZ2llc1tuXSh3aGF0LCBoYW5kbGVyKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCAnd2hhdCcgaW4gd2hlbigpXCIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyUHJvdmlkZXIjZGVmZXJJbnRlcmNlcHRcbiAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5yb3V0ZXIuJHVybFJvdXRlclByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBEaXNhYmxlcyAob3IgZW5hYmxlcykgZGVmZXJyaW5nIGxvY2F0aW9uIGNoYW5nZSBpbnRlcmNlcHRpb24uXG4gICAqXG4gICAqIElmIHlvdSB3aXNoIHRvIGN1c3RvbWl6ZSB0aGUgYmVoYXZpb3Igb2Ygc3luY2luZyB0aGUgVVJMIChmb3IgZXhhbXBsZSwgaWYgeW91IHdpc2ggdG9cbiAgICogZGVmZXIgYSB0cmFuc2l0aW9uIGJ1dCBtYWludGFpbiB0aGUgY3VycmVudCBVUkwpLCBjYWxsIHRoaXMgbWV0aG9kIGF0IGNvbmZpZ3VyYXRpb24gdGltZS5cbiAgICogVGhlbiwgYXQgcnVuIHRpbWUsIGNhbGwgYCR1cmxSb3V0ZXIubGlzdGVuKClgIGFmdGVyIHlvdSBoYXZlIGNvbmZpZ3VyZWQgeW91ciBvd25cbiAgICogYCRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3NgIGV2ZW50IGhhbmRsZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxwcmU+XG4gICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXIucm91dGVyJ10pO1xuICAgKlxuICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICpcbiAgICogICAvLyBQcmV2ZW50ICR1cmxSb3V0ZXIgZnJvbSBhdXRvbWF0aWNhbGx5IGludGVyY2VwdGluZyBVUkwgY2hhbmdlcztcbiAgICogICAvLyB0aGlzIGFsbG93cyB5b3UgdG8gY29uZmlndXJlIGN1c3RvbSBiZWhhdmlvciBpbiBiZXR3ZWVuXG4gICAqICAgLy8gbG9jYXRpb24gY2hhbmdlcyBhbmQgcm91dGUgc3luY2hyb25pemF0aW9uOlxuICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5kZWZlckludGVyY2VwdCgpO1xuICAgKlxuICAgKiB9KS5ydW4oZnVuY3Rpb24gKCRyb290U2NvcGUsICR1cmxSb3V0ZXIsIFVzZXJTZXJ2aWNlKSB7XG4gICAqXG4gICAqICAgJHJvb3RTY29wZS4kb24oJyRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3MnLCBmdW5jdGlvbihlKSB7XG4gICAqICAgICAvLyBVc2VyU2VydmljZSBpcyBhbiBleGFtcGxlIHNlcnZpY2UgZm9yIG1hbmFnaW5nIHVzZXIgc3RhdGVcbiAgICogICAgIGlmIChVc2VyU2VydmljZS5pc0xvZ2dlZEluKCkpIHJldHVybjtcbiAgICpcbiAgICogICAgIC8vIFByZXZlbnQgJHVybFJvdXRlcidzIGRlZmF1bHQgaGFuZGxlciBmcm9tIGZpcmluZ1xuICAgKiAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgKlxuICAgKiAgICAgVXNlclNlcnZpY2UuaGFuZGxlTG9naW4oKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAvLyBPbmNlIHRoZSB1c2VyIGhhcyBsb2dnZWQgaW4sIHN5bmMgdGhlIGN1cnJlbnQgVVJMXG4gICAqICAgICAgIC8vIHRvIHRoZSByb3V0ZXI6XG4gICAqICAgICAgICR1cmxSb3V0ZXIuc3luYygpO1xuICAgKiAgICAgfSk7XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgLy8gQ29uZmlndXJlcyAkdXJsUm91dGVyJ3MgbGlzdGVuZXIgKmFmdGVyKiB5b3VyIGN1c3RvbSBsaXN0ZW5lclxuICAgKiAgICR1cmxSb3V0ZXIubGlzdGVuKCk7XG4gICAqIH0pO1xuICAgKiA8L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBkZWZlciBJbmRpY2F0ZXMgd2hldGhlciB0byBkZWZlciBsb2NhdGlvbiBjaGFuZ2UgaW50ZXJjZXB0aW9uLiBQYXNzaW5nXG4gICAgICAgICAgICBubyBwYXJhbWV0ZXIgaXMgZXF1aXZhbGVudCB0byBgdHJ1ZWAuXG4gICAqL1xuICB0aGlzLmRlZmVySW50ZXJjZXB0ID0gZnVuY3Rpb24gKGRlZmVyKSB7XG4gICAgaWYgKGRlZmVyID09PSB1bmRlZmluZWQpIGRlZmVyID0gdHJ1ZTtcbiAgICBpbnRlcmNlcHREZWZlcnJlZCA9IGRlZmVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2Mgb2JqZWN0XG4gICAqIEBuYW1lIHVpLnJvdXRlci5yb3V0ZXIuJHVybFJvdXRlclxuICAgKlxuICAgKiBAcmVxdWlyZXMgJGxvY2F0aW9uXG4gICAqIEByZXF1aXJlcyAkcm9vdFNjb3BlXG4gICAqIEByZXF1aXJlcyAkaW5qZWN0b3JcbiAgICogQHJlcXVpcmVzICRicm93c2VyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKi9cbiAgdGhpcy4kZ2V0ID0gJGdldDtcbiAgJGdldC4kaW5qZWN0ID0gWyckbG9jYXRpb24nLCAnJHJvb3RTY29wZScsICckaW5qZWN0b3InLCAnJGJyb3dzZXInLCAnJHNuaWZmZXInXTtcbiAgZnVuY3Rpb24gJGdldCggICAkbG9jYXRpb24sICAgJHJvb3RTY29wZSwgICAkaW5qZWN0b3IsICAgJGJyb3dzZXIsICAgJHNuaWZmZXIpIHtcblxuICAgIHZhciBiYXNlSHJlZiA9ICRicm93c2VyLmJhc2VIcmVmKCksIGxvY2F0aW9uID0gJGxvY2F0aW9uLnVybCgpLCBsYXN0UHVzaGVkVXJsO1xuXG4gICAgZnVuY3Rpb24gYXBwZW5kQmFzZVBhdGgodXJsLCBpc0h0bWw1LCBhYnNvbHV0ZSkge1xuICAgICAgaWYgKGJhc2VIcmVmID09PSAnLycpIHJldHVybiB1cmw7XG4gICAgICBpZiAoaXNIdG1sNSkgcmV0dXJuIGJhc2VIcmVmLnNsaWNlKDAsIC0xKSArIHVybDtcbiAgICAgIGlmIChhYnNvbHV0ZSkgcmV0dXJuIGJhc2VIcmVmLnNsaWNlKDEpICsgdXJsO1xuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBPcHRpbWl6ZSBncm91cHMgb2YgcnVsZXMgd2l0aCBub24tZW1wdHkgcHJlZml4IGludG8gc29tZSBzb3J0IG9mIGRlY2lzaW9uIHRyZWVcbiAgICBmdW5jdGlvbiB1cGRhdGUoZXZ0KSB7XG4gICAgICBpZiAoZXZ0ICYmIGV2dC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICB2YXIgaWdub3JlVXBkYXRlID0gbGFzdFB1c2hlZFVybCAmJiAkbG9jYXRpb24udXJsKCkgPT09IGxhc3RQdXNoZWRVcmw7XG4gICAgICBsYXN0UHVzaGVkVXJsID0gdW5kZWZpbmVkO1xuICAgICAgLy8gVE9ETzogUmUtaW1wbGVtZW50IHRoaXMgaW4gMS4wIGZvciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci11aS91aS1yb3V0ZXIvaXNzdWVzLzE1NzNcbiAgICAgIC8vaWYgKGlnbm9yZVVwZGF0ZSkgcmV0dXJuIHRydWU7XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrKHJ1bGUpIHtcbiAgICAgICAgdmFyIGhhbmRsZWQgPSBydWxlKCRpbmplY3RvciwgJGxvY2F0aW9uKTtcblxuICAgICAgICBpZiAoIWhhbmRsZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGhhbmRsZWQpKSAkbG9jYXRpb24ucmVwbGFjZSgpLnVybChoYW5kbGVkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgbiA9IHJ1bGVzLmxlbmd0aCwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoY2hlY2socnVsZXNbaV0pKSByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBhbHdheXMgY2hlY2sgb3RoZXJ3aXNlIGxhc3QgdG8gYWxsb3cgZHluYW1pYyB1cGRhdGVzIHRvIHRoZSBzZXQgb2YgcnVsZXNcbiAgICAgIGlmIChvdGhlcndpc2UpIGNoZWNrKG90aGVyd2lzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lciB8fCAkcm9vdFNjb3BlLiRvbignJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsIHVwZGF0ZSk7XG4gICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcmNlcHREZWZlcnJlZCkgbGlzdGVuKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIHVpLnJvdXRlci5yb3V0ZXIuJHVybFJvdXRlciNzeW5jXG4gICAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBUcmlnZ2VycyBhbiB1cGRhdGU7IHRoZSBzYW1lIHVwZGF0ZSB0aGF0IGhhcHBlbnMgd2hlbiB0aGUgYWRkcmVzcyBiYXIgdXJsIGNoYW5nZXMsIGFrYSBgJGxvY2F0aW9uQ2hhbmdlU3VjY2Vzc2AuXG4gICAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byB1c2UgYHByZXZlbnREZWZhdWx0KClgIG9uIHRoZSBgJGxvY2F0aW9uQ2hhbmdlU3VjY2Vzc2AgZXZlbnQsXG4gICAgICAgKiBwZXJmb3JtIHNvbWUgY3VzdG9tIGxvZ2ljIChyb3V0ZSBwcm90ZWN0aW9uLCBhdXRoLCBjb25maWcsIHJlZGlyZWN0aW9uLCBldGMpIGFuZCB0aGVuIGZpbmFsbHkgcHJvY2VlZFxuICAgICAgICogd2l0aCB0aGUgdHJhbnNpdGlvbiBieSBjYWxsaW5nIGAkdXJsUm91dGVyLnN5bmMoKWAuXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIDxwcmU+XG4gICAgICAgKiBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSlcbiAgICAgICAqICAgLnJ1bihmdW5jdGlvbigkcm9vdFNjb3BlLCAkdXJsUm91dGVyKSB7XG4gICAgICAgKiAgICAgJHJvb3RTY29wZS4kb24oJyRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3MnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAqICAgICAgIC8vIEhhbHQgc3RhdGUgY2hhbmdlIGZyb20gZXZlbiBzdGFydGluZ1xuICAgICAgICogICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgKiAgICAgICAvLyBQZXJmb3JtIGN1c3RvbSBsb2dpY1xuICAgICAgICogICAgICAgdmFyIG1lZXRzUmVxdWlyZW1lbnQgPSAuLi5cbiAgICAgICAqICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIHVwZGF0ZSBhbmQgc3RhdGUgdHJhbnNpdGlvbiBpZiBsb2dpYyBhbGxvd3NcbiAgICAgICAqICAgICAgIGlmIChtZWV0c1JlcXVpcmVtZW50KSAkdXJsUm91dGVyLnN5bmMoKTtcbiAgICAgICAqICAgICB9KTtcbiAgICAgICAqIH0pO1xuICAgICAgICogPC9wcmU+XG4gICAgICAgKi9cbiAgICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB1cGRhdGUoKTtcbiAgICAgIH0sXG5cbiAgICAgIGxpc3RlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW4oKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24ocmVhZCkge1xuICAgICAgICBpZiAocmVhZCkge1xuICAgICAgICAgIGxvY2F0aW9uID0gJGxvY2F0aW9uLnVybCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGxvY2F0aW9uLnVybCgpID09PSBsb2NhdGlvbikgcmV0dXJuO1xuXG4gICAgICAgICRsb2NhdGlvbi51cmwobG9jYXRpb24pO1xuICAgICAgICAkbG9jYXRpb24ucmVwbGFjZSgpO1xuICAgICAgfSxcblxuICAgICAgcHVzaDogZnVuY3Rpb24odXJsTWF0Y2hlciwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgICB2YXIgdXJsID0gdXJsTWF0Y2hlci5mb3JtYXQocGFyYW1zIHx8IHt9KTtcblxuICAgICAgICAvLyBIYW5kbGUgdGhlIHNwZWNpYWwgaGFzaCBwYXJhbSwgaWYgbmVlZGVkXG4gICAgICAgIGlmICh1cmwgIT09IG51bGwgJiYgcGFyYW1zICYmIHBhcmFtc1snIyddKSB7XG4gICAgICAgICAgICB1cmwgKz0gJyMnICsgcGFyYW1zWycjJ107XG4gICAgICAgIH1cblxuICAgICAgICAkbG9jYXRpb24udXJsKHVybCk7XG4gICAgICAgIGxhc3RQdXNoZWRVcmwgPSBvcHRpb25zICYmIG9wdGlvbnMuJCRhdm9pZFJlc3luYyA/ICRsb2NhdGlvbi51cmwoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSAkbG9jYXRpb24ucmVwbGFjZSgpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIHVpLnJvdXRlci5yb3V0ZXIuJHVybFJvdXRlciNocmVmXG4gICAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBBIFVSTCBnZW5lcmF0aW9uIG1ldGhvZCB0aGF0IHJldHVybnMgdGhlIGNvbXBpbGVkIFVSTCBmb3IgYSBnaXZlblxuICAgICAgICoge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciBgVXJsTWF0Y2hlcmB9LCBwb3B1bGF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy5cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogPHByZT5cbiAgICAgICAqICRib2IgPSAkdXJsUm91dGVyLmhyZWYobmV3IFVybE1hdGNoZXIoXCIvYWJvdXQvOnBlcnNvblwiKSwge1xuICAgICAgICogICBwZXJzb246IFwiYm9iXCJcbiAgICAgICAqIH0pO1xuICAgICAgICogLy8gJGJvYiA9PSBcIi9hYm91dC9ib2JcIjtcbiAgICAgICAqIDwvcHJlPlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7VXJsTWF0Y2hlcn0gdXJsTWF0Y2hlciBUaGUgYFVybE1hdGNoZXJgIG9iamVjdCB3aGljaCBpcyB1c2VkIGFzIHRoZSB0ZW1wbGF0ZSBvZiB0aGUgVVJMIHRvIGdlbmVyYXRlLlxuICAgICAgICogQHBhcmFtIHtvYmplY3Q9fSBwYXJhbXMgQW4gb2JqZWN0IG9mIHBhcmFtZXRlciB2YWx1ZXMgdG8gZmlsbCB0aGUgbWF0Y2hlcidzIHJlcXVpcmVkIHBhcmFtZXRlcnMuXG4gICAgICAgKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICAgICAqXG4gICAgICAgKiAtICoqYGFic29sdXRlYCoqIC0ge2Jvb2xlYW49ZmFsc2V9LCAgSWYgdHJ1ZSB3aWxsIGdlbmVyYXRlIGFuIGFic29sdXRlIHVybCwgZS5nLiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vZnVsbHVybFwiLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bGx5IGNvbXBpbGVkIFVSTCwgb3IgYG51bGxgIGlmIGBwYXJhbXNgIGZhaWwgdmFsaWRhdGlvbiBhZ2FpbnN0IGB1cmxNYXRjaGVyYFxuICAgICAgICovXG4gICAgICBocmVmOiBmdW5jdGlvbih1cmxNYXRjaGVyLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF1cmxNYXRjaGVyLnZhbGlkYXRlcyhwYXJhbXMpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgaXNIdG1sNSA9ICRsb2NhdGlvblByb3ZpZGVyLmh0bWw1TW9kZSgpO1xuICAgICAgICBpZiAoYW5ndWxhci5pc09iamVjdChpc0h0bWw1KSkge1xuICAgICAgICAgIGlzSHRtbDUgPSBpc0h0bWw1LmVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpc0h0bWw1ID0gaXNIdG1sNSAmJiAkc25pZmZlci5oaXN0b3J5O1xuICAgICAgICBcbiAgICAgICAgdmFyIHVybCA9IHVybE1hdGNoZXIuZm9ybWF0KHBhcmFtcyk7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmICghaXNIdG1sNSAmJiB1cmwgIT09IG51bGwpIHtcbiAgICAgICAgICB1cmwgPSBcIiNcIiArICRsb2NhdGlvblByb3ZpZGVyLmhhc2hQcmVmaXgoKSArIHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBzcGVjaWFsIGhhc2ggcGFyYW0sIGlmIG5lZWRlZFxuICAgICAgICBpZiAodXJsICE9PSBudWxsICYmIHBhcmFtcyAmJiBwYXJhbXNbJyMnXSkge1xuICAgICAgICAgIHVybCArPSAnIycgKyBwYXJhbXNbJyMnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybCA9IGFwcGVuZEJhc2VQYXRoKHVybCwgaXNIdG1sNSwgb3B0aW9ucy5hYnNvbHV0ZSk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmFic29sdXRlIHx8ICF1cmwpIHtcbiAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNsYXNoID0gKCFpc0h0bWw1ICYmIHVybCA/ICcvJyA6ICcnKSwgcG9ydCA9ICRsb2NhdGlvbi5wb3J0KCk7XG4gICAgICAgIHBvcnQgPSAocG9ydCA9PT0gODAgfHwgcG9ydCA9PT0gNDQzID8gJycgOiAnOicgKyBwb3J0KTtcblxuICAgICAgICByZXR1cm4gWyRsb2NhdGlvbi5wcm90b2NvbCgpLCAnOi8vJywgJGxvY2F0aW9uLmhvc3QoKSwgcG9ydCwgc2xhc2gsIHVybF0uam9pbignJyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnJvdXRlcicpLnByb3ZpZGVyKCckdXJsUm91dGVyJywgJFVybFJvdXRlclByb3ZpZGVyKTtcblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlUHJvdmlkZXJcbiAqXG4gKiBAcmVxdWlyZXMgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyUHJvdmlkZXJcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIG5ldyBgJHN0YXRlUHJvdmlkZXJgIHdvcmtzIHNpbWlsYXIgdG8gQW5ndWxhcidzIHYxIHJvdXRlciwgYnV0IGl0IGZvY3VzZXMgcHVyZWx5XG4gKiBvbiBzdGF0ZS5cbiAqXG4gKiBBIHN0YXRlIGNvcnJlc3BvbmRzIHRvIGEgXCJwbGFjZVwiIGluIHRoZSBhcHBsaWNhdGlvbiBpbiB0ZXJtcyBvZiB0aGUgb3ZlcmFsbCBVSSBhbmRcbiAqIG5hdmlnYXRpb24uIEEgc3RhdGUgZGVzY3JpYmVzICh2aWEgdGhlIGNvbnRyb2xsZXIgLyB0ZW1wbGF0ZSAvIHZpZXcgcHJvcGVydGllcykgd2hhdFxuICogdGhlIFVJIGxvb2tzIGxpa2UgYW5kIGRvZXMgYXQgdGhhdCBwbGFjZS5cbiAqXG4gKiBTdGF0ZXMgb2Z0ZW4gaGF2ZSB0aGluZ3MgaW4gY29tbW9uLCBhbmQgdGhlIHByaW1hcnkgd2F5IG9mIGZhY3RvcmluZyBvdXQgdGhlc2VcbiAqIGNvbW1vbmFsaXRpZXMgaW4gdGhpcyBtb2RlbCBpcyB2aWEgdGhlIHN0YXRlIGhpZXJhcmNoeSwgaS5lLiBwYXJlbnQvY2hpbGQgc3RhdGVzIGFrYVxuICogbmVzdGVkIHN0YXRlcy5cbiAqXG4gKiBUaGUgYCRzdGF0ZVByb3ZpZGVyYCBwcm92aWRlcyBpbnRlcmZhY2VzIHRvIGRlY2xhcmUgdGhlc2Ugc3RhdGVzIGZvciB5b3VyIGFwcC5cbiAqL1xuJFN0YXRlUHJvdmlkZXIuJGluamVjdCA9IFsnJHVybFJvdXRlclByb3ZpZGVyJywgJyR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyJ107XG5mdW5jdGlvbiAkU3RhdGVQcm92aWRlciggICAkdXJsUm91dGVyUHJvdmlkZXIsICAgJHVybE1hdGNoZXJGYWN0b3J5KSB7XG5cbiAgdmFyIHJvb3QsIHN0YXRlcyA9IHt9LCAkc3RhdGUsIHF1ZXVlID0ge30sIGFic3RyYWN0S2V5ID0gJ2Fic3RyYWN0JztcblxuICAvLyBCdWlsZHMgc3RhdGUgcHJvcGVydGllcyBmcm9tIGRlZmluaXRpb24gcGFzc2VkIHRvIHJlZ2lzdGVyU3RhdGUoKVxuICB2YXIgc3RhdGVCdWlsZGVyID0ge1xuXG4gICAgLy8gRGVyaXZlIHBhcmVudCBzdGF0ZSBmcm9tIGEgaGllcmFyY2hpY2FsIG5hbWUgb25seSBpZiAncGFyZW50JyBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkLlxuICAgIC8vIHN0YXRlLmNoaWxkcmVuID0gW107XG4gICAgLy8gaWYgKHBhcmVudCkgcGFyZW50LmNoaWxkcmVuLnB1c2goc3RhdGUpO1xuICAgIHBhcmVudDogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIGlmIChpc0RlZmluZWQoc3RhdGUucGFyZW50KSAmJiBzdGF0ZS5wYXJlbnQpIHJldHVybiBmaW5kU3RhdGUoc3RhdGUucGFyZW50KTtcbiAgICAgIC8vIHJlZ2V4IG1hdGNoZXMgYW55IHZhbGlkIGNvbXBvc2l0ZSBzdGF0ZSBuYW1lXG4gICAgICAvLyB3b3VsZCBtYXRjaCBcImNvbnRhY3QubGlzdFwiIGJ1dCBub3QgXCJjb250YWN0c1wiXG4gICAgICB2YXIgY29tcG9zaXRlTmFtZSA9IC9eKC4rKVxcLlteLl0rJC8uZXhlYyhzdGF0ZS5uYW1lKTtcbiAgICAgIHJldHVybiBjb21wb3NpdGVOYW1lID8gZmluZFN0YXRlKGNvbXBvc2l0ZU5hbWVbMV0pIDogcm9vdDtcbiAgICB9LFxuXG4gICAgLy8gaW5oZXJpdCAnZGF0YScgZnJvbSBwYXJlbnQgYW5kIG92ZXJyaWRlIGJ5IG93biB2YWx1ZXMgKGlmIGFueSlcbiAgICBkYXRhOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlLnBhcmVudCAmJiBzdGF0ZS5wYXJlbnQuZGF0YSkge1xuICAgICAgICBzdGF0ZS5kYXRhID0gc3RhdGUuc2VsZi5kYXRhID0gaW5oZXJpdChzdGF0ZS5wYXJlbnQuZGF0YSwgc3RhdGUuZGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUuZGF0YTtcbiAgICB9LFxuXG4gICAgLy8gQnVpbGQgYSBVUkxNYXRjaGVyIGlmIG5lY2Vzc2FyeSwgZWl0aGVyIHZpYSBhIHJlbGF0aXZlIG9yIGFic29sdXRlIFVSTFxuICAgIHVybDogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciB1cmwgPSBzdGF0ZS51cmwsIGNvbmZpZyA9IHsgcGFyYW1zOiBzdGF0ZS5wYXJhbXMgfHwge30gfTtcblxuICAgICAgaWYgKGlzU3RyaW5nKHVybCkpIHtcbiAgICAgICAgaWYgKHVybC5jaGFyQXQoMCkgPT0gJ14nKSByZXR1cm4gJHVybE1hdGNoZXJGYWN0b3J5LmNvbXBpbGUodXJsLnN1YnN0cmluZygxKSwgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIChzdGF0ZS5wYXJlbnQubmF2aWdhYmxlIHx8IHJvb3QpLnVybC5jb25jYXQodXJsLCBjb25maWcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXVybCB8fCAkdXJsTWF0Y2hlckZhY3RvcnkuaXNNYXRjaGVyKHVybCkpIHJldHVybiB1cmw7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHVybCAnXCIgKyB1cmwgKyBcIicgaW4gc3RhdGUgJ1wiICsgc3RhdGUgKyBcIidcIik7XG4gICAgfSxcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igc3RhdGUgdGhhdCBoYXMgYSBVUkwgKGkuZS4gaXMgbmF2aWdhYmxlKVxuICAgIG5hdmlnYWJsZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS51cmwgPyBzdGF0ZSA6IChzdGF0ZS5wYXJlbnQgPyBzdGF0ZS5wYXJlbnQubmF2aWdhYmxlIDogbnVsbCk7XG4gICAgfSxcblxuICAgIC8vIE93biBwYXJhbWV0ZXJzIGZvciB0aGlzIHN0YXRlLiBzdGF0ZS51cmwucGFyYW1zIGlzIGFscmVhZHkgYnVpbHQgYXQgdGhpcyBwb2ludC4gQ3JlYXRlIGFuZCBhZGQgbm9uLXVybCBwYXJhbXNcbiAgICBvd25QYXJhbXM6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICB2YXIgcGFyYW1zID0gc3RhdGUudXJsICYmIHN0YXRlLnVybC5wYXJhbXMgfHwgbmV3ICQkVU1GUC5QYXJhbVNldCgpO1xuICAgICAgZm9yRWFjaChzdGF0ZS5wYXJhbXMgfHwge30sIGZ1bmN0aW9uKGNvbmZpZywgaWQpIHtcbiAgICAgICAgaWYgKCFwYXJhbXNbaWRdKSBwYXJhbXNbaWRdID0gbmV3ICQkVU1GUC5QYXJhbShpZCwgbnVsbCwgY29uZmlnLCBcImNvbmZpZ1wiKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG4gICAgLy8gRGVyaXZlIHBhcmFtZXRlcnMgZm9yIHRoaXMgc3RhdGUgYW5kIGVuc3VyZSB0aGV5J3JlIGEgc3VwZXItc2V0IG9mIHBhcmVudCdzIHBhcmFtZXRlcnNcbiAgICBwYXJhbXM6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICB2YXIgb3duUGFyYW1zID0gcGljayhzdGF0ZS5vd25QYXJhbXMsIHN0YXRlLm93blBhcmFtcy4kJGtleXMoKSk7XG4gICAgICByZXR1cm4gc3RhdGUucGFyZW50ICYmIHN0YXRlLnBhcmVudC5wYXJhbXMgPyBleHRlbmQoc3RhdGUucGFyZW50LnBhcmFtcy4kJG5ldygpLCBvd25QYXJhbXMpIDogbmV3ICQkVU1GUC5QYXJhbVNldCgpO1xuICAgIH0sXG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBleHBsaWNpdCBtdWx0aS12aWV3IGNvbmZpZ3VyYXRpb24sIG1ha2Ugb25lIHVwIHNvIHdlIGRvbid0IGhhdmVcbiAgICAvLyB0byBoYW5kbGUgYm90aCBjYXNlcyBpbiB0aGUgdmlldyBkaXJlY3RpdmUgbGF0ZXIuIE5vdGUgdGhhdCBoYXZpbmcgYW4gZXhwbGljaXRcbiAgICAvLyAndmlld3MnIHByb3BlcnR5IHdpbGwgbWVhbiB0aGUgZGVmYXVsdCB1bm5hbWVkIHZpZXcgcHJvcGVydGllcyBhcmUgaWdub3JlZC4gVGhpc1xuICAgIC8vIGlzIGFsc28gYSBnb29kIHRpbWUgdG8gcmVzb2x2ZSB2aWV3IG5hbWVzIHRvIGFic29sdXRlIG5hbWVzLCBzbyBldmVyeXRoaW5nIGlzIGFcbiAgICAvLyBzdHJhaWdodCBsb29rdXAgYXQgbGluayB0aW1lLlxuICAgIHZpZXdzOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgdmFyIHZpZXdzID0ge307XG5cbiAgICAgIGZvckVhY2goaXNEZWZpbmVkKHN0YXRlLnZpZXdzKSA/IHN0YXRlLnZpZXdzIDogeyAnJzogc3RhdGUgfSwgZnVuY3Rpb24gKHZpZXcsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignQCcpIDwgMCkgbmFtZSArPSAnQCcgKyBzdGF0ZS5wYXJlbnQubmFtZTtcbiAgICAgICAgdmlld3NbbmFtZV0gPSB2aWV3O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmlld3M7XG4gICAgfSxcblxuICAgIC8vIEtlZXAgYSBmdWxsIHBhdGggZnJvbSB0aGUgcm9vdCBkb3duIHRvIHRoaXMgc3RhdGUgYXMgdGhpcyBpcyBuZWVkZWQgZm9yIHN0YXRlIGFjdGl2YXRpb24uXG4gICAgcGF0aDogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5wYXJlbnQgPyBzdGF0ZS5wYXJlbnQucGF0aC5jb25jYXQoc3RhdGUpIDogW107IC8vIGV4Y2x1ZGUgcm9vdCBmcm9tIHBhdGhcbiAgICB9LFxuXG4gICAgLy8gU3BlZWQgdXAgJHN0YXRlLmNvbnRhaW5zKCkgYXMgaXQncyB1c2VkIGEgbG90XG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICB2YXIgaW5jbHVkZXMgPSBzdGF0ZS5wYXJlbnQgPyBleHRlbmQoe30sIHN0YXRlLnBhcmVudC5pbmNsdWRlcykgOiB7fTtcbiAgICAgIGluY2x1ZGVzW3N0YXRlLm5hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBpbmNsdWRlcztcbiAgICB9LFxuXG4gICAgJGRlbGVnYXRlczoge31cbiAgfTtcblxuICBmdW5jdGlvbiBpc1JlbGF0aXZlKHN0YXRlTmFtZSkge1xuICAgIHJldHVybiBzdGF0ZU5hbWUuaW5kZXhPZihcIi5cIikgPT09IDAgfHwgc3RhdGVOYW1lLmluZGV4T2YoXCJeXCIpID09PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFN0YXRlKHN0YXRlT3JOYW1lLCBiYXNlKSB7XG4gICAgaWYgKCFzdGF0ZU9yTmFtZSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIHZhciBpc1N0ciA9IGlzU3RyaW5nKHN0YXRlT3JOYW1lKSxcbiAgICAgICAgbmFtZSAgPSBpc1N0ciA/IHN0YXRlT3JOYW1lIDogc3RhdGVPck5hbWUubmFtZSxcbiAgICAgICAgcGF0aCAgPSBpc1JlbGF0aXZlKG5hbWUpO1xuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGlmICghYmFzZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVmZXJlbmNlIHBvaW50IGdpdmVuIGZvciBwYXRoICdcIiAgKyBuYW1lICsgXCInXCIpO1xuICAgICAgYmFzZSA9IGZpbmRTdGF0ZShiYXNlKTtcbiAgICAgIFxuICAgICAgdmFyIHJlbCA9IG5hbWUuc3BsaXQoXCIuXCIpLCBpID0gMCwgcGF0aExlbmd0aCA9IHJlbC5sZW5ndGgsIGN1cnJlbnQgPSBiYXNlO1xuXG4gICAgICBmb3IgKDsgaSA8IHBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVsW2ldID09PSBcIlwiICYmIGkgPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50ID0gYmFzZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsW2ldID09PSBcIl5cIikge1xuICAgICAgICAgIGlmICghY3VycmVudC5wYXJlbnQpIHRocm93IG5ldyBFcnJvcihcIlBhdGggJ1wiICsgbmFtZSArIFwiJyBub3QgdmFsaWQgZm9yIHN0YXRlICdcIiArIGJhc2UubmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZWwgPSByZWwuc2xpY2UoaSkuam9pbihcIi5cIik7XG4gICAgICBuYW1lID0gY3VycmVudC5uYW1lICsgKGN1cnJlbnQubmFtZSAmJiByZWwgPyBcIi5cIiA6IFwiXCIpICsgcmVsO1xuICAgIH1cbiAgICB2YXIgc3RhdGUgPSBzdGF0ZXNbbmFtZV07XG5cbiAgICBpZiAoc3RhdGUgJiYgKGlzU3RyIHx8ICghaXNTdHIgJiYgKHN0YXRlID09PSBzdGF0ZU9yTmFtZSB8fCBzdGF0ZS5zZWxmID09PSBzdGF0ZU9yTmFtZSkpKSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVldWVTdGF0ZShwYXJlbnROYW1lLCBzdGF0ZSkge1xuICAgIGlmICghcXVldWVbcGFyZW50TmFtZV0pIHtcbiAgICAgIHF1ZXVlW3BhcmVudE5hbWVdID0gW107XG4gICAgfVxuICAgIHF1ZXVlW3BhcmVudE5hbWVdLnB1c2goc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hRdWV1ZWRDaGlsZHJlbihwYXJlbnROYW1lKSB7XG4gICAgdmFyIHF1ZXVlZCA9IHF1ZXVlW3BhcmVudE5hbWVdIHx8IFtdO1xuICAgIHdoaWxlKHF1ZXVlZC5sZW5ndGgpIHtcbiAgICAgIHJlZ2lzdGVyU3RhdGUocXVldWVkLnNoaWZ0KCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyU3RhdGUoc3RhdGUpIHtcbiAgICAvLyBXcmFwIGEgbmV3IG9iamVjdCBhcm91bmQgdGhlIHN0YXRlIHNvIHdlIGNhbiBzdG9yZSBvdXIgcHJpdmF0ZSBkZXRhaWxzIGVhc2lseS5cbiAgICBzdGF0ZSA9IGluaGVyaXQoc3RhdGUsIHtcbiAgICAgIHNlbGY6IHN0YXRlLFxuICAgICAgcmVzb2x2ZTogc3RhdGUucmVzb2x2ZSB8fCB7fSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubmFtZTsgfVxuICAgIH0pO1xuXG4gICAgdmFyIG5hbWUgPSBzdGF0ZS5uYW1lO1xuICAgIGlmICghaXNTdHJpbmcobmFtZSkgfHwgbmFtZS5pbmRleE9mKCdAJykgPj0gMCkgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgbXVzdCBoYXZlIGEgdmFsaWQgbmFtZVwiKTtcbiAgICBpZiAoc3RhdGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSAnXCIgKyBuYW1lICsgXCInIGlzIGFscmVhZHkgZGVmaW5lZFwiKTtcblxuICAgIC8vIEdldCBwYXJlbnQgbmFtZVxuICAgIHZhciBwYXJlbnROYW1lID0gKG5hbWUuaW5kZXhPZignLicpICE9PSAtMSkgPyBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxhc3RJbmRleE9mKCcuJykpXG4gICAgICAgIDogKGlzU3RyaW5nKHN0YXRlLnBhcmVudCkpID8gc3RhdGUucGFyZW50XG4gICAgICAgIDogKGlzT2JqZWN0KHN0YXRlLnBhcmVudCkgJiYgaXNTdHJpbmcoc3RhdGUucGFyZW50Lm5hbWUpKSA/IHN0YXRlLnBhcmVudC5uYW1lXG4gICAgICAgIDogJyc7XG5cbiAgICAvLyBJZiBwYXJlbnQgaXMgbm90IHJlZ2lzdGVyZWQgeWV0LCBhZGQgc3RhdGUgdG8gcXVldWUgYW5kIHJlZ2lzdGVyIGxhdGVyXG4gICAgaWYgKHBhcmVudE5hbWUgJiYgIXN0YXRlc1twYXJlbnROYW1lXSkge1xuICAgICAgcmV0dXJuIHF1ZXVlU3RhdGUocGFyZW50TmFtZSwgc3RhdGUuc2VsZik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIga2V5IGluIHN0YXRlQnVpbGRlcikge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oc3RhdGVCdWlsZGVyW2tleV0pKSBzdGF0ZVtrZXldID0gc3RhdGVCdWlsZGVyW2tleV0oc3RhdGUsIHN0YXRlQnVpbGRlci4kZGVsZWdhdGVzW2tleV0pO1xuICAgIH1cbiAgICBzdGF0ZXNbbmFtZV0gPSBzdGF0ZTtcblxuICAgIC8vIFJlZ2lzdGVyIHRoZSBzdGF0ZSBpbiB0aGUgZ2xvYmFsIHN0YXRlIGxpc3QgYW5kIHdpdGggJHVybFJvdXRlciBpZiBuZWNlc3NhcnkuXG4gICAgaWYgKCFzdGF0ZVthYnN0cmFjdEtleV0gJiYgc3RhdGUudXJsKSB7XG4gICAgICAkdXJsUm91dGVyUHJvdmlkZXIud2hlbihzdGF0ZS51cmwsIFsnJG1hdGNoJywgJyRzdGF0ZVBhcmFtcycsIGZ1bmN0aW9uICgkbWF0Y2gsICRzdGF0ZVBhcmFtcykge1xuICAgICAgICBpZiAoJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZSAhPSBzdGF0ZSB8fCAhZXF1YWxGb3JLZXlzKCRtYXRjaCwgJHN0YXRlUGFyYW1zKSkge1xuICAgICAgICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oc3RhdGUsICRtYXRjaCwgeyBpbmhlcml0OiB0cnVlLCBsb2NhdGlvbjogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBhbnkgcXVldWVkIGNoaWxkcmVuXG4gICAgZmx1c2hRdWV1ZWRDaGlsZHJlbihuYW1lKTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8vIENoZWNrcyB0ZXh0IHRvIHNlZSBpZiBpdCBsb29rcyBsaWtlIGEgZ2xvYi5cbiAgZnVuY3Rpb24gaXNHbG9iICh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQuaW5kZXhPZignKicpID4gLTE7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRydWUgaWYgZ2xvYiBtYXRjaGVzIGN1cnJlbnQgJHN0YXRlIG5hbWUuXG4gIGZ1bmN0aW9uIGRvZXNTdGF0ZU1hdGNoR2xvYiAoZ2xvYikge1xuICAgIHZhciBnbG9iU2VnbWVudHMgPSBnbG9iLnNwbGl0KCcuJyksXG4gICAgICAgIHNlZ21lbnRzID0gJHN0YXRlLiRjdXJyZW50Lm5hbWUuc3BsaXQoJy4nKTtcblxuICAgIC8vbWF0Y2ggc2luZ2xlIHN0YXJzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBnbG9iU2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoZ2xvYlNlZ21lbnRzW2ldID09PSAnKicpIHtcbiAgICAgICAgc2VnbWVudHNbaV0gPSAnKic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9tYXRjaCBncmVlZHkgc3RhcnRzXG4gICAgaWYgKGdsb2JTZWdtZW50c1swXSA9PT0gJyoqJykge1xuICAgICAgIHNlZ21lbnRzID0gc2VnbWVudHMuc2xpY2UoaW5kZXhPZihzZWdtZW50cywgZ2xvYlNlZ21lbnRzWzFdKSk7XG4gICAgICAgc2VnbWVudHMudW5zaGlmdCgnKionKTtcbiAgICB9XG4gICAgLy9tYXRjaCBncmVlZHkgZW5kc1xuICAgIGlmIChnbG9iU2VnbWVudHNbZ2xvYlNlZ21lbnRzLmxlbmd0aCAtIDFdID09PSAnKionKSB7XG4gICAgICAgc2VnbWVudHMuc3BsaWNlKGluZGV4T2Yoc2VnbWVudHMsIGdsb2JTZWdtZW50c1tnbG9iU2VnbWVudHMubGVuZ3RoIC0gMl0pICsgMSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgc2VnbWVudHMucHVzaCgnKionKTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYlNlZ21lbnRzLmxlbmd0aCAhPSBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VnbWVudHMuam9pbignJykgPT09IGdsb2JTZWdtZW50cy5qb2luKCcnKTtcbiAgfVxuXG5cbiAgLy8gSW1wbGljaXQgcm9vdCBzdGF0ZSB0aGF0IGlzIGFsd2F5cyBhY3RpdmVcbiAgcm9vdCA9IHJlZ2lzdGVyU3RhdGUoe1xuICAgIG5hbWU6ICcnLFxuICAgIHVybDogJ14nLFxuICAgIHZpZXdzOiBudWxsLFxuICAgICdhYnN0cmFjdCc6IHRydWVcbiAgfSk7XG4gIHJvb3QubmF2aWdhYmxlID0gbnVsbDtcblxuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVByb3ZpZGVyI2RlY29yYXRvclxuICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBbGxvd3MgeW91IHRvIGV4dGVuZCAoY2FyZWZ1bGx5KSBvciBvdmVycmlkZSAoYXQgeW91ciBvd24gcGVyaWwpIHRoZSBcbiAgICogYHN0YXRlQnVpbGRlcmAgb2JqZWN0IHVzZWQgaW50ZXJuYWxseSBieSBgJHN0YXRlUHJvdmlkZXJgLiBUaGlzIGNhbiBiZSB1c2VkIFxuICAgKiB0byBhZGQgY3VzdG9tIGZ1bmN0aW9uYWxpdHkgdG8gdWktcm91dGVyLCBmb3IgZXhhbXBsZSBpbmZlcnJpbmcgdGVtcGxhdGVVcmwgXG4gICAqIGJhc2VkIG9uIHRoZSBzdGF0ZSBuYW1lLlxuICAgKlxuICAgKiBXaGVuIHBhc3Npbmcgb25seSBhIG5hbWUsIGl0IHJldHVybnMgdGhlIGN1cnJlbnQgKG9yaWdpbmFsIG9yIGRlY29yYXRlZCkgYnVpbGRlclxuICAgKiBmdW5jdGlvbiB0aGF0IG1hdGNoZXMgYG5hbWVgLlxuICAgKlxuICAgKiBUaGUgYnVpbGRlciBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgZGVjb3JhdGVkIGFyZSBsaXN0ZWQgYmVsb3cuIFRob3VnaCBub3QgYWxsXG4gICAqIG5lY2Vzc2FyaWx5IGhhdmUgYSBnb29kIHVzZSBjYXNlIGZvciBkZWNvcmF0aW9uLCB0aGF0IGlzIHVwIHRvIHlvdSB0byBkZWNpZGUuXG4gICAqXG4gICAqIEluIGFkZGl0aW9uLCB1c2VycyBjYW4gYXR0YWNoIGN1c3RvbSBkZWNvcmF0b3JzLCB3aGljaCB3aWxsIGdlbmVyYXRlIG5ldyBcbiAgICogcHJvcGVydGllcyB3aXRoaW4gdGhlIHN0YXRlJ3MgaW50ZXJuYWwgZGVmaW5pdGlvbi4gVGhlcmUgaXMgY3VycmVudGx5IG5vIGNsZWFyIFxuICAgKiB1c2UtY2FzZSBmb3IgdGhpcyBiZXlvbmQgYWNjZXNzaW5nIGludGVybmFsIHN0YXRlcyAoaS5lLiAkc3RhdGUuJGN1cnJlbnQpLCBcbiAgICogaG93ZXZlciwgZXhwZWN0IHRoaXMgdG8gYmVjb21lIGluY3JlYXNpbmdseSByZWxldmFudCBhcyB3ZSBpbnRyb2R1Y2UgYWRkaXRpb25hbCBcbiAgICogbWV0YS1wcm9ncmFtbWluZyBmZWF0dXJlcy5cbiAgICpcbiAgICogKipXYXJuaW5nKio6IERlY29yYXRvcnMgc2hvdWxkIG5vdCBiZSBpbnRlcmRlcGVuZGVudCBiZWNhdXNlIHRoZSBvcmRlciBvZiBcbiAgICogZXhlY3V0aW9uIG9mIHRoZSBidWlsZGVyIGZ1bmN0aW9ucyBpbiBub24tZGV0ZXJtaW5pc3RpYy4gQnVpbGRlciBmdW5jdGlvbnMgXG4gICAqIHNob3VsZCBvbmx5IGJlIGRlcGVuZGVudCBvbiB0aGUgc3RhdGUgZGVmaW5pdGlvbiBvYmplY3QgYW5kIHN1cGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKlxuICAgKiBFeGlzdGluZyBidWlsZGVyIGZ1bmN0aW9ucyBhbmQgY3VycmVudCByZXR1cm4gdmFsdWVzOlxuICAgKlxuICAgKiAtICoqcGFyZW50KiogYHtvYmplY3R9YCAtIHJldHVybnMgdGhlIHBhcmVudCBzdGF0ZSBvYmplY3QuXG4gICAqIC0gKipkYXRhKiogYHtvYmplY3R9YCAtIHJldHVybnMgc3RhdGUgZGF0YSwgaW5jbHVkaW5nIGFueSBpbmhlcml0ZWQgZGF0YSB0aGF0IGlzIG5vdFxuICAgKiAgIG92ZXJyaWRkZW4gYnkgb3duIHZhbHVlcyAoaWYgYW55KS5cbiAgICogLSAqKnVybCoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGEge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciBVcmxNYXRjaGVyfVxuICAgKiAgIG9yIGBudWxsYC5cbiAgICogLSAqKm5hdmlnYWJsZSoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGNsb3Nlc3QgYW5jZXN0b3Igc3RhdGUgdGhhdCBoYXMgYSBVUkwgKGFrYSBpcyBcbiAgICogICBuYXZpZ2FibGUpLlxuICAgKiAtICoqcGFyYW1zKiogYHtvYmplY3R9YCAtIHJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGUgcGFyYW1zIHRoYXQgYXJlIGVuc3VyZWQgdG8gXG4gICAqICAgYmUgYSBzdXBlci1zZXQgb2YgcGFyZW50J3MgcGFyYW1zLlxuICAgKiAtICoqdmlld3MqKiBge29iamVjdH1gIC0gcmV0dXJucyBhIHZpZXdzIG9iamVjdCB3aGVyZSBlYWNoIGtleSBpcyBhbiBhYnNvbHV0ZSB2aWV3IFxuICAgKiAgIG5hbWUgKGkuZS4gXCJ2aWV3TmFtZUBzdGF0ZU5hbWVcIikgYW5kIGVhY2ggdmFsdWUgaXMgdGhlIGNvbmZpZyBvYmplY3QgXG4gICAqICAgKHRlbXBsYXRlLCBjb250cm9sbGVyKSBmb3IgdGhlIHZpZXcuIEV2ZW4gd2hlbiB5b3UgZG9uJ3QgdXNlIHRoZSB2aWV3cyBvYmplY3QgXG4gICAqICAgZXhwbGljaXRseSBvbiBhIHN0YXRlIGNvbmZpZywgb25lIGlzIHN0aWxsIGNyZWF0ZWQgZm9yIHlvdSBpbnRlcm5hbGx5LlxuICAgKiAgIFNvIGJ5IGRlY29yYXRpbmcgdGhpcyBidWlsZGVyIGZ1bmN0aW9uIHlvdSBoYXZlIGFjY2VzcyB0byBkZWNvcmF0aW5nIHRlbXBsYXRlIFxuICAgKiAgIGFuZCBjb250cm9sbGVyIHByb3BlcnRpZXMuXG4gICAqIC0gKipvd25QYXJhbXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBhcnJheSBvZiBwYXJhbXMgdGhhdCBiZWxvbmcgdG8gdGhlIHN0YXRlLCBcbiAgICogICBub3QgaW5jbHVkaW5nIGFueSBwYXJhbXMgZGVmaW5lZCBieSBhbmNlc3RvciBzdGF0ZXMuXG4gICAqIC0gKipwYXRoKiogYHtzdHJpbmd9YCAtIHJldHVybnMgdGhlIGZ1bGwgcGF0aCBmcm9tIHRoZSByb290IGRvd24gdG8gdGhpcyBzdGF0ZS4gXG4gICAqICAgTmVlZGVkIGZvciBzdGF0ZSBhY3RpdmF0aW9uLlxuICAgKiAtICoqaW5jbHVkZXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBvYmplY3QgdGhhdCBpbmNsdWRlcyBldmVyeSBzdGF0ZSB0aGF0IFxuICAgKiAgIHdvdWxkIHBhc3MgYSBgJHN0YXRlLmluY2x1ZGVzKClgIHRlc3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxwcmU+XG4gICAqIC8vIE92ZXJyaWRlIHRoZSBpbnRlcm5hbCAndmlld3MnIGJ1aWxkZXIgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHN0YXRlXG4gICAqIC8vIGRlZmluaXRpb24sIGFuZCBhIHJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgZnVuY3Rpb24gYmVpbmcgb3ZlcnJpZGRlbjpcbiAgICogJHN0YXRlUHJvdmlkZXIuZGVjb3JhdG9yKCd2aWV3cycsIGZ1bmN0aW9uIChzdGF0ZSwgcGFyZW50KSB7XG4gICAqICAgdmFyIHJlc3VsdCA9IHt9LFxuICAgKiAgICAgICB2aWV3cyA9IHBhcmVudChzdGF0ZSk7XG4gICAqXG4gICAqICAgYW5ndWxhci5mb3JFYWNoKHZpZXdzLCBmdW5jdGlvbiAoY29uZmlnLCBuYW1lKSB7XG4gICAqICAgICB2YXIgYXV0b05hbWUgPSAoc3RhdGUubmFtZSArICcuJyArIG5hbWUpLnJlcGxhY2UoJy4nLCAnLycpO1xuICAgKiAgICAgY29uZmlnLnRlbXBsYXRlVXJsID0gY29uZmlnLnRlbXBsYXRlVXJsIHx8ICcvcGFydGlhbHMvJyArIGF1dG9OYW1lICsgJy5odG1sJztcbiAgICogICAgIHJlc3VsdFtuYW1lXSA9IGNvbmZpZztcbiAgICogICB9KTtcbiAgICogICByZXR1cm4gcmVzdWx0O1xuICAgKiB9KTtcbiAgICpcbiAgICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoJ2hvbWUnLCB7XG4gICAqICAgdmlld3M6IHtcbiAgICogICAgICdjb250YWN0Lmxpc3QnOiB7IGNvbnRyb2xsZXI6ICdMaXN0Q29udHJvbGxlcicgfSxcbiAgICogICAgICdjb250YWN0Lml0ZW0nOiB7IGNvbnRyb2xsZXI6ICdJdGVtQ29udHJvbGxlcicgfVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIC8vIC4uLlxuICAgKlxuICAgKiAkc3RhdGUuZ28oJ2hvbWUnKTtcbiAgICogLy8gQXV0by1wb3B1bGF0ZXMgbGlzdCBhbmQgaXRlbSB2aWV3cyB3aXRoIC9wYXJ0aWFscy9ob21lL2NvbnRhY3QvbGlzdC5odG1sLFxuICAgKiAvLyBhbmQgL3BhcnRpYWxzL2hvbWUvY29udGFjdC9pdGVtLmh0bWwsIHJlc3BlY3RpdmVseS5cbiAgICogPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBidWlsZGVyIGZ1bmN0aW9uIHRvIGRlY29yYXRlLiBcbiAgICogQHBhcmFtIHtvYmplY3R9IGZ1bmMgQSBmdW5jdGlvbiB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBkZWNvcmF0aW5nIHRoZSBvcmlnaW5hbCBcbiAgICogYnVpbGRlciBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgIC0gYHtvYmplY3R9YCAtIHN0YXRlIC0gVGhlIHN0YXRlIGNvbmZpZyBvYmplY3QuXG4gICAqICAgLSBge29iamVjdH1gIC0gc3VwZXIgLSBUaGUgb3JpZ2luYWwgYnVpbGRlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSAkc3RhdGVQcm92aWRlciAtICRzdGF0ZVByb3ZpZGVyIGluc3RhbmNlXG4gICAqL1xuICB0aGlzLmRlY29yYXRvciA9IGRlY29yYXRvcjtcbiAgZnVuY3Rpb24gZGVjb3JhdG9yKG5hbWUsIGZ1bmMpIHtcbiAgICAvKmpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgICBpZiAoaXNTdHJpbmcobmFtZSkgJiYgIWlzRGVmaW5lZChmdW5jKSkge1xuICAgICAgcmV0dXJuIHN0YXRlQnVpbGRlcltuYW1lXTtcbiAgICB9XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpIHx8ICFpc1N0cmluZyhuYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChzdGF0ZUJ1aWxkZXJbbmFtZV0gJiYgIXN0YXRlQnVpbGRlci4kZGVsZWdhdGVzW25hbWVdKSB7XG4gICAgICBzdGF0ZUJ1aWxkZXIuJGRlbGVnYXRlc1tuYW1lXSA9IHN0YXRlQnVpbGRlcltuYW1lXTtcbiAgICB9XG4gICAgc3RhdGVCdWlsZGVyW25hbWVdID0gZnVuYztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVByb3ZpZGVyI3N0YXRlXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlUHJvdmlkZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJlZ2lzdGVycyBhIHN0YXRlIGNvbmZpZ3VyYXRpb24gdW5kZXIgYSBnaXZlbiBzdGF0ZSBuYW1lLiBUaGUgc3RhdGVDb25maWcgb2JqZWN0XG4gICAqIGhhcyB0aGUgZm9sbG93aW5nIGFjY2VwdGFibGUgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSB1bmlxdWUgc3RhdGUgbmFtZSwgZS5nLiBcImhvbWVcIiwgXCJhYm91dFwiLCBcImNvbnRhY3RzXCIuXG4gICAqIFRvIGNyZWF0ZSBhIHBhcmVudC9jaGlsZCBzdGF0ZSB1c2UgYSBkb3QsIGUuZy4gXCJhYm91dC5zYWxlc1wiLCBcImhvbWUubmV3ZXN0XCIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZUNvbmZpZyBTdGF0ZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb249fSBzdGF0ZUNvbmZpZy50ZW1wbGF0ZVxuICAgKiA8YSBpZD0ndGVtcGxhdGUnPjwvYT5cbiAgICogICBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAqICAgYW4gaHRtbCB0ZW1wbGF0ZSBhcyBhIHN0cmluZyB3aGljaCBzaG91bGQgYmUgdXNlZCBieSB0aGUgdWlWaWV3IGRpcmVjdGl2ZXMuIFRoaXMgcHJvcGVydHkgXG4gICAqICAgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRlbXBsYXRlVXJsLlxuICAgKiAgIFxuICAgKiAgIElmIGB0ZW1wbGF0ZWAgaXMgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAqXG4gICAqICAgLSB7YXJyYXkuJmx0O29iamVjdCZndDt9IC0gc3RhdGUgcGFyYW1ldGVycyBleHRyYWN0ZWQgZnJvbSB0aGUgY3VycmVudCAkbG9jYXRpb24ucGF0aCgpIGJ5XG4gICAqICAgICBhcHBseWluZyB0aGUgY3VycmVudCBzdGF0ZVxuICAgKlxuICAgKiA8cHJlPnRlbXBsYXRlOlxuICAgKiAgIFwiPGgxPmlubGluZSB0ZW1wbGF0ZSBkZWZpbml0aW9uPC9oMT5cIiArXG4gICAqICAgXCI8ZGl2IHVpLXZpZXc+PC9kaXY+XCI8L3ByZT5cbiAgICogPHByZT50ZW1wbGF0ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAqICAgICAgIHJldHVybiBcIjxoMT5nZW5lcmF0ZWQgdGVtcGxhdGU8L2gxPlwiOyB9PC9wcmU+XG4gICAqIDwvZGl2PlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbj19IHN0YXRlQ29uZmlnLnRlbXBsYXRlVXJsXG4gICAqIDxhIGlkPSd0ZW1wbGF0ZVVybCc+PC9hPlxuICAgKlxuICAgKiAgIHBhdGggb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcGF0aCB0byBhbiBodG1sXG4gICAqICAgdGVtcGxhdGUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSB1aVZpZXcuXG4gICAqICAgXG4gICAqICAgSWYgYHRlbXBsYXRlVXJsYCBpcyBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICpcbiAgICogICAtIHthcnJheS4mbHQ7b2JqZWN0Jmd0O30gLSBzdGF0ZSBwYXJhbWV0ZXJzIGV4dHJhY3RlZCBmcm9tIHRoZSBjdXJyZW50ICRsb2NhdGlvbi5wYXRoKCkgYnkgXG4gICAqICAgICBhcHBseWluZyB0aGUgY3VycmVudCBzdGF0ZVxuICAgKlxuICAgKiA8cHJlPnRlbXBsYXRlVXJsOiBcImhvbWUuaHRtbFwiPC9wcmU+XG4gICAqIDxwcmU+dGVtcGxhdGVVcmw6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgKiAgICAgcmV0dXJuIG15VGVtcGxhdGVzW3BhcmFtcy5wYWdlSWRdOyB9PC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBzdGF0ZUNvbmZpZy50ZW1wbGF0ZVByb3ZpZGVyXG4gICAqIDxhIGlkPSd0ZW1wbGF0ZVByb3ZpZGVyJz48L2E+XG4gICAqICAgIFByb3ZpZGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBIVE1MIGNvbnRlbnQgc3RyaW5nLlxuICAgKiA8cHJlPiB0ZW1wbGF0ZVByb3ZpZGVyOlxuICAgKiAgICAgICBmdW5jdGlvbihNeVRlbXBsYXRlU2VydmljZSwgcGFyYW1zKSB7XG4gICAqICAgICAgICAgcmV0dXJuIE15VGVtcGxhdGVTZXJ2aWNlLmdldFRlbXBsYXRlKHBhcmFtcy5wYWdlSWQpO1xuICAgKiAgICAgICB9PC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9uPX0gc3RhdGVDb25maWcuY29udHJvbGxlclxuICAgKiA8YSBpZD0nY29udHJvbGxlcic+PC9hPlxuICAgKlxuICAgKiAgQ29udHJvbGxlciBmbiB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggbmV3bHlcbiAgICogICByZWxhdGVkIHNjb3BlIG9yIHRoZSBuYW1lIG9mIGEgcmVnaXN0ZXJlZCBjb250cm9sbGVyIGlmIHBhc3NlZCBhcyBhIHN0cmluZy5cbiAgICogICBPcHRpb25hbGx5LCB0aGUgQ29udHJvbGxlckFzIG1heSBiZSBkZWNsYXJlZCBoZXJlLlxuICAgKiA8cHJlPmNvbnRyb2xsZXI6IFwiTXlSZWdpc3RlcmVkQ29udHJvbGxlclwiPC9wcmU+XG4gICAqIDxwcmU+Y29udHJvbGxlcjpcbiAgICogICAgIFwiTXlSZWdpc3RlcmVkQ29udHJvbGxlciBhcyBmb29DdHJsXCJ9PC9wcmU+XG4gICAqIDxwcmU+Y29udHJvbGxlcjogZnVuY3Rpb24oJHNjb3BlLCBNeVNlcnZpY2UpIHtcbiAgICogICAgICRzY29wZS5kYXRhID0gTXlTZXJ2aWNlLmdldERhdGEoKTsgfTwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gc3RhdGVDb25maWcuY29udHJvbGxlclByb3ZpZGVyXG4gICAqIDxhIGlkPSdjb250cm9sbGVyUHJvdmlkZXInPjwvYT5cbiAgICpcbiAgICogSW5qZWN0YWJsZSBwcm92aWRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGFjdHVhbCBjb250cm9sbGVyIG9yIHN0cmluZy5cbiAgICogPHByZT5jb250cm9sbGVyUHJvdmlkZXI6XG4gICAqICAgZnVuY3Rpb24oTXlSZXNvbHZlRGF0YSkge1xuICAgKiAgICAgaWYgKE15UmVzb2x2ZURhdGEuZm9vKVxuICAgKiAgICAgICByZXR1cm4gXCJGb29DdHJsXCJcbiAgICogICAgIGVsc2UgaWYgKE15UmVzb2x2ZURhdGEuYmFyKVxuICAgKiAgICAgICByZXR1cm4gXCJCYXJDdHJsXCI7XG4gICAqICAgICBlbHNlIHJldHVybiBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICogICAgICAgJHNjb3BlLmJheiA9IFwiUXV4XCI7XG4gICAqICAgICB9XG4gICAqICAgfTwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHN0YXRlQ29uZmlnLmNvbnRyb2xsZXJBc1xuICAgKiA8YSBpZD0nY29udHJvbGxlckFzJz48L2E+XG4gICAqIFxuICAgKiBBIGNvbnRyb2xsZXIgYWxpYXMgbmFtZS4gSWYgcHJlc2VudCB0aGUgY29udHJvbGxlciB3aWxsIGJlXG4gICAqICAgcHVibGlzaGVkIHRvIHNjb3BlIHVuZGVyIHRoZSBjb250cm9sbGVyQXMgbmFtZS5cbiAgICogPHByZT5jb250cm9sbGVyQXM6IFwibXlDdHJsXCI8L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0PX0gc3RhdGVDb25maWcucGFyZW50XG4gICAqIDxhIGlkPSdwYXJlbnQnPjwvYT5cbiAgICogT3B0aW9uYWxseSBzcGVjaWZpZXMgdGhlIHBhcmVudCBzdGF0ZSBvZiB0aGlzIHN0YXRlLlxuICAgKlxuICAgKiA8cHJlPnBhcmVudDogJ3BhcmVudFN0YXRlJzwvcHJlPlxuICAgKiA8cHJlPnBhcmVudDogcGFyZW50U3RhdGUgLy8gSlMgdmFyaWFibGU8L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3Q9fSBzdGF0ZUNvbmZpZy5yZXNvbHZlXG4gICAqIDxhIGlkPSdyZXNvbHZlJz48L2E+XG4gICAqXG4gICAqIEFuIG9wdGlvbmFsIG1hcCZsdDtzdHJpbmcsIGZ1bmN0aW9uJmd0OyBvZiBkZXBlbmRlbmNpZXMgd2hpY2hcbiAgICogICBzaG91bGQgYmUgaW5qZWN0ZWQgaW50byB0aGUgY29udHJvbGxlci4gSWYgYW55IG9mIHRoZXNlIGRlcGVuZGVuY2llcyBhcmUgcHJvbWlzZXMsIFxuICAgKiAgIHRoZSByb3V0ZXIgd2lsbCB3YWl0IGZvciB0aGVtIGFsbCB0byBiZSByZXNvbHZlZCBiZWZvcmUgdGhlIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkLlxuICAgKiAgIElmIGFsbCB0aGUgcHJvbWlzZXMgYXJlIHJlc29sdmVkIHN1Y2Nlc3NmdWxseSwgdGhlICRzdGF0ZUNoYW5nZVN1Y2Nlc3MgZXZlbnQgaXMgZmlyZWRcbiAgICogICBhbmQgdGhlIHZhbHVlcyBvZiB0aGUgcmVzb2x2ZWQgcHJvbWlzZXMgYXJlIGluamVjdGVkIGludG8gYW55IGNvbnRyb2xsZXJzIHRoYXQgcmVmZXJlbmNlIHRoZW0uXG4gICAqICAgSWYgYW55ICBvZiB0aGUgcHJvbWlzZXMgYXJlIHJlamVjdGVkIHRoZSAkc3RhdGVDaGFuZ2VFcnJvciBldmVudCBpcyBmaXJlZC5cbiAgICpcbiAgICogICBUaGUgbWFwIG9iamVjdCBpczpcbiAgICogICBcbiAgICogICAtIGtleSAtIHtzdHJpbmd9OiBuYW1lIG9mIGRlcGVuZGVuY3kgdG8gYmUgaW5qZWN0ZWQgaW50byBjb250cm9sbGVyXG4gICAqICAgLSBmYWN0b3J5IC0ge3N0cmluZ3xmdW5jdGlvbn06IElmIHN0cmluZyB0aGVuIGl0IGlzIGFsaWFzIGZvciBzZXJ2aWNlLiBPdGhlcndpc2UgaWYgZnVuY3Rpb24sIFxuICAgKiAgICAgaXQgaXMgaW5qZWN0ZWQgYW5kIHJldHVybiB2YWx1ZSBpdCB0cmVhdGVkIGFzIGRlcGVuZGVuY3kuIElmIHJlc3VsdCBpcyBhIHByb21pc2UsIGl0IGlzIFxuICAgKiAgICAgcmVzb2x2ZWQgYmVmb3JlIGl0cyB2YWx1ZSBpcyBpbmplY3RlZCBpbnRvIGNvbnRyb2xsZXIuXG4gICAqXG4gICAqIDxwcmU+cmVzb2x2ZToge1xuICAgKiAgICAgbXlSZXNvbHZlMTpcbiAgICogICAgICAgZnVuY3Rpb24oJGh0dHAsICRzdGF0ZVBhcmFtcykge1xuICAgKiAgICAgICAgIHJldHVybiAkaHR0cC5nZXQoXCIvYXBpL2Zvb3MvXCIrc3RhdGVQYXJhbXMuZm9vSUQpO1xuICAgKiAgICAgICB9XG4gICAqICAgICB9PC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gc3RhdGVDb25maWcudXJsXG4gICAqIDxhIGlkPSd1cmwnPjwvYT5cbiAgICpcbiAgICogICBBIHVybCBmcmFnbWVudCB3aXRoIG9wdGlvbmFsIHBhcmFtZXRlcnMuIFdoZW4gYSBzdGF0ZSBpcyBuYXZpZ2F0ZWQgb3JcbiAgICogICB0cmFuc2l0aW9uZWQgdG8sIHRoZSBgJHN0YXRlUGFyYW1zYCBzZXJ2aWNlIHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggYW55IFxuICAgKiAgIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhc3NlZC5cbiAgICpcbiAgICogICAoU2VlIHtAbGluayB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIgVXJsTWF0Y2hlcn0gYFVybE1hdGNoZXJgfSBmb3JcbiAgICogICBtb3JlIGRldGFpbHMgb24gYWNjZXB0YWJsZSBwYXR0ZXJucyApXG4gICAqXG4gICAqIGV4YW1wbGVzOlxuICAgKiA8cHJlPnVybDogXCIvaG9tZVwiXG4gICAqIHVybDogXCIvdXNlcnMvOnVzZXJpZFwiXG4gICAqIHVybDogXCIvYm9va3Mve2Jvb2tpZDpbYS16QS1aXy1dfVwiXG4gICAqIHVybDogXCIvYm9va3Mve2NhdGVnb3J5aWQ6aW50fVwiXG4gICAqIHVybDogXCIvYm9va3Mve3B1Ymxpc2hlcm5hbWU6c3RyaW5nfS97Y2F0ZWdvcnlpZDppbnR9XCJcbiAgICogdXJsOiBcIi9tZXNzYWdlcz9iZWZvcmUmYWZ0ZXJcIlxuICAgKiB1cmw6IFwiL21lc3NhZ2VzP3tiZWZvcmU6ZGF0ZX0me2FmdGVyOmRhdGV9XCJcbiAgICogdXJsOiBcIi9tZXNzYWdlcy86bWFpbGJveGlkP3tiZWZvcmU6ZGF0ZX0me2FmdGVyOmRhdGV9XCJcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gc3RhdGVDb25maWcudmlld3NcbiAgICogPGEgaWQ9J3ZpZXdzJz48L2E+XG4gICAqIGFuIG9wdGlvbmFsIG1hcCZsdDtzdHJpbmcsIG9iamVjdCZndDsgd2hpY2ggZGVmaW5lZCBtdWx0aXBsZSB2aWV3cywgb3IgdGFyZ2V0cyB2aWV3c1xuICAgKiBtYW51YWxseS9leHBsaWNpdGx5LlxuICAgKlxuICAgKiBFeGFtcGxlczpcbiAgICpcbiAgICogVGFyZ2V0cyB0aHJlZSBuYW1lZCBgdWktdmlld2BzIGluIHRoZSBwYXJlbnQgc3RhdGUncyB0ZW1wbGF0ZVxuICAgKiA8cHJlPnZpZXdzOiB7XG4gICAqICAgICBoZWFkZXI6IHtcbiAgICogICAgICAgY29udHJvbGxlcjogXCJoZWFkZXJDdHJsXCIsXG4gICAqICAgICAgIHRlbXBsYXRlVXJsOiBcImhlYWRlci5odG1sXCJcbiAgICogICAgIH0sIGJvZHk6IHtcbiAgICogICAgICAgY29udHJvbGxlcjogXCJib2R5Q3RybFwiLFxuICAgKiAgICAgICB0ZW1wbGF0ZVVybDogXCJib2R5Lmh0bWxcIlxuICAgKiAgICAgfSwgZm9vdGVyOiB7XG4gICAqICAgICAgIGNvbnRyb2xsZXI6IFwiZm9vdEN0cmxcIixcbiAgICogICAgICAgdGVtcGxhdGVVcmw6IFwiZm9vdGVyLmh0bWxcIlxuICAgKiAgICAgfVxuICAgKiAgIH08L3ByZT5cbiAgICpcbiAgICogVGFyZ2V0cyBuYW1lZCBgdWktdmlldz1cImhlYWRlclwiYCBmcm9tIGdyYW5kcGFyZW50IHN0YXRlICd0b3AnJ3MgdGVtcGxhdGUsIGFuZCBuYW1lZCBgdWktdmlldz1cImJvZHlcIiBmcm9tIHBhcmVudCBzdGF0ZSdzIHRlbXBsYXRlLlxuICAgKiA8cHJlPnZpZXdzOiB7XG4gICAqICAgICAnaGVhZGVyQHRvcCc6IHtcbiAgICogICAgICAgY29udHJvbGxlcjogXCJtc2dIZWFkZXJDdHJsXCIsXG4gICAqICAgICAgIHRlbXBsYXRlVXJsOiBcIm1zZ0hlYWRlci5odG1sXCJcbiAgICogICAgIH0sICdib2R5Jzoge1xuICAgKiAgICAgICBjb250cm9sbGVyOiBcIm1lc3NhZ2VzQ3RybFwiLFxuICAgKiAgICAgICB0ZW1wbGF0ZVVybDogXCJtZXNzYWdlcy5odG1sXCJcbiAgICogICAgIH1cbiAgICogICB9PC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtzdGF0ZUNvbmZpZy5hYnN0cmFjdD1mYWxzZV1cbiAgICogPGEgaWQ9J2Fic3RyYWN0Jz48L2E+XG4gICAqIEFuIGFic3RyYWN0IHN0YXRlIHdpbGwgbmV2ZXIgYmUgZGlyZWN0bHkgYWN0aXZhdGVkLFxuICAgKiAgIGJ1dCBjYW4gcHJvdmlkZSBpbmhlcml0ZWQgcHJvcGVydGllcyB0byBpdHMgY29tbW9uIGNoaWxkcmVuIHN0YXRlcy5cbiAgICogPHByZT5hYnN0cmFjdDogdHJ1ZTwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gc3RhdGVDb25maWcub25FbnRlclxuICAgKiA8YSBpZD0nb25FbnRlcic+PC9hPlxuICAgKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igd2hlbiBhIHN0YXRlIGlzIGVudGVyZWQuIEdvb2Qgd2F5XG4gICAqICAgdG8gdHJpZ2dlciBhbiBhY3Rpb24gb3IgZGlzcGF0Y2ggYW4gZXZlbnQsIHN1Y2ggYXMgb3BlbmluZyBhIGRpYWxvZy5cbiAgICogSWYgbWluaWZ5aW5nIHlvdXIgc2NyaXB0cywgbWFrZSBzdXJlIHRvIGV4cGxpY2l0bHkgYW5ub3RhdGUgdGhpcyBmdW5jdGlvbixcbiAgICogYmVjYXVzZSBpdCB3b24ndCBiZSBhdXRvbWF0aWNhbGx5IGFubm90YXRlZCBieSB5b3VyIGJ1aWxkIHRvb2xzLlxuICAgKlxuICAgKiA8cHJlPm9uRW50ZXI6IGZ1bmN0aW9uKE15U2VydmljZSwgJHN0YXRlUGFyYW1zKSB7XG4gICAqICAgICBNeVNlcnZpY2UuZm9vKCRzdGF0ZVBhcmFtcy5teVBhcmFtKTtcbiAgICogfTwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gc3RhdGVDb25maWcub25FeGl0XG4gICAqIDxhIGlkPSdvbkV4aXQnPjwvYT5cbiAgICpcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHdoZW4gYSBzdGF0ZSBpcyBleGl0ZWQuIEdvb2Qgd2F5IHRvXG4gICAqICAgdHJpZ2dlciBhbiBhY3Rpb24gb3IgZGlzcGF0Y2ggYW4gZXZlbnQsIHN1Y2ggYXMgb3BlbmluZyBhIGRpYWxvZy5cbiAgICogSWYgbWluaWZ5aW5nIHlvdXIgc2NyaXB0cywgbWFrZSBzdXJlIHRvIGV4cGxpY2l0bHkgYW5ub3RhdGUgdGhpcyBmdW5jdGlvbixcbiAgICogYmVjYXVzZSBpdCB3b24ndCBiZSBhdXRvbWF0aWNhbGx5IGFubm90YXRlZCBieSB5b3VyIGJ1aWxkIHRvb2xzLlxuICAgKlxuICAgKiA8cHJlPm9uRXhpdDogZnVuY3Rpb24oTXlTZXJ2aWNlLCAkc3RhdGVQYXJhbXMpIHtcbiAgICogICAgIE15U2VydmljZS5jbGVhbnVwKCRzdGF0ZVBhcmFtcy5teVBhcmFtKTtcbiAgICogfTwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbc3RhdGVDb25maWcucmVsb2FkT25TZWFyY2g9dHJ1ZV1cbiAgICogPGEgaWQ9J3JlbG9hZE9uU2VhcmNoJz48L2E+XG4gICAqXG4gICAqIElmIGBmYWxzZWAsIHdpbGwgbm90IHJldHJpZ2dlciB0aGUgc2FtZSBzdGF0ZVxuICAgKiAgIGp1c3QgYmVjYXVzZSBhIHNlYXJjaC9xdWVyeSBwYXJhbWV0ZXIgaGFzIGNoYW5nZWQgKHZpYSAkbG9jYXRpb24uc2VhcmNoKCkgb3IgJGxvY2F0aW9uLmhhc2goKSkuIFxuICAgKiAgIFVzZWZ1bCBmb3Igd2hlbiB5b3UnZCBsaWtlIHRvIG1vZGlmeSAkbG9jYXRpb24uc2VhcmNoKCkgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcmVsb2FkLlxuICAgKiA8cHJlPnJlbG9hZE9uU2VhcmNoOiBmYWxzZTwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdD19IHN0YXRlQ29uZmlnLmRhdGFcbiAgICogPGEgaWQ9J2RhdGEnPjwvYT5cbiAgICpcbiAgICogQXJiaXRyYXJ5IGRhdGEgb2JqZWN0LCB1c2VmdWwgZm9yIGN1c3RvbSBjb25maWd1cmF0aW9uLiAgVGhlIHBhcmVudCBzdGF0ZSdzIGBkYXRhYCBpc1xuICAgKiAgIHByb3RvdHlwYWxseSBpbmhlcml0ZWQuICBJbiBvdGhlciB3b3JkcywgYWRkaW5nIGEgZGF0YSBwcm9wZXJ0eSB0byBhIHN0YXRlIGFkZHMgaXQgdG9cbiAgICogICB0aGUgZW50aXJlIHN1YnRyZWUgdmlhIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UuXG4gICAqXG4gICAqIDxwcmU+ZGF0YToge1xuICAgKiAgICAgcmVxdWlyZWRSb2xlOiAnZm9vJ1xuICAgKiB9IDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdD19IHN0YXRlQ29uZmlnLnBhcmFtc1xuICAgKiA8YSBpZD0ncGFyYW1zJz48L2E+XG4gICAqXG4gICAqIEEgbWFwIHdoaWNoIG9wdGlvbmFsbHkgY29uZmlndXJlcyBwYXJhbWV0ZXJzIGRlY2xhcmVkIGluIHRoZSBgdXJsYCwgb3JcbiAgICogICBkZWZpbmVzIGFkZGl0aW9uYWwgbm9uLXVybCBwYXJhbWV0ZXJzLiAgRm9yIGVhY2ggcGFyYW1ldGVyIGJlaW5nXG4gICAqICAgY29uZmlndXJlZCwgYWRkIGEgY29uZmlndXJhdGlvbiBvYmplY3Qga2V5ZWQgdG8gdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICpcbiAgICogICBFYWNoIHBhcmFtZXRlciBjb25maWd1cmF0aW9uIG9iamVjdCBtYXkgY29udGFpbiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSAqKiB2YWx1ZSAqKiAtIHtvYmplY3R8ZnVuY3Rpb249fTogc3BlY2lmaWVzIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzXG4gICAqICAgICBwYXJhbWV0ZXIuICBUaGlzIGltcGxpY2l0bHkgc2V0cyB0aGlzIHBhcmFtZXRlciBhcyBvcHRpb25hbC5cbiAgICpcbiAgICogICAgIFdoZW4gVUktUm91dGVyIHJvdXRlcyB0byBhIHN0YXRlIGFuZCBubyB2YWx1ZSBpc1xuICAgKiAgICAgc3BlY2lmaWVkIGZvciB0aGlzIHBhcmFtZXRlciBpbiB0aGUgVVJMIG9yIHRyYW5zaXRpb24sIHRoZVxuICAgKiAgICAgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gIElmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbixcbiAgICogICAgIGl0IHdpbGwgYmUgaW5qZWN0ZWQgYW5kIGludm9rZWQsIGFuZCB0aGUgcmV0dXJuIHZhbHVlIHVzZWQuXG4gICAqXG4gICAqICAgICAqTm90ZSo6IGB1bmRlZmluZWRgIGlzIHRyZWF0ZWQgYXMgXCJubyBkZWZhdWx0IHZhbHVlXCIgd2hpbGUgYG51bGxgXG4gICAqICAgICBpcyB0cmVhdGVkIGFzIFwidGhlIGRlZmF1bHQgdmFsdWUgaXMgYG51bGxgXCIuXG4gICAqXG4gICAqICAgICAqU2hvcnRoYW5kKjogSWYgeW91IG9ubHkgbmVlZCB0byBjb25maWd1cmUgdGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlXG4gICAqICAgICBwYXJhbWV0ZXIsIHlvdSBtYXkgdXNlIGEgc2hvcnRoYW5kIHN5bnRheC4gICBJbiB0aGUgKipgcGFyYW1zYCoqXG4gICAqICAgICBtYXAsIGluc3RlYWQgbWFwcGluZyB0aGUgcGFyYW0gbmFtZSB0byBhIGZ1bGwgcGFyYW1ldGVyIGNvbmZpZ3VyYXRpb25cbiAgICogICAgIG9iamVjdCwgc2ltcGx5IHNldCBtYXAgaXQgdG8gdGhlIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlLCBlLmcuOlxuICAgKlxuICAgKiA8cHJlPi8vIGRlZmluZSBhIHBhcmFtZXRlcidzIGRlZmF1bHQgdmFsdWVcbiAgICogcGFyYW1zOiB7XG4gICAqICAgICBwYXJhbTE6IHsgdmFsdWU6IFwiZGVmYXVsdFZhbHVlXCIgfVxuICAgKiB9XG4gICAqIC8vIHNob3J0aGFuZCBkZWZhdWx0IHZhbHVlc1xuICAgKiBwYXJhbXM6IHtcbiAgICogICAgIHBhcmFtMTogXCJkZWZhdWx0VmFsdWVcIixcbiAgICogICAgIHBhcmFtMjogXCJwYXJhbTJEZWZhdWx0XCJcbiAgICogfTwvcHJlPlxuICAgKlxuICAgKiAgIC0gKiogYXJyYXkgKiogLSB7Ym9vbGVhbj19OiAqKGRlZmF1bHQ6IGZhbHNlKSogSWYgdHJ1ZSwgdGhlIHBhcmFtIHZhbHVlIHdpbGwgYmVcbiAgICogICAgIHRyZWF0ZWQgYXMgYW4gYXJyYXkgb2YgdmFsdWVzLiAgSWYgeW91IHNwZWNpZmllZCBhIFR5cGUsIHRoZSB2YWx1ZSB3aWxsIGJlXG4gICAqICAgICB0cmVhdGVkIGFzIGFuIGFycmF5IG9mIHRoZSBzcGVjaWZpZWQgVHlwZS4gIE5vdGU6IHF1ZXJ5IHBhcmFtZXRlciB2YWx1ZXNcbiAgICogICAgIGRlZmF1bHQgdG8gYSBzcGVjaWFsIGBcImF1dG9cImAgbW9kZS5cbiAgICpcbiAgICogICAgIEZvciBxdWVyeSBwYXJhbWV0ZXJzIGluIGBcImF1dG9cImAgbW9kZSwgaWYgbXVsdGlwbGUgIHZhbHVlcyBmb3IgYSBzaW5nbGUgcGFyYW1ldGVyXG4gICAqICAgICBhcmUgcHJlc2VudCBpbiB0aGUgVVJMIChlLmcuOiBgL2Zvbz9iYXI9MSZiYXI9MiZiYXI9M2ApIHRoZW4gdGhlIHZhbHVlc1xuICAgKiAgICAgYXJlIG1hcHBlZCB0byBhbiBhcnJheSAoZS5nLjogYHsgZm9vOiBbICcxJywgJzInLCAnMycgXSB9YCkuICBIb3dldmVyLCBpZlxuICAgKiAgICAgb25seSBvbmUgdmFsdWUgaXMgcHJlc2VudCAoZS5nLjogYC9mb28/YmFyPTFgKSB0aGVuIHRoZSB2YWx1ZSBpcyB0cmVhdGVkIGFzIHNpbmdsZVxuICAgKiAgICAgdmFsdWUgKGUuZy46IGB7IGZvbzogJzEnIH1gKS5cbiAgICpcbiAgICogPHByZT5wYXJhbXM6IHtcbiAgICogICAgIHBhcmFtMTogeyBhcnJheTogdHJ1ZSB9XG4gICAqIH08L3ByZT5cbiAgICpcbiAgICogICAtICoqIHNxdWFzaCAqKiAtIHtib29sfHN0cmluZz19OiBgc3F1YXNoYCBjb25maWd1cmVzIGhvdyBhIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlIGlzIHJlcHJlc2VudGVkIGluIHRoZSBVUkwgd2hlblxuICAgKiAgICAgdGhlIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSBkZWZhdWx0IHZhbHVlLiBJZiBgc3F1YXNoYCBpcyBub3Qgc2V0LCBpdCB1c2VzIHRoZVxuICAgKiAgICAgY29uZmlndXJlZCBkZWZhdWx0IHNxdWFzaCBwb2xpY3kuXG4gICAqICAgICAoU2VlIHtAbGluayB1aS5yb3V0ZXIudXRpbC4kdXJsTWF0Y2hlckZhY3RvcnkjbWV0aG9kc19kZWZhdWx0U3F1YXNoUG9saWN5IGBkZWZhdWx0U3F1YXNoUG9saWN5KClgfSlcbiAgICpcbiAgICogICBUaGVyZSBhcmUgdGhyZWUgc3F1YXNoIHNldHRpbmdzOlxuICAgKlxuICAgKiAgICAgLSBmYWxzZTogVGhlIHBhcmFtZXRlcidzIGRlZmF1bHQgdmFsdWUgaXMgbm90IHNxdWFzaGVkLiAgSXQgaXMgZW5jb2RlZCBhbmQgaW5jbHVkZWQgaW4gdGhlIFVSTFxuICAgKiAgICAgLSB0cnVlOiBUaGUgcGFyYW1ldGVyJ3MgZGVmYXVsdCB2YWx1ZSBpcyBvbWl0dGVkIGZyb20gdGhlIFVSTC4gIElmIHRoZSBwYXJhbWV0ZXIgaXMgcHJlY2VlZGVkIGFuZCBmb2xsb3dlZFxuICAgKiAgICAgICBieSBzbGFzaGVzIGluIHRoZSBzdGF0ZSdzIGB1cmxgIGRlY2xhcmF0aW9uLCB0aGVuIG9uZSBvZiB0aG9zZSBzbGFzaGVzIGFyZSBvbWl0dGVkLlxuICAgKiAgICAgICBUaGlzIGNhbiBhbGxvdyBmb3IgY2xlYW5lciBsb29raW5nIFVSTHMuXG4gICAqICAgICAtIGBcIjxhcmJpdHJhcnkgc3RyaW5nPlwiYDogVGhlIHBhcmFtZXRlcidzIGRlZmF1bHQgdmFsdWUgaXMgcmVwbGFjZWQgd2l0aCBhbiBhcmJpdHJhcnkgcGxhY2Vob2xkZXIgb2YgIHlvdXIgY2hvaWNlLlxuICAgKlxuICAgKiA8cHJlPnBhcmFtczoge1xuICAgKiAgICAgcGFyYW0xOiB7XG4gICAqICAgICAgIHZhbHVlOiBcImRlZmF1bHRJZFwiLFxuICAgKiAgICAgICBzcXVhc2g6IHRydWVcbiAgICogfSB9XG4gICAqIC8vIHNxdWFzaCBcImRlZmF1bHRWYWx1ZVwiIHRvIFwiflwiXG4gICAqIHBhcmFtczoge1xuICAgKiAgICAgcGFyYW0xOiB7XG4gICAqICAgICAgIHZhbHVlOiBcImRlZmF1bHRWYWx1ZVwiLFxuICAgKiAgICAgICBzcXVhc2g6IFwiflwiXG4gICAqIH0gfVxuICAgKiA8L3ByZT5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogPHByZT5cbiAgICogLy8gU29tZSBzdGF0ZSBuYW1lIGV4YW1wbGVzXG4gICAqXG4gICAqIC8vIHN0YXRlTmFtZSBjYW4gYmUgYSBzaW5nbGUgdG9wLWxldmVsIG5hbWUgKG11c3QgYmUgdW5pcXVlKS5cbiAgICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lXCIsIHt9KTtcbiAgICpcbiAgICogLy8gT3IgaXQgY2FuIGJlIGEgbmVzdGVkIHN0YXRlIG5hbWUuIFRoaXMgc3RhdGUgaXMgYSBjaGlsZCBvZiB0aGVcbiAgICogLy8gYWJvdmUgXCJob21lXCIgc3RhdGUuXG4gICAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZS5uZXdlc3RcIiwge30pO1xuICAgKlxuICAgKiAvLyBOZXN0IHN0YXRlcyBhcyBkZWVwbHkgYXMgbmVlZGVkLlxuICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWUubmV3ZXN0LmFiYy54eXouaW5jZXB0aW9uXCIsIHt9KTtcbiAgICpcbiAgICogLy8gc3RhdGUoKSByZXR1cm5zICRzdGF0ZVByb3ZpZGVyLCBzbyB5b3UgY2FuIGNoYWluIHN0YXRlIGRlY2xhcmF0aW9ucy5cbiAgICogJHN0YXRlUHJvdmlkZXJcbiAgICogICAuc3RhdGUoXCJob21lXCIsIHt9KVxuICAgKiAgIC5zdGF0ZShcImFib3V0XCIsIHt9KVxuICAgKiAgIC5zdGF0ZShcImNvbnRhY3RzXCIsIHt9KTtcbiAgICogPC9wcmU+XG4gICAqXG4gICAqL1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIGZ1bmN0aW9uIHN0YXRlKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAvKmpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgICBpZiAoaXNPYmplY3QobmFtZSkpIGRlZmluaXRpb24gPSBuYW1lO1xuICAgIGVsc2UgZGVmaW5pdGlvbi5uYW1lID0gbmFtZTtcbiAgICByZWdpc3RlclN0YXRlKGRlZmluaXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBvYmplY3RcbiAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICAgKlxuICAgKiBAcmVxdWlyZXMgJHJvb3RTY29wZVxuICAgKiBAcmVxdWlyZXMgJHFcbiAgICogQHJlcXVpcmVzIHVpLnJvdXRlci5zdGF0ZS4kdmlld1xuICAgKiBAcmVxdWlyZXMgJGluamVjdG9yXG4gICAqIEByZXF1aXJlcyB1aS5yb3V0ZXIudXRpbC4kcmVzb2x2ZVxuICAgKiBAcmVxdWlyZXMgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVBhcmFtc1xuICAgKiBAcmVxdWlyZXMgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyXG4gICAqXG4gICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBwYXJhbXMgQSBwYXJhbSBvYmplY3QsIGUuZy4ge3NlY3Rpb25JZDogc2VjdGlvbi5pZCl9LCB0aGF0IFxuICAgKiB5b3UnZCBsaWtlIHRvIHRlc3QgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUuXG4gICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjdXJyZW50IEEgcmVmZXJlbmNlIHRvIHRoZSBzdGF0ZSdzIGNvbmZpZyBvYmplY3QuIEhvd2V2ZXIgXG4gICAqIHlvdSBwYXNzZWQgaXQgaW4uIFVzZWZ1bCBmb3IgYWNjZXNzaW5nIGN1c3RvbSBkYXRhLlxuICAgKiBAcHJvcGVydHkge29iamVjdH0gdHJhbnNpdGlvbiBDdXJyZW50bHkgcGVuZGluZyB0cmFuc2l0aW9uLiBBIHByb21pc2UgdGhhdCdsbCBcbiAgICogcmVzb2x2ZSBvciByZWplY3QuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBgJHN0YXRlYCBzZXJ2aWNlIGlzIHJlc3BvbnNpYmxlIGZvciByZXByZXNlbnRpbmcgc3RhdGVzIGFzIHdlbGwgYXMgdHJhbnNpdGlvbmluZ1xuICAgKiBiZXR3ZWVuIHRoZW0uIEl0IGFsc28gcHJvdmlkZXMgaW50ZXJmYWNlcyB0byBhc2sgZm9yIGN1cnJlbnQgc3RhdGUgb3IgZXZlbiBzdGF0ZXNcbiAgICogeW91J3JlIGNvbWluZyBmcm9tLlxuICAgKi9cbiAgdGhpcy4kZ2V0ID0gJGdldDtcbiAgJGdldC4kaW5qZWN0ID0gWyckcm9vdFNjb3BlJywgJyRxJywgJyR2aWV3JywgJyRpbmplY3RvcicsICckcmVzb2x2ZScsICckc3RhdGVQYXJhbXMnLCAnJHVybFJvdXRlcicsICckbG9jYXRpb24nLCAnJHVybE1hdGNoZXJGYWN0b3J5J107XG4gIGZ1bmN0aW9uICRnZXQoICAgJHJvb3RTY29wZSwgICAkcSwgICAkdmlldywgICAkaW5qZWN0b3IsICAgJHJlc29sdmUsICAgJHN0YXRlUGFyYW1zLCAgICR1cmxSb3V0ZXIsICAgJGxvY2F0aW9uLCAgICR1cmxNYXRjaGVyRmFjdG9yeSkge1xuXG4gICAgdmFyIFRyYW5zaXRpb25TdXBlcnNlZGVkID0gJHEucmVqZWN0KG5ldyBFcnJvcigndHJhbnNpdGlvbiBzdXBlcnNlZGVkJykpO1xuICAgIHZhciBUcmFuc2l0aW9uUHJldmVudGVkID0gJHEucmVqZWN0KG5ldyBFcnJvcigndHJhbnNpdGlvbiBwcmV2ZW50ZWQnKSk7XG4gICAgdmFyIFRyYW5zaXRpb25BYm9ydGVkID0gJHEucmVqZWN0KG5ldyBFcnJvcigndHJhbnNpdGlvbiBhYm9ydGVkJykpO1xuICAgIHZhciBUcmFuc2l0aW9uRmFpbGVkID0gJHEucmVqZWN0KG5ldyBFcnJvcigndHJhbnNpdGlvbiBmYWlsZWQnKSk7XG5cbiAgICAvLyBIYW5kbGVzIHRoZSBjYXNlIHdoZXJlIGEgc3RhdGUgd2hpY2ggaXMgdGhlIHRhcmdldCBvZiBhIHRyYW5zaXRpb24gaXMgbm90IGZvdW5kLCBhbmQgdGhlIHVzZXJcbiAgICAvLyBjYW4gb3B0aW9uYWxseSByZXRyeSBvciBkZWZlciB0aGUgdHJhbnNpdGlvblxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlZGlyZWN0KHJlZGlyZWN0LCBzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSMkc3RhdGVOb3RGb3VuZFxuICAgICAgICogQGV2ZW50T2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICAgICAgICogQGV2ZW50VHlwZSBicm9hZGNhc3Qgb24gcm9vdCBzY29wZVxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBGaXJlZCB3aGVuIGEgcmVxdWVzdGVkIHN0YXRlICoqY2Fubm90IGJlIGZvdW5kKiogdXNpbmcgdGhlIHByb3ZpZGVkIHN0YXRlIG5hbWUgZHVyaW5nIHRyYW5zaXRpb24uXG4gICAgICAgKiBUaGUgZXZlbnQgaXMgYnJvYWRjYXN0IGFsbG93aW5nIGFueSBoYW5kbGVycyBhIHNpbmdsZSBjaGFuY2UgdG8gZGVhbCB3aXRoIHRoZSBlcnJvciAodXN1YWxseSBieVxuICAgICAgICogbGF6eS1sb2FkaW5nIHRoZSB1bmZvdW5kIHN0YXRlKS4gQSBzcGVjaWFsIGB1bmZvdW5kU3RhdGVgIG9iamVjdCBpcyBwYXNzZWQgdG8gdGhlIGxpc3RlbmVyIGhhbmRsZXIsXG4gICAgICAgKiB5b3UgY2FuIHNlZSBpdHMgdGhyZWUgcHJvcGVydGllcyBpbiB0aGUgZXhhbXBsZS4gWW91IGNhbiB1c2UgYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIHRvIGFib3J0IHRoZVxuICAgICAgICogdHJhbnNpdGlvbiBhbmQgdGhlIHByb21pc2UgcmV0dXJuZWQgZnJvbSBgZ29gIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhIGAndHJhbnNpdGlvbiBhYm9ydGVkJ2AgdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmZvdW5kU3RhdGUgVW5mb3VuZCBTdGF0ZSBpbmZvcm1hdGlvbi4gQ29udGFpbnM6IGB0bywgdG9QYXJhbXMsIG9wdGlvbnNgIHByb3BlcnRpZXMuXG4gICAgICAgKiBAcGFyYW0ge1N0YXRlfSBmcm9tU3RhdGUgQ3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZnJvbVBhcmFtcyBDdXJyZW50IHN0YXRlIHBhcmFtcy5cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICpcbiAgICAgICAqIDxwcmU+XG4gICAgICAgKiAvLyBzb21ld2hlcmUsIGFzc3VtZSBsYXp5LnN0YXRlIGhhcyBub3QgYmVlbiBkZWZpbmVkXG4gICAgICAgKiAkc3RhdGUuZ28oXCJsYXp5LnN0YXRlXCIsIHthOjEsIGI6Mn0sIHtpbmhlcml0OmZhbHNlfSk7XG4gICAgICAgKlxuICAgICAgICogLy8gc29tZXdoZXJlIGVsc2VcbiAgICAgICAqICRzY29wZS4kb24oJyRzdGF0ZU5vdEZvdW5kJyxcbiAgICAgICAqIGZ1bmN0aW9uKGV2ZW50LCB1bmZvdW5kU3RhdGUsIGZyb21TdGF0ZSwgZnJvbVBhcmFtcyl7XG4gICAgICAgKiAgICAgY29uc29sZS5sb2codW5mb3VuZFN0YXRlLnRvKTsgLy8gXCJsYXp5LnN0YXRlXCJcbiAgICAgICAqICAgICBjb25zb2xlLmxvZyh1bmZvdW5kU3RhdGUudG9QYXJhbXMpOyAvLyB7YToxLCBiOjJ9XG4gICAgICAgKiAgICAgY29uc29sZS5sb2codW5mb3VuZFN0YXRlLm9wdGlvbnMpOyAvLyB7aW5oZXJpdDpmYWxzZX0gKyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAqIH0pXG4gICAgICAgKiA8L3ByZT5cbiAgICAgICAqL1xuICAgICAgdmFyIGV2dCA9ICRyb290U2NvcGUuJGJyb2FkY2FzdCgnJHN0YXRlTm90Rm91bmQnLCByZWRpcmVjdCwgc3RhdGUsIHBhcmFtcyk7XG5cbiAgICAgIGlmIChldnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAkdXJsUm91dGVyLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gVHJhbnNpdGlvbkFib3J0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghZXZ0LnJldHJ5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyB0aGUgaGFuZGxlciB0byByZXR1cm4gYSBwcm9taXNlIHRvIGRlZmVyIHN0YXRlIGxvb2t1cCByZXRyeVxuICAgICAgaWYgKG9wdGlvbnMuJHJldHJ5KSB7XG4gICAgICAgICR1cmxSb3V0ZXIudXBkYXRlKCk7XG4gICAgICAgIHJldHVybiBUcmFuc2l0aW9uRmFpbGVkO1xuICAgICAgfVxuICAgICAgdmFyIHJldHJ5VHJhbnNpdGlvbiA9ICRzdGF0ZS50cmFuc2l0aW9uID0gJHEud2hlbihldnQucmV0cnkpO1xuXG4gICAgICByZXRyeVRyYW5zaXRpb24udGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJldHJ5VHJhbnNpdGlvbiAhPT0gJHN0YXRlLnRyYW5zaXRpb24pIHJldHVybiBUcmFuc2l0aW9uU3VwZXJzZWRlZDtcbiAgICAgICAgcmVkaXJlY3Qub3B0aW9ucy4kcmV0cnkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gJHN0YXRlLnRyYW5zaXRpb25UbyhyZWRpcmVjdC50bywgcmVkaXJlY3QudG9QYXJhbXMsIHJlZGlyZWN0Lm9wdGlvbnMpO1xuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2l0aW9uQWJvcnRlZDtcbiAgICAgIH0pO1xuICAgICAgJHVybFJvdXRlci51cGRhdGUoKTtcblxuICAgICAgcmV0dXJuIHJldHJ5VHJhbnNpdGlvbjtcbiAgICB9XG5cbiAgICByb290LmxvY2FscyA9IHsgcmVzb2x2ZTogbnVsbCwgZ2xvYmFsczogeyAkc3RhdGVQYXJhbXM6IHt9IH0gfTtcblxuICAgICRzdGF0ZSA9IHtcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBjdXJyZW50OiByb290LnNlbGYsXG4gICAgICAkY3VycmVudDogcm9vdCxcbiAgICAgIHRyYW5zaXRpb246IG51bGxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNyZWxvYWRcbiAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQSBtZXRob2QgdGhhdCBmb3JjZSByZWxvYWRzIHRoZSBjdXJyZW50IHN0YXRlLiBBbGwgcmVzb2x2ZXMgYXJlIHJlLXJlc29sdmVkLFxuICAgICAqIGNvbnRyb2xsZXJzIHJlaW5zdGFudGlhdGVkLCBhbmQgZXZlbnRzIHJlLWZpcmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiA8cHJlPlxuICAgICAqIHZhciBhcHAgYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuICAgICAqXG4gICAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcbiAgICAgKiAgICRzY29wZS5yZWxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAqICAgICAkc3RhdGUucmVsb2FkKCk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogPC9wcmU+XG4gICAgICpcbiAgICAgKiBgcmVsb2FkKClgIGlzIGp1c3QgYW4gYWxpYXMgZm9yOlxuICAgICAqIDxwcmU+XG4gICAgICogJHN0YXRlLnRyYW5zaXRpb25Ubygkc3RhdGUuY3VycmVudCwgJHN0YXRlUGFyYW1zLCB7IFxuICAgICAqICAgcmVsb2FkOiB0cnVlLCBpbmhlcml0OiBmYWxzZSwgbm90aWZ5OiB0cnVlXG4gICAgICogfSk7XG4gICAgICogPC9wcmU+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZz18b2JqZWN0PX0gc3RhdGUgLSBBIHN0YXRlIG5hbWUgb3IgYSBzdGF0ZSBvYmplY3QsIHdoaWNoIGlzIHRoZSByb290IG9mIHRoZSByZXNvbHZlcyB0byBiZSByZS1yZXNvbHZlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIDxwcmU+XG4gICAgICogLy9hc3N1bWluZyBhcHAgYXBwbGljYXRpb24gY29uc2lzdHMgb2YgMyBzdGF0ZXM6ICdjb250YWN0cycsICdjb250YWN0cy5kZXRhaWwnLCAnY29udGFjdHMuZGV0YWlsLml0ZW0nIFxuICAgICAqIC8vYW5kIGN1cnJlbnQgc3RhdGUgaXMgJ2NvbnRhY3RzLmRldGFpbC5pdGVtJ1xuICAgICAqIHZhciBhcHAgYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuICAgICAqXG4gICAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcbiAgICAgKiAgICRzY29wZS5yZWxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAqICAgICAvL3dpbGwgcmVsb2FkICdjb250YWN0LmRldGFpbCcgYW5kICdjb250YWN0LmRldGFpbC5pdGVtJyBzdGF0ZXNcbiAgICAgKiAgICAgJHN0YXRlLnJlbG9hZCgnY29udGFjdC5kZXRhaWwnKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqIGByZWxvYWQoKWAgaXMganVzdCBhbiBhbGlhcyBmb3I6XG4gICAgICogPHByZT5cbiAgICAgKiAkc3RhdGUudHJhbnNpdGlvblRvKCRzdGF0ZS5jdXJyZW50LCAkc3RhdGVQYXJhbXMsIHsgXG4gICAgICogICByZWxvYWQ6IHRydWUsIGluaGVyaXQ6IGZhbHNlLCBub3RpZnk6IHRydWVcbiAgICAgKiB9KTtcbiAgICAgKiA8L3ByZT5cblxuICAgICAqIEByZXR1cm5zIHtwcm9taXNlfSBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uIFNlZVxuICAgICAqIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI21ldGhvZHNfZ28gJHN0YXRlLmdvfS5cbiAgICAgKi9cbiAgICAkc3RhdGUucmVsb2FkID0gZnVuY3Rpb24gcmVsb2FkKHN0YXRlKSB7XG4gICAgICByZXR1cm4gJHN0YXRlLnRyYW5zaXRpb25Ubygkc3RhdGUuY3VycmVudCwgJHN0YXRlUGFyYW1zLCB7IHJlbG9hZDogc3RhdGUgfHwgdHJ1ZSwgaW5oZXJpdDogZmFsc2UsIG5vdGlmeTogdHJ1ZX0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI2dvXG4gICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgdHJhbnNpdGlvbmluZyB0byBhIG5ldyBzdGF0ZS4gYCRzdGF0ZS5nb2AgY2FsbHMgXG4gICAgICogYCRzdGF0ZS50cmFuc2l0aW9uVG9gIGludGVybmFsbHkgYnV0IGF1dG9tYXRpY2FsbHkgc2V0cyBvcHRpb25zIHRvIFxuICAgICAqIGB7IGxvY2F0aW9uOiB0cnVlLCBpbmhlcml0OiB0cnVlLCByZWxhdGl2ZTogJHN0YXRlLiRjdXJyZW50LCBub3RpZnk6IHRydWUgfWAuIFxuICAgICAqIFRoaXMgYWxsb3dzIHlvdSB0byBlYXNpbHkgdXNlIGFuIGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHBhdGggYW5kIHNwZWNpZnkgXG4gICAgICogb25seSB0aGUgcGFyYW1ldGVycyB5b3UnZCBsaWtlIHRvIHVwZGF0ZSAod2hpbGUgbGV0dGluZyB1bnNwZWNpZmllZCBwYXJhbWV0ZXJzIFxuICAgICAqIGluaGVyaXQgZnJvbSB0aGUgY3VycmVudGx5IGFjdGl2ZSBhbmNlc3RvciBzdGF0ZXMpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiA8cHJlPlxuICAgICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xuICAgICAqICAgJHNjb3BlLmNoYW5nZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICAkc3RhdGUuZ28oJ2NvbnRhY3QuZGV0YWlsJyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqIDwvcHJlPlxuICAgICAqIDxpbWcgc3JjPScuLi9uZ2RvY19hc3NldHMvU3RhdGVHb0V4YW1wbGVzLnBuZycvPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRvIEFic29sdXRlIHN0YXRlIG5hbWUgb3IgcmVsYXRpdmUgc3RhdGUgcGF0aC4gU29tZSBleGFtcGxlczpcbiAgICAgKlxuICAgICAqIC0gYCRzdGF0ZS5nbygnY29udGFjdC5kZXRhaWwnKWAgLSB3aWxsIGdvIHRvIHRoZSBgY29udGFjdC5kZXRhaWxgIHN0YXRlXG4gICAgICogLSBgJHN0YXRlLmdvKCdeJylgIC0gd2lsbCBnbyB0byBhIHBhcmVudCBzdGF0ZVxuICAgICAqIC0gYCRzdGF0ZS5nbygnXi5zaWJsaW5nJylgIC0gd2lsbCBnbyB0byBhIHNpYmxpbmcgc3RhdGVcbiAgICAgKiAtIGAkc3RhdGUuZ28oJy5jaGlsZC5ncmFuZGNoaWxkJylgIC0gd2lsbCBnbyB0byBncmFuZGNoaWxkIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdD19IHBhcmFtcyBBIG1hcCBvZiB0aGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgc3RhdGUsIFxuICAgICAqIHdpbGwgcG9wdWxhdGUgJHN0YXRlUGFyYW1zLiBBbnkgcGFyYW1ldGVycyB0aGF0IGFyZSBub3Qgc3BlY2lmaWVkIHdpbGwgYmUgaW5oZXJpdGVkIGZyb20gY3VycmVudGx5IFxuICAgICAqIGRlZmluZWQgcGFyYW1ldGVycy4gT25seSBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiB0aGUgc3RhdGUgZGVmaW5pdGlvbiBjYW4gYmUgb3ZlcnJpZGRlbiwgbmV3IFxuICAgICAqIHBhcmFtZXRlcnMgd2lsbCBiZSBpZ25vcmVkLiBUaGlzIGFsbG93cywgZm9yIGV4YW1wbGUsIGdvaW5nIHRvIGEgc2libGluZyBzdGF0ZSB0aGF0IHNoYXJlcyBwYXJhbWV0ZXJzXG4gICAgICogc3BlY2lmaWVkIGluIGEgcGFyZW50IHN0YXRlLiBQYXJhbWV0ZXIgaW5oZXJpdGFuY2Ugb25seSB3b3JrcyBiZXR3ZWVuIGNvbW1vbiBhbmNlc3RvciBzdGF0ZXMsIEkuZS5cbiAgICAgKiB0cmFuc2l0aW9uaW5nIHRvIGEgc2libGluZyB3aWxsIGdldCB5b3UgdGhlIHBhcmFtZXRlcnMgZm9yIGFsbCBwYXJlbnRzLCB0cmFuc2l0aW9uaW5nIHRvIGEgY2hpbGRcbiAgICAgKiB3aWxsIGdldCB5b3UgYWxsIGN1cnJlbnQgcGFyYW1ldGVycywgZXRjLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIG9iamVjdC4gVGhlIG9wdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogLSAqKmBsb2NhdGlvbmAqKiAtIHtib29sZWFuPXRydWV8c3RyaW5nPX0gLSBJZiBgdHJ1ZWAgd2lsbCB1cGRhdGUgdGhlIHVybCBpbiB0aGUgbG9jYXRpb24gYmFyLCBpZiBgZmFsc2VgXG4gICAgICogICAgd2lsbCBub3QuIElmIHN0cmluZywgbXVzdCBiZSBgXCJyZXBsYWNlXCJgLCB3aGljaCB3aWxsIHVwZGF0ZSB1cmwgYW5kIGFsc28gcmVwbGFjZSBsYXN0IGhpc3RvcnkgcmVjb3JkLlxuICAgICAqIC0gKipgaW5oZXJpdGAqKiAtIHtib29sZWFuPXRydWV9LCBJZiBgdHJ1ZWAgd2lsbCBpbmhlcml0IHVybCBwYXJhbWV0ZXJzIGZyb20gY3VycmVudCB1cmwuXG4gICAgICogLSAqKmByZWxhdGl2ZWAqKiAtIHtvYmplY3Q9JHN0YXRlLiRjdXJyZW50fSwgV2hlbiB0cmFuc2l0aW9uaW5nIHdpdGggcmVsYXRpdmUgcGF0aCAoZS5nICdeJyksIFxuICAgICAqICAgIGRlZmluZXMgd2hpY2ggc3RhdGUgdG8gYmUgcmVsYXRpdmUgZnJvbS5cbiAgICAgKiAtICoqYG5vdGlmeWAqKiAtIHtib29sZWFuPXRydWV9LCBJZiBgdHJ1ZWAgd2lsbCBicm9hZGNhc3QgJHN0YXRlQ2hhbmdlU3RhcnQgYW5kICRzdGF0ZUNoYW5nZVN1Y2Nlc3MgZXZlbnRzLlxuICAgICAqIC0gKipgcmVsb2FkYCoqICh2MC4yLjUpIC0ge2Jvb2xlYW49ZmFsc2V8c3RyaW5nfG9iamVjdH0sIElmIGB0cnVlYCB3aWxsIGZvcmNlIHRyYW5zaXRpb24gZXZlbiBpZiBubyBzdGF0ZSBvciBwYXJhbXNcbiAgICAgKiAgICBoYXZlIGNoYW5nZWQuICBJdCB3aWxsIHJlbG9hZCB0aGUgcmVzb2x2ZXMgYW5kIHZpZXdzIG9mIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBwYXJlbnQgc3RhdGVzLlxuICAgICAqICAgIElmIGByZWxvYWRgIGlzIGEgc3RyaW5nIChvciBzdGF0ZSBvYmplY3QpLCB0aGUgc3RhdGUgb2JqZWN0IGlzIGZldGNoZWQgKGJ5IG5hbWUsIG9yIG9iamVjdCByZWZlcmVuY2UpOyBhbmQgXFxcbiAgICAgKiAgICB0aGUgdHJhbnNpdGlvbiByZWxvYWRzIHRoZSByZXNvbHZlcyBhbmQgdmlld3MgZm9yIHRoYXQgbWF0Y2hlZCBzdGF0ZSwgYW5kIGFsbCBpdHMgY2hpbGRyZW4gc3RhdGVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3Byb21pc2V9IEEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBuZXcgdHJhbnNpdGlvbi5cbiAgICAgKlxuICAgICAqIFBvc3NpYmxlIHN1Y2Nlc3MgdmFsdWVzOlxuICAgICAqXG4gICAgICogLSAkc3RhdGUuY3VycmVudFxuICAgICAqXG4gICAgICogPGJyLz5Qb3NzaWJsZSByZWplY3Rpb24gdmFsdWVzOlxuICAgICAqXG4gICAgICogLSAndHJhbnNpdGlvbiBzdXBlcnNlZGVkJyAtIHdoZW4gYSBuZXdlciB0cmFuc2l0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQgYWZ0ZXIgdGhpcyBvbmVcbiAgICAgKiAtICd0cmFuc2l0aW9uIHByZXZlbnRlZCcgLSB3aGVuIGBldmVudC5wcmV2ZW50RGVmYXVsdCgpYCBoYXMgYmVlbiBjYWxsZWQgaW4gYSBgJHN0YXRlQ2hhbmdlU3RhcnRgIGxpc3RlbmVyXG4gICAgICogLSAndHJhbnNpdGlvbiBhYm9ydGVkJyAtIHdoZW4gYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIGhhcyBiZWVuIGNhbGxlZCBpbiBhIGAkc3RhdGVOb3RGb3VuZGAgbGlzdGVuZXIgb3JcbiAgICAgKiAgIHdoZW4gYSBgJHN0YXRlTm90Rm91bmRgIGBldmVudC5yZXRyeWAgcHJvbWlzZSBlcnJvcnMuXG4gICAgICogLSAndHJhbnNpdGlvbiBmYWlsZWQnIC0gd2hlbiBhIHN0YXRlIGhhcyBiZWVuIHVuc3VjY2Vzc2Z1bGx5IGZvdW5kIGFmdGVyIDIgdHJpZXMuXG4gICAgICogLSAqcmVzb2x2ZSBlcnJvciogLSB3aGVuIGFuIGVycm9yIGhhcyBvY2N1cnJlZCB3aXRoIGEgYHJlc29sdmVgXG4gICAgICpcbiAgICAgKi9cbiAgICAkc3RhdGUuZ28gPSBmdW5jdGlvbiBnbyh0bywgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gJHN0YXRlLnRyYW5zaXRpb25Ubyh0bywgcGFyYW1zLCBleHRlbmQoeyBpbmhlcml0OiB0cnVlLCByZWxhdGl2ZTogJHN0YXRlLiRjdXJyZW50IH0sIG9wdGlvbnMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSN0cmFuc2l0aW9uVG9cbiAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTG93LWxldmVsIG1ldGhvZCBmb3IgdHJhbnNpdGlvbmluZyB0byBhIG5ldyBzdGF0ZS4ge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjbWV0aG9kc19nbyAkc3RhdGUuZ299XG4gICAgICogdXNlcyBgdHJhbnNpdGlvblRvYCBpbnRlcm5hbGx5LiBgJHN0YXRlLmdvYCBpcyByZWNvbW1lbmRlZCBpbiBtb3N0IHNpdHVhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIDxwcmU+XG4gICAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICogICAkc2NvcGUuY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oJ2NvbnRhY3QuZGV0YWlsJyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqIDwvcHJlPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRvIFN0YXRlIG5hbWUuXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSB0b1BhcmFtcyBBIG1hcCBvZiB0aGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgc3RhdGUsXG4gICAgICogd2lsbCBwb3B1bGF0ZSAkc3RhdGVQYXJhbXMuXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtICoqYGxvY2F0aW9uYCoqIC0ge2Jvb2xlYW49dHJ1ZXxzdHJpbmc9fSAtIElmIGB0cnVlYCB3aWxsIHVwZGF0ZSB0aGUgdXJsIGluIHRoZSBsb2NhdGlvbiBiYXIsIGlmIGBmYWxzZWBcbiAgICAgKiAgICB3aWxsIG5vdC4gSWYgc3RyaW5nLCBtdXN0IGJlIGBcInJlcGxhY2VcImAsIHdoaWNoIHdpbGwgdXBkYXRlIHVybCBhbmQgYWxzbyByZXBsYWNlIGxhc3QgaGlzdG9yeSByZWNvcmQuXG4gICAgICogLSAqKmBpbmhlcml0YCoqIC0ge2Jvb2xlYW49ZmFsc2V9LCBJZiBgdHJ1ZWAgd2lsbCBpbmhlcml0IHVybCBwYXJhbWV0ZXJzIGZyb20gY3VycmVudCB1cmwuXG4gICAgICogLSAqKmByZWxhdGl2ZWAqKiAtIHtvYmplY3Q9fSwgV2hlbiB0cmFuc2l0aW9uaW5nIHdpdGggcmVsYXRpdmUgcGF0aCAoZS5nICdeJyksIFxuICAgICAqICAgIGRlZmluZXMgd2hpY2ggc3RhdGUgdG8gYmUgcmVsYXRpdmUgZnJvbS5cbiAgICAgKiAtICoqYG5vdGlmeWAqKiAtIHtib29sZWFuPXRydWV9LCBJZiBgdHJ1ZWAgd2lsbCBicm9hZGNhc3QgJHN0YXRlQ2hhbmdlU3RhcnQgYW5kICRzdGF0ZUNoYW5nZVN1Y2Nlc3MgZXZlbnRzLlxuICAgICAqIC0gKipgcmVsb2FkYCoqICh2MC4yLjUpIC0ge2Jvb2xlYW49ZmFsc2V8c3RyaW5nPXxvYmplY3Q9fSwgSWYgYHRydWVgIHdpbGwgZm9yY2UgdHJhbnNpdGlvbiBldmVuIGlmIHRoZSBzdGF0ZSBvciBwYXJhbXMgXG4gICAgICogICAgaGF2ZSBub3QgY2hhbmdlZCwgYWthIGEgcmVsb2FkIG9mIHRoZSBzYW1lIHN0YXRlLiBJdCBkaWZmZXJzIGZyb20gcmVsb2FkT25TZWFyY2ggYmVjYXVzZSB5b3UnZFxuICAgICAqICAgIHVzZSB0aGlzIHdoZW4geW91IHdhbnQgdG8gZm9yY2UgYSByZWxvYWQgd2hlbiAqZXZlcnl0aGluZyogaXMgdGhlIHNhbWUsIGluY2x1ZGluZyBzZWFyY2ggcGFyYW1zLlxuICAgICAqICAgIGlmIFN0cmluZywgdGhlbiB3aWxsIHJlbG9hZCB0aGUgc3RhdGUgd2l0aCB0aGUgbmFtZSBnaXZlbiBpbiByZWxvYWQsIGFuZCBhbnkgY2hpbGRyZW4uXG4gICAgICogICAgaWYgT2JqZWN0LCB0aGVuIGEgc3RhdGVPYmogaXMgZXhwZWN0ZWQsIHdpbGwgcmVsb2FkIHRoZSBzdGF0ZSBmb3VuZCBpbiBzdGF0ZU9iaiwgYW5kIGFueSBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtwcm9taXNlfSBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uIFNlZVxuICAgICAqIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI21ldGhvZHNfZ28gJHN0YXRlLmdvfS5cbiAgICAgKi9cbiAgICAkc3RhdGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvKHRvLCB0b1BhcmFtcywgb3B0aW9ucykge1xuICAgICAgdG9QYXJhbXMgPSB0b1BhcmFtcyB8fCB7fTtcbiAgICAgIG9wdGlvbnMgPSBleHRlbmQoe1xuICAgICAgICBsb2NhdGlvbjogdHJ1ZSwgaW5oZXJpdDogZmFsc2UsIHJlbGF0aXZlOiBudWxsLCBub3RpZnk6IHRydWUsIHJlbG9hZDogZmFsc2UsICRyZXRyeTogZmFsc2VcbiAgICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgICB2YXIgZnJvbSA9ICRzdGF0ZS4kY3VycmVudCwgZnJvbVBhcmFtcyA9ICRzdGF0ZS5wYXJhbXMsIGZyb21QYXRoID0gZnJvbS5wYXRoO1xuICAgICAgdmFyIGV2dCwgdG9TdGF0ZSA9IGZpbmRTdGF0ZSh0bywgb3B0aW9ucy5yZWxhdGl2ZSk7XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBoYXNoIHBhcmFtIGZvciBsYXRlciAoc2luY2UgaXQgd2lsbCBiZSBzdHJpcHBlZCBvdXQgYnkgdmFyaW91cyBtZXRob2RzKVxuICAgICAgdmFyIGhhc2ggPSB0b1BhcmFtc1snIyddO1xuXG4gICAgICBpZiAoIWlzRGVmaW5lZCh0b1N0YXRlKSkge1xuICAgICAgICB2YXIgcmVkaXJlY3QgPSB7IHRvOiB0bywgdG9QYXJhbXM6IHRvUGFyYW1zLCBvcHRpb25zOiBvcHRpb25zIH07XG4gICAgICAgIHZhciByZWRpcmVjdFJlc3VsdCA9IGhhbmRsZVJlZGlyZWN0KHJlZGlyZWN0LCBmcm9tLnNlbGYsIGZyb21QYXJhbXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChyZWRpcmVjdFJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZWRpcmVjdFJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsd2F5cyByZXRyeSBvbmNlIGlmIHRoZSAkc3RhdGVOb3RGb3VuZCB3YXMgbm90IHByZXZlbnRlZFxuICAgICAgICAvLyAoaGFuZGxlcyBlaXRoZXIgcmVkaXJlY3QgY2hhbmdlZCBvciBzdGF0ZSBsYXp5LWRlZmluaXRpb24pXG4gICAgICAgIHRvID0gcmVkaXJlY3QudG87XG4gICAgICAgIHRvUGFyYW1zID0gcmVkaXJlY3QudG9QYXJhbXM7XG4gICAgICAgIG9wdGlvbnMgPSByZWRpcmVjdC5vcHRpb25zO1xuICAgICAgICB0b1N0YXRlID0gZmluZFN0YXRlKHRvLCBvcHRpb25zLnJlbGF0aXZlKTtcblxuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0b1N0YXRlKSkge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5yZWxhdGl2ZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBzdGF0ZSAnXCIgKyB0byArIFwiJ1wiKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSAnXCIgKyB0byArIFwiJyBmcm9tIHN0YXRlICdcIiArIG9wdGlvbnMucmVsYXRpdmUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0b1N0YXRlW2Fic3RyYWN0S2V5XSkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRyYW5zaXRpb24gdG8gYWJzdHJhY3Qgc3RhdGUgJ1wiICsgdG8gKyBcIidcIik7XG4gICAgICBpZiAob3B0aW9ucy5pbmhlcml0KSB0b1BhcmFtcyA9IGluaGVyaXRQYXJhbXMoJHN0YXRlUGFyYW1zLCB0b1BhcmFtcyB8fCB7fSwgJHN0YXRlLiRjdXJyZW50LCB0b1N0YXRlKTtcbiAgICAgIGlmICghdG9TdGF0ZS5wYXJhbXMuJCR2YWxpZGF0ZXModG9QYXJhbXMpKSByZXR1cm4gVHJhbnNpdGlvbkZhaWxlZDtcblxuICAgICAgdG9QYXJhbXMgPSB0b1N0YXRlLnBhcmFtcy4kJHZhbHVlcyh0b1BhcmFtcyk7XG4gICAgICB0byA9IHRvU3RhdGU7XG5cbiAgICAgIHZhciB0b1BhdGggPSB0by5wYXRoO1xuXG4gICAgICAvLyBTdGFydGluZyBmcm9tIHRoZSByb290IG9mIHRoZSBwYXRoLCBrZWVwIGFsbCBsZXZlbHMgdGhhdCBoYXZlbid0IGNoYW5nZWRcbiAgICAgIHZhciBrZWVwID0gMCwgc3RhdGUgPSB0b1BhdGhba2VlcF0sIGxvY2FscyA9IHJvb3QubG9jYWxzLCB0b0xvY2FscyA9IFtdO1xuXG4gICAgICBpZiAoIW9wdGlvbnMucmVsb2FkKSB7XG4gICAgICAgIHdoaWxlIChzdGF0ZSAmJiBzdGF0ZSA9PT0gZnJvbVBhdGhba2VlcF0gJiYgc3RhdGUub3duUGFyYW1zLiQkZXF1YWxzKHRvUGFyYW1zLCBmcm9tUGFyYW1zKSkge1xuICAgICAgICAgIGxvY2FscyA9IHRvTG9jYWxzW2tlZXBdID0gc3RhdGUubG9jYWxzO1xuICAgICAgICAgIGtlZXArKztcbiAgICAgICAgICBzdGF0ZSA9IHRvUGF0aFtrZWVwXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhvcHRpb25zLnJlbG9hZCkgfHwgaXNPYmplY3Qob3B0aW9ucy5yZWxvYWQpKSB7XG4gICAgICAgIGlmIChpc09iamVjdChvcHRpb25zLnJlbG9hZCkgJiYgIW9wdGlvbnMucmVsb2FkLm5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVsb2FkIHN0YXRlIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgcmVsb2FkU3RhdGUgPSBvcHRpb25zLnJlbG9hZCA9PT0gdHJ1ZSA/IGZyb21QYXRoWzBdIDogZmluZFN0YXRlKG9wdGlvbnMucmVsb2FkKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVsb2FkICYmICFyZWxvYWRTdGF0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggcmVsb2FkIHN0YXRlICdcIiArIChpc1N0cmluZyhvcHRpb25zLnJlbG9hZCkgPyBvcHRpb25zLnJlbG9hZCA6IG9wdGlvbnMucmVsb2FkLm5hbWUpICsgXCInXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHN0YXRlICYmIHN0YXRlID09PSBmcm9tUGF0aFtrZWVwXSAmJiBzdGF0ZSAhPT0gcmVsb2FkU3RhdGUpIHtcbiAgICAgICAgICBsb2NhbHMgPSB0b0xvY2Fsc1trZWVwXSA9IHN0YXRlLmxvY2FscztcbiAgICAgICAgICBrZWVwKys7XG4gICAgICAgICAgc3RhdGUgPSB0b1BhdGhba2VlcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UncmUgZ29pbmcgdG8gdGhlIHNhbWUgc3RhdGUgYW5kIGFsbCBsb2NhbHMgYXJlIGtlcHQsIHdlJ3ZlIGdvdCBub3RoaW5nIHRvIGRvLlxuICAgICAgLy8gQnV0IGNsZWFyICd0cmFuc2l0aW9uJywgYXMgd2Ugc3RpbGwgd2FudCB0byBjYW5jZWwgYW55IG90aGVyIHBlbmRpbmcgdHJhbnNpdGlvbnMuXG4gICAgICAvLyBUT0RPOiBXZSBtYXkgbm90IHdhbnQgdG8gYnVtcCAndHJhbnNpdGlvbicgaWYgd2UncmUgY2FsbGVkIGZyb20gYSBsb2NhdGlvbiBjaGFuZ2VcbiAgICAgIC8vIHRoYXQgd2UndmUgaW5pdGlhdGVkIG91cnNlbHZlcywgYmVjYXVzZSB3ZSBtaWdodCBhY2NpZGVudGFsbHkgYWJvcnQgYSBsZWdpdGltYXRlXG4gICAgICAvLyB0cmFuc2l0aW9uIGluaXRpYXRlZCBmcm9tIGNvZGU/XG4gICAgICBpZiAoc2hvdWxkU2tpcFJlbG9hZCh0bywgdG9QYXJhbXMsIGZyb20sIGZyb21QYXJhbXMsIGxvY2Fscywgb3B0aW9ucykpIHtcbiAgICAgICAgaWYgKGhhc2gpIHRvUGFyYW1zWycjJ10gPSBoYXNoO1xuICAgICAgICAkc3RhdGUucGFyYW1zID0gdG9QYXJhbXM7XG4gICAgICAgIGNvcHkoJHN0YXRlLnBhcmFtcywgJHN0YXRlUGFyYW1zKTtcbiAgICAgICAgY29weShmaWx0ZXJCeUtleXModG8ucGFyYW1zLiQka2V5cygpLCAkc3RhdGVQYXJhbXMpLCB0by5sb2NhbHMuZ2xvYmFscy4kc3RhdGVQYXJhbXMpO1xuICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbiAmJiB0by5uYXZpZ2FibGUgJiYgdG8ubmF2aWdhYmxlLnVybCkge1xuICAgICAgICAgICR1cmxSb3V0ZXIucHVzaCh0by5uYXZpZ2FibGUudXJsLCB0b1BhcmFtcywge1xuICAgICAgICAgICAgJCRhdm9pZFJlc3luYzogdHJ1ZSwgcmVwbGFjZTogb3B0aW9ucy5sb2NhdGlvbiA9PT0gJ3JlcGxhY2UnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgJHVybFJvdXRlci51cGRhdGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgJHN0YXRlLnRyYW5zaXRpb24gPSBudWxsO1xuICAgICAgICByZXR1cm4gJHEud2hlbigkc3RhdGUuY3VycmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbHRlciBwYXJhbWV0ZXJzIGJlZm9yZSB3ZSBwYXNzIHRoZW0gdG8gZXZlbnQgaGFuZGxlcnMgZXRjLlxuICAgICAgdG9QYXJhbXMgPSBmaWx0ZXJCeUtleXModG8ucGFyYW1zLiQka2V5cygpLCB0b1BhcmFtcyB8fCB7fSk7XG4gICAgICBcbiAgICAgIC8vIFJlLWFkZCB0aGUgc2F2ZWQgaGFzaCBiZWZvcmUgd2Ugc3RhcnQgcmV0dXJuaW5nIHRoaW5ncyBvciBicm9hZGNhc3RpbmcgJHN0YXRlQ2hhbmdlU3RhcnRcbiAgICAgIGlmIChoYXNoKSB0b1BhcmFtc1snIyddID0gaGFzaDtcbiAgICAgIFxuICAgICAgLy8gQnJvYWRjYXN0IHN0YXJ0IGV2ZW50IGFuZCBjYW5jZWwgdGhlIHRyYW5zaXRpb24gaWYgcmVxdWVzdGVkXG4gICAgICBpZiAob3B0aW9ucy5ub3RpZnkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlIyRzdGF0ZUNoYW5nZVN0YXJ0XG4gICAgICAgICAqIEBldmVudE9mIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVcbiAgICAgICAgICogQGV2ZW50VHlwZSBicm9hZGNhc3Qgb24gcm9vdCBzY29wZVxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogRmlyZWQgd2hlbiB0aGUgc3RhdGUgdHJhbnNpdGlvbiAqKmJlZ2lucyoqLiBZb3UgY2FuIHVzZSBgZXZlbnQucHJldmVudERlZmF1bHQoKWBcbiAgICAgICAgICogdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbiBmcm9tIGhhcHBlbmluZyBhbmQgdGhlbiB0aGUgdHJhbnNpdGlvbiBwcm9taXNlIHdpbGwgYmVcbiAgICAgICAgICogcmVqZWN0ZWQgd2l0aCBhIGAndHJhbnNpdGlvbiBwcmV2ZW50ZWQnYCB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtTdGF0ZX0gdG9TdGF0ZSBUaGUgc3RhdGUgYmVpbmcgdHJhbnNpdGlvbmVkIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9QYXJhbXMgVGhlIHBhcmFtcyBzdXBwbGllZCB0byB0aGUgYHRvU3RhdGVgLlxuICAgICAgICAgKiBAcGFyYW0ge1N0YXRlfSBmcm9tU3RhdGUgVGhlIGN1cnJlbnQgc3RhdGUsIHByZS10cmFuc2l0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZnJvbVBhcmFtcyBUaGUgcGFyYW1zIHN1cHBsaWVkIHRvIHRoZSBgZnJvbVN0YXRlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogPHByZT5cbiAgICAgICAgICogJHJvb3RTY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN0YXJ0JyxcbiAgICAgICAgICogZnVuY3Rpb24oZXZlbnQsIHRvU3RhdGUsIHRvUGFyYW1zLCBmcm9tU3RhdGUsIGZyb21QYXJhbXMpe1xuICAgICAgICAgKiAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICogICAgIC8vIHRyYW5zaXRpb25UbygpIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoXG4gICAgICAgICAqICAgICAvLyBhICd0cmFuc2l0aW9uIHByZXZlbnRlZCcgZXJyb3JcbiAgICAgICAgICogfSlcbiAgICAgICAgICogPC9wcmU+XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoJHJvb3RTY29wZS4kYnJvYWRjYXN0KCckc3RhdGVDaGFuZ2VTdGFydCcsIHRvLnNlbGYsIHRvUGFyYW1zLCBmcm9tLnNlbGYsIGZyb21QYXJhbXMsIG9wdGlvbnMpLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRzdGF0ZUNoYW5nZUNhbmNlbCcsIHRvLnNlbGYsIHRvUGFyYW1zLCBmcm9tLnNlbGYsIGZyb21QYXJhbXMpO1xuICAgICAgICAgIC8vRG9uJ3QgdXBkYXRlIGFuZCByZXN5bmMgdXJsIGlmIHRoZXJlJ3MgYmVlbiBhIG5ldyB0cmFuc2l0aW9uIHN0YXJ0ZWQuIHNlZSBpc3N1ZSAjMjIzOCwgIzYwMFxuICAgICAgICAgIGlmICgkc3RhdGUudHJhbnNpdGlvbiA9PSBudWxsKSAkdXJsUm91dGVyLnVwZGF0ZSgpO1xuICAgICAgICAgIHJldHVybiBUcmFuc2l0aW9uUHJldmVudGVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc29sdmUgbG9jYWxzIGZvciB0aGUgcmVtYWluaW5nIHN0YXRlcywgYnV0IGRvbid0IHVwZGF0ZSBhbnkgZ2xvYmFsIHN0YXRlIGp1c3RcbiAgICAgIC8vIHlldCAtLSBpZiBhbnl0aGluZyBmYWlscyB0byByZXNvbHZlIHRoZSBjdXJyZW50IHN0YXRlIG5lZWRzIHRvIHJlbWFpbiB1bnRvdWNoZWQuXG4gICAgICAvLyBXZSBhbHNvIHNldCB1cCBhbiBpbmhlcml0YW5jZSBjaGFpbiBmb3IgdGhlIGxvY2FscyBoZXJlLiBUaGlzIGFsbG93cyB0aGUgdmlldyBkaXJlY3RpdmVcbiAgICAgIC8vIHRvIHF1aWNrbHkgbG9vayB1cCB0aGUgY29ycmVjdCBkZWZpbml0aW9uIGZvciBlYWNoIHZpZXcgaW4gdGhlIGN1cnJlbnQgc3RhdGUuIEV2ZW5cbiAgICAgIC8vIHRob3VnaCB3ZSBjcmVhdGUgdGhlIGxvY2FscyBvYmplY3QgaXRzZWxmIG91dHNpZGUgcmVzb2x2ZVN0YXRlKCksIGl0IGlzIGluaXRpYWxseVxuICAgICAgLy8gZW1wdHkgYW5kIGdldHMgZmlsbGVkIGFzeW5jaHJvbm91c2x5LiBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHByb21pc2UgZm9yIHRoZVxuICAgICAgLy8gKGZ1bGx5IHJlc29sdmVkKSBjdXJyZW50IGxvY2FscywgYW5kIHBhc3MgdGhpcyBkb3duIHRoZSBjaGFpbi5cbiAgICAgIHZhciByZXNvbHZlZCA9ICRxLndoZW4obG9jYWxzKTtcblxuICAgICAgZm9yICh2YXIgbCA9IGtlZXA7IGwgPCB0b1BhdGgubGVuZ3RoOyBsKyssIHN0YXRlID0gdG9QYXRoW2xdKSB7XG4gICAgICAgIGxvY2FscyA9IHRvTG9jYWxzW2xdID0gaW5oZXJpdChsb2NhbHMpO1xuICAgICAgICByZXNvbHZlZCA9IHJlc29sdmVTdGF0ZShzdGF0ZSwgdG9QYXJhbXMsIHN0YXRlID09PSB0bywgcmVzb2x2ZWQsIGxvY2Fscywgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE9uY2UgZXZlcnl0aGluZyBpcyByZXNvbHZlZCwgd2UgYXJlIHJlYWR5IHRvIHBlcmZvcm0gdGhlIGFjdHVhbCB0cmFuc2l0aW9uXG4gICAgICAvLyBhbmQgcmV0dXJuIGEgcHJvbWlzZSBmb3IgdGhlIG5ldyBzdGF0ZS4gV2UgYWxzbyBrZWVwIHRyYWNrIG9mIHdoYXQgdGhlXG4gICAgICAvLyBjdXJyZW50IHByb21pc2UgaXMsIHNvIHRoYXQgd2UgY2FuIGRldGVjdCBvdmVybGFwcGluZyB0cmFuc2l0aW9ucyBhbmRcbiAgICAgIC8vIGtlZXAgb25seSB0aGUgb3V0Y29tZSBvZiB0aGUgbGFzdCB0cmFuc2l0aW9uLlxuICAgICAgdmFyIHRyYW5zaXRpb24gPSAkc3RhdGUudHJhbnNpdGlvbiA9IHJlc29sdmVkLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbCwgZW50ZXJpbmcsIGV4aXRpbmc7XG5cbiAgICAgICAgaWYgKCRzdGF0ZS50cmFuc2l0aW9uICE9PSB0cmFuc2l0aW9uKSByZXR1cm4gVHJhbnNpdGlvblN1cGVyc2VkZWQ7XG5cbiAgICAgICAgLy8gRXhpdCAnZnJvbScgc3RhdGVzIG5vdCBrZXB0XG4gICAgICAgIGZvciAobCA9IGZyb21QYXRoLmxlbmd0aCAtIDE7IGwgPj0ga2VlcDsgbC0tKSB7XG4gICAgICAgICAgZXhpdGluZyA9IGZyb21QYXRoW2xdO1xuICAgICAgICAgIGlmIChleGl0aW5nLnNlbGYub25FeGl0KSB7XG4gICAgICAgICAgICAkaW5qZWN0b3IuaW52b2tlKGV4aXRpbmcuc2VsZi5vbkV4aXQsIGV4aXRpbmcuc2VsZiwgZXhpdGluZy5sb2NhbHMuZ2xvYmFscyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4aXRpbmcubG9jYWxzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVudGVyICd0bycgc3RhdGVzIG5vdCBrZXB0XG4gICAgICAgIGZvciAobCA9IGtlZXA7IGwgPCB0b1BhdGgubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICBlbnRlcmluZyA9IHRvUGF0aFtsXTtcbiAgICAgICAgICBlbnRlcmluZy5sb2NhbHMgPSB0b0xvY2Fsc1tsXTtcbiAgICAgICAgICBpZiAoZW50ZXJpbmcuc2VsZi5vbkVudGVyKSB7XG4gICAgICAgICAgICAkaW5qZWN0b3IuaW52b2tlKGVudGVyaW5nLnNlbGYub25FbnRlciwgZW50ZXJpbmcuc2VsZiwgZW50ZXJpbmcubG9jYWxzLmdsb2JhbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJ1biBpdCBhZ2FpbiwgdG8gY2F0Y2ggYW55IHRyYW5zaXRpb25zIGluIGNhbGxiYWNrc1xuICAgICAgICBpZiAoJHN0YXRlLnRyYW5zaXRpb24gIT09IHRyYW5zaXRpb24pIHJldHVybiBUcmFuc2l0aW9uU3VwZXJzZWRlZDtcblxuICAgICAgICAvLyBVcGRhdGUgZ2xvYmFscyBpbiAkc3RhdGVcbiAgICAgICAgJHN0YXRlLiRjdXJyZW50ID0gdG87XG4gICAgICAgICRzdGF0ZS5jdXJyZW50ID0gdG8uc2VsZjtcbiAgICAgICAgJHN0YXRlLnBhcmFtcyA9IHRvUGFyYW1zO1xuICAgICAgICBjb3B5KCRzdGF0ZS5wYXJhbXMsICRzdGF0ZVBhcmFtcyk7XG4gICAgICAgICRzdGF0ZS50cmFuc2l0aW9uID0gbnVsbDtcblxuICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbiAmJiB0by5uYXZpZ2FibGUpIHtcbiAgICAgICAgICAkdXJsUm91dGVyLnB1c2godG8ubmF2aWdhYmxlLnVybCwgdG8ubmF2aWdhYmxlLmxvY2Fscy5nbG9iYWxzLiRzdGF0ZVBhcmFtcywge1xuICAgICAgICAgICAgJCRhdm9pZFJlc3luYzogdHJ1ZSwgcmVwbGFjZTogb3B0aW9ucy5sb2NhdGlvbiA9PT0gJ3JlcGxhY2UnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5ub3RpZnkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlIyRzdGF0ZUNoYW5nZVN1Y2Nlc3NcbiAgICAgICAgICogQGV2ZW50T2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICAgICAgICAgKiBAZXZlbnRUeXBlIGJyb2FkY2FzdCBvbiByb290IHNjb3BlXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBGaXJlZCBvbmNlIHRoZSBzdGF0ZSB0cmFuc2l0aW9uIGlzICoqY29tcGxldGUqKi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtTdGF0ZX0gdG9TdGF0ZSBUaGUgc3RhdGUgYmVpbmcgdHJhbnNpdGlvbmVkIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9QYXJhbXMgVGhlIHBhcmFtcyBzdXBwbGllZCB0byB0aGUgYHRvU3RhdGVgLlxuICAgICAgICAgKiBAcGFyYW0ge1N0YXRlfSBmcm9tU3RhdGUgVGhlIGN1cnJlbnQgc3RhdGUsIHByZS10cmFuc2l0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZnJvbVBhcmFtcyBUaGUgcGFyYW1zIHN1cHBsaWVkIHRvIHRoZSBgZnJvbVN0YXRlYC5cbiAgICAgICAgICovXG4gICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCckc3RhdGVDaGFuZ2VTdWNjZXNzJywgdG8uc2VsZiwgdG9QYXJhbXMsIGZyb20uc2VsZiwgZnJvbVBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgJHVybFJvdXRlci51cGRhdGUodHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuICRzdGF0ZS5jdXJyZW50O1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICgkc3RhdGUudHJhbnNpdGlvbiAhPT0gdHJhbnNpdGlvbikgcmV0dXJuIFRyYW5zaXRpb25TdXBlcnNlZGVkO1xuXG4gICAgICAgICRzdGF0ZS50cmFuc2l0aW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlIyRzdGF0ZUNoYW5nZUVycm9yXG4gICAgICAgICAqIEBldmVudE9mIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVcbiAgICAgICAgICogQGV2ZW50VHlwZSBicm9hZGNhc3Qgb24gcm9vdCBzY29wZVxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogRmlyZWQgd2hlbiBhbiAqKmVycm9yIG9jY3VycyoqIGR1cmluZyB0cmFuc2l0aW9uLiBJdCdzIGltcG9ydGFudCB0byBub3RlIHRoYXQgaWYgeW91XG4gICAgICAgICAqIGhhdmUgYW55IGVycm9ycyBpbiB5b3VyIHJlc29sdmUgZnVuY3Rpb25zIChqYXZhc2NyaXB0IGVycm9ycywgbm9uLWV4aXN0ZW50IHNlcnZpY2VzLCBldGMpXG4gICAgICAgICAqIHRoZXkgd2lsbCBub3QgdGhyb3cgdHJhZGl0aW9uYWxseS4gWW91IG11c3QgbGlzdGVuIGZvciB0aGlzICRzdGF0ZUNoYW5nZUVycm9yIGV2ZW50IHRvXG4gICAgICAgICAqIGNhdGNoICoqQUxMKiogZXJyb3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge1N0YXRlfSB0b1N0YXRlIFRoZSBzdGF0ZSBiZWluZyB0cmFuc2l0aW9uZWQgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b1BhcmFtcyBUaGUgcGFyYW1zIHN1cHBsaWVkIHRvIHRoZSBgdG9TdGF0ZWAuXG4gICAgICAgICAqIEBwYXJhbSB7U3RhdGV9IGZyb21TdGF0ZSBUaGUgY3VycmVudCBzdGF0ZSwgcHJlLXRyYW5zaXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tUGFyYW1zIFRoZSBwYXJhbXMgc3VwcGxpZWQgdG8gdGhlIGBmcm9tU3RhdGVgLlxuICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgcmVzb2x2ZSBlcnJvciBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBldnQgPSAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRzdGF0ZUNoYW5nZUVycm9yJywgdG8uc2VsZiwgdG9QYXJhbXMsIGZyb20uc2VsZiwgZnJvbVBhcmFtcywgZXJyb3IpO1xuXG4gICAgICAgIGlmICghZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICR1cmxSb3V0ZXIudXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdHJhbnNpdGlvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNpc1xuICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTaW1pbGFyIHRvIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI21ldGhvZHNfaW5jbHVkZXMgJHN0YXRlLmluY2x1ZGVzfSxcbiAgICAgKiBidXQgb25seSBjaGVja3MgZm9yIHRoZSBmdWxsIHN0YXRlIG5hbWUuIElmIHBhcmFtcyBpcyBzdXBwbGllZCB0aGVuIGl0IHdpbGwgYmVcbiAgICAgKiB0ZXN0ZWQgZm9yIHN0cmljdCBlcXVhbGl0eSBhZ2FpbnN0IHRoZSBjdXJyZW50IGFjdGl2ZSBwYXJhbXMgb2JqZWN0LCBzbyBhbGwgcGFyYW1zXG4gICAgICogbXVzdCBtYXRjaCB3aXRoIG5vbmUgbWlzc2luZyBhbmQgbm8gZXh0cmFzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiA8cHJlPlxuICAgICAqICRzdGF0ZS4kY3VycmVudC5uYW1lID0gJ2NvbnRhY3RzLmRldGFpbHMuaXRlbSc7XG4gICAgICpcbiAgICAgKiAvLyBhYnNvbHV0ZSBuYW1lXG4gICAgICogJHN0YXRlLmlzKCdjb250YWN0LmRldGFpbHMuaXRlbScpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaXMoY29udGFjdERldGFpbEl0ZW1TdGF0ZU9iamVjdCk7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqXG4gICAgICogLy8gcmVsYXRpdmUgbmFtZSAoLiBhbmQgXiksIHR5cGljYWxseSBmcm9tIGEgdGVtcGxhdGVcbiAgICAgKiAvLyBFLmcuIGZyb20gdGhlICdjb250YWN0cy5kZXRhaWxzJyB0ZW1wbGF0ZVxuICAgICAqIDxkaXYgbmctY2xhc3M9XCJ7aGlnaGxpZ2h0ZWQ6ICRzdGF0ZS5pcygnLml0ZW0nKX1cIj5JdGVtPC9kaXY+XG4gICAgICogPC9wcmU+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHN0YXRlT3JOYW1lIFRoZSBzdGF0ZSBuYW1lIChhYnNvbHV0ZSBvciByZWxhdGl2ZSkgb3Igc3RhdGUgb2JqZWN0IHlvdSdkIGxpa2UgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBwYXJhbXMgQSBwYXJhbSBvYmplY3QsIGUuZy4gYHtzZWN0aW9uSWQ6IHNlY3Rpb24uaWR9YCwgdGhhdCB5b3UnZCBsaWtlXG4gICAgICogdG8gdGVzdCBhZ2FpbnN0IHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QuICBUaGUgb3B0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtICoqYHJlbGF0aXZlYCoqIC0ge3N0cmluZ3xvYmplY3R9IC0gIElmIGBzdGF0ZU9yTmFtZWAgaXMgYSByZWxhdGl2ZSBzdGF0ZSBuYW1lIGFuZCBgb3B0aW9ucy5yZWxhdGl2ZWAgaXMgc2V0LCAuaXMgd2lsbFxuICAgICAqIHRlc3QgcmVsYXRpdmUgdG8gYG9wdGlvbnMucmVsYXRpdmVgIHN0YXRlIChvciBuYW1lKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgaXQgaXMgdGhlIHN0YXRlLlxuICAgICAqL1xuICAgICRzdGF0ZS5pcyA9IGZ1bmN0aW9uIGlzKHN0YXRlT3JOYW1lLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBleHRlbmQoeyByZWxhdGl2ZTogJHN0YXRlLiRjdXJyZW50IH0sIG9wdGlvbnMgfHwge30pO1xuICAgICAgdmFyIHN0YXRlID0gZmluZFN0YXRlKHN0YXRlT3JOYW1lLCBvcHRpb25zLnJlbGF0aXZlKTtcblxuICAgICAgaWYgKCFpc0RlZmluZWQoc3RhdGUpKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICAgIGlmICgkc3RhdGUuJGN1cnJlbnQgIT09IHN0YXRlKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgcmV0dXJuIHBhcmFtcyA/IGVxdWFsRm9yS2V5cyhzdGF0ZS5wYXJhbXMuJCR2YWx1ZXMocGFyYW1zKSwgJHN0YXRlUGFyYW1zKSA6IHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjaW5jbHVkZXNcbiAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZSBpcyBlcXVhbCB0byBvciBpcyB0aGUgY2hpbGQgb2YgdGhlXG4gICAgICogc3RhdGUgc3RhdGVOYW1lLiBJZiBhbnkgcGFyYW1zIGFyZSBwYXNzZWQgdGhlbiB0aGV5IHdpbGwgYmUgdGVzdGVkIGZvciBhIG1hdGNoIGFzIHdlbGwuXG4gICAgICogTm90IGFsbCB0aGUgcGFyYW1ldGVycyBuZWVkIHRvIGJlIHBhc3NlZCwganVzdCB0aGUgb25lcyB5b3UnZCBsaWtlIHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBQYXJ0aWFsIGFuZCByZWxhdGl2ZSBuYW1lc1xuICAgICAqIDxwcmU+XG4gICAgICogJHN0YXRlLiRjdXJyZW50Lm5hbWUgPSAnY29udGFjdHMuZGV0YWlscy5pdGVtJztcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIHBhcnRpYWwgbmFtZXNcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0c1wiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMuZGV0YWlsc1wiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMuZGV0YWlscy5pdGVtXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0cy5saXN0XCIpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiYWJvdXRcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFVzaW5nIHJlbGF0aXZlIG5hbWVzICguIGFuZCBeKSwgdHlwaWNhbGx5IGZyb20gYSB0ZW1wbGF0ZVxuICAgICAqIC8vIEUuZy4gZnJvbSB0aGUgJ2NvbnRhY3RzLmRldGFpbHMnIHRlbXBsYXRlXG4gICAgICogPGRpdiBuZy1jbGFzcz1cIntoaWdobGlnaHRlZDogJHN0YXRlLmluY2x1ZGVzKCcuaXRlbScpfVwiPkl0ZW08L2Rpdj5cbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqIEJhc2ljIGdsb2JiaW5nIHBhdHRlcm5zXG4gICAgICogPHByZT5cbiAgICAgKiAkc3RhdGUuJGN1cnJlbnQubmFtZSA9ICdjb250YWN0cy5kZXRhaWxzLml0ZW0udXJsJztcbiAgICAgKlxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy4qLipcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy4qKlwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKiouaXRlbS4qKlwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLml0ZW0udXJsXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKi51cmxcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy4qXCIpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiaXRlbS4qKlwiKTsgLy8gcmV0dXJucyBmYWxzZVxuICAgICAqIDwvcHJlPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlT3JOYW1lIEEgcGFydGlhbCBuYW1lLCByZWxhdGl2ZSBuYW1lLCBvciBnbG9iIHBhdHRlcm5cbiAgICAgKiB0byBiZSBzZWFyY2hlZCBmb3Igd2l0aGluIHRoZSBjdXJyZW50IHN0YXRlIG5hbWUuXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBwYXJhbXMgQSBwYXJhbSBvYmplY3QsIGUuZy4gYHtzZWN0aW9uSWQ6IHNlY3Rpb24uaWR9YCxcbiAgICAgKiB0aGF0IHlvdSdkIGxpa2UgdG8gdGVzdCBhZ2FpbnN0IHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QuICBUaGUgb3B0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtICoqYHJlbGF0aXZlYCoqIC0ge3N0cmluZ3xvYmplY3Q9fSAtICBJZiBgc3RhdGVPck5hbWVgIGlzIGEgcmVsYXRpdmUgc3RhdGUgcmVmZXJlbmNlIGFuZCBgb3B0aW9ucy5yZWxhdGl2ZWAgaXMgc2V0LFxuICAgICAqIC5pbmNsdWRlcyB3aWxsIHRlc3QgcmVsYXRpdmUgdG8gYG9wdGlvbnMucmVsYXRpdmVgIHN0YXRlIChvciBuYW1lKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgaXQgZG9lcyBpbmNsdWRlIHRoZSBzdGF0ZVxuICAgICAqL1xuICAgICRzdGF0ZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHN0YXRlT3JOYW1lLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBleHRlbmQoeyByZWxhdGl2ZTogJHN0YXRlLiRjdXJyZW50IH0sIG9wdGlvbnMgfHwge30pO1xuICAgICAgaWYgKGlzU3RyaW5nKHN0YXRlT3JOYW1lKSAmJiBpc0dsb2Ioc3RhdGVPck5hbWUpKSB7XG4gICAgICAgIGlmICghZG9lc1N0YXRlTWF0Y2hHbG9iKHN0YXRlT3JOYW1lKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZU9yTmFtZSA9ICRzdGF0ZS4kY3VycmVudC5uYW1lO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSBmaW5kU3RhdGUoc3RhdGVPck5hbWUsIG9wdGlvbnMucmVsYXRpdmUpO1xuICAgICAgaWYgKCFpc0RlZmluZWQoc3RhdGUpKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICAgIGlmICghaXNEZWZpbmVkKCRzdGF0ZS4kY3VycmVudC5pbmNsdWRlc1tzdGF0ZS5uYW1lXSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICByZXR1cm4gcGFyYW1zID8gZXF1YWxGb3JLZXlzKHN0YXRlLnBhcmFtcy4kJHZhbHVlcyhwYXJhbXMpLCAkc3RhdGVQYXJhbXMsIG9iamVjdEtleXMocGFyYW1zKSkgOiB0cnVlO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjaHJlZlxuICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBBIHVybCBnZW5lcmF0aW9uIG1ldGhvZCB0aGF0IHJldHVybnMgdGhlIGNvbXBpbGVkIHVybCBmb3IgdGhlIGdpdmVuIHN0YXRlIHBvcHVsYXRlZCB3aXRoIHRoZSBnaXZlbiBwYXJhbXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIDxwcmU+XG4gICAgICogZXhwZWN0KCRzdGF0ZS5ocmVmKFwiYWJvdXQucGVyc29uXCIsIHsgcGVyc29uOiBcImJvYlwiIH0pKS50b0VxdWFsKFwiL2Fib3V0L2JvYlwiKTtcbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gc3RhdGVPck5hbWUgVGhlIHN0YXRlIG5hbWUgb3Igc3RhdGUgb2JqZWN0IHlvdSdkIGxpa2UgdG8gZ2VuZXJhdGUgYSB1cmwgZnJvbS5cbiAgICAgKiBAcGFyYW0ge29iamVjdD19IHBhcmFtcyBBbiBvYmplY3Qgb2YgcGFyYW1ldGVyIHZhbHVlcyB0byBmaWxsIHRoZSBzdGF0ZSdzIHJlcXVpcmVkIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtICoqYGxvc3N5YCoqIC0ge2Jvb2xlYW49dHJ1ZX0gLSAgSWYgdHJ1ZSwgYW5kIGlmIHRoZXJlIGlzIG5vIHVybCBhc3NvY2lhdGVkIHdpdGggdGhlIHN0YXRlIHByb3ZpZGVkIGluIHRoZVxuICAgICAqICAgIGZpcnN0IHBhcmFtZXRlciwgdGhlbiB0aGUgY29uc3RydWN0ZWQgaHJlZiB1cmwgd2lsbCBiZSBidWlsdCBmcm9tIHRoZSBmaXJzdCBuYXZpZ2FibGUgYW5jZXN0b3IgKGFrYVxuICAgICAqICAgIGFuY2VzdG9yIHdpdGggYSB2YWxpZCB1cmwpLlxuICAgICAqIC0gKipgaW5oZXJpdGAqKiAtIHtib29sZWFuPXRydWV9LCBJZiBgdHJ1ZWAgd2lsbCBpbmhlcml0IHVybCBwYXJhbWV0ZXJzIGZyb20gY3VycmVudCB1cmwuXG4gICAgICogLSAqKmByZWxhdGl2ZWAqKiAtIHtvYmplY3Q9JHN0YXRlLiRjdXJyZW50fSwgV2hlbiB0cmFuc2l0aW9uaW5nIHdpdGggcmVsYXRpdmUgcGF0aCAoZS5nICdeJyksIFxuICAgICAqICAgIGRlZmluZXMgd2hpY2ggc3RhdGUgdG8gYmUgcmVsYXRpdmUgZnJvbS5cbiAgICAgKiAtICoqYGFic29sdXRlYCoqIC0ge2Jvb2xlYW49ZmFsc2V9LCAgSWYgdHJ1ZSB3aWxsIGdlbmVyYXRlIGFuIGFic29sdXRlIHVybCwgZS5nLiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vZnVsbHVybFwiLlxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbXBpbGVkIHN0YXRlIHVybFxuICAgICAqL1xuICAgICRzdGF0ZS5ocmVmID0gZnVuY3Rpb24gaHJlZihzdGF0ZU9yTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gZXh0ZW5kKHtcbiAgICAgICAgbG9zc3k6ICAgIHRydWUsXG4gICAgICAgIGluaGVyaXQ6ICB0cnVlLFxuICAgICAgICBhYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgIHJlbGF0aXZlOiAkc3RhdGUuJGN1cnJlbnRcbiAgICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgICB2YXIgc3RhdGUgPSBmaW5kU3RhdGUoc3RhdGVPck5hbWUsIG9wdGlvbnMucmVsYXRpdmUpO1xuXG4gICAgICBpZiAoIWlzRGVmaW5lZChzdGF0ZSkpIHJldHVybiBudWxsO1xuICAgICAgaWYgKG9wdGlvbnMuaW5oZXJpdCkgcGFyYW1zID0gaW5oZXJpdFBhcmFtcygkc3RhdGVQYXJhbXMsIHBhcmFtcyB8fCB7fSwgJHN0YXRlLiRjdXJyZW50LCBzdGF0ZSk7XG4gICAgICBcbiAgICAgIHZhciBuYXYgPSAoc3RhdGUgJiYgb3B0aW9ucy5sb3NzeSkgPyBzdGF0ZS5uYXZpZ2FibGUgOiBzdGF0ZTtcblxuICAgICAgaWYgKCFuYXYgfHwgbmF2LnVybCA9PT0gdW5kZWZpbmVkIHx8IG5hdi51cmwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gJHVybFJvdXRlci5ocmVmKG5hdi51cmwsIGZpbHRlckJ5S2V5cyhzdGF0ZS5wYXJhbXMuJCRrZXlzKCkuY29uY2F0KCcjJyksIHBhcmFtcyB8fCB7fSksIHtcbiAgICAgICAgYWJzb2x1dGU6IG9wdGlvbnMuYWJzb2x1dGVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI2dldFxuICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYW55IHNwZWNpZmljIHN0YXRlIG9yIGFsbCBzdGF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3Q9fSBzdGF0ZU9yTmFtZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUpIElmIHByb3ZpZGVkLCB3aWxsIG9ubHkgZ2V0IHRoZSBjb25maWcgZm9yXG4gICAgICogdGhlIHJlcXVlc3RlZCBzdGF0ZS4gSWYgbm90IHByb3ZpZGVkLCByZXR1cm5zIGFuIGFycmF5IG9mIEFMTCBzdGF0ZSBjb25maWdzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdD19IGNvbnRleHQgV2hlbiBzdGF0ZU9yTmFtZSBpcyBhIHJlbGF0aXZlIHN0YXRlIHJlZmVyZW5jZSwgdGhlIHN0YXRlIHdpbGwgYmUgcmV0cmlldmVkIHJlbGF0aXZlIHRvIGNvbnRleHQuXG4gICAgICogQHJldHVybnMge09iamVjdHxBcnJheX0gU3RhdGUgY29uZmlndXJhdGlvbiBvYmplY3Qgb3IgYXJyYXkgb2YgYWxsIG9iamVjdHMuXG4gICAgICovXG4gICAgJHN0YXRlLmdldCA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBtYXAob2JqZWN0S2V5cyhzdGF0ZXMpLCBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBzdGF0ZXNbbmFtZV0uc2VsZjsgfSk7XG4gICAgICB2YXIgc3RhdGUgPSBmaW5kU3RhdGUoc3RhdGVPck5hbWUsIGNvbnRleHQgfHwgJHN0YXRlLiRjdXJyZW50KTtcbiAgICAgIHJldHVybiAoc3RhdGUgJiYgc3RhdGUuc2VsZikgPyBzdGF0ZS5zZWxmIDogbnVsbDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVN0YXRlKHN0YXRlLCBwYXJhbXMsIHBhcmFtc0FyZUZpbHRlcmVkLCBpbmhlcml0ZWQsIGRzdCwgb3B0aW9ucykge1xuICAgICAgLy8gTWFrZSBhIHJlc3RyaWN0ZWQgJHN0YXRlUGFyYW1zIHdpdGggb25seSB0aGUgcGFyYW1ldGVycyB0aGF0IGFwcGx5IHRvIHRoaXMgc3RhdGUgaWZcbiAgICAgIC8vIG5lY2Vzc2FyeS4gSW4gYWRkaXRpb24gdG8gYmVpbmcgYXZhaWxhYmxlIHRvIHRoZSBjb250cm9sbGVyIGFuZCBvbkVudGVyL29uRXhpdCBjYWxsYmFja3MsXG4gICAgICAvLyB3ZSBhbHNvIG5lZWQgJHN0YXRlUGFyYW1zIHRvIGJlIGF2YWlsYWJsZSBmb3IgYW55ICRpbmplY3RvciBjYWxscyB3ZSBtYWtlIGR1cmluZyB0aGVcbiAgICAgIC8vIGRlcGVuZGVuY3kgcmVzb2x1dGlvbiBwcm9jZXNzLlxuICAgICAgdmFyICRzdGF0ZVBhcmFtcyA9IChwYXJhbXNBcmVGaWx0ZXJlZCkgPyBwYXJhbXMgOiBmaWx0ZXJCeUtleXMoc3RhdGUucGFyYW1zLiQka2V5cygpLCBwYXJhbXMpO1xuICAgICAgdmFyIGxvY2FscyA9IHsgJHN0YXRlUGFyYW1zOiAkc3RhdGVQYXJhbXMgfTtcblxuICAgICAgLy8gUmVzb2x2ZSAnZ2xvYmFsJyBkZXBlbmRlbmNpZXMgZm9yIHRoZSBzdGF0ZSwgaS5lLiB0aG9zZSBub3Qgc3BlY2lmaWMgdG8gYSB2aWV3LlxuICAgICAgLy8gV2UncmUgYWxzbyBpbmNsdWRpbmcgJHN0YXRlUGFyYW1zIGluIHRoaXM7IHRoYXQgd2F5IHRoZSBwYXJhbWV0ZXJzIGFyZSByZXN0cmljdGVkXG4gICAgICAvLyB0byB0aGUgc2V0IHRoYXQgc2hvdWxkIGJlIHZpc2libGUgdG8gdGhlIHN0YXRlLCBhbmQgYXJlIGluZGVwZW5kZW50IG9mIHdoZW4gd2UgdXBkYXRlXG4gICAgICAvLyB0aGUgZ2xvYmFsICRzdGF0ZSBhbmQgJHN0YXRlUGFyYW1zIHZhbHVlcy5cbiAgICAgIGRzdC5yZXNvbHZlID0gJHJlc29sdmUucmVzb2x2ZShzdGF0ZS5yZXNvbHZlLCBsb2NhbHMsIGRzdC5yZXNvbHZlLCBzdGF0ZSk7XG4gICAgICB2YXIgcHJvbWlzZXMgPSBbZHN0LnJlc29sdmUudGhlbihmdW5jdGlvbiAoZ2xvYmFscykge1xuICAgICAgICBkc3QuZ2xvYmFscyA9IGdsb2JhbHM7XG4gICAgICB9KV07XG4gICAgICBpZiAoaW5oZXJpdGVkKSBwcm9taXNlcy5wdXNoKGluaGVyaXRlZCk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVWaWV3cygpIHtcbiAgICAgICAgdmFyIHZpZXdzUHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAvLyBSZXNvbHZlIHRlbXBsYXRlIGFuZCBkZXBlbmRlbmNpZXMgZm9yIGFsbCB2aWV3cy5cbiAgICAgICAgZm9yRWFjaChzdGF0ZS52aWV3cywgZnVuY3Rpb24gKHZpZXcsIG5hbWUpIHtcbiAgICAgICAgICB2YXIgaW5qZWN0YWJsZXMgPSAodmlldy5yZXNvbHZlICYmIHZpZXcucmVzb2x2ZSAhPT0gc3RhdGUucmVzb2x2ZSA/IHZpZXcucmVzb2x2ZSA6IHt9KTtcbiAgICAgICAgICBpbmplY3RhYmxlcy4kdGVtcGxhdGUgPSBbIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAkdmlldy5sb2FkKG5hbWUsIHsgdmlldzogdmlldywgbG9jYWxzOiBkc3QuZ2xvYmFscywgcGFyYW1zOiAkc3RhdGVQYXJhbXMsIG5vdGlmeTogb3B0aW9ucy5ub3RpZnkgfSkgfHwgJyc7XG4gICAgICAgICAgfV07XG5cbiAgICAgICAgICB2aWV3c1Byb21pc2VzLnB1c2goJHJlc29sdmUucmVzb2x2ZShpbmplY3RhYmxlcywgZHN0Lmdsb2JhbHMsIGRzdC5yZXNvbHZlLCBzdGF0ZSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBSZWZlcmVuY2VzIHRvIHRoZSBjb250cm9sbGVyIChvbmx5IGluc3RhbnRpYXRlZCBhdCBsaW5rIHRpbWUpXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2aWV3LmNvbnRyb2xsZXJQcm92aWRlcikgfHwgaXNBcnJheSh2aWV3LmNvbnRyb2xsZXJQcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgdmFyIGluamVjdExvY2FscyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBpbmplY3RhYmxlcywgZHN0Lmdsb2JhbHMpO1xuICAgICAgICAgICAgICByZXN1bHQuJCRjb250cm9sbGVyID0gJGluamVjdG9yLmludm9rZSh2aWV3LmNvbnRyb2xsZXJQcm92aWRlciwgbnVsbCwgaW5qZWN0TG9jYWxzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdC4kJGNvbnRyb2xsZXIgPSB2aWV3LmNvbnRyb2xsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm92aWRlIGFjY2VzcyB0byB0aGUgc3RhdGUgaXRzZWxmIGZvciBpbnRlcm5hbCB1c2VcbiAgICAgICAgICAgIHJlc3VsdC4kJHN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICByZXN1bHQuJCRjb250cm9sbGVyQXMgPSB2aWV3LmNvbnRyb2xsZXJBcztcbiAgICAgICAgICAgIGRzdFtuYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAkcS5hbGwodmlld3NQcm9taXNlcykudGhlbihmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiBkc3QuZ2xvYmFscztcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhaXQgZm9yIGFsbCB0aGUgcHJvbWlzZXMgYW5kIHRoZW4gcmV0dXJuIHRoZSBhY3RpdmF0aW9uIG9iamVjdFxuICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihyZXNvbHZlVmlld3MpLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICRzdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZFNraXBSZWxvYWQodG8sIHRvUGFyYW1zLCBmcm9tLCBmcm9tUGFyYW1zLCBsb2NhbHMsIG9wdGlvbnMpIHtcbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGVyZSBhcmUgbm8gZGlmZmVyZW5jZXMgaW4gbm9uLXNlYXJjaCAocGF0aC9vYmplY3QpIHBhcmFtcywgZmFsc2UgaWYgdGhlcmUgYXJlIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gbm9uU2VhcmNoUGFyYW1zRXF1YWwoZnJvbUFuZFRvU3RhdGUsIGZyb21QYXJhbXMsIHRvUGFyYW1zKSB7XG4gICAgICAvLyBJZGVudGlmeSB3aGV0aGVyIGFsbCB0aGUgcGFyYW1ldGVycyB0aGF0IGRpZmZlciBiZXR3ZWVuIGBmcm9tUGFyYW1zYCBhbmQgYHRvUGFyYW1zYCB3ZXJlIHNlYXJjaCBwYXJhbXMuXG4gICAgICBmdW5jdGlvbiBub3RTZWFyY2hQYXJhbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21BbmRUb1N0YXRlLnBhcmFtc1trZXldLmxvY2F0aW9uICE9IFwic2VhcmNoXCI7XG4gICAgICB9XG4gICAgICB2YXIgbm9uUXVlcnlQYXJhbUtleXMgPSBmcm9tQW5kVG9TdGF0ZS5wYXJhbXMuJCRrZXlzKCkuZmlsdGVyKG5vdFNlYXJjaFBhcmFtKTtcbiAgICAgIHZhciBub25RdWVyeVBhcmFtcyA9IHBpY2suYXBwbHkoe30sIFtmcm9tQW5kVG9TdGF0ZS5wYXJhbXNdLmNvbmNhdChub25RdWVyeVBhcmFtS2V5cykpO1xuICAgICAgdmFyIG5vblF1ZXJ5UGFyYW1TZXQgPSBuZXcgJCRVTUZQLlBhcmFtU2V0KG5vblF1ZXJ5UGFyYW1zKTtcbiAgICAgIHJldHVybiBub25RdWVyeVBhcmFtU2V0LiQkZXF1YWxzKGZyb21QYXJhbXMsIHRvUGFyYW1zKTtcbiAgICB9XG5cbiAgICAvLyBJZiByZWxvYWQgd2FzIG5vdCBleHBsaWNpdGx5IHJlcXVlc3RlZFxuICAgIC8vIGFuZCB3ZSdyZSB0cmFuc2l0aW9uaW5nIHRvIHRoZSBzYW1lIHN0YXRlIHdlJ3JlIGFscmVhZHkgaW5cbiAgICAvLyBhbmQgICAgdGhlIGxvY2FscyBkaWRuJ3QgY2hhbmdlXG4gICAgLy8gICAgIG9yIHRoZXkgY2hhbmdlZCBpbiBhIHdheSB0aGF0IGRvZXNuJ3QgbWVyaXQgcmVsb2FkaW5nXG4gICAgLy8gICAgICAgIChyZWxvYWRPblBhcmFtczpmYWxzZSwgb3IgcmVsb2FkT25TZWFyY2guZmFsc2UgYW5kIG9ubHkgc2VhcmNoIHBhcmFtcyBjaGFuZ2VkKVxuICAgIC8vIFRoZW4gcmV0dXJuIHRydWUuXG4gICAgaWYgKCFvcHRpb25zLnJlbG9hZCAmJiB0byA9PT0gZnJvbSAmJlxuICAgICAgKGxvY2FscyA9PT0gZnJvbS5sb2NhbHMgfHwgKHRvLnNlbGYucmVsb2FkT25TZWFyY2ggPT09IGZhbHNlICYmIG5vblNlYXJjaFBhcmFtc0VxdWFsKGZyb20sIGZyb21QYXJhbXMsIHRvUGFyYW1zKSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXG4gIC5mYWN0b3J5KCckc3RhdGVQYXJhbXMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB7fTsgfSlcbiAgLnByb3ZpZGVyKCckc3RhdGUnLCAkU3RhdGVQcm92aWRlcik7XG5cblxuJFZpZXdQcm92aWRlci4kaW5qZWN0ID0gW107XG5mdW5jdGlvbiAkVmlld1Byb3ZpZGVyKCkge1xuXG4gIHRoaXMuJGdldCA9ICRnZXQ7XG4gIC8qKlxuICAgKiBAbmdkb2Mgb2JqZWN0XG4gICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kdmlld1xuICAgKlxuICAgKiBAcmVxdWlyZXMgdWkucm91dGVyLnV0aWwuJHRlbXBsYXRlRmFjdG9yeVxuICAgKiBAcmVxdWlyZXMgJHJvb3RTY29wZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICovXG4gICRnZXQuJGluamVjdCA9IFsnJHJvb3RTY29wZScsICckdGVtcGxhdGVGYWN0b3J5J107XG4gIGZ1bmN0aW9uICRnZXQoICAgJHJvb3RTY29wZSwgICAkdGVtcGxhdGVGYWN0b3J5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vICR2aWV3LmxvYWQoJ2Z1bGwudmlld05hbWUnLCB7IHRlbXBsYXRlOiAuLi4sIGNvbnRyb2xsZXI6IC4uLiwgcmVzb2x2ZTogLi4uLCBhc3luYzogZmFsc2UsIHBhcmFtczogLi4uIH0pXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiR2aWV3I2xvYWRcbiAgICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHZpZXdcbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBvcHRpb24gb2JqZWN0LlxuICAgICAgICovXG4gICAgICBsb2FkOiBmdW5jdGlvbiBsb2FkKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgdGVtcGxhdGU6IG51bGwsIGNvbnRyb2xsZXI6IG51bGwsIHZpZXc6IG51bGwsIGxvY2FsczogbnVsbCwgbm90aWZ5OiB0cnVlLCBhc3luYzogdHJ1ZSwgcGFyYW1zOiB7fVxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zID0gZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAob3B0aW9ucy52aWV3KSB7XG4gICAgICAgICAgcmVzdWx0ID0gJHRlbXBsYXRlRmFjdG9yeS5mcm9tQ29uZmlnKG9wdGlvbnMudmlldywgb3B0aW9ucy5wYXJhbXMsIG9wdGlvbnMubG9jYWxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLnByb3ZpZGVyKCckdmlldycsICRWaWV3UHJvdmlkZXIpO1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kdWlWaWV3U2Nyb2xsUHJvdmlkZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVyIHRoYXQgcmV0dXJucyB0aGUge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kdWlWaWV3U2Nyb2xsfSBzZXJ2aWNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiAkVmlld1Njcm9sbFByb3ZpZGVyKCkge1xuXG4gIHZhciB1c2VBbmNob3JTY3JvbGwgPSBmYWxzZTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kdWlWaWV3U2Nyb2xsUHJvdmlkZXIjdXNlQW5jaG9yU2Nyb2xsXG4gICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHVpVmlld1Njcm9sbFByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXZlcnRzIGJhY2sgdG8gdXNpbmcgdGhlIGNvcmUgW2AkYW5jaG9yU2Nyb2xsYF0oaHR0cDovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmcuJGFuY2hvclNjcm9sbCkgc2VydmljZSBmb3JcbiAgICogc2Nyb2xsaW5nIGJhc2VkIG9uIHRoZSB1cmwgYW5jaG9yLlxuICAgKi9cbiAgdGhpcy51c2VBbmNob3JTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdXNlQW5jaG9yU2Nyb2xsID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIG9iamVjdFxuICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHVpVmlld1Njcm9sbFxuICAgKlxuICAgKiBAcmVxdWlyZXMgJGFuY2hvclNjcm9sbFxuICAgKiBAcmVxdWlyZXMgJHRpbWVvdXRcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFdoZW4gY2FsbGVkIHdpdGggYSBqcUxpdGUgZWxlbWVudCwgaXQgc2Nyb2xscyB0aGUgZWxlbWVudCBpbnRvIHZpZXcgKGFmdGVyIGFcbiAgICogYCR0aW1lb3V0YCBzbyB0aGUgRE9NIGhhcyB0aW1lIHRvIHJlZnJlc2gpLlxuICAgKlxuICAgKiBJZiB5b3UgcHJlZmVyIHRvIHJlbHkgb24gYCRhbmNob3JTY3JvbGxgIHRvIHNjcm9sbCB0aGUgdmlldyB0byB0aGUgYW5jaG9yLFxuICAgKiB0aGlzIGNhbiBiZSBlbmFibGVkIGJ5IGNhbGxpbmcge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kdWlWaWV3U2Nyb2xsUHJvdmlkZXIjbWV0aG9kc191c2VBbmNob3JTY3JvbGwgYCR1aVZpZXdTY3JvbGxQcm92aWRlci51c2VBbmNob3JTY3JvbGwoKWB9LlxuICAgKi9cbiAgdGhpcy4kZ2V0ID0gWyckYW5jaG9yU2Nyb2xsJywgJyR0aW1lb3V0JywgZnVuY3Rpb24gKCRhbmNob3JTY3JvbGwsICR0aW1lb3V0KSB7XG4gICAgaWYgKHVzZUFuY2hvclNjcm9sbCkge1xuICAgICAgcmV0dXJuICRhbmNob3JTY3JvbGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgkZWxlbWVudCkge1xuICAgICAgcmV0dXJuICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJGVsZW1lbnRbMF0uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgIH0sIDAsIGZhbHNlKTtcbiAgICB9O1xuICB9XTtcbn1cblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLnByb3ZpZGVyKCckdWlWaWV3U2Nyb2xsJywgJFZpZXdTY3JvbGxQcm92aWRlcik7XG5cbnZhciBuZ01ham9yVmVyID0gYW5ndWxhci52ZXJzaW9uLm1ham9yO1xudmFyIG5nTWlub3JWZXIgPSBhbmd1bGFyLnZlcnNpb24ubWlub3I7XG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlld1xuICpcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG4gKiBAcmVxdWlyZXMgJGNvbXBpbGVcbiAqIEByZXF1aXJlcyAkY29udHJvbGxlclxuICogQHJlcXVpcmVzICRpbmplY3RvclxuICogQHJlcXVpcmVzIHVpLnJvdXRlci5zdGF0ZS4kdWlWaWV3U2Nyb2xsXG4gKiBAcmVxdWlyZXMgJGRvY3VtZW50XG4gKlxuICogQHJlc3RyaWN0IEVDQVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIHVpLXZpZXcgZGlyZWN0aXZlIHRlbGxzICRzdGF0ZSB3aGVyZSB0byBwbGFjZSB5b3VyIHRlbXBsYXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgQSB2aWV3IG5hbWUuIFRoZSBuYW1lIHNob3VsZCBiZSB1bmlxdWUgYW1vbmdzdCB0aGUgb3RoZXIgdmlld3MgaW4gdGhlXG4gKiBzYW1lIHN0YXRlLiBZb3UgY2FuIGhhdmUgdmlld3Mgb2YgdGhlIHNhbWUgbmFtZSB0aGF0IGxpdmUgaW4gZGlmZmVyZW50IHN0YXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IGF1dG9zY3JvbGwgSXQgYWxsb3dzIHlvdSB0byBzZXQgdGhlIHNjcm9sbCBiZWhhdmlvciBvZiB0aGUgYnJvd3NlciB3aW5kb3dcbiAqIHdoZW4gYSB2aWV3IGlzIHBvcHVsYXRlZC4gQnkgZGVmYXVsdCwgJGFuY2hvclNjcm9sbCBpcyBvdmVycmlkZGVuIGJ5IHVpLXJvdXRlcidzIGN1c3RvbSBzY3JvbGxcbiAqIHNlcnZpY2UsIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHVpVmlld1Njcm9sbH0uIFRoaXMgY3VzdG9tIHNlcnZpY2UgbGV0J3MgeW91XG4gKiBzY3JvbGwgdWktdmlldyBlbGVtZW50cyBpbnRvIHZpZXcgd2hlbiB0aGV5IGFyZSBwb3B1bGF0ZWQgZHVyaW5nIGEgc3RhdGUgYWN0aXZhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG5vYW5pbWF0aW9uIElmIHRydXRoeSwgdGhlIG5vbi1hbmltYXRlZCByZW5kZXJlciB3aWxsIGJlIHNlbGVjdGVkIChubyBhbmltYXRpb25zXG4gKiB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHVpLXZpZXcpXG4gKlxuICogKk5vdGU6IFRvIHJldmVydCBiYWNrIHRvIG9sZCBbYCRhbmNob3JTY3JvbGxgXShodHRwOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZy4kYW5jaG9yU2Nyb2xsKVxuICogZnVuY3Rpb25hbGl0eSwgY2FsbCBgJHVpVmlld1Njcm9sbFByb3ZpZGVyLnVzZUFuY2hvclNjcm9sbCgpYC4qXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBvbmxvYWQgRXhwcmVzc2lvbiB0byBldmFsdWF0ZSB3aGVuZXZlciB0aGUgdmlldyB1cGRhdGVzLlxuICogXG4gKiBAZXhhbXBsZVxuICogQSB2aWV3IGNhbiBiZSB1bm5hbWVkIG9yIG5hbWVkLiBcbiAqIDxwcmU+XG4gKiA8IS0tIFVubmFtZWQgLS0+XG4gKiA8ZGl2IHVpLXZpZXc+PC9kaXY+IFxuICogXG4gKiA8IS0tIE5hbWVkIC0tPlxuICogPGRpdiB1aS12aWV3PVwidmlld05hbWVcIj48L2Rpdj5cbiAqIDwvcHJlPlxuICpcbiAqIFlvdSBjYW4gb25seSBoYXZlIG9uZSB1bm5hbWVkIHZpZXcgd2l0aGluIGFueSB0ZW1wbGF0ZSAob3Igcm9vdCBodG1sKS4gSWYgeW91IGFyZSBvbmx5IHVzaW5nIGEgXG4gKiBzaW5nbGUgdmlldyBhbmQgaXQgaXMgdW5uYW1lZCB0aGVuIHlvdSBjYW4gcG9wdWxhdGUgaXQgbGlrZSBzbzpcbiAqIDxwcmU+XG4gKiA8ZGl2IHVpLXZpZXc+PC9kaXY+IFxuICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lXCIsIHtcbiAqICAgdGVtcGxhdGU6IFwiPGgxPkhFTExPITwvaDE+XCJcbiAqIH0pXG4gKiA8L3ByZT5cbiAqIFxuICogVGhlIGFib3ZlIGlzIGEgY29udmVuaWVudCBzaG9ydGN1dCBlcXVpdmFsZW50IHRvIHNwZWNpZnlpbmcgeW91ciB2aWV3IGV4cGxpY2l0bHkgd2l0aCB0aGUge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVQcm92aWRlciN2aWV3cyBgdmlld3NgfVxuICogY29uZmlnIHByb3BlcnR5LCBieSBuYW1lLCBpbiB0aGlzIGNhc2UgYW4gZW1wdHkgbmFtZTpcbiAqIDxwcmU+XG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB2aWV3czoge1xuICogICAgIFwiXCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxoMT5IRUxMTyE8L2gxPlwiXG4gKiAgICAgfVxuICogICB9ICAgIFxuICogfSlcbiAqIDwvcHJlPlxuICogXG4gKiBCdXQgdHlwaWNhbGx5IHlvdSdsbCBvbmx5IHVzZSB0aGUgdmlld3MgcHJvcGVydHkgaWYgeW91IG5hbWUgeW91ciB2aWV3IG9yIGhhdmUgbW9yZSB0aGFuIG9uZSB2aWV3IFxuICogaW4gdGhlIHNhbWUgdGVtcGxhdGUuIFRoZXJlJ3Mgbm90IHJlYWxseSBhIGNvbXBlbGxpbmcgcmVhc29uIHRvIG5hbWUgYSB2aWV3IGlmIGl0cyB0aGUgb25seSBvbmUsIFxuICogYnV0IHlvdSBjb3VsZCBpZiB5b3Ugd2FudGVkLCBsaWtlIHNvOlxuICogPHByZT5cbiAqIDxkaXYgdWktdmlldz1cIm1haW5cIj48L2Rpdj5cbiAqIDwvcHJlPiBcbiAqIDxwcmU+XG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB2aWV3czoge1xuICogICAgIFwibWFpblwiOiB7XG4gKiAgICAgICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuICogICAgIH1cbiAqICAgfSAgICBcbiAqIH0pXG4gKiA8L3ByZT5cbiAqIFxuICogUmVhbGx5IHRob3VnaCwgeW91J2xsIHVzZSB2aWV3cyB0byBzZXQgdXAgbXVsdGlwbGUgdmlld3M6XG4gKiA8cHJlPlxuICogPGRpdiB1aS12aWV3PjwvZGl2PlxuICogPGRpdiB1aS12aWV3PVwiY2hhcnRcIj48L2Rpdj4gXG4gKiA8ZGl2IHVpLXZpZXc9XCJkYXRhXCI+PC9kaXY+IFxuICogPC9wcmU+XG4gKiBcbiAqIDxwcmU+XG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB2aWV3czoge1xuICogICAgIFwiXCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxoMT5IRUxMTyE8L2gxPlwiXG4gKiAgICAgfSxcbiAqICAgICBcImNoYXJ0XCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxjaGFydF90aGluZy8+XCJcbiAqICAgICB9LFxuICogICAgIFwiZGF0YVwiOiB7XG4gKiAgICAgICB0ZW1wbGF0ZTogXCI8ZGF0YV90aGluZy8+XCJcbiAqICAgICB9XG4gKiAgIH0gICAgXG4gKiB9KVxuICogPC9wcmU+XG4gKlxuICogRXhhbXBsZXMgZm9yIGBhdXRvc2Nyb2xsYDpcbiAqXG4gKiA8cHJlPlxuICogPCEtLSBJZiBhdXRvc2Nyb2xsIHByZXNlbnQgd2l0aCBubyBleHByZXNzaW9uLFxuICogICAgICB0aGVuIHNjcm9sbCB1aS12aWV3IGludG8gdmlldyAtLT5cbiAqIDx1aS12aWV3IGF1dG9zY3JvbGwvPlxuICpcbiAqIDwhLS0gSWYgYXV0b3Njcm9sbCBwcmVzZW50IHdpdGggdmFsaWQgZXhwcmVzc2lvbixcbiAqICAgICAgdGhlbiBzY3JvbGwgdWktdmlldyBpbnRvIHZpZXcgaWYgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1ZSAtLT5cbiAqIDx1aS12aWV3IGF1dG9zY3JvbGw9J3RydWUnLz5cbiAqIDx1aS12aWV3IGF1dG9zY3JvbGw9J2ZhbHNlJy8+XG4gKiA8dWktdmlldyBhdXRvc2Nyb2xsPSdzY29wZVZhcmlhYmxlJy8+XG4gKiA8L3ByZT5cbiAqL1xuJFZpZXdEaXJlY3RpdmUuJGluamVjdCA9IFsnJHN0YXRlJywgJyRpbmplY3RvcicsICckdWlWaWV3U2Nyb2xsJywgJyRpbnRlcnBvbGF0ZSddO1xuZnVuY3Rpb24gJFZpZXdEaXJlY3RpdmUoICAgJHN0YXRlLCAgICRpbmplY3RvciwgICAkdWlWaWV3U2Nyb2xsLCAgICRpbnRlcnBvbGF0ZSkge1xuXG4gIGZ1bmN0aW9uIGdldFNlcnZpY2UoKSB7XG4gICAgcmV0dXJuICgkaW5qZWN0b3IuaGFzKSA/IGZ1bmN0aW9uKHNlcnZpY2UpIHtcbiAgICAgIHJldHVybiAkaW5qZWN0b3IuaGFzKHNlcnZpY2UpID8gJGluamVjdG9yLmdldChzZXJ2aWNlKSA6IG51bGw7XG4gICAgfSA6IGZ1bmN0aW9uKHNlcnZpY2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAkaW5qZWN0b3IuZ2V0KHNlcnZpY2UpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHNlcnZpY2UgPSBnZXRTZXJ2aWNlKCksXG4gICAgICAkYW5pbWF0b3IgPSBzZXJ2aWNlKCckYW5pbWF0b3InKSxcbiAgICAgICRhbmltYXRlID0gc2VydmljZSgnJGFuaW1hdGUnKTtcblxuICAvLyBSZXR1cm5zIGEgc2V0IG9mIERPTSBtYW5pcHVsYXRpb24gZnVuY3Rpb25zIGJhc2VkIG9uIHdoaWNoIEFuZ3VsYXIgdmVyc2lvblxuICAvLyBpdCBzaG91bGQgdXNlXG4gIGZ1bmN0aW9uIGdldFJlbmRlcmVyKGF0dHJzLCBzY29wZSkge1xuICAgIHZhciBzdGF0aWNzID0ge1xuICAgICAgZW50ZXI6IGZ1bmN0aW9uIChlbGVtZW50LCB0YXJnZXQsIGNiKSB7IHRhcmdldC5hZnRlcihlbGVtZW50KTsgY2IoKTsgfSxcbiAgICAgIGxlYXZlOiBmdW5jdGlvbiAoZWxlbWVudCwgY2IpIHsgZWxlbWVudC5yZW1vdmUoKTsgY2IoKTsgfVxuICAgIH07XG5cbiAgICBpZiAoISFhdHRycy5ub2FuaW1hdGlvbikgcmV0dXJuIHN0YXRpY3M7XG5cbiAgICBmdW5jdGlvbiBhbmltRW5hYmxlZChlbGVtZW50KSB7XG4gICAgICBpZiAobmdNYWpvclZlciA9PT0gMSAmJiBuZ01pbm9yVmVyID49IDQpIHJldHVybiAhISRhbmltYXRlLmVuYWJsZWQoZWxlbWVudCk7XG4gICAgICBpZiAobmdNYWpvclZlciA9PT0gMSAmJiBuZ01pbm9yVmVyID49IDIpIHJldHVybiAhISRhbmltYXRlLmVuYWJsZWQoKTtcbiAgICAgIHJldHVybiAoISEkYW5pbWF0b3IpO1xuICAgIH1cblxuICAgIC8vIG5nIDEuMitcbiAgICBpZiAoJGFuaW1hdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudGVyOiBmdW5jdGlvbihlbGVtZW50LCB0YXJnZXQsIGNiKSB7XG4gICAgICAgICAgaWYgKCFhbmltRW5hYmxlZChlbGVtZW50KSkge1xuICAgICAgICAgICAgc3RhdGljcy5lbnRlcihlbGVtZW50LCB0YXJnZXQsIGNiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIudmVyc2lvbi5taW5vciA+IDIpIHtcbiAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIG51bGwsIHRhcmdldCkudGhlbihjYik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIG51bGwsIHRhcmdldCwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uKGVsZW1lbnQsIGNiKSB7XG4gICAgICAgICAgaWYgKCFhbmltRW5hYmxlZChlbGVtZW50KSkge1xuICAgICAgICAgICAgc3RhdGljcy5sZWF2ZShlbGVtZW50LCBjYik7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLnZlcnNpb24ubWlub3IgPiAyKSB7XG4gICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShlbGVtZW50KS50aGVuKGNiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGFuaW1hdGUubGVhdmUoZWxlbWVudCwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBuZyAxLjEuNVxuICAgIGlmICgkYW5pbWF0b3IpIHtcbiAgICAgIHZhciBhbmltYXRlID0gJGFuaW1hdG9yICYmICRhbmltYXRvcihzY29wZSwgYXR0cnMpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24oZWxlbWVudCwgdGFyZ2V0LCBjYikge2FuaW1hdGUuZW50ZXIoZWxlbWVudCwgbnVsbCwgdGFyZ2V0KTsgY2IoKTsgfSxcbiAgICAgICAgbGVhdmU6IGZ1bmN0aW9uKGVsZW1lbnQsIGNiKSB7IGFuaW1hdGUubGVhdmUoZWxlbWVudCk7IGNiKCk7IH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRpY3M7XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlID0ge1xuICAgIHJlc3RyaWN0OiAnRUNBJyxcbiAgICB0ZXJtaW5hbDogdHJ1ZSxcbiAgICBwcmlvcml0eTogNDAwLFxuICAgIHRyYW5zY2x1ZGU6ICdlbGVtZW50JyxcbiAgICBjb21waWxlOiBmdW5jdGlvbiAodEVsZW1lbnQsIHRBdHRycywgJHRyYW5zY2x1ZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsICRlbGVtZW50LCBhdHRycykge1xuICAgICAgICB2YXIgcHJldmlvdXNFbCwgY3VycmVudEVsLCBjdXJyZW50U2NvcGUsIGxhdGVzdExvY2FscyxcbiAgICAgICAgICAgIG9ubG9hZEV4cCAgICAgPSBhdHRycy5vbmxvYWQgfHwgJycsXG4gICAgICAgICAgICBhdXRvU2Nyb2xsRXhwID0gYXR0cnMuYXV0b3Njcm9sbCxcbiAgICAgICAgICAgIHJlbmRlcmVyICAgICAgPSBnZXRSZW5kZXJlcihhdHRycywgc2NvcGUpO1xuXG4gICAgICAgIHNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHVwZGF0ZVZpZXcoZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB1cGRhdGVWaWV3KHRydWUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFudXBMYXN0VmlldygpIHtcbiAgICAgICAgICB2YXIgX3ByZXZpb3VzRWwgPSBwcmV2aW91c0VsO1xuICAgICAgICAgIHZhciBfY3VycmVudFNjb3BlID0gY3VycmVudFNjb3BlO1xuXG4gICAgICAgICAgaWYgKF9jdXJyZW50U2NvcGUpIHtcbiAgICAgICAgICAgIF9jdXJyZW50U2NvcGUuX3dpbGxCZURlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY2xlYW5PbGQoKSB7XG4gICAgICAgICAgICBpZiAoX3ByZXZpb3VzRWwpIHtcbiAgICAgICAgICAgICAgX3ByZXZpb3VzRWwucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfY3VycmVudFNjb3BlKSB7XG4gICAgICAgICAgICAgIF9jdXJyZW50U2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudEVsKSB7XG4gICAgICAgICAgICByZW5kZXJlci5sZWF2ZShjdXJyZW50RWwsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjbGVhbk9sZCgpO1xuICAgICAgICAgICAgICBwcmV2aW91c0VsID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcmV2aW91c0VsID0gY3VycmVudEVsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhbk9sZCgpO1xuICAgICAgICAgICAgcHJldmlvdXNFbCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudEVsID0gbnVsbDtcbiAgICAgICAgICBjdXJyZW50U2NvcGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmlldyhmaXJzdFRpbWUpIHtcbiAgICAgICAgICB2YXIgbmV3U2NvcGUsXG4gICAgICAgICAgICAgIG5hbWUgICAgICAgICAgICA9IGdldFVpVmlld05hbWUoc2NvcGUsIGF0dHJzLCAkZWxlbWVudCwgJGludGVycG9sYXRlKSxcbiAgICAgICAgICAgICAgcHJldmlvdXNMb2NhbHMgID0gbmFtZSAmJiAkc3RhdGUuJGN1cnJlbnQgJiYgJHN0YXRlLiRjdXJyZW50LmxvY2Fsc1tuYW1lXTtcblxuICAgICAgICAgIGlmICghZmlyc3RUaW1lICYmIHByZXZpb3VzTG9jYWxzID09PSBsYXRlc3RMb2NhbHMgfHwgc2NvcGUuX3dpbGxCZURlc3Ryb3llZCkgcmV0dXJuOyAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgbmV3U2NvcGUgPSBzY29wZS4kbmV3KCk7XG4gICAgICAgICAgbGF0ZXN0TG9jYWxzID0gJHN0YXRlLiRjdXJyZW50LmxvY2Fsc1tuYW1lXTtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlldyMkdmlld0NvbnRlbnRMb2FkaW5nXG4gICAgICAgICAgICogQGV2ZW50T2YgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS12aWV3XG4gICAgICAgICAgICogQGV2ZW50VHlwZSBlbWl0cyBvbiB1aS12aWV3IGRpcmVjdGl2ZSBzY29wZVxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgICAqXG4gICAgICAgICAgICogRmlyZWQgb25jZSB0aGUgdmlldyAqKmJlZ2lucyBsb2FkaW5nKiosICpiZWZvcmUqIHRoZSBET00gaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3TmFtZSBOYW1lIG9mIHRoZSB2aWV3LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIG5ld1Njb3BlLiRlbWl0KCckdmlld0NvbnRlbnRMb2FkaW5nJywgbmFtZSk7XG5cbiAgICAgICAgICB2YXIgY2xvbmUgPSAkdHJhbnNjbHVkZShuZXdTY29wZSwgZnVuY3Rpb24oY2xvbmUpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmVudGVyKGNsb25lLCAkZWxlbWVudCwgZnVuY3Rpb24gb25VaVZpZXdFbnRlcigpIHtcbiAgICAgICAgICAgICAgaWYoY3VycmVudFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFNjb3BlLiRlbWl0KCckdmlld0NvbnRlbnRBbmltYXRpb25FbmRlZCcpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGF1dG9TY3JvbGxFeHApICYmICFhdXRvU2Nyb2xsRXhwIHx8IHNjb3BlLiRldmFsKGF1dG9TY3JvbGxFeHApKSB7XG4gICAgICAgICAgICAgICAgJHVpVmlld1Njcm9sbChjbG9uZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xlYW51cExhc3RWaWV3KCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjdXJyZW50RWwgPSBjbG9uZTtcbiAgICAgICAgICBjdXJyZW50U2NvcGUgPSBuZXdTY29wZTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAbmdkb2MgZXZlbnRcbiAgICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXcjJHZpZXdDb250ZW50TG9hZGVkXG4gICAgICAgICAgICogQGV2ZW50T2YgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS12aWV3XG4gICAgICAgICAgICogQGV2ZW50VHlwZSBlbWl0cyBvbiB1aS12aWV3IGRpcmVjdGl2ZSBzY29wZVxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgICAqIEZpcmVkIG9uY2UgdGhlIHZpZXcgaXMgKipsb2FkZWQqKiwgKmFmdGVyKiB0aGUgRE9NIGlzIHJlbmRlcmVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld05hbWUgTmFtZSBvZiB0aGUgdmlldy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjdXJyZW50U2NvcGUuJGVtaXQoJyR2aWV3Q29udGVudExvYWRlZCcsIG5hbWUpO1xuICAgICAgICAgIGN1cnJlbnRTY29wZS4kZXZhbChvbmxvYWRFeHApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZGlyZWN0aXZlO1xufVxuXG4kVmlld0RpcmVjdGl2ZUZpbGwuJGluamVjdCA9IFsnJGNvbXBpbGUnLCAnJGNvbnRyb2xsZXInLCAnJHN0YXRlJywgJyRpbnRlcnBvbGF0ZSddO1xuZnVuY3Rpb24gJFZpZXdEaXJlY3RpdmVGaWxsICggICRjb21waWxlLCAgICRjb250cm9sbGVyLCAgICRzdGF0ZSwgICAkaW50ZXJwb2xhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VDQScsXG4gICAgcHJpb3JpdHk6IC00MDAsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gKHRFbGVtZW50KSB7XG4gICAgICB2YXIgaW5pdGlhbCA9IHRFbGVtZW50Lmh0bWwoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsICRlbGVtZW50LCBhdHRycykge1xuICAgICAgICB2YXIgY3VycmVudCA9ICRzdGF0ZS4kY3VycmVudCxcbiAgICAgICAgICAgIG5hbWUgPSBnZXRVaVZpZXdOYW1lKHNjb3BlLCBhdHRycywgJGVsZW1lbnQsICRpbnRlcnBvbGF0ZSksXG4gICAgICAgICAgICBsb2NhbHMgID0gY3VycmVudCAmJiBjdXJyZW50LmxvY2Fsc1tuYW1lXTtcblxuICAgICAgICBpZiAoISBsb2NhbHMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAkZWxlbWVudC5kYXRhKCckdWlWaWV3JywgeyBuYW1lOiBuYW1lLCBzdGF0ZTogbG9jYWxzLiQkc3RhdGUgfSk7XG4gICAgICAgICRlbGVtZW50Lmh0bWwobG9jYWxzLiR0ZW1wbGF0ZSA/IGxvY2Fscy4kdGVtcGxhdGUgOiBpbml0aWFsKTtcblxuICAgICAgICB2YXIgbGluayA9ICRjb21waWxlKCRlbGVtZW50LmNvbnRlbnRzKCkpO1xuXG4gICAgICAgIGlmIChsb2NhbHMuJCRjb250cm9sbGVyKSB7XG4gICAgICAgICAgbG9jYWxzLiRzY29wZSA9IHNjb3BlO1xuICAgICAgICAgIGxvY2Fscy4kZWxlbWVudCA9ICRlbGVtZW50O1xuICAgICAgICAgIHZhciBjb250cm9sbGVyID0gJGNvbnRyb2xsZXIobG9jYWxzLiQkY29udHJvbGxlciwgbG9jYWxzKTtcbiAgICAgICAgICBpZiAobG9jYWxzLiQkY29udHJvbGxlckFzKSB7XG4gICAgICAgICAgICBzY29wZVtsb2NhbHMuJCRjb250cm9sbGVyQXNdID0gY29udHJvbGxlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgJGVsZW1lbnQuZGF0YSgnJG5nQ29udHJvbGxlckNvbnRyb2xsZXInLCBjb250cm9sbGVyKTtcbiAgICAgICAgICAkZWxlbWVudC5jaGlsZHJlbigpLmRhdGEoJyRuZ0NvbnRyb2xsZXJDb250cm9sbGVyJywgY29udHJvbGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5rKHNjb3BlKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFNoYXJlZCB1aS12aWV3IGNvZGUgZm9yIGJvdGggZGlyZWN0aXZlczpcbiAqIEdpdmVuIHNjb3BlLCBlbGVtZW50LCBhbmQgaXRzIGF0dHJpYnV0ZXMsIHJldHVybiB0aGUgdmlldydzIG5hbWVcbiAqL1xuZnVuY3Rpb24gZ2V0VWlWaWV3TmFtZShzY29wZSwgYXR0cnMsIGVsZW1lbnQsICRpbnRlcnBvbGF0ZSkge1xuICB2YXIgbmFtZSA9ICRpbnRlcnBvbGF0ZShhdHRycy51aVZpZXcgfHwgYXR0cnMubmFtZSB8fCAnJykoc2NvcGUpO1xuICB2YXIgaW5oZXJpdGVkID0gZWxlbWVudC5pbmhlcml0ZWREYXRhKCckdWlWaWV3Jyk7XG4gIHJldHVybiBuYW1lLmluZGV4T2YoJ0AnKSA+PSAwID8gIG5hbWUgOiAgKG5hbWUgKyAnQCcgKyAoaW5oZXJpdGVkID8gaW5oZXJpdGVkLnN0YXRlLm5hbWUgOiAnJykpO1xufVxuXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykuZGlyZWN0aXZlKCd1aVZpZXcnLCAkVmlld0RpcmVjdGl2ZSk7XG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykuZGlyZWN0aXZlKCd1aVZpZXcnLCAkVmlld0RpcmVjdGl2ZUZpbGwpO1xuXG5mdW5jdGlvbiBwYXJzZVN0YXRlUmVmKHJlZiwgY3VycmVudCkge1xuICB2YXIgcHJlcGFyc2VkID0gcmVmLm1hdGNoKC9eXFxzKih7W159XSp9KVxccyokLyksIHBhcnNlZDtcbiAgaWYgKHByZXBhcnNlZCkgcmVmID0gY3VycmVudCArICcoJyArIHByZXBhcnNlZFsxXSArICcpJztcbiAgcGFyc2VkID0gcmVmLnJlcGxhY2UoL1xcbi9nLCBcIiBcIikubWF0Y2goL14oW14oXSs/KVxccyooXFwoKC4qKVxcKSk/JC8pO1xuICBpZiAoIXBhcnNlZCB8fCBwYXJzZWQubGVuZ3RoICE9PSA0KSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIHJlZiAnXCIgKyByZWYgKyBcIidcIik7XG4gIHJldHVybiB7IHN0YXRlOiBwYXJzZWRbMV0sIHBhcmFtRXhwcjogcGFyc2VkWzNdIHx8IG51bGwgfTtcbn1cblxuZnVuY3Rpb24gc3RhdGVDb250ZXh0KGVsKSB7XG4gIHZhciBzdGF0ZURhdGEgPSBlbC5wYXJlbnQoKS5pbmhlcml0ZWREYXRhKCckdWlWaWV3Jyk7XG5cbiAgaWYgKHN0YXRlRGF0YSAmJiBzdGF0ZURhdGEuc3RhdGUgJiYgc3RhdGVEYXRhLnN0YXRlLm5hbWUpIHtcbiAgICByZXR1cm4gc3RhdGVEYXRhLnN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmZvKGVsKSB7XG4gIC8vIFNWR0FFbGVtZW50IGRvZXMgbm90IHVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUsIGJ1dCByYXRoZXIgdGhlICd4bGlua0hyZWYnIGF0dHJpYnV0ZS5cbiAgdmFyIGlzU3ZnID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsLnByb3AoJ2hyZWYnKSkgPT09ICdbb2JqZWN0IFNWR0FuaW1hdGVkU3RyaW5nXSc7XG4gIHZhciBpc0Zvcm0gPSBlbFswXS5ub2RlTmFtZSA9PT0gXCJGT1JNXCI7XG5cbiAgcmV0dXJuIHtcbiAgICBhdHRyOiBpc0Zvcm0gPyBcImFjdGlvblwiIDogKGlzU3ZnID8gJ3hsaW5rOmhyZWYnIDogJ2hyZWYnKSxcbiAgICBpc0FuY2hvcjogZWwucHJvcChcInRhZ05hbWVcIikudG9VcHBlckNhc2UoKSA9PT0gXCJBXCIsXG4gICAgY2xpY2thYmxlOiAhaXNGb3JtXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsaWNrSG9vayhlbCwgJHN0YXRlLCAkdGltZW91dCwgdHlwZSwgY3VycmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgIHZhciBidXR0b24gPSBlLndoaWNoIHx8IGUuYnV0dG9uLCB0YXJnZXQgPSBjdXJyZW50KCk7XG5cbiAgICBpZiAoIShidXR0b24gPiAxIHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlbC5hdHRyKCd0YXJnZXQnKSkpIHtcbiAgICAgIC8vIEhBQ0s6IFRoaXMgaXMgdG8gYWxsb3cgbmctY2xpY2tzIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmUgdGhlIHRyYW5zaXRpb24gaXMgaW5pdGlhdGVkOlxuICAgICAgdmFyIHRyYW5zaXRpb24gPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgJHN0YXRlLmdvKHRhcmdldC5zdGF0ZSwgdGFyZ2V0LnBhcmFtcywgdGFyZ2V0Lm9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIGlmIHRoZSBzdGF0ZSBoYXMgbm8gVVJMLCBpZ25vcmUgb25lIHByZXZlbnREZWZhdWx0IGZyb20gdGhlIDxhPiBkaXJlY3RpdmUuXG4gICAgICB2YXIgaWdub3JlUHJldmVudERlZmF1bHRDb3VudCA9IHR5cGUuaXNBbmNob3IgJiYgIXRhcmdldC5ocmVmID8gMTogMDtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoaWdub3JlUHJldmVudERlZmF1bHRDb3VudC0tIDw9IDApICR0aW1lb3V0LmNhbmNlbCh0cmFuc2l0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0T3B0cyhlbCwgJHN0YXRlKSB7XG4gIHJldHVybiB7IHJlbGF0aXZlOiBzdGF0ZUNvbnRleHQoZWwpIHx8ICRzdGF0ZS4kY3VycmVudCwgaW5oZXJpdDogdHJ1ZSB9O1xufVxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktc3JlZlxuICpcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG4gKiBAcmVxdWlyZXMgJHRpbWVvdXRcbiAqXG4gKiBAcmVzdHJpY3QgQVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBkaXJlY3RpdmUgdGhhdCBiaW5kcyBhIGxpbmsgKGA8YT5gIHRhZykgdG8gYSBzdGF0ZS4gSWYgdGhlIHN0YXRlIGhhcyBhbiBhc3NvY2lhdGVkXG4gKiBVUkwsIHRoZSBkaXJlY3RpdmUgd2lsbCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlICYgdXBkYXRlIHRoZSBgaHJlZmAgYXR0cmlidXRlIHZpYVxuICogdGhlIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI21ldGhvZHNfaHJlZiAkc3RhdGUuaHJlZigpfSBtZXRob2QuIENsaWNraW5nXG4gKiB0aGUgbGluayB3aWxsIHRyaWdnZXIgYSBzdGF0ZSB0cmFuc2l0aW9uIHdpdGggb3B0aW9uYWwgcGFyYW1ldGVycy5cbiAqXG4gKiBBbHNvIG1pZGRsZS1jbGlja2luZywgcmlnaHQtY2xpY2tpbmcsIGFuZCBjdHJsLWNsaWNraW5nIG9uIHRoZSBsaW5rIHdpbGwgYmVcbiAqIGhhbmRsZWQgbmF0aXZlbHkgYnkgdGhlIGJyb3dzZXIuXG4gKlxuICogWW91IGNhbiBhbHNvIHVzZSByZWxhdGl2ZSBzdGF0ZSBwYXRocyB3aXRoaW4gdWktc3JlZiwganVzdCBsaWtlIHRoZSByZWxhdGl2ZVxuICogcGF0aHMgcGFzc2VkIHRvIGAkc3RhdGUuZ28oKWAuIFlvdSBqdXN0IG5lZWQgdG8gYmUgYXdhcmUgdGhhdCB0aGUgcGF0aCBpcyByZWxhdGl2ZVxuICogdG8gdGhlIHN0YXRlIHRoYXQgdGhlIGxpbmsgbGl2ZXMgaW4sIGluIG90aGVyIHdvcmRzIHRoZSBzdGF0ZSB0aGF0IGxvYWRlZCB0aGVcbiAqIHRlbXBsYXRlIGNvbnRhaW5pbmcgdGhlIGxpbmsuXG4gKlxuICogWW91IGNhbiBzcGVjaWZ5IG9wdGlvbnMgdG8gcGFzcyB0byB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNnbyAkc3RhdGUuZ28oKX1cbiAqIHVzaW5nIHRoZSBgdWktc3JlZi1vcHRzYCBhdHRyaWJ1dGUuIE9wdGlvbnMgYXJlIHJlc3RyaWN0ZWQgdG8gYGxvY2F0aW9uYCwgYGluaGVyaXRgLFxuICogYW5kIGByZWxvYWRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBvZiBob3cgeW91J2QgdXNlIHVpLXNyZWYgYW5kIGhvdyBpdCB3b3VsZCBjb21waWxlLiBJZiB5b3UgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyB0ZW1wbGF0ZTpcbiAqIDxwcmU+XG4gKiA8YSB1aS1zcmVmPVwiaG9tZVwiPkhvbWU8L2E+IHwgPGEgdWktc3JlZj1cImFib3V0XCI+QWJvdXQ8L2E+IHwgPGEgdWktc3JlZj1cIntwYWdlOiAyfVwiPk5leHQgcGFnZTwvYT5cbiAqXG4gKiA8dWw+XG4gKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cbiAqICAgICAgICAgPGEgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+e3sgY29udGFjdC5uYW1lIH19PC9hPlxuICogICAgIDwvbGk+XG4gKiA8L3VsPlxuICogPC9wcmU+XG4gKlxuICogVGhlbiB0aGUgY29tcGlsZWQgaHRtbCB3b3VsZCBiZSAoYXNzdW1pbmcgSHRtbDVNb2RlIGlzIG9mZiBhbmQgY3VycmVudCBzdGF0ZSBpcyBjb250YWN0cyk6XG4gKiA8cHJlPlxuICogPGEgaHJlZj1cIiMvaG9tZVwiIHVpLXNyZWY9XCJob21lXCI+SG9tZTwvYT4gfCA8YSBocmVmPVwiIy9hYm91dFwiIHVpLXNyZWY9XCJhYm91dFwiPkFib3V0PC9hPiB8IDxhIGhyZWY9XCIjL2NvbnRhY3RzP3BhZ2U9MlwiIHVpLXNyZWY9XCJ7cGFnZTogMn1cIj5OZXh0IHBhZ2U8L2E+XG4gKlxuICogPHVsPlxuICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XG4gKiAgICAgICAgIDxhIGhyZWY9XCIjL2NvbnRhY3RzLzFcIiB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj5Kb2U8L2E+XG4gKiAgICAgPC9saT5cbiAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxuICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8yXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+QWxpY2U8L2E+XG4gKiAgICAgPC9saT5cbiAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxuICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8zXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+Qm9iPC9hPlxuICogICAgIDwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIDxhIHVpLXNyZWY9XCJob21lXCIgdWktc3JlZi1vcHRzPVwie3JlbG9hZDogdHJ1ZX1cIj5Ib21lPC9hPlxuICogPC9wcmU+XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVpLXNyZWYgJ3N0YXRlTmFtZScgY2FuIGJlIGFueSB2YWxpZCBhYnNvbHV0ZSBvciByZWxhdGl2ZSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHVpLXNyZWYtb3B0cyBvcHRpb25zIHRvIHBhc3MgdG8ge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjZ28gJHN0YXRlLmdvKCl9XG4gKi9cbiRTdGF0ZVJlZkRpcmVjdGl2ZS4kaW5qZWN0ID0gWyckc3RhdGUnLCAnJHRpbWVvdXQnXTtcbmZ1bmN0aW9uICRTdGF0ZVJlZkRpcmVjdGl2ZSgkc3RhdGUsICR0aW1lb3V0KSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICByZXF1aXJlOiBbJz9edWlTcmVmQWN0aXZlJywgJz9edWlTcmVmQWN0aXZlRXEnXSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIHVpU3JlZkFjdGl2ZSkge1xuICAgICAgdmFyIHJlZiAgICA9IHBhcnNlU3RhdGVSZWYoYXR0cnMudWlTcmVmLCAkc3RhdGUuY3VycmVudC5uYW1lKTtcbiAgICAgIHZhciBkZWYgICAgPSB7IHN0YXRlOiByZWYuc3RhdGUsIGhyZWY6IG51bGwsIHBhcmFtczogbnVsbCB9O1xuICAgICAgdmFyIHR5cGUgICA9IGdldFR5cGVJbmZvKGVsZW1lbnQpO1xuICAgICAgdmFyIGFjdGl2ZSA9IHVpU3JlZkFjdGl2ZVsxXSB8fCB1aVNyZWZBY3RpdmVbMF07XG5cbiAgICAgIGRlZi5vcHRpb25zID0gZXh0ZW5kKGRlZmF1bHRPcHRzKGVsZW1lbnQsICRzdGF0ZSksIGF0dHJzLnVpU3JlZk9wdHMgPyBzY29wZS4kZXZhbChhdHRycy51aVNyZWZPcHRzKSA6IHt9KTtcblxuICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAodmFsKSBkZWYucGFyYW1zID0gYW5ndWxhci5jb3B5KHZhbCk7XG4gICAgICAgIGRlZi5ocmVmID0gJHN0YXRlLmhyZWYocmVmLnN0YXRlLCBkZWYucGFyYW1zLCBkZWYub3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKGFjdGl2ZSkgYWN0aXZlLiQkYWRkU3RhdGVJbmZvKHJlZi5zdGF0ZSwgZGVmLnBhcmFtcyk7XG4gICAgICAgIGlmIChkZWYuaHJlZiAhPT0gbnVsbCkgYXR0cnMuJHNldCh0eXBlLmF0dHIsIGRlZi5ocmVmKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChyZWYucGFyYW1FeHByKSB7XG4gICAgICAgIHNjb3BlLiR3YXRjaChyZWYucGFyYW1FeHByLCBmdW5jdGlvbih2YWwpIHsgaWYgKHZhbCAhPT0gZGVmLnBhcmFtcykgdXBkYXRlKHZhbCk7IH0sIHRydWUpO1xuICAgICAgICBkZWYucGFyYW1zID0gYW5ndWxhci5jb3B5KHNjb3BlLiRldmFsKHJlZi5wYXJhbUV4cHIpKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuXG4gICAgICBpZiAoIXR5cGUuY2xpY2thYmxlKSByZXR1cm47XG4gICAgICBlbGVtZW50LmJpbmQoXCJjbGlja1wiLCBjbGlja0hvb2soZWxlbWVudCwgJHN0YXRlLCAkdGltZW91dCwgdHlwZSwgZnVuY3Rpb24oKSB7IHJldHVybiBkZWY7IH0pKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS1zdGF0ZVxuICpcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIuc3RhdGUudWlTcmVmXG4gKlxuICogQHJlc3RyaWN0IEFcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIE11Y2ggbGlrZSB1aS1zcmVmLCBidXQgd2lsbCBhY2NlcHQgbmFtZWQgJHNjb3BlIHByb3BlcnRpZXMgdG8gZXZhbHVhdGUgZm9yIGEgc3RhdGUgZGVmaW5pdGlvbixcbiAqIHBhcmFtcyBhbmQgb3ZlcnJpZGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdWktc3RhdGUgJ3N0YXRlTmFtZScgY2FuIGJlIGFueSB2YWxpZCBhYnNvbHV0ZSBvciByZWxhdGl2ZSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHVpLXN0YXRlLXBhcmFtcyBwYXJhbXMgdG8gcGFzcyB0byB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNocmVmICRzdGF0ZS5ocmVmKCl9XG4gKiBAcGFyYW0ge09iamVjdH0gdWktc3RhdGUtb3B0cyBvcHRpb25zIHRvIHBhc3MgdG8ge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjZ28gJHN0YXRlLmdvKCl9XG4gKi9cbiRTdGF0ZVJlZkR5bmFtaWNEaXJlY3RpdmUuJGluamVjdCA9IFsnJHN0YXRlJywgJyR0aW1lb3V0J107XG5mdW5jdGlvbiAkU3RhdGVSZWZEeW5hbWljRGlyZWN0aXZlKCRzdGF0ZSwgJHRpbWVvdXQpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHJlcXVpcmU6IFsnP151aVNyZWZBY3RpdmUnLCAnP151aVNyZWZBY3RpdmVFcSddLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgdWlTcmVmQWN0aXZlKSB7XG4gICAgICB2YXIgdHlwZSAgID0gZ2V0VHlwZUluZm8oZWxlbWVudCk7XG4gICAgICB2YXIgYWN0aXZlID0gdWlTcmVmQWN0aXZlWzFdIHx8IHVpU3JlZkFjdGl2ZVswXTtcbiAgICAgIHZhciBncm91cCAgPSBbYXR0cnMudWlTdGF0ZSwgYXR0cnMudWlTdGF0ZVBhcmFtcyB8fCBudWxsLCBhdHRycy51aVN0YXRlT3B0cyB8fCBudWxsXTtcbiAgICAgIHZhciB3YXRjaCAgPSAnWycgKyBncm91cC5tYXAoZnVuY3Rpb24odmFsKSB7IHJldHVybiB2YWwgfHwgJ251bGwnOyB9KS5qb2luKCcsICcpICsgJ10nO1xuICAgICAgdmFyIGRlZiAgICA9IHsgc3RhdGU6IG51bGwsIHBhcmFtczogbnVsbCwgb3B0aW9uczogbnVsbCwgaHJlZjogbnVsbCB9O1xuXG4gICAgICBmdW5jdGlvbiBydW5TdGF0ZVJlZkxpbmsgKGdyb3VwKSB7XG4gICAgICAgIGRlZi5zdGF0ZSA9IGdyb3VwWzBdOyBkZWYucGFyYW1zID0gZ3JvdXBbMV07IGRlZi5vcHRpb25zID0gZ3JvdXBbMl07XG4gICAgICAgIGRlZi5ocmVmID0gJHN0YXRlLmhyZWYoZGVmLnN0YXRlLCBkZWYucGFyYW1zLCBkZWYub3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKGFjdGl2ZSkgYWN0aXZlLiQkYWRkU3RhdGVJbmZvKGRlZi5zdGF0ZSwgZGVmLnBhcmFtcyk7XG4gICAgICAgIGlmIChkZWYuaHJlZikgYXR0cnMuJHNldCh0eXBlLmF0dHIsIGRlZi5ocmVmKTtcbiAgICAgIH1cblxuICAgICAgc2NvcGUuJHdhdGNoKHdhdGNoLCBydW5TdGF0ZVJlZkxpbmssIHRydWUpO1xuICAgICAgcnVuU3RhdGVSZWZMaW5rKHNjb3BlLiRldmFsKHdhdGNoKSk7XG5cbiAgICAgIGlmICghdHlwZS5jbGlja2FibGUpIHJldHVybjtcbiAgICAgIGVsZW1lbnQuYmluZChcImNsaWNrXCIsIGNsaWNrSG9vayhlbGVtZW50LCAkc3RhdGUsICR0aW1lb3V0LCB0eXBlLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZjsgfSkpO1xuICAgIH1cbiAgfTtcbn1cblxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktc3JlZi1hY3RpdmVcbiAqXG4gKiBAcmVxdWlyZXMgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICogQHJlcXVpcmVzIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVQYXJhbXNcbiAqIEByZXF1aXJlcyAkaW50ZXJwb2xhdGVcbiAqXG4gKiBAcmVzdHJpY3QgQVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBkaXJlY3RpdmUgd29ya2luZyBhbG9uZ3NpZGUgdWktc3JlZiB0byBhZGQgY2xhc3NlcyB0byBhbiBlbGVtZW50IHdoZW4gdGhlXG4gKiByZWxhdGVkIHVpLXNyZWYgZGlyZWN0aXZlJ3Mgc3RhdGUgaXMgYWN0aXZlLCBhbmQgcmVtb3ZpbmcgdGhlbSB3aGVuIGl0IGlzIGluYWN0aXZlLlxuICogVGhlIHByaW1hcnkgdXNlLWNhc2UgaXMgdG8gc2ltcGxpZnkgdGhlIHNwZWNpYWwgYXBwZWFyYW5jZSBvZiBuYXZpZ2F0aW9uIG1lbnVzXG4gKiByZWx5aW5nIG9uIGB1aS1zcmVmYCwgYnkgaGF2aW5nIHRoZSBcImFjdGl2ZVwiIHN0YXRlJ3MgbWVudSBidXR0b24gYXBwZWFyIGRpZmZlcmVudCxcbiAqIGRpc3Rpbmd1aXNoaW5nIGl0IGZyb20gdGhlIGluYWN0aXZlIG1lbnUgaXRlbXMuXG4gKlxuICogdWktc3JlZi1hY3RpdmUgY2FuIGxpdmUgb24gdGhlIHNhbWUgZWxlbWVudCBhcyB1aS1zcmVmIG9yIG9uIGEgcGFyZW50IGVsZW1lbnQuIFRoZSBmaXJzdFxuICogdWktc3JlZi1hY3RpdmUgZm91bmQgYXQgdGhlIHNhbWUgbGV2ZWwgb3IgYWJvdmUgdGhlIHVpLXNyZWYgd2lsbCBiZSB1c2VkLlxuICpcbiAqIFdpbGwgYWN0aXZhdGUgd2hlbiB0aGUgdWktc3JlZidzIHRhcmdldCBzdGF0ZSBvciBhbnkgY2hpbGQgc3RhdGUgaXMgYWN0aXZlLiBJZiB5b3VcbiAqIG5lZWQgdG8gYWN0aXZhdGUgb25seSB3aGVuIHRoZSB1aS1zcmVmIHRhcmdldCBzdGF0ZSBpcyBhY3RpdmUgYW5kICpub3QqIGFueSBvZlxuICogaXQncyBjaGlsZHJlbiwgdGhlbiB5b3Ugd2lsbCB1c2VcbiAqIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXNyZWYtYWN0aXZlLWVxIHVpLXNyZWYtYWN0aXZlLWVxfVxuICpcbiAqIEBleGFtcGxlXG4gKiBHaXZlbiB0aGUgZm9sbG93aW5nIHRlbXBsYXRlOlxuICogPHByZT5cbiAqIDx1bD5cbiAqICAgPGxpIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCIgY2xhc3M9XCJpdGVtXCI+XG4gKiAgICAgPGEgaHJlZiB1aS1zcmVmPVwiYXBwLnVzZXIoe3VzZXI6ICdiaWxib2JhZ2dpbnMnfSlcIj5AYmlsYm9iYWdnaW5zPC9hPlxuICogICA8L2xpPlxuICogPC91bD5cbiAqIDwvcHJlPlxuICpcbiAqXG4gKiBXaGVuIHRoZSBhcHAgc3RhdGUgaXMgXCJhcHAudXNlclwiIChvciBhbnkgY2hpbGRyZW4gc3RhdGVzKSwgYW5kIGNvbnRhaW5zIHRoZSBzdGF0ZSBwYXJhbWV0ZXIgXCJ1c2VyXCIgd2l0aCB2YWx1ZSBcImJpbGJvYmFnZ2luc1wiLFxuICogdGhlIHJlc3VsdGluZyBIVE1MIHdpbGwgYXBwZWFyIGFzIChub3RlIHRoZSAnYWN0aXZlJyBjbGFzcyk6XG4gKiA8cHJlPlxuICogPHVsPlxuICogICA8bGkgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiBjbGFzcz1cIml0ZW0gYWN0aXZlXCI+XG4gKiAgICAgPGEgdWktc3JlZj1cImFwcC51c2VyKHt1c2VyOiAnYmlsYm9iYWdnaW5zJ30pXCIgaHJlZj1cIi91c2Vycy9iaWxib2JhZ2dpbnNcIj5AYmlsYm9iYWdnaW5zPC9hPlxuICogICA8L2xpPlxuICogPC91bD5cbiAqIDwvcHJlPlxuICpcbiAqIFRoZSBjbGFzcyBuYW1lIGlzIGludGVycG9sYXRlZCAqKm9uY2UqKiBkdXJpbmcgdGhlIGRpcmVjdGl2ZXMgbGluayB0aW1lIChhbnkgZnVydGhlciBjaGFuZ2VzIHRvIHRoZVxuICogaW50ZXJwb2xhdGVkIHZhbHVlIGFyZSBpZ25vcmVkKS5cbiAqXG4gKiBNdWx0aXBsZSBjbGFzc2VzIG1heSBiZSBzcGVjaWZpZWQgaW4gYSBzcGFjZS1zZXBhcmF0ZWQgZm9ybWF0OlxuICogPHByZT5cbiAqIDx1bD5cbiAqICAgPGxpIHVpLXNyZWYtYWN0aXZlPSdjbGFzczEgY2xhc3MyIGNsYXNzMyc+XG4gKiAgICAgPGEgdWktc3JlZj1cImFwcC51c2VyXCI+bGluazwvYT5cbiAqICAgPC9saT5cbiAqIDwvdWw+XG4gKiA8L3ByZT5cbiAqXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHBhc3MgdWktc3JlZi1hY3RpdmUgYW4gZXhwcmVzc2lvbiB0aGF0IGV2YWx1YXRlc1xuICogdG8gYW4gb2JqZWN0IGhhc2gsIHdob3NlIGtleXMgcmVwcmVzZW50IGFjdGl2ZSBjbGFzcyBuYW1lcyBhbmQgd2hvc2VcbiAqIHZhbHVlcyByZXByZXNlbnQgdGhlIHJlc3BlY3RpdmUgc3RhdGUgbmFtZXMvZ2xvYnMuXG4gKiB1aS1zcmVmLWFjdGl2ZSB3aWxsIG1hdGNoIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZSAqKmluY2x1ZGVzKiogYW55IG9mXG4gKiB0aGUgc3BlY2lmaWVkIHN0YXRlIG5hbWVzL2dsb2JzLCBldmVuIHRoZSBhYnN0cmFjdCBvbmVzLlxuICpcbiAqIEBFeGFtcGxlXG4gKiBHaXZlbiB0aGUgZm9sbG93aW5nIHRlbXBsYXRlLCB3aXRoIFwiYWRtaW5cIiBiZWluZyBhbiBhYnN0cmFjdCBzdGF0ZTpcbiAqIDxwcmU+XG4gKiA8ZGl2IHVpLXNyZWYtYWN0aXZlPVwieydhY3RpdmUnOiAnYWRtaW4uKid9XCI+XG4gKiAgIDxhIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCIgdWktc3JlZj1cImFkbWluLnJvbGVzXCI+Um9sZXM8L2E+XG4gKiA8L2Rpdj5cbiAqIDwvcHJlPlxuICpcbiAqIFdoZW4gdGhlIGN1cnJlbnQgc3RhdGUgaXMgXCJhZG1pbi5yb2xlc1wiIHRoZSBcImFjdGl2ZVwiIGNsYXNzIHdpbGwgYmUgYXBwbGllZFxuICogdG8gYm90aCB0aGUgPGRpdj4gYW5kIDxhPiBlbGVtZW50cy4gSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCB0aGUgc3RhdGVcbiAqIG5hbWVzL2dsb2JzIHBhc3NlZCB0byB1aS1zcmVmLWFjdGl2ZSBzaGFkb3cgdGhlIHN0YXRlIHByb3ZpZGVkIGJ5IHVpLXNyZWYuXG4gKi9cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXNyZWYtYWN0aXZlLWVxXG4gKlxuICogQHJlcXVpcmVzIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlUGFyYW1zXG4gKiBAcmVxdWlyZXMgJGludGVycG9sYXRlXG4gKlxuICogQHJlc3RyaWN0IEFcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBzYW1lIGFzIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXNyZWYtYWN0aXZlIHVpLXNyZWYtYWN0aXZlfSBidXQgd2lsbCBvbmx5IGFjdGl2YXRlXG4gKiB3aGVuIHRoZSBleGFjdCB0YXJnZXQgc3RhdGUgdXNlZCBpbiB0aGUgYHVpLXNyZWZgIGlzIGFjdGl2ZTsgbm8gY2hpbGQgc3RhdGVzLlxuICpcbiAqL1xuJFN0YXRlUmVmQWN0aXZlRGlyZWN0aXZlLiRpbmplY3QgPSBbJyRzdGF0ZScsICckc3RhdGVQYXJhbXMnLCAnJGludGVycG9sYXRlJ107XG5mdW5jdGlvbiAkU3RhdGVSZWZBY3RpdmVEaXJlY3RpdmUoJHN0YXRlLCAkc3RhdGVQYXJhbXMsICRpbnRlcnBvbGF0ZSkge1xuICByZXR1cm4gIHtcbiAgICByZXN0cmljdDogXCJBXCIsXG4gICAgY29udHJvbGxlcjogWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGF0dHJzJywgJyR0aW1lb3V0JywgZnVuY3Rpb24gKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJHRpbWVvdXQpIHtcbiAgICAgIHZhciBzdGF0ZXMgPSBbXSwgYWN0aXZlQ2xhc3NlcyA9IHt9LCBhY3RpdmVFcUNsYXNzLCB1aVNyZWZBY3RpdmU7XG5cbiAgICAgIC8vIFRoZXJlIHByb2JhYmx5IGlzbid0IG11Y2ggcG9pbnQgaW4gJG9ic2VydmluZyB0aGlzXG4gICAgICAvLyB1aVNyZWZBY3RpdmUgYW5kIHVpU3JlZkFjdGl2ZUVxIHNoYXJlIHRoZSBzYW1lIGRpcmVjdGl2ZSBvYmplY3Qgd2l0aCBzb21lXG4gICAgICAvLyBzbGlnaHQgZGlmZmVyZW5jZSBpbiBsb2dpYyByb3V0aW5nXG4gICAgICBhY3RpdmVFcUNsYXNzID0gJGludGVycG9sYXRlKCRhdHRycy51aVNyZWZBY3RpdmVFcSB8fCAnJywgZmFsc2UpKCRzY29wZSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHVpU3JlZkFjdGl2ZSA9ICRzY29wZS4kZXZhbCgkYXR0cnMudWlTcmVmQWN0aXZlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy4gdWlTcmVmQWN0aXZlIGlzIG5vdCBhIHZhbGlkIGV4cHJlc3Npb24uXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byB1c2luZyAkaW50ZXJwb2xhdGUgYmVsb3dcbiAgICAgIH1cbiAgICAgIHVpU3JlZkFjdGl2ZSA9IHVpU3JlZkFjdGl2ZSB8fCAkaW50ZXJwb2xhdGUoJGF0dHJzLnVpU3JlZkFjdGl2ZSB8fCAnJywgZmFsc2UpKCRzY29wZSk7XG4gICAgICBpZiAoaXNPYmplY3QodWlTcmVmQWN0aXZlKSkge1xuICAgICAgICBmb3JFYWNoKHVpU3JlZkFjdGl2ZSwgZnVuY3Rpb24oc3RhdGVPck5hbWUsIGFjdGl2ZUNsYXNzKSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHN0YXRlT3JOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHJlZiA9IHBhcnNlU3RhdGVSZWYoc3RhdGVPck5hbWUsICRzdGF0ZS5jdXJyZW50Lm5hbWUpO1xuICAgICAgICAgICAgYWRkU3RhdGUocmVmLnN0YXRlLCAkc2NvcGUuJGV2YWwocmVmLnBhcmFtRXhwciksIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyB1aVNyZWYgdG8gY29tbXVuaWNhdGUgd2l0aCB1aVNyZWZBY3RpdmVbRXF1YWxzXVxuICAgICAgdGhpcy4kJGFkZFN0YXRlSW5mbyA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgbmV3UGFyYW1zKSB7XG4gICAgICAgIC8vIHdlIGFscmVhZHkgZ290IGFuIGV4cGxpY2l0IHN0YXRlIHByb3ZpZGVkIGJ5IHVpLXNyZWYtYWN0aXZlLCBzbyB3ZVxuICAgICAgICAvLyBzaGFkb3cgdGhlIG9uZSB0aGF0IGNvbWVzIGZyb20gdWktc3JlZlxuICAgICAgICBpZiAoaXNPYmplY3QodWlTcmVmQWN0aXZlKSAmJiBzdGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhZGRTdGF0ZShuZXdTdGF0ZSwgbmV3UGFyYW1zLCB1aVNyZWZBY3RpdmUpO1xuICAgICAgICB1cGRhdGUoKTtcbiAgICAgIH07XG5cbiAgICAgICRzY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN1Y2Nlc3MnLCB1cGRhdGUpO1xuXG4gICAgICBmdW5jdGlvbiBhZGRTdGF0ZShzdGF0ZU5hbWUsIHN0YXRlUGFyYW1zLCBhY3RpdmVDbGFzcykge1xuICAgICAgICB2YXIgc3RhdGUgPSAkc3RhdGUuZ2V0KHN0YXRlTmFtZSwgc3RhdGVDb250ZXh0KCRlbGVtZW50KSk7XG4gICAgICAgIHZhciBzdGF0ZUhhc2ggPSBjcmVhdGVTdGF0ZUhhc2goc3RhdGVOYW1lLCBzdGF0ZVBhcmFtcyk7XG5cbiAgICAgICAgc3RhdGVzLnB1c2goe1xuICAgICAgICAgIHN0YXRlOiBzdGF0ZSB8fCB7IG5hbWU6IHN0YXRlTmFtZSB9LFxuICAgICAgICAgIHBhcmFtczogc3RhdGVQYXJhbXMsXG4gICAgICAgICAgaGFzaDogc3RhdGVIYXNoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFjdGl2ZUNsYXNzZXNbc3RhdGVIYXNoXSA9IGFjdGl2ZUNsYXNzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbcGFyYW1zXVxuICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBjcmVhdGVTdGF0ZUhhc2goc3RhdGUsIHBhcmFtcykge1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhdGUgc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUgKyB0b0pzb24ocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSAkc2NvcGUuJGV2YWwocGFyYW1zKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUgKyB0b0pzb24ocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSByb3V0ZSBzdGF0ZVxuICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhbnlNYXRjaChzdGF0ZXNbaV0uc3RhdGUsIHN0YXRlc1tpXS5wYXJhbXMpKSB7XG4gICAgICAgICAgICBhZGRDbGFzcygkZWxlbWVudCwgYWN0aXZlQ2xhc3Nlc1tzdGF0ZXNbaV0uaGFzaF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcygkZWxlbWVudCwgYWN0aXZlQ2xhc3Nlc1tzdGF0ZXNbaV0uaGFzaF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChleGFjdE1hdGNoKHN0YXRlc1tpXS5zdGF0ZSwgc3RhdGVzW2ldLnBhcmFtcykpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKCRlbGVtZW50LCBhY3RpdmVFcUNsYXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoJGVsZW1lbnQsIGFjdGl2ZUVxQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xhc3NOYW1lKSB7ICR0aW1lb3V0KGZ1bmN0aW9uICgpIHsgZWwuYWRkQ2xhc3MoY2xhc3NOYW1lKTsgfSk7IH1cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHsgZWwucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTsgfVxuICAgICAgZnVuY3Rpb24gYW55TWF0Y2goc3RhdGUsIHBhcmFtcykgeyByZXR1cm4gJHN0YXRlLmluY2x1ZGVzKHN0YXRlLm5hbWUsIHBhcmFtcyk7IH1cbiAgICAgIGZ1bmN0aW9uIGV4YWN0TWF0Y2goc3RhdGUsIHBhcmFtcykgeyByZXR1cm4gJHN0YXRlLmlzKHN0YXRlLm5hbWUsIHBhcmFtcyk7IH1cblxuICAgICAgdXBkYXRlKCk7XG4gICAgfV1cbiAgfTtcbn1cblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXG4gIC5kaXJlY3RpdmUoJ3VpU3JlZicsICRTdGF0ZVJlZkRpcmVjdGl2ZSlcbiAgLmRpcmVjdGl2ZSgndWlTcmVmQWN0aXZlJywgJFN0YXRlUmVmQWN0aXZlRGlyZWN0aXZlKVxuICAuZGlyZWN0aXZlKCd1aVNyZWZBY3RpdmVFcScsICRTdGF0ZVJlZkFjdGl2ZURpcmVjdGl2ZSlcbiAgLmRpcmVjdGl2ZSgndWlTdGF0ZScsICRTdGF0ZVJlZkR5bmFtaWNEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5maWx0ZXI6aXNTdGF0ZVxuICpcbiAqIEByZXF1aXJlcyB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUcmFuc2xhdGVzIHRvIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI21ldGhvZHNfaXMgJHN0YXRlLmlzKFwic3RhdGVOYW1lXCIpfS5cbiAqL1xuJElzU3RhdGVGaWx0ZXIuJGluamVjdCA9IFsnJHN0YXRlJ107XG5mdW5jdGlvbiAkSXNTdGF0ZUZpbHRlcigkc3RhdGUpIHtcbiAgdmFyIGlzRmlsdGVyID0gZnVuY3Rpb24gKHN0YXRlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gJHN0YXRlLmlzKHN0YXRlLCBwYXJhbXMpO1xuICB9O1xuICBpc0ZpbHRlci4kc3RhdGVmdWwgPSB0cnVlO1xuICByZXR1cm4gaXNGaWx0ZXI7XG59XG5cbi8qKlxuICogQG5nZG9jIGZpbHRlclxuICogQG5hbWUgdWkucm91dGVyLnN0YXRlLmZpbHRlcjppbmNsdWRlZEJ5U3RhdGVcbiAqXG4gKiBAcmVxdWlyZXMgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVHJhbnNsYXRlcyB0byB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNtZXRob2RzX2luY2x1ZGVzICRzdGF0ZS5pbmNsdWRlcygnZnVsbE9yUGFydGlhbFN0YXRlTmFtZScpfS5cbiAqL1xuJEluY2x1ZGVkQnlTdGF0ZUZpbHRlci4kaW5qZWN0ID0gWyckc3RhdGUnXTtcbmZ1bmN0aW9uICRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIoJHN0YXRlKSB7XG4gIHZhciBpbmNsdWRlc0ZpbHRlciA9IGZ1bmN0aW9uIChzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICRzdGF0ZS5pbmNsdWRlcyhzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfTtcbiAgaW5jbHVkZXNGaWx0ZXIuJHN0YXRlZnVsID0gdHJ1ZTtcbiAgcmV0dXJuICBpbmNsdWRlc0ZpbHRlcjtcbn1cblxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXG4gIC5maWx0ZXIoJ2lzU3RhdGUnLCAkSXNTdGF0ZUZpbHRlcilcbiAgLmZpbHRlcignaW5jbHVkZWRCeVN0YXRlJywgJEluY2x1ZGVkQnlTdGF0ZUZpbHRlcik7XG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTsiLCIndXNlIHN0cmljdCc7XG4vLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBicm93c2VyIGZpZWxkLCBjaGVjayBvdXQgdGhlIGJyb3dzZXIgZmllbGQgYXQgaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2Jyb3dzZXJpZnktaGFuZGJvb2sjYnJvd3Nlci1maWVsZC5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLy8gQ3JlYXRlIGEgPGxpbms+IHRhZyB3aXRoIG9wdGlvbmFsIGRhdGEgYXR0cmlidXRlc1xuICAgIGNyZWF0ZUxpbms6IGZ1bmN0aW9uKGhyZWYsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuXG4gICAgICAgIGxpbmsuaHJlZiA9IGhyZWY7XG4gICAgICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoICEgYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnZGF0YS0nICsga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBoZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH0sXG4gICAgLy8gQ3JlYXRlIGEgPHN0eWxlPiB0YWcgd2l0aCBvcHRpb25hbCBkYXRhIGF0dHJpYnV0ZXNcbiAgICBjcmVhdGVTdHlsZTogZnVuY3Rpb24oY3NzVGV4dCwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSxcbiAgICAgICAgICAgIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICAgICAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKCAhIGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdkYXRhLScgKyBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHN0eWxlLnNoZWV0KSB7IC8vIGZvciBqc2RvbSBhbmQgSUU5K1xuICAgICAgICAgICAgc3R5bGUuaW5uZXJIVE1MID0gY3NzVGV4dDtcbiAgICAgICAgICAgIHN0eWxlLnNoZWV0LmNzc1RleHQgPSBjc3NUZXh0O1xuICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUuc3R5bGVTaGVldCkgeyAvLyBmb3IgSUU4IGFuZCBiZWxvd1xuICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NUZXh0O1xuICAgICAgICB9IGVsc2UgeyAvLyBmb3IgQ2hyb21lLCBGaXJlZm94LCBhbmQgU2FmYXJpXG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NUZXh0KSk7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iXX0=
